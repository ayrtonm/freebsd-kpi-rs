# Getting Started

## Adding rust sources

Rust sources are added the same way as C sources under`src/sys/conf`, but with a .rs suffix instead
of .c. Each file must begin with `#![no_std]` and is built as a separate crate. Crates may depend on
other crates, but dependencies must be explicitly specified using `dependency` and the .rlib name in
the `config(8)` entry. Cyclic dependencies between crates are forbidden by the rust compiler. For
example to add a file `src/sys/foo.rs` that depends on `src/sys/bar.rs` and a `src/sys/baz.rs`
that's optional on some `KERNCONF` setting add the following in `src/sys/conf/files`.

```
foo.rs  standard
bar.rs  standard    dependency "libfoo.rlib"
baz.rs  optional    some_option
```

The following error means that one of the .rs files is missing `#![no_std]` at the start.

```
error[E0463]: can't find crate for `std`
```

Building modules is currently not supported. TODO: explain why


Custom KERNCONFs are also currently not well-supported and the makefile assumes that
KERNCONF=GENERIC/VIRT includes the virtio_snd driver.
TODO: explain why and plans for the bindgen headers conf(8) patch

## Dependencies

Crates may also import items from [`core`](https://doc.rust-lang.org/core/) and
[`kpi`](https://ayrtonm.github.io/freebsd-kpi-rs/). Importing anything from
[`std`](https://doc.rust-lang.org/std/) or [`alloc`](https://doc.rust-lang.org/alloc/) is not
supported. As mentioned in the README, using crates from the wider rust ecosystem (e.g.
https://crates.io) is not supported.

## KPI Prelude and conventions

Adding `use kpi::prelude::*;` imports all rust wrappers for C KPI functions that have them. It also
imports the `kpi::bindings` module which provides access to the declarations generated by bindgen.
Note the latter point refers to the `bindings` module itself, not its contents so this doesn't
create ambiguities about what an identifier refers to. Importing the prelude is optional, but the
convention in the demos is currently to import it and use fully-qualified syntax for calling the
bindgen declarations (i.e. use `bindings::foo()` to call the C version of `foo`).

`core` provides a generic [`Result<T, E>`](https://doc.rust-lang.org/core/result/enum.Result.html)
type that can be either some type `T` in the happy path or another type `E` if there was an error.
The KPI crate defines its own `Result<T>` (note the single generic parameter) in the prelude which
sets `E` to a FreeBSD error code. Using the KPI `Result` instead of `core`'s is strongly suggested
where possible. This avoids proliferating various kinds of error codes and simplifies interop
between different functions. Aside from calling `.unwrap()` here are some other typical ways to use
`Result`.

```
// bar either returns u64 or an error code
fn bar() -> Result<u64> { ... }

fn foo() -> Result<()> {
    // x is a u64. If bar resulted in an error, return that return to foo's caller
    let x = bar()?;

    // y is still a Result<u64>. If bar resulted in an error, print what it was.
    let y = bar().inspect_err(|e| {
        device_println!(dev, "{e:?}");
    });

    // z is a u64. If bar resulted in an error, print what it was but return ENXIO to the caller.
    let z = bar().map_err(|e| {
        device_println!(dev, "the original error was {e:?}");
        ENXIO
    })?;
}
```

## Dynamic memory allocation

Since `alloc` can't be used the KPI crate provides minimal versions of `Vec`, `Box` and `Arc`. Their
APIs loosely mirror the standard rust versions, but differ to provide finer control over memory
management and simplify FFI interop with existing C code. In particular `Vec` will never allocate
more capacity than explicitly requested.

The KPI crate provides as much transparency as C about dynamic memory allocations. More specifically
this means that functions and methods will only ever dynamically allocate if they take both
`MallocFlags` and `MallocType` arguments or if the underlying C function allocates. The language
itself cannot dynamically allocate.

## Defining a driver

FIXME: This section became out of date after the switch to not refcounting the softc and ExtRef

The `driver!` rust macro is the equivalent of using the `DEFINE_CLASS` C macro for device drivers.
This is a typical way to use it.

```
use kpi::bindings::device_t;
use kpi::device::{DeviceIf, BusProbe};
use kpi::driver;
use kpi::ffi::{CallbackArg, Ext, UninitExt};
use kpi::prelude::*;

impl CallbackArg for FooSoftc {}

pub struct FooSoftc {
    dev: device_t,
    some_field: u32,
}

impl DeviceIf for FooDriver {
    // This is the only required item in this trait. Omitting any methods makes them panic if called
    type Softc = FooSoftc;

    fn device_probe(dev: device_t) -> Result<BusProbe> {
        if !ofw_bus_status_okay(dev) {
            return Err(ENXIO);
        }
        if !ofw_bus_is_compatible(dev, c"vendor,foo-device") {
            return Err(ENXIO);
        }
        device_set_desc(dev, c"FooDevice");

        Ok(BUS_PROBE_DEFAULT)
    }

    // The first argument is a pointer to the softc. You must call `.init()` on it before returning
    // from this function.
    fn device_attach(uninit_sc: UninitExt<FooSoftc>, dev: device_t) -> Result<()> {
        let sc_on_stack = FooSoftc {
            dev,
            some_field: 0xdeadbeef,
        };

        // Initializing the softc gives you mutable access to it since there is only one pointer to it
        let mut unique_sc = uninit_sc.init(sc_on_stack);
        unique_sc.some_field = 0xdeadc0de;

        let sc = unique_sc.into_ref();

        Ok(())
    }

    fn device_detach(sc: Ext<FooSoftc>, dev: device_t) -> Result<()> {
        Ok(())
    }
}

driver! {
    foo_driver, c"foo", FooDriver,
    foo_methods = {
        device_probe foo_probe,
        device_attach foo_attach,
        device_detach foo_detach,
    }
}
```

This example creates functions `foo_detach` and `foo_attach` that use the default C calling
convention and adds them to the method table. The `driver!` macro generates the glue so these
functions can call the `device_detach` and `device_attach` methods on the implementation of
`DeviceIf` for `FooDriver`. Also the names `foo_detach` and `foo_attach` are not mangled so they must
be unique.

Here the function `foo_probe` is expected to be defined in a .c file and declared in a header that
gets `#include`d by `src/sys/rust/bindings.h`. This allows adding C functions to the method table
(see `virtio_snd`'s `device_probe` for a good use-case for this). Also keep in mind that even if
a `DeviceIf` implementation has a `device_probe` method it will not get called if the method has
`defined in C`.

Note there is no equivalent of the `DRIVER_MODULE` macro (since there's no real benefit to creating
a parallel implementation of it in rust) so the code above would require the following in a .c file.

```
extern driver_t foo_driver;

DRIVER_MODULE(foo, simplebus, foo_driver, 0, 0);
```

## Defining a generic kobj class

The `define_class!` and `method_table!` macros are the more generic equivalents of `DEFINE_CLASS`
and creating a standalone method table. Using `define_class!` does not require implementing the
`DeviceIf` trait for the driver type, but it does require implementing the `KobjLayout` trait.
