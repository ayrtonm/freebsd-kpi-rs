# Getting Started

## Adding rust sources

Rust sources are added the same way as C sources under`src/sys/conf`, but with a .rs suffix instead
of .c. Each file must begin with `#![no_std]` and is built as a separate crate. Multi-file crates
are not supported.  Crates may depend on other crates, but dependencies must be explicitly specified
using `dependency` in the `config(8)` entry and cyclic dependencies are not allowed. For example to
add a file `src/sys/foo.rs` that depends on `src/sys/bar.rs` and a `src/sys/baz.rs` that's optional
on a `KERNCONF` setting add the following in `src/sys/conf/files`.

```
foo.rs  standard
bar.rs  standard    dependency "libfoo.rlib"
baz.rs  optional    some_option
```

The following error means that one of the .rs files is missing `#![no_std]` at the start.

```
error[E0463]: can't find crate for `std`
```

## Dependencies

Crates may also import items from [`core`](https://doc.rust-lang.org/core/) and
[`kpi`](https://ayrtonm.github.io/freebsd-kpi-rs/). Importing anything from
[`std`](https://doc.rust-lang.org/std/) or [`alloc`](https://doc.rust-lang.org/alloc/) is not
supported. As mentioned in the README, using crates from the wider rust ecosystem (e.g.
https://crates.io) is not supported.

## KPI Prelude and conventions

Adding `use kpi::prelude::*;` imports all rust wrappers for C KPI functions that have them. It also
imports the `kpi::bindings` module which provides access to the declarations generated by bindgen.
Note the latter point refers to the `bindings` module itself, not its contents so this doesn't
create ambiguities about what an identifier refers to. Importing the prelude is optional, but the
convention in the demos is currently to import it and use fully-qualified syntax for calling the
bindgen declarations (i.e. use `bindings::foo()` to call the C version of `foo`).

`core` provides a generic [`Result<T, E>`](https://doc.rust-lang.org/core/result/enum.Result.html)
type that can be either some type `T` in the happy path or another type `E` if there was an error.
The KPI crate defines its own `Result<T>` (note the single generic parameter) in the prelude which
sets `E` to a FreeBSD error code. Using the KPI `Result` instead of `core`'s is strongly suggested
where possible. This avoids proliferating various kinds of error codes and simplifies interop
between different functions. Aside from calling `.unwrap()` here are some other typical ways to use
`Result`.

```
// bar either returns u64 or an error code
fn bar() -> Result<u64> { ... }

fn foo() -> Result<()> {
    // x is a u64. If bar resulted in an error, return that return to foo's caller
    let x = bar()?;

    // y is still a Result<u64>. If bar resulted in an error, print what it was.
    let y = bar().inspect_err(|e| {
        device_println!(dev, "{e:?}");
    });

    // z is a u64. If bar resulted in an error, print what it was but return ENXIO to the caller.
    let z = bar().map_err(|e| {
        device_println!(dev, "the original error was {e:?}");
        ENXIO
    })?;
}
```

## Dynamic memory allocation

Since `alloc` can't be used the KPI crate provides minimal versions of `Vec`, `Box` and `Arc`. Their
APIs loosely mirror the standard rust versions, but differ to provide more finer control over memory
management and simplify FFI interop with existing C code. In particular `Vec` will never allocate
more capacity than explicitly requested.

The KPI crate provides as much transparency as C about dynamic memory allocations. More specifically
this means that functions and methods will only ever dynamically allocate if they take both
`MallocFlags` and `MallocType` arguments or if the underlying C function allocates. The language
itself cannot dynamically allocate.

## Defining a driver

The `driver!` rust macro is the equivalent of using the `DEFINE_CLASS` C macro for device drivers.
This is a typical way to use it.

```
use kpi::bindings::device_t;
use kpi::driver;
use kpi::kobj::interfaces::DeviceIf;
use kpi::prelude::*;

pub struct FooSoftc {
    dev: device_t,
    some_field: u32,
}

impl DeviceIf for FooDriver {
    // This is the only required item in this trait. Omitting any methods makes them panic if called
    type Softc = FooSoftc;

    // The first argument is a pointer to the softc. You must call `.init()` on it before returning
    // from this function. The KPI glue acquires a refcount for the softc before device_attach.
    // device_detach takes an Arc argument which releases that refcount when it goes out of scope.
    fn device_attach(uninit_sc: UninitArc<FooSoftc>, dev: device_t) -> Result<()> {
        let sc_on_stack = FooSoftc {
            dev,
            some_field: 0xdeadbeef,
        };

        // Initializing the softc gives you mutable access to it since there is only one pointer to it
        let mut unique_sc = uninit_sc.init(sc_on_stack);
        unique_sc.some_field = 0xdeadc0de;

        // Calling `.into_arc()` acquires another refcount to allow sharing ownership of the softc
        let sc1 = unique_sc.into_arc();

        // Acquire two more refcounts to the softc
        let sc2 = sc1.clone();
        let sc3 = sc1.clone();

        // At this point sc1, sc2 and sc3 each own their own refcounts to the softc and the KPI glue
        // holds another one

        Ok(())
    }

    fn device_detach(sc: Arc<FooSoftc>, dev: device_t) -> Result<()> {
        // The refcount acquired before device_attach is released when sc gets dropped
        Ok(())
    }
}

driver! {
    foo_driver, c"foo", FooDriver,
    foo_methods = {
        device_probe foo_probe defined in C,
        device_attach foo_attach,
        device_detach foo_detach,
    }
}
```

This example creates functions `foo_detach` and `foo_attach` that use the default C calling
convention and adds them to the method table. The `driver!` macro generates the glue so these
functions can call the `device_detach` and `device_attach` methods on the implementation of
`DeviceIf` for `FooDriver`. Also the names `foo_detach` and `foo_attach` are not mangled so they must
be unique.

Here the function `foo_probe` is expected to be defined in a .c file and declared in a header that
gets `#include`d by `src/sys/rust/bindings.h`. This allows adding C functions to the method table
(see `virtio_snd`'s `device_probe` for a good use-case for this). Also keep in mind that even if
a `DeviceIf` implementation has a `device_probe` method it will not get called if the method has
`defined in C`.

Note there is no equivalent of the `DRIVER_MODULE` macro (since there's no real benefit to creating
a parallel implementation of it in rust) so the code above would require the following in a .c file.

```
extern driver_t foo_driver;

DRIVER_MODULE(foo, simplebus, foo_driver, 0, 0);
```

## Defining a generic kobj class

The `define_class!` and `method_table!` macros are the more generic equivalents of `DEFINE_CLASS`
and creating a standalone method table. Using `define_class!` does not require implementing the
`DeviceIf` trait for the driver type, but it does require implementing the `KobjLayout` trait.
