/* automatically generated by rust-bindgen 0.72.0 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const __llvm__: i32 = 1;
pub const __clang__: i32 = 1;
pub const __clang_major__: i32 = 20;
pub const __clang_minor__: i32 = 1;
pub const __clang_patchlevel__: i32 = 8;
pub const __clang_version__: &[u8; 8] = b"20.1.8 \0";
pub const __GNUC__: i32 = 4;
pub const __GNUC_MINOR__: i32 = 2;
pub const __GNUC_PATCHLEVEL__: i32 = 1;
pub const __GXX_ABI_VERSION: i32 = 1002;
pub const __ATOMIC_RELAXED: i32 = 0;
pub const __ATOMIC_CONSUME: i32 = 1;
pub const __ATOMIC_ACQUIRE: i32 = 2;
pub const __ATOMIC_RELEASE: i32 = 3;
pub const __ATOMIC_ACQ_REL: i32 = 4;
pub const __ATOMIC_SEQ_CST: i32 = 5;
pub const __MEMORY_SCOPE_SYSTEM: i32 = 0;
pub const __MEMORY_SCOPE_DEVICE: i32 = 1;
pub const __MEMORY_SCOPE_WRKGRP: i32 = 2;
pub const __MEMORY_SCOPE_WVFRNT: i32 = 3;
pub const __MEMORY_SCOPE_SINGLE: i32 = 4;
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM: i32 = 0;
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP: i32 = 1;
pub const __OPENCL_MEMORY_SCOPE_DEVICE: i32 = 2;
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES: i32 = 3;
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP: i32 = 4;
pub const __FPCLASS_SNAN: i32 = 1;
pub const __FPCLASS_QNAN: i32 = 2;
pub const __FPCLASS_NEGINF: i32 = 4;
pub const __FPCLASS_NEGNORMAL: i32 = 8;
pub const __FPCLASS_NEGSUBNORMAL: i32 = 16;
pub const __FPCLASS_NEGZERO: i32 = 32;
pub const __FPCLASS_POSZERO: i32 = 64;
pub const __FPCLASS_POSSUBNORMAL: i32 = 128;
pub const __FPCLASS_POSNORMAL: i32 = 256;
pub const __FPCLASS_POSINF: i32 = 512;
pub const __PRAGMA_REDEFINE_EXTNAME: i32 = 1;
pub const __VERSION__: &[u8; 13] = b"Clang 20.1.8\0";
pub const __OBJC_BOOL_IS_BOOL: i32 = 0;
pub const __CONSTANT_CFSTRINGS__: i32 = 1;
pub const __clang_literal_encoding__: &[u8; 6] = b"UTF-8\0";
pub const __clang_wide_literal_encoding__: &[u8; 7] = b"UTF-32\0";
pub const __OPTIMIZE__: i32 = 1;
pub const __ORDER_LITTLE_ENDIAN__: i32 = 1234;
pub const __ORDER_BIG_ENDIAN__: i32 = 4321;
pub const __ORDER_PDP_ENDIAN__: i32 = 3412;
pub const __BYTE_ORDER__: i32 = 1234;
pub const __LITTLE_ENDIAN__: i32 = 1;
pub const _LP64: i32 = 1;
pub const __LP64__: i32 = 1;
pub const __CHAR_BIT__: i32 = 8;
pub const __BOOL_WIDTH__: i32 = 1;
pub const __SHRT_WIDTH__: i32 = 16;
pub const __INT_WIDTH__: i32 = 32;
pub const __LONG_WIDTH__: i32 = 64;
pub const __LLONG_WIDTH__: i32 = 64;
pub const __BITINT_MAXWIDTH__: i32 = 128;
pub const __SCHAR_MAX__: i32 = 127;
pub const __SHRT_MAX__: i32 = 32767;
pub const __INT_MAX__: i32 = 2147483647;
pub const __LONG_MAX__: i64 = 9223372036854775807;
pub const __LONG_LONG_MAX__: i64 = 9223372036854775807;
pub const __WCHAR_MAX__: i64 = 4294967295;
pub const __WCHAR_WIDTH__: i32 = 32;
pub const __WINT_MAX__: i32 = 2147483647;
pub const __WINT_WIDTH__: i32 = 32;
pub const __INTMAX_MAX__: i64 = 9223372036854775807;
pub const __INTMAX_WIDTH__: i32 = 64;
pub const __SIZE_MAX__: i32 = -1;
pub const __SIZE_WIDTH__: i32 = 64;
pub const __UINTMAX_MAX__: i32 = -1;
pub const __UINTMAX_WIDTH__: i32 = 64;
pub const __PTRDIFF_MAX__: i64 = 9223372036854775807;
pub const __PTRDIFF_WIDTH__: i32 = 64;
pub const __INTPTR_MAX__: i64 = 9223372036854775807;
pub const __INTPTR_WIDTH__: i32 = 64;
pub const __UINTPTR_MAX__: i32 = -1;
pub const __UINTPTR_WIDTH__: i32 = 64;
pub const __SIZEOF_DOUBLE__: i32 = 8;
pub const __SIZEOF_FLOAT__: i32 = 4;
pub const __SIZEOF_INT__: i32 = 4;
pub const __SIZEOF_LONG__: i32 = 8;
pub const __SIZEOF_LONG_DOUBLE__: i32 = 16;
pub const __SIZEOF_LONG_LONG__: i32 = 8;
pub const __SIZEOF_POINTER__: i32 = 8;
pub const __SIZEOF_SHORT__: i32 = 2;
pub const __SIZEOF_PTRDIFF_T__: i32 = 8;
pub const __SIZEOF_SIZE_T__: i32 = 8;
pub const __SIZEOF_WCHAR_T__: i32 = 4;
pub const __SIZEOF_WINT_T__: i32 = 4;
pub const __SIZEOF_INT128__: i32 = 16;
pub const __INTMAX_FMTd__: &[u8; 3] = b"ld\0";
pub const __INTMAX_FMTi__: &[u8; 3] = b"li\0";
pub const __UINTMAX_FMTo__: &[u8; 3] = b"lo\0";
pub const __UINTMAX_FMTu__: &[u8; 3] = b"lu\0";
pub const __UINTMAX_FMTx__: &[u8; 3] = b"lx\0";
pub const __UINTMAX_FMTX__: &[u8; 3] = b"lX\0";
pub const __PTRDIFF_FMTd__: &[u8; 3] = b"ld\0";
pub const __PTRDIFF_FMTi__: &[u8; 3] = b"li\0";
pub const __INTPTR_FMTd__: &[u8; 3] = b"ld\0";
pub const __INTPTR_FMTi__: &[u8; 3] = b"li\0";
pub const __SIZE_FMTo__: &[u8; 3] = b"lo\0";
pub const __SIZE_FMTu__: &[u8; 3] = b"lu\0";
pub const __SIZE_FMTx__: &[u8; 3] = b"lx\0";
pub const __SIZE_FMTX__: &[u8; 3] = b"lX\0";
pub const __SIG_ATOMIC_MAX__: i32 = 2147483647;
pub const __SIG_ATOMIC_WIDTH__: i32 = 32;
pub const __UINTPTR_FMTo__: &[u8; 3] = b"lo\0";
pub const __UINTPTR_FMTu__: &[u8; 3] = b"lu\0";
pub const __UINTPTR_FMTx__: &[u8; 3] = b"lx\0";
pub const __UINTPTR_FMTX__: &[u8; 3] = b"lX\0";
pub const __FLT16_HAS_DENORM__: i32 = 1;
pub const __FLT16_DIG__: i32 = 3;
pub const __FLT16_DECIMAL_DIG__: i32 = 5;
pub const __FLT16_HAS_INFINITY__: i32 = 1;
pub const __FLT16_HAS_QUIET_NAN__: i32 = 1;
pub const __FLT16_MANT_DIG__: i32 = 11;
pub const __FLT16_MAX_10_EXP__: i32 = 4;
pub const __FLT16_MAX_EXP__: i32 = 16;
pub const __FLT16_MIN_10_EXP__: i32 = -4;
pub const __FLT16_MIN_EXP__: i32 = -13;
pub const __FLT_HAS_DENORM__: i32 = 1;
pub const __FLT_DIG__: i32 = 6;
pub const __FLT_DECIMAL_DIG__: i32 = 9;
pub const __FLT_HAS_INFINITY__: i32 = 1;
pub const __FLT_HAS_QUIET_NAN__: i32 = 1;
pub const __FLT_MANT_DIG__: i32 = 24;
pub const __FLT_MAX_10_EXP__: i32 = 38;
pub const __FLT_MAX_EXP__: i32 = 128;
pub const __FLT_MIN_10_EXP__: i32 = -37;
pub const __FLT_MIN_EXP__: i32 = -125;
pub const __DBL_HAS_DENORM__: i32 = 1;
pub const __DBL_DIG__: i32 = 15;
pub const __DBL_DECIMAL_DIG__: i32 = 17;
pub const __DBL_HAS_INFINITY__: i32 = 1;
pub const __DBL_HAS_QUIET_NAN__: i32 = 1;
pub const __DBL_MANT_DIG__: i32 = 53;
pub const __DBL_MAX_10_EXP__: i32 = 308;
pub const __DBL_MAX_EXP__: i32 = 1024;
pub const __DBL_MIN_10_EXP__: i32 = -307;
pub const __DBL_MIN_EXP__: i32 = -1021;
pub const __LDBL_HAS_DENORM__: i32 = 1;
pub const __LDBL_DIG__: i32 = 33;
pub const __LDBL_DECIMAL_DIG__: i32 = 36;
pub const __LDBL_HAS_INFINITY__: i32 = 1;
pub const __LDBL_HAS_QUIET_NAN__: i32 = 1;
pub const __LDBL_MANT_DIG__: i32 = 113;
pub const __LDBL_MAX_10_EXP__: i32 = 4932;
pub const __LDBL_MAX_EXP__: i32 = 16384;
pub const __LDBL_MIN_10_EXP__: i32 = -4931;
pub const __LDBL_MIN_EXP__: i32 = -16381;
pub const __POINTER_WIDTH__: i32 = 64;
pub const __BIGGEST_ALIGNMENT__: i32 = 16;
pub const __CHAR_UNSIGNED__: i32 = 1;
pub const __WCHAR_UNSIGNED__: i32 = 1;
pub const __INT8_FMTd__: &[u8; 4] = b"hhd\0";
pub const __INT8_FMTi__: &[u8; 4] = b"hhi\0";
pub const __INT16_FMTd__: &[u8; 3] = b"hd\0";
pub const __INT16_FMTi__: &[u8; 3] = b"hi\0";
pub const __INT32_FMTd__: &[u8; 2] = b"d\0";
pub const __INT32_FMTi__: &[u8; 2] = b"i\0";
pub const __INT64_FMTd__: &[u8; 3] = b"ld\0";
pub const __INT64_FMTi__: &[u8; 3] = b"li\0";
pub const __UINT8_FMTo__: &[u8; 4] = b"hho\0";
pub const __UINT8_FMTu__: &[u8; 4] = b"hhu\0";
pub const __UINT8_FMTx__: &[u8; 4] = b"hhx\0";
pub const __UINT8_FMTX__: &[u8; 4] = b"hhX\0";
pub const __UINT8_MAX__: i32 = 255;
pub const __INT8_MAX__: i32 = 127;
pub const __UINT16_FMTo__: &[u8; 3] = b"ho\0";
pub const __UINT16_FMTu__: &[u8; 3] = b"hu\0";
pub const __UINT16_FMTx__: &[u8; 3] = b"hx\0";
pub const __UINT16_FMTX__: &[u8; 3] = b"hX\0";
pub const __UINT16_MAX__: i32 = 65535;
pub const __INT16_MAX__: i32 = 32767;
pub const __UINT32_FMTo__: &[u8; 2] = b"o\0";
pub const __UINT32_FMTu__: &[u8; 2] = b"u\0";
pub const __UINT32_FMTx__: &[u8; 2] = b"x\0";
pub const __UINT32_FMTX__: &[u8; 2] = b"X\0";
pub const __UINT32_MAX__: i64 = 4294967295;
pub const __INT32_MAX__: i32 = 2147483647;
pub const __UINT64_FMTo__: &[u8; 3] = b"lo\0";
pub const __UINT64_FMTu__: &[u8; 3] = b"lu\0";
pub const __UINT64_FMTx__: &[u8; 3] = b"lx\0";
pub const __UINT64_FMTX__: &[u8; 3] = b"lX\0";
pub const __UINT64_MAX__: i32 = -1;
pub const __INT64_MAX__: i64 = 9223372036854775807;
pub const __INT_LEAST8_MAX__: i32 = 127;
pub const __INT_LEAST8_WIDTH__: i32 = 8;
pub const __INT_LEAST8_FMTd__: &[u8; 4] = b"hhd\0";
pub const __INT_LEAST8_FMTi__: &[u8; 4] = b"hhi\0";
pub const __UINT_LEAST8_MAX__: i32 = 255;
pub const __UINT_LEAST8_FMTo__: &[u8; 4] = b"hho\0";
pub const __UINT_LEAST8_FMTu__: &[u8; 4] = b"hhu\0";
pub const __UINT_LEAST8_FMTx__: &[u8; 4] = b"hhx\0";
pub const __UINT_LEAST8_FMTX__: &[u8; 4] = b"hhX\0";
pub const __INT_LEAST16_MAX__: i32 = 32767;
pub const __INT_LEAST16_WIDTH__: i32 = 16;
pub const __INT_LEAST16_FMTd__: &[u8; 3] = b"hd\0";
pub const __INT_LEAST16_FMTi__: &[u8; 3] = b"hi\0";
pub const __UINT_LEAST16_MAX__: i32 = 65535;
pub const __UINT_LEAST16_FMTo__: &[u8; 3] = b"ho\0";
pub const __UINT_LEAST16_FMTu__: &[u8; 3] = b"hu\0";
pub const __UINT_LEAST16_FMTx__: &[u8; 3] = b"hx\0";
pub const __UINT_LEAST16_FMTX__: &[u8; 3] = b"hX\0";
pub const __INT_LEAST32_MAX__: i32 = 2147483647;
pub const __INT_LEAST32_WIDTH__: i32 = 32;
pub const __INT_LEAST32_FMTd__: &[u8; 2] = b"d\0";
pub const __INT_LEAST32_FMTi__: &[u8; 2] = b"i\0";
pub const __UINT_LEAST32_MAX__: i64 = 4294967295;
pub const __UINT_LEAST32_FMTo__: &[u8; 2] = b"o\0";
pub const __UINT_LEAST32_FMTu__: &[u8; 2] = b"u\0";
pub const __UINT_LEAST32_FMTx__: &[u8; 2] = b"x\0";
pub const __UINT_LEAST32_FMTX__: &[u8; 2] = b"X\0";
pub const __INT_LEAST64_MAX__: i64 = 9223372036854775807;
pub const __INT_LEAST64_WIDTH__: i32 = 64;
pub const __INT_LEAST64_FMTd__: &[u8; 3] = b"ld\0";
pub const __INT_LEAST64_FMTi__: &[u8; 3] = b"li\0";
pub const __UINT_LEAST64_MAX__: i32 = -1;
pub const __UINT_LEAST64_FMTo__: &[u8; 3] = b"lo\0";
pub const __UINT_LEAST64_FMTu__: &[u8; 3] = b"lu\0";
pub const __UINT_LEAST64_FMTx__: &[u8; 3] = b"lx\0";
pub const __UINT_LEAST64_FMTX__: &[u8; 3] = b"lX\0";
pub const __INT_FAST8_MAX__: i32 = 127;
pub const __INT_FAST8_WIDTH__: i32 = 8;
pub const __INT_FAST8_FMTd__: &[u8; 4] = b"hhd\0";
pub const __INT_FAST8_FMTi__: &[u8; 4] = b"hhi\0";
pub const __UINT_FAST8_MAX__: i32 = 255;
pub const __UINT_FAST8_FMTo__: &[u8; 4] = b"hho\0";
pub const __UINT_FAST8_FMTu__: &[u8; 4] = b"hhu\0";
pub const __UINT_FAST8_FMTx__: &[u8; 4] = b"hhx\0";
pub const __UINT_FAST8_FMTX__: &[u8; 4] = b"hhX\0";
pub const __INT_FAST16_MAX__: i32 = 32767;
pub const __INT_FAST16_WIDTH__: i32 = 16;
pub const __INT_FAST16_FMTd__: &[u8; 3] = b"hd\0";
pub const __INT_FAST16_FMTi__: &[u8; 3] = b"hi\0";
pub const __UINT_FAST16_MAX__: i32 = 65535;
pub const __UINT_FAST16_FMTo__: &[u8; 3] = b"ho\0";
pub const __UINT_FAST16_FMTu__: &[u8; 3] = b"hu\0";
pub const __UINT_FAST16_FMTx__: &[u8; 3] = b"hx\0";
pub const __UINT_FAST16_FMTX__: &[u8; 3] = b"hX\0";
pub const __INT_FAST32_MAX__: i32 = 2147483647;
pub const __INT_FAST32_WIDTH__: i32 = 32;
pub const __INT_FAST32_FMTd__: &[u8; 2] = b"d\0";
pub const __INT_FAST32_FMTi__: &[u8; 2] = b"i\0";
pub const __UINT_FAST32_MAX__: i64 = 4294967295;
pub const __UINT_FAST32_FMTo__: &[u8; 2] = b"o\0";
pub const __UINT_FAST32_FMTu__: &[u8; 2] = b"u\0";
pub const __UINT_FAST32_FMTx__: &[u8; 2] = b"x\0";
pub const __UINT_FAST32_FMTX__: &[u8; 2] = b"X\0";
pub const __INT_FAST64_MAX__: i64 = 9223372036854775807;
pub const __INT_FAST64_WIDTH__: i32 = 64;
pub const __INT_FAST64_FMTd__: &[u8; 3] = b"ld\0";
pub const __INT_FAST64_FMTi__: &[u8; 3] = b"li\0";
pub const __UINT_FAST64_MAX__: i32 = -1;
pub const __UINT_FAST64_FMTo__: &[u8; 3] = b"lo\0";
pub const __UINT_FAST64_FMTu__: &[u8; 3] = b"lu\0";
pub const __UINT_FAST64_FMTx__: &[u8; 3] = b"lx\0";
pub const __UINT_FAST64_FMTX__: &[u8; 3] = b"lX\0";
pub const __FINITE_MATH_ONLY__: i32 = 0;
pub const __GNUC_STDC_INLINE__: i32 = 1;
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL: i32 = 1;
pub const __GCC_DESTRUCTIVE_SIZE: i32 = 64;
pub const __GCC_CONSTRUCTIVE_SIZE: i32 = 64;
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE: i32 = 2;
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE: i32 = 2;
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE: i32 = 2;
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE: i32 = 2;
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE: i32 = 2;
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE: i32 = 2;
pub const __CLANG_ATOMIC_INT_LOCK_FREE: i32 = 2;
pub const __CLANG_ATOMIC_LONG_LOCK_FREE: i32 = 2;
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE: i32 = 2;
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE: i32 = 2;
pub const __GCC_ATOMIC_BOOL_LOCK_FREE: i32 = 2;
pub const __GCC_ATOMIC_CHAR_LOCK_FREE: i32 = 2;
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE: i32 = 2;
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE: i32 = 2;
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE: i32 = 2;
pub const __GCC_ATOMIC_SHORT_LOCK_FREE: i32 = 2;
pub const __GCC_ATOMIC_INT_LOCK_FREE: i32 = 2;
pub const __GCC_ATOMIC_LONG_LOCK_FREE: i32 = 2;
pub const __GCC_ATOMIC_LLONG_LOCK_FREE: i32 = 2;
pub const __GCC_ATOMIC_POINTER_LOCK_FREE: i32 = 2;
pub const __FLT_RADIX__: i32 = 2;
pub const __DECIMAL_DIG__: i32 = 36;
pub const __SSP__: i32 = 1;
pub const __ELF__: i32 = 1;
pub const __AARCH64EL__: i32 = 1;
pub const __aarch64__: i32 = 1;
pub const __GCC_ASM_FLAG_OUTPUTS__: i32 = 1;
pub const __AARCH64_CMODEL_SMALL__: i32 = 1;
pub const __ARM_ACLE: i32 = 202420;
pub const __FUNCTION_MULTI_VERSIONING_SUPPORT_LEVEL: i32 = 202430;
pub const __ARM_ARCH: i32 = 8;
pub const __ARM_ARCH_PROFILE: u8 = 65u8;
pub const __ARM_64BIT_STATE: i32 = 1;
pub const __ARM_PCS_AAPCS64: i32 = 1;
pub const __ARM_ARCH_ISA_A64: i32 = 1;
pub const __ARM_FEATURE_CLZ: i32 = 1;
pub const __ARM_FEATURE_FMA: i32 = 1;
pub const __ARM_FEATURE_LDREX: i32 = 15;
pub const __ARM_FEATURE_IDIV: i32 = 1;
pub const __ARM_FEATURE_DIV: i32 = 1;
pub const __ARM_FEATURE_NUMERIC_MAXMIN: i32 = 1;
pub const __ARM_FEATURE_DIRECTED_ROUNDING: i32 = 1;
pub const __ARM_ALIGN_MAX_STACK_PWR: i32 = 4;
pub const __ARM_STATE_ZA: i32 = 1;
pub const __ARM_STATE_ZT0: i32 = 1;
pub const __ARM_FP16_FORMAT_IEEE: i32 = 1;
pub const __ARM_FP16_ARGS: i32 = 1;
pub const __ARM_NEON_SVE_BRIDGE: i32 = 1;
pub const __ARM_SIZEOF_WCHAR_T: i32 = 4;
pub const __ARM_SIZEOF_MINIMAL_ENUM: i32 = 4;
pub const __ARM_FEATURE_UNALIGNED: i32 = 1;
pub const __ARM_FEATURE_PAC_DEFAULT: i32 = 1;
pub const __ARM_FEATURE_BTI_DEFAULT: i32 = 1;
pub const __ARM_FEATURE_GCS_DEFAULT: i32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1: i32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2: i32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4: i32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8: i32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16: i32 = 1;
pub const __FP_FAST_FMA: i32 = 1;
pub const __FP_FAST_FMAF: i32 = 1;
pub const __STDC__: i32 = 1;
pub const __STDC_HOSTED__: i32 = 0;
pub const __STDC_VERSION__: i32 = 201710;
pub const __STDC_UTF_16__: i32 = 1;
pub const __STDC_UTF_32__: i32 = 1;
pub const __STDC_EMBED_NOT_FOUND__: i32 = 0;
pub const __STDC_EMBED_FOUND__: i32 = 1;
pub const __STDC_EMBED_EMPTY__: i32 = 2;
pub const _KERNEL: i32 = 1;
pub const HAVE_KERNEL_OPTION_HEADERS: i32 = 1;
pub const LINUX_DTS_VERSION: &[u8; 5] = b"6.12\0";
pub const BINDGEN: i32 = 1;
pub const __GCC_HAVE_DWARF2_CFI_ASM: i32 = 1;
pub const BUF_TRACKING: i32 = 1;
pub const FULL_BUF_TRACKING: i32 = 1;
pub const QUEUE_MACRO_DEBUG_TRASH: i32 = 1;
pub const CC_CUBIC: i32 = 1;
pub const COMPAT_FREEBSD12: i32 = 1;
pub const COMPAT_FREEBSD14: i32 = 1;
pub const KDTRACE_MIB_SDT: i32 = 1;
pub const PCI_IOV: i32 = 1;
pub const NETDUMP: i32 = 1;
pub const TCP_BLACKBOX: i32 = 1;
pub const INVARIANT_SUPPORT: i32 = 1;
pub const SMP: i32 = 1;
pub const WITNESS: i32 = 1;
pub const VIMAGE: i32 = 1;
pub const RACCT_DEFAULT_TO_DISABLED: i32 = 1;
pub const ARM64: i32 = 1;
pub const VFP: i32 = 1;
pub const PERTHREAD_SSP: i32 = 1;
pub const COMPAT_FREEBSD32: i32 = 1;
pub const LINUX_BOOT_ABI: i32 = 1;
pub const INTRNG: i32 = 1;
pub const RCTL: i32 = 1;
pub const RACCT: i32 = 1;
pub const DEV_NETMAP: i32 = 1;
pub const NUMA: i32 = 1;
pub const INVARIANTS: i32 = 1;
pub const TCP_HHOOK: i32 = 1;
pub const NETLINK: i32 = 1;
pub const DEBUGNET: i32 = 1;
pub const MAC: i32 = 1;
pub const KDTRACE_HOOKS: i32 = 1;
pub const COMPAT_FREEBSD13: i32 = 1;
pub const COMPAT_FREEBSD11: i32 = 1;
pub const AUDIT: i32 = 1;
pub const KDB: i32 = 1;
pub const EXTERR_STRINGS: i32 = 1;
pub const FDT: i32 = 1;
pub const __CC_SUPPORTS___INLINE: i32 = 1;
pub const __CC_SUPPORTS_SYMVER: i32 = 1;
pub const __POSIX_VISIBLE: i32 = 202405;
pub const __XSI_VISIBLE: i32 = 800;
pub const __BSD_VISIBLE: i32 = 1;
pub const __ISO_C_VISIBLE: i32 = 2023;
pub const __EXT1_VISIBLE: i32 = 1;
pub const NBBY: i32 = 8;
pub const BSD: i32 = 199506;
pub const BSD4_3: i32 = 1;
pub const BSD4_4: i32 = 1;
pub const __FreeBSD_version: i32 = 1600002;
pub const P_OSREL_SIGWAIT: i32 = 700000;
pub const P_OSREL_SIGSEGV: i32 = 700004;
pub const P_OSREL_MAP_ANON: i32 = 800104;
pub const P_OSREL_MAP_FSTRICT: i32 = 1100036;
pub const P_OSREL_SHUTDOWN_ENOTCONN: i32 = 1100077;
pub const P_OSREL_MAP_GUARD: i32 = 1200035;
pub const P_OSREL_WRFSBASE: i32 = 1200041;
pub const P_OSREL_CK_CYLGRP: i32 = 1200046;
pub const P_OSREL_VMTOTAL64: i32 = 1200054;
pub const P_OSREL_CK_SUPERBLOCK: i32 = 1300000;
pub const P_OSREL_CK_INODE: i32 = 1300005;
pub const P_OSREL_POWERPC_NEW_AUX_ARGS: i32 = 1300070;
pub const P_OSREL_TIDPID: i32 = 1400079;
pub const P_OSREL_ARM64_SPSR: i32 = 1400084;
pub const P_OSREL_TLSBASE: i32 = 1500044;
pub const P_OSREL_EXTERRCTL: i32 = 1500045;
pub const __WCHAR_MIN: i32 = 0;
pub const _BYTE_ORDER: i32 = 1234;
pub const _LITTLE_ENDIAN: i32 = 1234;
pub const _BIG_ENDIAN: i32 = 4321;
pub const _PDP_ENDIAN: i32 = 3412;
pub const _QUAD_HIGHWORD: i32 = 1;
pub const _QUAD_LOWWORD: i32 = 0;
pub const LITTLE_ENDIAN: i32 = 1234;
pub const BIG_ENDIAN: i32 = 4321;
pub const PDP_ENDIAN: i32 = 3412;
pub const BYTE_ORDER: i32 = 1234;
pub const __bool_true_false_are_defined: i32 = 1;
pub const false_: i32 = 0;
pub const true_: i32 = 1;
pub const _SIG_WORDS: i32 = 4;
pub const _SIG_MAXSIG: i32 = 128;
pub const __SSP_FORTIFY_LEVEL: i32 = 0;
pub const FD_SETSIZE: i32 = 1024;
pub const ARG_MAX: i32 = 524288;
pub const CHILD_MAX: i32 = 40;
pub const MAX_CANON: i32 = 255;
pub const MAX_INPUT: i32 = 255;
pub const NAME_MAX: i32 = 255;
pub const NGROUPS_MAX: i32 = 1023;
pub const OPEN_MAX: i32 = 64;
pub const PATH_MAX: i32 = 1024;
pub const PIPE_BUF: i32 = 512;
pub const IOV_MAX: i32 = 1024;
pub const MAXCOMLEN: i32 = 19;
pub const MAXINTERP: i32 = 1024;
pub const MAXLOGNAME: i32 = 33;
pub const MAXUPRC: i32 = 40;
pub const NCARGS: i32 = 524288;
pub const NGROUPS: i32 = 1024;
pub const NOFILE: i32 = 64;
pub const NOGROUP: i32 = 65535;
pub const MAXHOSTNAMELEN: i32 = 256;
pub const SPECNAMELEN: i32 = 255;
pub const EPERM: i32 = 1;
pub const ENOENT: i32 = 2;
pub const ESRCH: i32 = 3;
pub const EINTR: i32 = 4;
pub const EIO: i32 = 5;
pub const ENXIO: i32 = 6;
pub const E2BIG: i32 = 7;
pub const ENOEXEC: i32 = 8;
pub const EBADF: i32 = 9;
pub const ECHILD: i32 = 10;
pub const EDEADLK: i32 = 11;
pub const ENOMEM: i32 = 12;
pub const EACCES: i32 = 13;
pub const EFAULT: i32 = 14;
pub const ENOTBLK: i32 = 15;
pub const EBUSY: i32 = 16;
pub const EEXIST: i32 = 17;
pub const EXDEV: i32 = 18;
pub const ENODEV: i32 = 19;
pub const ENOTDIR: i32 = 20;
pub const EISDIR: i32 = 21;
pub const EINVAL: i32 = 22;
pub const ENFILE: i32 = 23;
pub const EMFILE: i32 = 24;
pub const ENOTTY: i32 = 25;
pub const ETXTBSY: i32 = 26;
pub const EFBIG: i32 = 27;
pub const ENOSPC: i32 = 28;
pub const ESPIPE: i32 = 29;
pub const EROFS: i32 = 30;
pub const EMLINK: i32 = 31;
pub const EPIPE: i32 = 32;
pub const EDOM: i32 = 33;
pub const ERANGE: i32 = 34;
pub const EAGAIN: i32 = 35;
pub const EWOULDBLOCK: i32 = 35;
pub const EINPROGRESS: i32 = 36;
pub const EALREADY: i32 = 37;
pub const ENOTSOCK: i32 = 38;
pub const EDESTADDRREQ: i32 = 39;
pub const EMSGSIZE: i32 = 40;
pub const EPROTOTYPE: i32 = 41;
pub const ENOPROTOOPT: i32 = 42;
pub const EPROTONOSUPPORT: i32 = 43;
pub const ESOCKTNOSUPPORT: i32 = 44;
pub const EOPNOTSUPP: i32 = 45;
pub const ENOTSUP: i32 = 45;
pub const EPFNOSUPPORT: i32 = 46;
pub const EAFNOSUPPORT: i32 = 47;
pub const EADDRINUSE: i32 = 48;
pub const EADDRNOTAVAIL: i32 = 49;
pub const ENETDOWN: i32 = 50;
pub const ENETUNREACH: i32 = 51;
pub const ENETRESET: i32 = 52;
pub const ECONNABORTED: i32 = 53;
pub const ECONNRESET: i32 = 54;
pub const ENOBUFS: i32 = 55;
pub const EISCONN: i32 = 56;
pub const ENOTCONN: i32 = 57;
pub const ESHUTDOWN: i32 = 58;
pub const ETOOMANYREFS: i32 = 59;
pub const ETIMEDOUT: i32 = 60;
pub const ECONNREFUSED: i32 = 61;
pub const ELOOP: i32 = 62;
pub const ENAMETOOLONG: i32 = 63;
pub const EHOSTDOWN: i32 = 64;
pub const EHOSTUNREACH: i32 = 65;
pub const ENOTEMPTY: i32 = 66;
pub const EPROCLIM: i32 = 67;
pub const EUSERS: i32 = 68;
pub const EDQUOT: i32 = 69;
pub const ESTALE: i32 = 70;
pub const EREMOTE: i32 = 71;
pub const EBADRPC: i32 = 72;
pub const ERPCMISMATCH: i32 = 73;
pub const EPROGUNAVAIL: i32 = 74;
pub const EPROGMISMATCH: i32 = 75;
pub const EPROCUNAVAIL: i32 = 76;
pub const ENOLCK: i32 = 77;
pub const ENOSYS: i32 = 78;
pub const EFTYPE: i32 = 79;
pub const EAUTH: i32 = 80;
pub const ENEEDAUTH: i32 = 81;
pub const EIDRM: i32 = 82;
pub const ENOMSG: i32 = 83;
pub const EOVERFLOW: i32 = 84;
pub const ECANCELED: i32 = 85;
pub const EILSEQ: i32 = 86;
pub const ENOATTR: i32 = 87;
pub const EDOOFUS: i32 = 88;
pub const EBADMSG: i32 = 89;
pub const EMULTIHOP: i32 = 90;
pub const ENOLINK: i32 = 91;
pub const EPROTO: i32 = 92;
pub const ENOTCAPABLE: i32 = 93;
pub const ECAPMODE: i32 = 94;
pub const ENOTRECOVERABLE: i32 = 95;
pub const EOWNERDEAD: i32 = 96;
pub const EINTEGRITY: i32 = 97;
pub const ELAST: i32 = 97;
pub const ERESTART: i32 = -1;
pub const EJUSTRETURN: i32 = -2;
pub const ENOIOCTL: i32 = -3;
pub const EDIRIOCTL: i32 = -4;
pub const ERELOOKUP: i32 = -5;
pub const CLOCK_REALTIME: i32 = 0;
pub const CLOCK_VIRTUAL: i32 = 1;
pub const CLOCK_PROF: i32 = 2;
pub const CLOCK_MONOTONIC: i32 = 4;
pub const CLOCK_UPTIME_FAST: i32 = 8;
pub const CLOCK_UPTIME: i32 = 5;
pub const CLOCK_UPTIME_PRECISE: i32 = 7;
pub const CLOCK_REALTIME_PRECISE: i32 = 9;
pub const CLOCK_REALTIME_FAST: i32 = 10;
pub const CLOCK_MONOTONIC_PRECISE: i32 = 11;
pub const CLOCK_MONOTONIC_FAST: i32 = 12;
pub const CLOCK_SECOND: i32 = 13;
pub const CLOCK_THREAD_CPUTIME_ID: i32 = 14;
pub const CLOCK_PROCESS_CPUTIME_ID: i32 = 15;
pub const CLOCK_TAI: i32 = 16;
pub const CLOCK_BOOTTIME: i32 = 4;
pub const CLOCK_REALTIME_COARSE: i32 = 10;
pub const CLOCK_MONOTONIC_COARSE: i32 = 12;
pub const TIMER_RELTIME: i32 = 0;
pub const TIMER_ABSTIME: i32 = 1;
pub const DST_NONE: i32 = 0;
pub const DST_USA: i32 = 1;
pub const DST_AUST: i32 = 2;
pub const DST_WET: i32 = 3;
pub const DST_MET: i32 = 4;
pub const DST_EET: i32 = 5;
pub const DST_CAN: i32 = 6;
pub const SBT_MAX: i64 = 9223372036854775807;
pub const ITIMER_REAL: i32 = 0;
pub const ITIMER_VIRTUAL: i32 = 1;
pub const ITIMER_PROF: i32 = 2;
pub const CPUCLOCK_WHICH_PID: i32 = 0;
pub const CPUCLOCK_WHICH_TID: i32 = 1;
pub const HZ_MINIMUM: i32 = 8;
pub const TC_DEFAULTPERC: i32 = 5;
pub const PRI_ITHD: i32 = 1;
pub const PRI_REALTIME: i32 = 2;
pub const PRI_TIMESHARE: i32 = 3;
pub const PRI_IDLE: i32 = 4;
pub const PRI_FIFO_BIT: i32 = 8;
pub const PRI_FIFO: i32 = 10;
pub const PRI_MIN: i32 = 0;
pub const PRI_MAX: i32 = 255;
pub const PRI_MIN_ITHD: i32 = 0;
pub const PI_REALTIME: i32 = 0;
pub const PI_INTR: i32 = 1;
pub const PI_AV: i32 = 1;
pub const PI_NET: i32 = 1;
pub const PI_DISK: i32 = 1;
pub const PI_TTY: i32 = 1;
pub const PI_DULL: i32 = 1;
pub const PI_SOFT: i32 = 2;
pub const PI_SOFTCLOCK: i32 = 2;
pub const PRI_MIN_REALTIME: i32 = 8;
pub const PRI_MIN_KERN: i32 = 40;
pub const PSWP: i32 = 40;
pub const PVM: i32 = 41;
pub const PINOD: i32 = 42;
pub const PRIBIO: i32 = 43;
pub const PVFS: i32 = 44;
pub const PZERO: i32 = 45;
pub const PSOCK: i32 = 46;
pub const PWAIT: i32 = 47;
pub const PLOCK: i32 = 48;
pub const PPAUSE: i32 = 49;
pub const PRI_MIN_TIMESHARE: i32 = 56;
pub const PUSER: i32 = 56;
pub const PRI_MIN_IDLE: i32 = 224;
pub const PRI_MAX_IDLE: i32 = 255;
pub const PRI_USER: i32 = -2;
pub const PRI_UNCHANGED: i32 = -1;
pub const FALSE: i32 = 0;
pub const TRUE: i32 = 1;
pub const STACKALIGNBYTES: i32 = 15;
pub const MACHINE: &[u8; 6] = b"arm64\0";
pub const MACHINE_ARCH: &[u8; 8] = b"aarch64\0";
pub const MACHINE_ARCH32: &[u8; 6] = b"armv7\0";
pub const MAXCPU: i32 = 1024;
pub const MAXMEMDOM: i32 = 8;
pub const CACHE_LINE_SHIFT: i32 = 7;
pub const CACHE_LINE_SIZE: i32 = 128;
pub const PAGE_SHIFT_4K: i32 = 12;
pub const PAGE_SIZE_4K: i32 = 4096;
pub const PAGE_SHIFT_16K: i32 = 14;
pub const PAGE_SIZE_16K: i32 = 16384;
pub const PAGE_SHIFT_64K: i32 = 16;
pub const PAGE_SIZE_64K: i32 = 65536;
pub const PAGE_SHIFT: i32 = 14;
pub const PAGE_SIZE: i32 = 16384;
pub const PAGE_MASK: i32 = 16383;
pub const MAXPAGESIZES: i32 = 4;
pub const KSTACK_PAGES: i32 = 4;
pub const KSTACK_GUARD_PAGES: i32 = 1;
pub const PCPU_PAGES: i32 = 1;
pub const DEV_BSHIFT: i32 = 9;
pub const DEV_BSIZE: i32 = 512;
pub const BLKDEV_IOSIZE: i32 = 16384;
pub const DFLTPHYS: i32 = 65536;
pub const MAXDUMPPGS: i32 = 4;
pub const MSIZE: i32 = 256;
pub const MCLSHIFT: i32 = 11;
pub const MCLBYTES: i32 = 2048;
pub const MJUMPAGESIZE: i32 = 8192;
pub const MJUM9BYTES: i32 = 9216;
pub const MJUM16BYTES: i32 = 16384;
pub const PRIMASK: i32 = 255;
pub const PCATCH: i32 = 256;
pub const PDROP: i32 = 512;
pub const PNOLOCK: i32 = 1024;
pub const PRILASTFLAG: i32 = 1024;
pub const NZERO: i32 = 0;
pub const CMASK: i32 = 18;
pub const MAXBSIZE: i32 = 65536;
pub const MAXBCACHEBUF: i32 = 65536;
pub const BKVASIZE: i32 = 16384;
pub const BKVAMASK: i32 = 16383;
pub const MAXPATHLEN: i32 = 1024;
pub const MAXSYMLINKS: i32 = 32;
pub const FSHIFT: i32 = 11;
pub const FSCALE: i32 = 2048;
pub const __CHAR_BIT: i32 = 8;
pub const __SCHAR_MAX: i32 = 127;
pub const __SCHAR_MIN: i32 = -128;
pub const __UCHAR_MAX: i32 = 255;
pub const __USHRT_MAX: i32 = 65535;
pub const __SHRT_MAX: i32 = 32767;
pub const __SHRT_MIN: i32 = -32768;
pub const __UINT_MAX: i64 = 4294967295;
pub const __INT_MAX: i32 = 2147483647;
pub const __INT_MIN: i32 = -2147483648;
pub const __ULONG_MAX: i32 = -1;
pub const __LONG_MAX: i64 = 9223372036854775807;
pub const __LONG_MIN: i64 = -9223372036854775808;
pub const __ULLONG_MAX: i32 = -1;
pub const __LLONG_MAX: i64 = 9223372036854775807;
pub const __LLONG_MIN: i64 = -9223372036854775808;
pub const __SSIZE_MAX: i64 = 9223372036854775807;
pub const __SIZE_T_MAX: i32 = -1;
pub const __OFF_MAX: i64 = 9223372036854775807;
pub const __OFF_MIN: i64 = -9223372036854775808;
pub const __UQUAD_MAX: i32 = -1;
pub const __QUAD_MAX: i64 = 9223372036854775807;
pub const __QUAD_MIN: i64 = -9223372036854775808;
pub const __LONG_BIT: i32 = 64;
pub const __WORD_BIT: i32 = 32;
pub const __MINSIGSTKSZ: i32 = 4096;
pub const IOCPARM_SHIFT: i32 = 13;
pub const IOCPARM_MASK: i32 = 8191;
pub const IOCPARM_MAX: i32 = 8192;
pub const IOC_VOID: i32 = 536870912;
pub const IOC_OUT: i32 = 1073741824;
pub const IOC_IN: i64 = 2147483648;
pub const IOC_INOUT: i64 = 3221225472;
pub const IOC_DIRMASK: i64 = 3758096384;
pub const BUS_USER_VERSION: i32 = 2;
pub const BUS_USER_BUFFER: i32 = 3072;
pub const DF_ENABLED: i32 = 1;
pub const DF_FIXEDCLASS: i32 = 2;
pub const DF_WILDCARD: i32 = 4;
pub const DF_DESCMALLOCED: i32 = 8;
pub const DF_QUIET: i32 = 16;
pub const DF_DONENOMATCH: i32 = 32;
pub const DF_EXTERNALSOFTC: i32 = 64;
pub const DF_SUSPENDED: i32 = 256;
pub const DF_QUIET_CHILDREN: i32 = 512;
pub const DF_ATTACHED_ONCE: i32 = 1024;
pub const DF_NEEDNOMATCH: i32 = 2048;
pub const DEVF_FORCE_DETACH: i32 = 1;
pub const DEVF_SET_DRIVER_DETACH: i32 = 1;
pub const DEVF_CLEAR_DRIVER_DETACH: i32 = 1;
pub const DEVF_FORCE_DELETE: i32 = 1;
pub const DEVF_RESET_DETACH: i32 = 1;
pub const DEVICE_UNIT_ANY: i32 = -1;
pub const EHE_DEAD_PRIORITY: i32 = -1;
pub const KOBJ_CACHE_SIZE: i32 = 256;
pub const CALLOUT_TRYLOCK: i32 = 1;
pub const CALLOUT_ACTIVE: i32 = 2;
pub const CALLOUT_PENDING: i32 = 4;
pub const CALLOUT_MPSAFE: i32 = 8;
pub const CALLOUT_RETURNUNLOCKED: i32 = 16;
pub const CALLOUT_SHAREDLOCK: i32 = 32;
pub const CALLOUT_DFRMIGRATION: i32 = 64;
pub const CALLOUT_PROCESSED: i32 = 128;
pub const CALLOUT_DIRECT: i32 = 256;
pub const C_DIRECT_EXEC: i32 = 1;
pub const C_PRELBITS: i32 = 7;
pub const C_PRELRANGE: i32 = 127;
pub const C_HARDCLOCK: i32 = 256;
pub const C_ABSOLUTE: i32 = 512;
pub const C_PRECALC: i32 = 1024;
pub const C_CATCH: i32 = 2048;
pub const CS_DRAIN: i32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT8_MAX: i32 = 127;
pub const INT16_MAX: i32 = 32767;
pub const INT32_MAX: i32 = 2147483647;
pub const INT64_MAX: i64 = 9223372036854775807;
pub const UINT8_MAX: i32 = 255;
pub const UINT16_MAX: i32 = 65535;
pub const UINT32_MAX: i64 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: i32 = 127;
pub const INT_LEAST16_MAX: i32 = 32767;
pub const INT_LEAST32_MAX: i32 = 2147483647;
pub const INT_LEAST64_MAX: i64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: i32 = 255;
pub const UINT_LEAST16_MAX: i32 = 65535;
pub const UINT_LEAST32_MAX: i64 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -2147483648;
pub const INT_FAST16_MIN: i32 = -2147483648;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: i32 = 2147483647;
pub const INT_FAST16_MAX: i32 = 2147483647;
pub const INT_FAST32_MAX: i32 = 2147483647;
pub const INT_FAST64_MAX: i64 = 9223372036854775807;
pub const UINT_FAST8_MAX: i64 = 4294967295;
pub const UINT_FAST16_MAX: i64 = 4294967295;
pub const UINT_FAST32_MAX: i64 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: i64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: i64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: i64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i64 = -9223372036854775808;
pub const SIG_ATOMIC_MAX: i64 = 9223372036854775807;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: i32 = 2147483647;
pub const __WORDSIZE: i32 = 64;
pub const WCHAR_MIN: i32 = 0;
pub const RSIZE_MAX: i32 = -1;
pub const INSN_SIZE: i32 = 4;
pub const AFSR0_EL1_op0: i32 = 3;
pub const AFSR0_EL1_op1: i32 = 0;
pub const AFSR0_EL1_CRn: i32 = 5;
pub const AFSR0_EL1_CRm: i32 = 1;
pub const AFSR0_EL1_op2: i32 = 0;
pub const AFSR0_EL12_op0: i32 = 3;
pub const AFSR0_EL12_op1: i32 = 5;
pub const AFSR0_EL12_CRn: i32 = 5;
pub const AFSR0_EL12_CRm: i32 = 1;
pub const AFSR0_EL12_op2: i32 = 0;
pub const AFSR1_EL1_op0: i32 = 3;
pub const AFSR1_EL1_op1: i32 = 0;
pub const AFSR1_EL1_CRn: i32 = 5;
pub const AFSR1_EL1_CRm: i32 = 1;
pub const AFSR1_EL1_op2: i32 = 1;
pub const AFSR1_EL12_op0: i32 = 3;
pub const AFSR1_EL12_op1: i32 = 5;
pub const AFSR1_EL12_CRn: i32 = 5;
pub const AFSR1_EL12_CRm: i32 = 1;
pub const AFSR1_EL12_op2: i32 = 1;
pub const AMAIR_EL1_op0: i32 = 3;
pub const AMAIR_EL1_op1: i32 = 0;
pub const AMAIR_EL1_CRn: i32 = 10;
pub const AMAIR_EL1_CRm: i32 = 3;
pub const AMAIR_EL1_op2: i32 = 0;
pub const AMAIR_EL12_op0: i32 = 3;
pub const AMAIR_EL12_op1: i32 = 5;
pub const AMAIR_EL12_CRn: i32 = 10;
pub const AMAIR_EL12_CRm: i32 = 3;
pub const AMAIR_EL12_op2: i32 = 0;
pub const APDAKeyHi_EL1_op0: i32 = 3;
pub const APDAKeyHi_EL1_op1: i32 = 0;
pub const APDAKeyHi_EL1_CRn: i32 = 2;
pub const APDAKeyHi_EL1_CRm: i32 = 2;
pub const APDAKeyHi_EL1_op2: i32 = 1;
pub const APDAKeyLo_EL1_op0: i32 = 3;
pub const APDAKeyLo_EL1_op1: i32 = 0;
pub const APDAKeyLo_EL1_CRn: i32 = 2;
pub const APDAKeyLo_EL1_CRm: i32 = 2;
pub const APDAKeyLo_EL1_op2: i32 = 0;
pub const APDBKeyHi_EL1_op0: i32 = 3;
pub const APDBKeyHi_EL1_op1: i32 = 0;
pub const APDBKeyHi_EL1_CRn: i32 = 2;
pub const APDBKeyHi_EL1_CRm: i32 = 2;
pub const APDBKeyHi_EL1_op2: i32 = 3;
pub const APDBKeyLo_EL1_op0: i32 = 3;
pub const APDBKeyLo_EL1_op1: i32 = 0;
pub const APDBKeyLo_EL1_CRn: i32 = 2;
pub const APDBKeyLo_EL1_CRm: i32 = 2;
pub const APDBKeyLo_EL1_op2: i32 = 2;
pub const APGAKeyHi_EL1_op0: i32 = 3;
pub const APGAKeyHi_EL1_op1: i32 = 0;
pub const APGAKeyHi_EL1_CRn: i32 = 2;
pub const APGAKeyHi_EL1_CRm: i32 = 3;
pub const APGAKeyHi_EL1_op2: i32 = 1;
pub const APGAKeyLo_EL1_op0: i32 = 3;
pub const APGAKeyLo_EL1_op1: i32 = 0;
pub const APGAKeyLo_EL1_CRn: i32 = 2;
pub const APGAKeyLo_EL1_CRm: i32 = 3;
pub const APGAKeyLo_EL1_op2: i32 = 0;
pub const APIAKeyHi_EL1_op0: i32 = 3;
pub const APIAKeyHi_EL1_op1: i32 = 0;
pub const APIAKeyHi_EL1_CRn: i32 = 2;
pub const APIAKeyHi_EL1_CRm: i32 = 1;
pub const APIAKeyHi_EL1_op2: i32 = 1;
pub const APIAKeyLo_EL1_op0: i32 = 3;
pub const APIAKeyLo_EL1_op1: i32 = 0;
pub const APIAKeyLo_EL1_CRn: i32 = 2;
pub const APIAKeyLo_EL1_CRm: i32 = 1;
pub const APIAKeyLo_EL1_op2: i32 = 0;
pub const APIBKeyHi_EL1_op0: i32 = 3;
pub const APIBKeyHi_EL1_op1: i32 = 0;
pub const APIBKeyHi_EL1_CRn: i32 = 2;
pub const APIBKeyHi_EL1_CRm: i32 = 1;
pub const APIBKeyHi_EL1_op2: i32 = 3;
pub const APIBKeyLo_EL1_op0: i32 = 3;
pub const APIBKeyLo_EL1_op1: i32 = 0;
pub const APIBKeyLo_EL1_CRn: i32 = 2;
pub const APIBKeyLo_EL1_CRm: i32 = 1;
pub const APIBKeyLo_EL1_op2: i32 = 2;
pub const CCSIDR_NumSets_MASK: i32 = 268427264;
pub const CCSIDR_NumSets64_MASK: i64 = 72057589742960640;
pub const CCSIDR_NumSets_SHIFT: i32 = 13;
pub const CCSIDR_NumSets64_SHIFT: i32 = 32;
pub const CCSIDR_Assoc_MASK: i32 = 8184;
pub const CCSIDR_Assoc64_MASK: i32 = 16777208;
pub const CCSIDR_Assoc_SHIFT: i32 = 3;
pub const CCSIDR_Assoc64_SHIFT: i32 = 3;
pub const CCSIDR_LineSize_MASK: i32 = 7;
pub const CLIDR_CTYPE_MASK: i32 = 7;
pub const CLIDR_CTYPE_IO: i32 = 1;
pub const CLIDR_CTYPE_DO: i32 = 2;
pub const CLIDR_CTYPE_ID: i32 = 3;
pub const CLIDR_CTYPE_UNIFIED: i32 = 4;
pub const CNTKCTL_EL1_op0: i32 = 3;
pub const CNTKCTL_EL1_op1: i32 = 0;
pub const CNTKCTL_EL1_CRn: i32 = 14;
pub const CNTKCTL_EL1_CRm: i32 = 1;
pub const CNTKCTL_EL1_op2: i32 = 0;
pub const CNTKCTL_EL12_op0: i32 = 3;
pub const CNTKCTL_EL12_op1: i32 = 5;
pub const CNTKCTL_EL12_CRn: i32 = 14;
pub const CNTKCTL_EL12_CRm: i32 = 1;
pub const CNTKCTL_EL12_op2: i32 = 0;
pub const CNTP_CTL_EL0_op0: i32 = 3;
pub const CNTP_CTL_EL0_op1: i32 = 3;
pub const CNTP_CTL_EL0_CRn: i32 = 14;
pub const CNTP_CTL_EL0_CRm: i32 = 2;
pub const CNTP_CTL_EL0_op2: i32 = 1;
pub const CNTP_CTL_ENABLE: i32 = 1;
pub const CNTP_CTL_IMASK: i32 = 2;
pub const CNTP_CTL_ISTATUS: i32 = 4;
pub const CNTP_CTL_EL02_op0: i32 = 3;
pub const CNTP_CTL_EL02_op1: i32 = 5;
pub const CNTP_CTL_EL02_CRn: i32 = 14;
pub const CNTP_CTL_EL02_CRm: i32 = 2;
pub const CNTP_CTL_EL02_op2: i32 = 1;
pub const CNTP_CVAL_EL0_op0: i32 = 3;
pub const CNTP_CVAL_EL0_op1: i32 = 3;
pub const CNTP_CVAL_EL0_CRn: i32 = 14;
pub const CNTP_CVAL_EL0_CRm: i32 = 2;
pub const CNTP_CVAL_EL0_op2: i32 = 2;
pub const CNTP_CVAL_EL02_op0: i32 = 3;
pub const CNTP_CVAL_EL02_op1: i32 = 5;
pub const CNTP_CVAL_EL02_CRn: i32 = 14;
pub const CNTP_CVAL_EL02_CRm: i32 = 2;
pub const CNTP_CVAL_EL02_op2: i32 = 2;
pub const CNTP_TVAL_EL0_op0: i32 = 3;
pub const CNTP_TVAL_EL0_op1: i32 = 3;
pub const CNTP_TVAL_EL0_CRn: i32 = 14;
pub const CNTP_TVAL_EL0_CRm: i32 = 2;
pub const CNTP_TVAL_EL0_op2: i32 = 0;
pub const CNTPCT_EL0_op0: i32 = 3;
pub const CNTPCT_EL0_op1: i32 = 3;
pub const CNTPCT_EL0_CRn: i32 = 14;
pub const CNTPCT_EL0_CRm: i32 = 0;
pub const CNTPCT_EL0_op2: i32 = 1;
pub const CNTPCTSS_EL0_op0: i32 = 3;
pub const CNTPCTSS_EL0_op1: i32 = 3;
pub const CNTPCTSS_EL0_CRn: i32 = 14;
pub const CNTPCTSS_EL0_CRm: i32 = 0;
pub const CNTPCTSS_EL0_op2: i32 = 5;
pub const CNTV_CTL_EL0_op0: i32 = 3;
pub const CNTV_CTL_EL0_op1: i32 = 3;
pub const CNTV_CTL_EL0_CRn: i32 = 14;
pub const CNTV_CTL_EL0_CRm: i32 = 3;
pub const CNTV_CTL_EL0_op2: i32 = 1;
pub const CNTV_CTL_EL02_op0: i32 = 3;
pub const CNTV_CTL_EL02_op1: i32 = 5;
pub const CNTV_CTL_EL02_CRn: i32 = 14;
pub const CNTV_CTL_EL02_CRm: i32 = 3;
pub const CNTV_CTL_EL02_op2: i32 = 1;
pub const CNTV_CVAL_EL0_op0: i32 = 3;
pub const CNTV_CVAL_EL0_op1: i32 = 3;
pub const CNTV_CVAL_EL0_CRn: i32 = 14;
pub const CNTV_CVAL_EL0_CRm: i32 = 3;
pub const CNTV_CVAL_EL0_op2: i32 = 2;
pub const CNTV_CVAL_EL02_op0: i32 = 3;
pub const CNTV_CVAL_EL02_op1: i32 = 5;
pub const CNTV_CVAL_EL02_CRn: i32 = 14;
pub const CNTV_CVAL_EL02_CRm: i32 = 3;
pub const CNTV_CVAL_EL02_op2: i32 = 2;
pub const CNTVCTSS_EL0_op0: i32 = 3;
pub const CNTVCTSS_EL0_op1: i32 = 3;
pub const CNTVCTSS_EL0_CRn: i32 = 14;
pub const CNTVCTSS_EL0_CRm: i32 = 0;
pub const CNTVCTSS_EL0_op2: i32 = 6;
pub const CONTEXTIDR_EL1_op0: i32 = 3;
pub const CONTEXTIDR_EL1_op1: i32 = 0;
pub const CONTEXTIDR_EL1_CRn: i32 = 13;
pub const CONTEXTIDR_EL1_CRm: i32 = 0;
pub const CONTEXTIDR_EL1_op2: i32 = 1;
pub const CONTEXTIDR_EL12_op0: i32 = 3;
pub const CONTEXTIDR_EL12_op1: i32 = 5;
pub const CONTEXTIDR_EL12_CRn: i32 = 13;
pub const CONTEXTIDR_EL12_CRm: i32 = 0;
pub const CONTEXTIDR_EL12_op2: i32 = 1;
pub const CPACR_EL1_op0: i32 = 3;
pub const CPACR_EL1_op1: i32 = 0;
pub const CPACR_EL1_CRn: i32 = 1;
pub const CPACR_EL1_CRm: i32 = 0;
pub const CPACR_EL1_op2: i32 = 2;
pub const CPACR_ZEN_MASK: i32 = 196608;
pub const CPACR_ZEN_TRAP_ALL1: i32 = 0;
pub const CPACR_ZEN_TRAP_EL0: i32 = 65536;
pub const CPACR_ZEN_TRAP_ALL2: i32 = 131072;
pub const CPACR_ZEN_TRAP_NONE: i32 = 196608;
pub const CPACR_FPEN_MASK: i32 = 3145728;
pub const CPACR_FPEN_TRAP_ALL1: i32 = 0;
pub const CPACR_FPEN_TRAP_EL0: i32 = 1048576;
pub const CPACR_FPEN_TRAP_ALL2: i32 = 2097152;
pub const CPACR_FPEN_TRAP_NONE: i32 = 3145728;
pub const CPACR_TTA: i32 = 268435456;
pub const CPACR_EL12_op0: i32 = 3;
pub const CPACR_EL12_op1: i32 = 5;
pub const CPACR_EL12_CRn: i32 = 1;
pub const CPACR_EL12_CRm: i32 = 0;
pub const CPACR_EL12_op2: i32 = 2;
pub const CSSELR_InD: i32 = 1;
pub const CTR_EL0_op0: i32 = 3;
pub const CTR_EL0_op1: i32 = 3;
pub const CTR_EL0_CRn: i32 = 0;
pub const CTR_EL0_CRm: i32 = 0;
pub const CTR_EL0_op2: i32 = 1;
pub const CTR_RES1: i64 = 2147483648;
pub const CTR_TminLine_SHIFT: i32 = 32;
pub const CTR_DIC_SHIFT: i32 = 29;
pub const CTR_DIC_WIDTH: i32 = 1;
pub const CTR_DIC_MASK: i32 = 536870912;
pub const CTR_DIC_NONE: i32 = 0;
pub const CTR_DIC_IMPL: i32 = 536870912;
pub const CTR_IDC_SHIFT: i32 = 28;
pub const CTR_IDC_WIDTH: i32 = 1;
pub const CTR_IDC_MASK: i32 = 268435456;
pub const CTR_IDC_NONE: i32 = 0;
pub const CTR_IDC_IMPL: i32 = 268435456;
pub const CTR_CWG_SHIFT: i32 = 24;
pub const CTR_CWG_WIDTH: i32 = 4;
pub const CTR_CWG_MASK: i32 = 251658240;
pub const CTR_ERG_SHIFT: i32 = 20;
pub const CTR_ERG_WIDTH: i32 = 4;
pub const CTR_ERG_MASK: i32 = 15728640;
pub const CTR_DLINE_SHIFT: i32 = 16;
pub const CTR_DLINE_WIDTH: i32 = 4;
pub const CTR_DLINE_MASK: i32 = 983040;
pub const CTR_L1IP_SHIFT: i32 = 14;
pub const CTR_L1IP_WIDTH: i32 = 2;
pub const CTR_L1IP_MASK: i32 = 49152;
pub const CTR_L1IP_VIPT: i32 = 32768;
pub const CTR_L1IP_PIPT: i32 = 49152;
pub const CTR_ILINE_SHIFT: i32 = 0;
pub const CTR_ILINE_WIDTH: i32 = 4;
pub const CTR_ILINE_MASK: i32 = 15;
pub const CURRENTEL_EL_SHIFT: i32 = 2;
pub const CURRENTEL_EL_MASK: i32 = 12;
pub const CURRENTEL_EL_EL0: i32 = 0;
pub const CURRENTEL_EL_EL1: i32 = 4;
pub const CURRENTEL_EL_EL2: i32 = 8;
pub const CURRENTEL_EL_EL3: i32 = 12;
pub const DAIF_D: i32 = 8;
pub const DAIF_A: i32 = 4;
pub const DAIF_I: i32 = 2;
pub const DAIF_F: i32 = 1;
pub const DAIF_ALL: i32 = 15;
pub const DAIF_INTR: i32 = 3;
pub const DBGBCR_EL1_op0: i32 = 2;
pub const DBGBCR_EL1_op1: i32 = 0;
pub const DBGBCR_EL1_CRn: i32 = 0;
pub const DBGBCR_EL1_op2: i32 = 5;
pub const DBGBCR_EN: i32 = 1;
pub const DBGBCR_PMC_SHIFT: i32 = 1;
pub const DBGBCR_PMC: i32 = 6;
pub const DBGBCR_PMC_EL1: i32 = 2;
pub const DBGBCR_PMC_EL0: i32 = 4;
pub const DBGBCR_BAS_SHIFT: i32 = 5;
pub const DBGBCR_BAS: i32 = 480;
pub const DBGBCR_HMC_SHIFT: i32 = 13;
pub const DBGBCR_HMC: i32 = 8192;
pub const DBGBCR_SSC_SHIFT: i32 = 14;
pub const DBGBCR_SSC: i32 = 49152;
pub const DBGBCR_LBN_SHIFT: i32 = 16;
pub const DBGBCR_LBN: i32 = 983040;
pub const DBGBCR_BT_SHIFT: i32 = 20;
pub const DBGBCR_BT: i32 = 15728640;
pub const DBGBVR_EL1_op0: i32 = 2;
pub const DBGBVR_EL1_op1: i32 = 0;
pub const DBGBVR_EL1_CRn: i32 = 0;
pub const DBGBVR_EL1_op2: i32 = 4;
pub const DBGWCR_EL1_op0: i32 = 2;
pub const DBGWCR_EL1_op1: i32 = 0;
pub const DBGWCR_EL1_CRn: i32 = 0;
pub const DBGWCR_EL1_op2: i32 = 7;
pub const DBGWCR_EN: i32 = 1;
pub const DBGWCR_PAC_SHIFT: i32 = 1;
pub const DBGWCR_PAC: i32 = 6;
pub const DBGWCR_PAC_EL1: i32 = 2;
pub const DBGWCR_PAC_EL0: i32 = 4;
pub const DBGWCR_LSC_SHIFT: i32 = 3;
pub const DBGWCR_LSC: i32 = 24;
pub const DBGWCR_BAS_SHIFT: i32 = 5;
pub const DBGWCR_BAS: i32 = 8160;
pub const DBGWCR_HMC_SHIFT: i32 = 13;
pub const DBGWCR_HMC: i32 = 8192;
pub const DBGWCR_SSC_SHIFT: i32 = 14;
pub const DBGWCR_SSC: i32 = 49152;
pub const DBGWCR_LBN_SHIFT: i32 = 16;
pub const DBGWCR_LBN: i32 = 983040;
pub const DBGWCR_WT_SHIFT: i32 = 20;
pub const DBGWCR_WT: i32 = 1048576;
pub const DBGWCR_MASK_SHIFT: i32 = 24;
pub const DBGWCR_MASK: i32 = 520093696;
pub const DBGWVR_EL1_op0: i32 = 2;
pub const DBGWVR_EL1_op1: i32 = 0;
pub const DBGWVR_EL1_CRn: i32 = 0;
pub const DBGWVR_EL1_op2: i32 = 6;
pub const DCZID_DZP: i32 = 16;
pub const DCZID_BS_SHIFT: i32 = 0;
pub const DCZID_BS_MASK: i32 = 15;
pub const DBGAUTHSTATUS_EL1_op0: i32 = 2;
pub const DBGAUTHSTATUS_EL1_op1: i32 = 0;
pub const DBGAUTHSTATUS_EL1_CRn: i32 = 7;
pub const DBGAUTHSTATUS_EL1_CRm: i32 = 14;
pub const DBGAUTHSTATUS_EL1_op2: i32 = 6;
pub const DBGCLAIMCLR_EL1_op0: i32 = 2;
pub const DBGCLAIMCLR_EL1_op1: i32 = 0;
pub const DBGCLAIMCLR_EL1_CRn: i32 = 7;
pub const DBGCLAIMCLR_EL1_CRm: i32 = 9;
pub const DBGCLAIMCLR_EL1_op2: i32 = 6;
pub const DBGCLAIMSET_EL1_op0: i32 = 2;
pub const DBGCLAIMSET_EL1_op1: i32 = 0;
pub const DBGCLAIMSET_EL1_CRn: i32 = 7;
pub const DBGCLAIMSET_EL1_CRm: i32 = 8;
pub const DBGCLAIMSET_EL1_op2: i32 = 6;
pub const DBGPRCR_EL1_op0: i32 = 2;
pub const DBGPRCR_EL1_op1: i32 = 0;
pub const DBGPRCR_EL1_CRn: i32 = 1;
pub const DBGPRCR_EL1_CRm: i32 = 4;
pub const DBGPRCR_EL1_op2: i32 = 4;
pub const ELR_EL1_op0: i32 = 3;
pub const ELR_EL1_op1: i32 = 0;
pub const ELR_EL1_CRn: i32 = 4;
pub const ELR_EL1_CRm: i32 = 0;
pub const ELR_EL1_op2: i32 = 1;
pub const ELR_EL12_op0: i32 = 3;
pub const ELR_EL12_op1: i32 = 5;
pub const ELR_EL12_CRn: i32 = 4;
pub const ELR_EL12_CRm: i32 = 0;
pub const ELR_EL12_op2: i32 = 1;
pub const ESR_ELx_ISS_MASK: i32 = 33554431;
pub const ISS_FP_TFV_SHIFT: i32 = 23;
pub const ISS_FP_TFV: i32 = 8388608;
pub const ISS_FP_IOF: i32 = 1;
pub const ISS_FP_DZF: i32 = 2;
pub const ISS_FP_OFF: i32 = 4;
pub const ISS_FP_UFF: i32 = 8;
pub const ISS_FP_IXF: i32 = 16;
pub const ISS_FP_IDF: i32 = 128;
pub const ISS_INSN_FnV: i32 = 1024;
pub const ISS_INSN_EA: i32 = 512;
pub const ISS_INSN_S1PTW: i32 = 128;
pub const ISS_INSN_IFSC_MASK: i32 = 31;
pub const ISS_WFx_TI_SHIFT: i32 = 0;
pub const ISS_WFx_TI_MASK: i32 = 3;
pub const ISS_WFx_TI_WFI: i32 = 0;
pub const ISS_WFx_TI_WFE: i32 = 1;
pub const ISS_WFx_TI_WFIT: i32 = 2;
pub const ISS_WFx_TI_WFET: i32 = 3;
pub const ISS_WFx_RV_SHIFT: i32 = 2;
pub const ISS_WFx_RV_MASK: i32 = 4;
pub const ISS_WFx_RV_INVALID: i32 = 0;
pub const ISS_WFx_RV_VALID: i32 = 4;
pub const ISS_WFx_RN_SHIFT: i32 = 5;
pub const ISS_WFx_RN_MASK: i32 = 992;
pub const ISS_WFx_COND_SHIFT: i32 = 20;
pub const ISS_WFx_COND_MASK: i32 = 15728640;
pub const ISS_WFx_CV_SHIFT: i32 = 24;
pub const ISS_WFx_CV_MASK: i32 = 16777216;
pub const ISS_WFx_CV_INVALID: i32 = 0;
pub const ISS_WFx_CV_VALID: i32 = 16777216;
pub const ISS_MSR_DIR_SHIFT: i32 = 0;
pub const ISS_MSR_DIR: i32 = 1;
pub const ISS_MSR_Rt_SHIFT: i32 = 5;
pub const ISS_MSR_Rt_MASK: i32 = 992;
pub const ISS_MSR_CRm_SHIFT: i32 = 1;
pub const ISS_MSR_CRm_MASK: i32 = 30;
pub const ISS_MSR_CRn_SHIFT: i32 = 10;
pub const ISS_MSR_CRn_MASK: i32 = 15360;
pub const ISS_MSR_OP1_SHIFT: i32 = 14;
pub const ISS_MSR_OP1_MASK: i32 = 114688;
pub const ISS_MSR_OP2_SHIFT: i32 = 17;
pub const ISS_MSR_OP2_MASK: i32 = 917504;
pub const ISS_MSR_OP0_SHIFT: i32 = 20;
pub const ISS_MSR_OP0_MASK: i32 = 3145728;
pub const ISS_MSR_REG_MASK: i32 = 4193310;
pub const ISS_DATA_ISV_SHIFT: i32 = 24;
pub const ISS_DATA_ISV: i32 = 16777216;
pub const ISS_DATA_SAS_SHIFT: i32 = 22;
pub const ISS_DATA_SAS_MASK: i32 = 12582912;
pub const ISS_DATA_SSE_SHIFT: i32 = 21;
pub const ISS_DATA_SSE: i32 = 2097152;
pub const ISS_DATA_SRT_SHIFT: i32 = 16;
pub const ISS_DATA_SRT_MASK: i32 = 2031616;
pub const ISS_DATA_SF: i32 = 32768;
pub const ISS_DATA_AR: i32 = 16384;
pub const ISS_DATA_FnV: i32 = 1024;
pub const ISS_DATA_EA: i32 = 512;
pub const ISS_DATA_CM: i32 = 256;
pub const ISS_DATA_S1PTW: i32 = 128;
pub const ISS_DATA_WnR_SHIFT: i32 = 6;
pub const ISS_DATA_WnR: i32 = 64;
pub const ISS_DATA_DFSC_MASK: i32 = 63;
pub const ISS_DATA_DFSC_ASF_L0: i32 = 0;
pub const ISS_DATA_DFSC_ASF_L1: i32 = 1;
pub const ISS_DATA_DFSC_ASF_L2: i32 = 2;
pub const ISS_DATA_DFSC_ASF_L3: i32 = 3;
pub const ISS_DATA_DFSC_TF_L0: i32 = 4;
pub const ISS_DATA_DFSC_TF_L1: i32 = 5;
pub const ISS_DATA_DFSC_TF_L2: i32 = 6;
pub const ISS_DATA_DFSC_TF_L3: i32 = 7;
pub const ISS_DATA_DFSC_AFF_L1: i32 = 9;
pub const ISS_DATA_DFSC_AFF_L2: i32 = 10;
pub const ISS_DATA_DFSC_AFF_L3: i32 = 11;
pub const ISS_DATA_DFSC_PF_L1: i32 = 13;
pub const ISS_DATA_DFSC_PF_L2: i32 = 14;
pub const ISS_DATA_DFSC_PF_L3: i32 = 15;
pub const ISS_DATA_DFSC_EXT: i32 = 16;
pub const ISS_DATA_DFSC_EXT_L0: i32 = 20;
pub const ISS_DATA_DFSC_EXT_L1: i32 = 21;
pub const ISS_DATA_DFSC_EXT_L2: i32 = 22;
pub const ISS_DATA_DFSC_EXT_L3: i32 = 23;
pub const ISS_DATA_DFSC_ECC: i32 = 24;
pub const ISS_DATA_DFSC_ECC_L0: i32 = 28;
pub const ISS_DATA_DFSC_ECC_L1: i32 = 29;
pub const ISS_DATA_DFSC_ECC_L2: i32 = 30;
pub const ISS_DATA_DFSC_ECC_L3: i32 = 31;
pub const ISS_DATA_DFSC_ALIGN: i32 = 33;
pub const ISS_DATA_DFSC_TLB_CONFLICT: i32 = 48;
pub const ESR_ELx_IL: i32 = 33554432;
pub const ESR_ELx_EC_SHIFT: i32 = 26;
pub const ESR_ELx_EC_MASK: i64 = 4227858432;
pub const EXCP_UNKNOWN: i32 = 0;
pub const EXCP_TRAP_WFI_WFE: i32 = 1;
pub const EXCP_FP_SIMD: i32 = 7;
pub const EXCP_BTI: i32 = 13;
pub const EXCP_ILL_STATE: i32 = 14;
pub const EXCP_SVC32: i32 = 17;
pub const EXCP_SVC64: i32 = 21;
pub const EXCP_HVC: i32 = 22;
pub const EXCP_MSR: i32 = 24;
pub const EXCP_SVE: i32 = 25;
pub const EXCP_FPAC: i32 = 28;
pub const EXCP_INSN_ABORT_L: i32 = 32;
pub const EXCP_INSN_ABORT: i32 = 33;
pub const EXCP_PC_ALIGN: i32 = 34;
pub const EXCP_DATA_ABORT_L: i32 = 36;
pub const EXCP_DATA_ABORT: i32 = 37;
pub const EXCP_SP_ALIGN: i32 = 38;
pub const EXCP_TRAP_FP: i32 = 44;
pub const EXCP_SERROR: i32 = 47;
pub const EXCP_BRKPT_EL0: i32 = 48;
pub const EXCP_BRKPT_EL1: i32 = 49;
pub const EXCP_SOFTSTP_EL0: i32 = 50;
pub const EXCP_SOFTSTP_EL1: i32 = 51;
pub const EXCP_WATCHPT_EL0: i32 = 52;
pub const EXCP_WATCHPT_EL1: i32 = 53;
pub const EXCP_BRKPT_32: i32 = 56;
pub const EXCP_BRK: i32 = 60;
pub const ESR_EL1_op0: i32 = 3;
pub const ESR_EL1_op1: i32 = 0;
pub const ESR_EL1_CRn: i32 = 5;
pub const ESR_EL1_CRm: i32 = 2;
pub const ESR_EL1_op2: i32 = 0;
pub const ESR_EL12_op0: i32 = 3;
pub const ESR_EL12_op1: i32 = 5;
pub const ESR_EL12_CRn: i32 = 5;
pub const ESR_EL12_CRm: i32 = 2;
pub const ESR_EL12_op2: i32 = 0;
pub const FAR_EL1_op0: i32 = 3;
pub const FAR_EL1_op1: i32 = 0;
pub const FAR_EL1_CRn: i32 = 6;
pub const FAR_EL1_CRm: i32 = 0;
pub const FAR_EL1_op2: i32 = 0;
pub const FAR_EL12_op0: i32 = 3;
pub const FAR_EL12_op1: i32 = 5;
pub const FAR_EL12_CRn: i32 = 6;
pub const FAR_EL12_CRm: i32 = 0;
pub const FAR_EL12_op2: i32 = 0;
pub const ICC_CTLR_EL1_EOIMODE: i32 = 2;
pub const ICC_IAR1_EL1_SPUR: i32 = 1023;
pub const ICC_IGRPEN0_EL1_EN: i32 = 1;
pub const ICC_PMR_EL1_PRIO_MASK: i32 = 255;
pub const ICC_SGI1R_EL1_op0: i32 = 3;
pub const ICC_SGI1R_EL1_op1: i32 = 0;
pub const ICC_SGI1R_EL1_CRn: i32 = 12;
pub const ICC_SGI1R_EL1_CRm: i32 = 11;
pub const ICC_SGI1R_EL1_op2: i32 = 5;
pub const ICC_SGI1R_EL1_TL_SHIFT: i32 = 0;
pub const ICC_SGI1R_EL1_TL_MASK: i32 = 65535;
pub const ICC_SGI1R_EL1_AFF1_SHIFT: i32 = 16;
pub const ICC_SGI1R_EL1_AFF1_MASK: i32 = 16711680;
pub const ICC_SGI1R_EL1_SGIID_SHIFT: i32 = 24;
pub const ICC_SGI1R_EL1_SGIID_MASK: i32 = 251658240;
pub const ICC_SGI1R_EL1_AFF2_SHIFT: i32 = 32;
pub const ICC_SGI1R_EL1_AFF2_MASK: i64 = 1095216660480;
pub const ICC_SGI1R_EL1_RS_SHIFT: i32 = 44;
pub const ICC_SGI1R_EL1_RS_MASK: i64 = 263882790666240;
pub const ICC_SGI1R_EL1_AFF3_SHIFT: i32 = 48;
pub const ICC_SGI1R_EL1_AFF3_MASK: i64 = 71776119061217280;
pub const ICC_SGI1R_EL1_IRM: i64 = 1099511627776;
pub const ICC_SRE_EL1_SRE: i32 = 1;
pub const ID_AA64AFR0_EL1_op0: i32 = 3;
pub const ID_AA64AFR0_EL1_op1: i32 = 0;
pub const ID_AA64AFR0_EL1_CRn: i32 = 0;
pub const ID_AA64AFR0_EL1_CRm: i32 = 5;
pub const ID_AA64AFR0_EL1_op2: i32 = 4;
pub const ID_AA64AFR1_EL1_op0: i32 = 3;
pub const ID_AA64AFR1_EL1_op1: i32 = 0;
pub const ID_AA64AFR1_EL1_CRn: i32 = 0;
pub const ID_AA64AFR1_EL1_CRm: i32 = 5;
pub const ID_AA64AFR1_EL1_op2: i32 = 5;
pub const ID_AA64DFR0_EL1_op0: i32 = 3;
pub const ID_AA64DFR0_EL1_op1: i32 = 0;
pub const ID_AA64DFR0_EL1_CRn: i32 = 0;
pub const ID_AA64DFR0_EL1_CRm: i32 = 5;
pub const ID_AA64DFR0_EL1_op2: i32 = 0;
pub const ID_AA64DFR0_DebugVer_SHIFT: i32 = 0;
pub const ID_AA64DFR0_DebugVer_WIDTH: i32 = 4;
pub const ID_AA64DFR0_TraceVer_SHIFT: i32 = 4;
pub const ID_AA64DFR0_TraceVer_WIDTH: i32 = 4;
pub const ID_AA64DFR0_PMUVer_SHIFT: i32 = 8;
pub const ID_AA64DFR0_PMUVer_WIDTH: i32 = 4;
pub const ID_AA64DFR0_BRPs_SHIFT: i32 = 12;
pub const ID_AA64DFR0_BRPs_WIDTH: i32 = 4;
pub const ID_AA64DFR0_PMSS_SHIFT: i32 = 16;
pub const ID_AA64DFR0_PMSS_WIDTH: i32 = 4;
pub const ID_AA64DFR0_WRPs_SHIFT: i32 = 20;
pub const ID_AA64DFR0_WRPs_WIDTH: i32 = 4;
pub const ID_AA64DFR0_CTX_CMPs_SHIFT: i32 = 28;
pub const ID_AA64DFR0_CTX_CMPs_WIDTH: i32 = 4;
pub const ID_AA64DFR0_PMSVer_SHIFT: i32 = 32;
pub const ID_AA64DFR0_PMSVer_WIDTH: i32 = 4;
pub const ID_AA64DFR0_DoubleLock_SHIFT: i32 = 36;
pub const ID_AA64DFR0_DoubleLock_WIDTH: i32 = 4;
pub const ID_AA64DFR0_TraceFilt_SHIFT: i32 = 40;
pub const ID_AA64DFR0_TraceFilt_WIDTH: i32 = 4;
pub const ID_AA64DFR0_TraceBuffer_SHIFT: i32 = 44;
pub const ID_AA64DFR0_TraceBuffer_WIDTH: i32 = 4;
pub const ID_AA64DFR0_MTPMU_SHIFT: i32 = 48;
pub const ID_AA64DFR0_MTPMU_WIDTH: i32 = 4;
pub const ID_AA64DFR0_BRBE_SHIFT: i32 = 52;
pub const ID_AA64DFR0_BRBE_WIDTH: i32 = 4;
pub const ID_AA64DFR0_HPMN0_SHIFT: i32 = 60;
pub const ID_AA64DFR0_HPMN0_WIDTH: i32 = 4;
pub const ID_AA64DFR1_EL1_op0: i32 = 3;
pub const ID_AA64DFR1_EL1_op1: i32 = 0;
pub const ID_AA64DFR1_EL1_CRn: i32 = 0;
pub const ID_AA64DFR1_EL1_CRm: i32 = 5;
pub const ID_AA64DFR1_EL1_op2: i32 = 1;
pub const ID_AA64DFR1_SPMU_SHIFT: i32 = 32;
pub const ID_AA64DFR1_SPMU_WIDTH: i32 = 4;
pub const ID_AA64DFR1_PMICNTR_SHIFT: i32 = 36;
pub const ID_AA64DFR1_PMICNTR_WIDTH: i32 = 4;
pub const ID_AA64DFR1_DPFZS_SHIFT: i32 = 52;
pub const ID_AA64DFR1_DPFZS_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_EL1_op0: i32 = 3;
pub const ID_AA64ISAR0_EL1_op1: i32 = 0;
pub const ID_AA64ISAR0_EL1_CRn: i32 = 0;
pub const ID_AA64ISAR0_EL1_CRm: i32 = 6;
pub const ID_AA64ISAR0_EL1_op2: i32 = 0;
pub const ID_AA64ISAR0_AES_SHIFT: i32 = 4;
pub const ID_AA64ISAR0_AES_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_SHA1_SHIFT: i32 = 8;
pub const ID_AA64ISAR0_SHA1_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_SHA2_SHIFT: i32 = 12;
pub const ID_AA64ISAR0_SHA2_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_CRC32_SHIFT: i32 = 16;
pub const ID_AA64ISAR0_CRC32_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_Atomic_SHIFT: i32 = 20;
pub const ID_AA64ISAR0_Atomic_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_TME_SHIFT: i32 = 24;
pub const ID_AA64ISAR0_TME_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_RDM_SHIFT: i32 = 28;
pub const ID_AA64ISAR0_RDM_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_SHA3_SHIFT: i32 = 32;
pub const ID_AA64ISAR0_SHA3_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_SM3_SHIFT: i32 = 36;
pub const ID_AA64ISAR0_SM3_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_SM4_SHIFT: i32 = 40;
pub const ID_AA64ISAR0_SM4_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_DP_SHIFT: i32 = 44;
pub const ID_AA64ISAR0_DP_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_FHM_SHIFT: i32 = 48;
pub const ID_AA64ISAR0_FHM_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_TS_SHIFT: i32 = 52;
pub const ID_AA64ISAR0_TS_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_TLB_SHIFT: i32 = 56;
pub const ID_AA64ISAR0_TLB_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_RNDR_SHIFT: i32 = 60;
pub const ID_AA64ISAR0_RNDR_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_EL1_op0: i32 = 3;
pub const ID_AA64ISAR1_EL1_op1: i32 = 0;
pub const ID_AA64ISAR1_EL1_CRn: i32 = 0;
pub const ID_AA64ISAR1_EL1_CRm: i32 = 6;
pub const ID_AA64ISAR1_EL1_op2: i32 = 1;
pub const ID_AA64ISAR1_DPB_SHIFT: i32 = 0;
pub const ID_AA64ISAR1_DPB_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_APA_SHIFT: i32 = 4;
pub const ID_AA64ISAR1_APA_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_API_SHIFT: i32 = 8;
pub const ID_AA64ISAR1_API_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_JSCVT_SHIFT: i32 = 12;
pub const ID_AA64ISAR1_JSCVT_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_FCMA_SHIFT: i32 = 16;
pub const ID_AA64ISAR1_FCMA_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_LRCPC_SHIFT: i32 = 20;
pub const ID_AA64ISAR1_LRCPC_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_GPA_SHIFT: i32 = 24;
pub const ID_AA64ISAR1_GPA_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_GPI_SHIFT: i32 = 28;
pub const ID_AA64ISAR1_GPI_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_FRINTTS_SHIFT: i32 = 32;
pub const ID_AA64ISAR1_FRINTTS_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_SB_SHIFT: i32 = 36;
pub const ID_AA64ISAR1_SB_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_SPECRES_SHIFT: i32 = 40;
pub const ID_AA64ISAR1_SPECRES_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_BF16_SHIFT: i32 = 44;
pub const ID_AA64ISAR1_BF16_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_DGH_SHIFT: i32 = 48;
pub const ID_AA64ISAR1_DGH_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_I8MM_SHIFT: i32 = 52;
pub const ID_AA64ISAR1_I8MM_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_XS_SHIFT: i32 = 56;
pub const ID_AA64ISAR1_XS_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_LS64_SHIFT: i32 = 60;
pub const ID_AA64ISAR1_LS64_WIDTH: i32 = 4;
pub const ID_AA64ISAR2_EL1_op0: i32 = 3;
pub const ID_AA64ISAR2_EL1_op1: i32 = 0;
pub const ID_AA64ISAR2_EL1_CRn: i32 = 0;
pub const ID_AA64ISAR2_EL1_CRm: i32 = 6;
pub const ID_AA64ISAR2_EL1_op2: i32 = 2;
pub const ID_AA64ISAR2_WFxT_SHIFT: i32 = 0;
pub const ID_AA64ISAR2_WFxT_WIDTH: i32 = 4;
pub const ID_AA64ISAR2_RPRES_SHIFT: i32 = 4;
pub const ID_AA64ISAR2_RPRES_WIDTH: i32 = 4;
pub const ID_AA64ISAR2_GPA3_SHIFT: i32 = 8;
pub const ID_AA64ISAR2_GPA3_WIDTH: i32 = 4;
pub const ID_AA64ISAR2_APA3_SHIFT: i32 = 12;
pub const ID_AA64ISAR2_APA3_WIDTH: i32 = 4;
pub const ID_AA64ISAR2_MOPS_SHIFT: i32 = 16;
pub const ID_AA64ISAR2_MOPS_WIDTH: i32 = 4;
pub const ID_AA64ISAR2_BC_SHIFT: i32 = 20;
pub const ID_AA64ISAR2_BC_WIDTH: i32 = 4;
pub const ID_AA64ISAR2_PAC_frac_SHIFT: i32 = 24;
pub const ID_AA64ISAR2_PAC_frac_WIDTH: i32 = 4;
pub const ID_AA64ISAR2_CLRBHB_SHIFT: i32 = 28;
pub const ID_AA64ISAR2_CLRBHB_WIDTH: i32 = 4;
pub const ID_AA64ISAR2_PRFMSLC_SHIFT: i32 = 40;
pub const ID_AA64ISAR2_PRFMSLC_WIDTH: i32 = 4;
pub const ID_AA64ISAR2_RPRFM_SHIFT: i32 = 48;
pub const ID_AA64ISAR2_RPRFM_WIDTH: i32 = 4;
pub const ID_AA64ISAR2_CSSC_SHIFT: i32 = 52;
pub const ID_AA64ISAR2_CSSC_WIDTH: i32 = 4;
pub const ID_AA64ISAR2_ATS1A_SHIFT: i32 = 60;
pub const ID_AA64ISAR2_ATS1A_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_EL1_op0: i32 = 3;
pub const ID_AA64MMFR0_EL1_op1: i32 = 0;
pub const ID_AA64MMFR0_EL1_CRn: i32 = 0;
pub const ID_AA64MMFR0_EL1_CRm: i32 = 7;
pub const ID_AA64MMFR0_EL1_op2: i32 = 0;
pub const ID_AA64MMFR0_PARange_SHIFT: i32 = 0;
pub const ID_AA64MMFR0_PARange_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_ASIDBits_SHIFT: i32 = 4;
pub const ID_AA64MMFR0_ASIDBits_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_BigEnd_SHIFT: i32 = 8;
pub const ID_AA64MMFR0_BigEnd_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_SNSMem_SHIFT: i32 = 12;
pub const ID_AA64MMFR0_SNSMem_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_BigEndEL0_SHIFT: i32 = 16;
pub const ID_AA64MMFR0_BigEndEL0_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_TGran16_SHIFT: i32 = 20;
pub const ID_AA64MMFR0_TGran16_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_TGran64_SHIFT: i32 = 24;
pub const ID_AA64MMFR0_TGran64_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_TGran4_SHIFT: i32 = 28;
pub const ID_AA64MMFR0_TGran4_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_TGran16_2_SHIFT: i32 = 32;
pub const ID_AA64MMFR0_TGran16_2_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_TGran64_2_SHIFT: i32 = 36;
pub const ID_AA64MMFR0_TGran64_2_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_TGran4_2_SHIFT: i32 = 40;
pub const ID_AA64MMFR0_TGran4_2_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_ExS_SHIFT: i32 = 44;
pub const ID_AA64MMFR0_ExS_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_FGT_SHIFT: i32 = 56;
pub const ID_AA64MMFR0_FGT_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_ECV_SHIFT: i32 = 60;
pub const ID_AA64MMFR0_ECV_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_EL1_op0: i32 = 3;
pub const ID_AA64MMFR1_EL1_op1: i32 = 0;
pub const ID_AA64MMFR1_EL1_CRn: i32 = 0;
pub const ID_AA64MMFR1_EL1_CRm: i32 = 7;
pub const ID_AA64MMFR1_EL1_op2: i32 = 1;
pub const ID_AA64MMFR1_HAFDBS_SHIFT: i32 = 0;
pub const ID_AA64MMFR1_HAFDBS_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_VMIDBits_SHIFT: i32 = 4;
pub const ID_AA64MMFR1_VMIDBits_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_VH_SHIFT: i32 = 8;
pub const ID_AA64MMFR1_VH_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_HPDS_SHIFT: i32 = 12;
pub const ID_AA64MMFR1_HPDS_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_LO_SHIFT: i32 = 16;
pub const ID_AA64MMFR1_LO_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_PAN_SHIFT: i32 = 20;
pub const ID_AA64MMFR1_PAN_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_SpecSEI_SHIFT: i32 = 24;
pub const ID_AA64MMFR1_SpecSEI_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_XNX_SHIFT: i32 = 28;
pub const ID_AA64MMFR1_XNX_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_TWED_SHIFT: i32 = 32;
pub const ID_AA64MMFR1_TWED_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_ETS_SHIFT: i32 = 36;
pub const ID_AA64MMFR1_ETS_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_HCX_SHIFT: i32 = 40;
pub const ID_AA64MMFR1_HCX_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_AFP_SHIFT: i32 = 44;
pub const ID_AA64MMFR1_AFP_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_nTLBPA_SHIFT: i32 = 48;
pub const ID_AA64MMFR1_nTLBPA_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_TIDCP1_SHIFT: i32 = 52;
pub const ID_AA64MMFR1_TIDCP1_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_CMOVW_SHIFT: i32 = 56;
pub const ID_AA64MMFR1_CMOVW_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_ECBHB_SHIFT: i32 = 60;
pub const ID_AA64MMFR1_ECBHB_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_EL1_op0: i32 = 3;
pub const ID_AA64MMFR2_EL1_op1: i32 = 0;
pub const ID_AA64MMFR2_EL1_CRn: i32 = 0;
pub const ID_AA64MMFR2_EL1_CRm: i32 = 7;
pub const ID_AA64MMFR2_EL1_op2: i32 = 2;
pub const ID_AA64MMFR2_CnP_SHIFT: i32 = 0;
pub const ID_AA64MMFR2_CnP_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_UAO_SHIFT: i32 = 4;
pub const ID_AA64MMFR2_UAO_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_LSM_SHIFT: i32 = 8;
pub const ID_AA64MMFR2_LSM_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_IESB_SHIFT: i32 = 12;
pub const ID_AA64MMFR2_IESB_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_VARange_SHIFT: i32 = 16;
pub const ID_AA64MMFR2_VARange_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_CCIDX_SHIFT: i32 = 20;
pub const ID_AA64MMFR2_CCIDX_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_NV_SHIFT: i32 = 24;
pub const ID_AA64MMFR2_NV_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_ST_SHIFT: i32 = 28;
pub const ID_AA64MMFR2_ST_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_AT_SHIFT: i32 = 32;
pub const ID_AA64MMFR2_AT_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_IDS_SHIFT: i32 = 36;
pub const ID_AA64MMFR2_IDS_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_FWB_SHIFT: i32 = 40;
pub const ID_AA64MMFR2_FWB_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_TTL_SHIFT: i32 = 48;
pub const ID_AA64MMFR2_TTL_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_BBM_SHIFT: i32 = 52;
pub const ID_AA64MMFR2_BBM_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_EVT_SHIFT: i32 = 56;
pub const ID_AA64MMFR2_EVT_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_E0PD_SHIFT: i32 = 60;
pub const ID_AA64MMFR2_E0PD_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_EL1_op0: i32 = 3;
pub const ID_AA64MMFR3_EL1_op1: i32 = 0;
pub const ID_AA64MMFR3_EL1_CRn: i32 = 0;
pub const ID_AA64MMFR3_EL1_CRm: i32 = 7;
pub const ID_AA64MMFR3_EL1_op2: i32 = 3;
pub const ID_AA64MMFR3_TCRX_SHIFT: i32 = 0;
pub const ID_AA64MMFR3_TCRX_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_SCTLRX_SHIFT: i32 = 4;
pub const ID_AA64MMFR3_SCTLRX_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_S1PIE_SHIFT: i32 = 8;
pub const ID_AA64MMFR3_S1PIE_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_S2PIE_SHIFT: i32 = 12;
pub const ID_AA64MMFR3_S2PIE_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_S1POE_SHIFT: i32 = 16;
pub const ID_AA64MMFR3_S1POE_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_S2POE_SHIFT: i32 = 20;
pub const ID_AA64MMFR3_S2POE_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_AIE_SHIFT: i32 = 24;
pub const ID_AA64MMFR3_AIE_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_MEC_SHIFT: i32 = 28;
pub const ID_AA64MMFR3_MEC_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_SNERR_SHIFT: i32 = 40;
pub const ID_AA64MMFR3_SNERR_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_ANERR_SHIFT: i32 = 44;
pub const ID_AA64MMFR3_ANERR_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_SDERR_SHIFT: i32 = 52;
pub const ID_AA64MMFR3_SDERR_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_ADERR_SHIFT: i32 = 56;
pub const ID_AA64MMFR3_ADERR_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_Spec_FPACC_SHIFT: i32 = 60;
pub const ID_AA64MMFR3_Spec_FPACC_WIDTH: i32 = 4;
pub const ID_AA64MMFR4_EL1_op0: i32 = 3;
pub const ID_AA64MMFR4_EL1_op1: i32 = 0;
pub const ID_AA64MMFR4_EL1_CRn: i32 = 0;
pub const ID_AA64MMFR4_EL1_CRm: i32 = 7;
pub const ID_AA64MMFR4_EL1_op2: i32 = 4;
pub const ID_AA64PFR0_EL1_op0: i32 = 3;
pub const ID_AA64PFR0_EL1_op1: i32 = 0;
pub const ID_AA64PFR0_EL1_CRn: i32 = 0;
pub const ID_AA64PFR0_EL1_CRm: i32 = 4;
pub const ID_AA64PFR0_EL1_op2: i32 = 0;
pub const ID_AA64PFR0_EL0_SHIFT: i32 = 0;
pub const ID_AA64PFR0_EL0_WIDTH: i32 = 4;
pub const ID_AA64PFR0_EL1_SHIFT: i32 = 4;
pub const ID_AA64PFR0_EL1_WIDTH: i32 = 4;
pub const ID_AA64PFR0_EL2_SHIFT: i32 = 8;
pub const ID_AA64PFR0_EL2_WIDTH: i32 = 4;
pub const ID_AA64PFR0_EL3_SHIFT: i32 = 12;
pub const ID_AA64PFR0_EL3_WIDTH: i32 = 4;
pub const ID_AA64PFR0_FP_SHIFT: i32 = 16;
pub const ID_AA64PFR0_FP_WIDTH: i32 = 4;
pub const ID_AA64PFR0_AdvSIMD_SHIFT: i32 = 20;
pub const ID_AA64PFR0_AdvSIMD_WIDTH: i32 = 4;
pub const ID_AA64PFR0_GIC_BITS: i32 = 4;
pub const ID_AA64PFR0_GIC_SHIFT: i32 = 24;
pub const ID_AA64PFR0_GIC_WIDTH: i32 = 4;
pub const ID_AA64PFR0_RAS_SHIFT: i32 = 28;
pub const ID_AA64PFR0_RAS_WIDTH: i32 = 4;
pub const ID_AA64PFR0_SVE_SHIFT: i32 = 32;
pub const ID_AA64PFR0_SVE_WIDTH: i32 = 4;
pub const ID_AA64PFR0_SEL2_SHIFT: i32 = 36;
pub const ID_AA64PFR0_SEL2_WIDTH: i32 = 4;
pub const ID_AA64PFR0_MPAM_SHIFT: i32 = 40;
pub const ID_AA64PFR0_MPAM_WIDTH: i32 = 4;
pub const ID_AA64PFR0_AMU_SHIFT: i32 = 44;
pub const ID_AA64PFR0_AMU_WIDTH: i32 = 4;
pub const ID_AA64PFR0_DIT_SHIFT: i32 = 48;
pub const ID_AA64PFR0_DIT_WIDTH: i32 = 4;
pub const ID_AA64PFR0_RME_SHIFT: i32 = 52;
pub const ID_AA64PFR0_RME_WIDTH: i32 = 4;
pub const ID_AA64PFR0_CSV2_SHIFT: i32 = 56;
pub const ID_AA64PFR0_CSV2_WIDTH: i32 = 4;
pub const ID_AA64PFR0_CSV3_SHIFT: i32 = 60;
pub const ID_AA64PFR0_CSV3_WIDTH: i32 = 4;
pub const ID_AA64PFR1_EL1_op0: i32 = 3;
pub const ID_AA64PFR1_EL1_op1: i32 = 0;
pub const ID_AA64PFR1_EL1_CRn: i32 = 0;
pub const ID_AA64PFR1_EL1_CRm: i32 = 4;
pub const ID_AA64PFR1_EL1_op2: i32 = 1;
pub const ID_AA64PFR1_BT_SHIFT: i32 = 0;
pub const ID_AA64PFR1_BT_WIDTH: i32 = 4;
pub const ID_AA64PFR1_SSBS_SHIFT: i32 = 4;
pub const ID_AA64PFR1_SSBS_WIDTH: i32 = 4;
pub const ID_AA64PFR1_MTE_SHIFT: i32 = 8;
pub const ID_AA64PFR1_MTE_WIDTH: i32 = 4;
pub const ID_AA64PFR1_RAS_frac_SHIFT: i32 = 12;
pub const ID_AA64PFR1_RAS_frac_WIDTH: i32 = 4;
pub const ID_AA64PFR1_MPAM_frac_SHIFT: i32 = 16;
pub const ID_AA64PFR1_MPAM_frac_WIDTH: i32 = 4;
pub const ID_AA64PFR1_SME_SHIFT: i32 = 24;
pub const ID_AA64PFR1_SME_WIDTH: i32 = 4;
pub const ID_AA64PFR1_RNDR_trap_SHIFT: i32 = 28;
pub const ID_AA64PFR1_RNDR_trap_WIDTH: i32 = 4;
pub const ID_AA64PFR1_CSV2_frac_SHIFT: i32 = 32;
pub const ID_AA64PFR1_CSV2_frac_WIDTH: i32 = 4;
pub const ID_AA64PFR1_NMI_SHIFT: i32 = 36;
pub const ID_AA64PFR1_NMI_WIDTH: i32 = 4;
pub const ID_AA64PFR1_MTE_frac_SHIFT: i32 = 40;
pub const ID_AA64PFR1_MTE_frac_WIDTH: i32 = 4;
pub const ID_AA64PFR1_THE_SHIFT: i32 = 48;
pub const ID_AA64PFR1_THE_WIDTH: i32 = 4;
pub const ID_AA64PFR1_MTEX_SHIFT: i32 = 52;
pub const ID_AA64PFR1_MTEX_WIDTH: i32 = 4;
pub const ID_AA64PFR1_DF2_SHIFT: i32 = 56;
pub const ID_AA64PFR1_DF2_WIDTH: i32 = 4;
pub const ID_AA64PFR1_PFAR_SHIFT: i32 = 60;
pub const ID_AA64PFR1_PFAR_WIDTH: i32 = 4;
pub const ID_AA64PFR2_EL1_op0: i32 = 3;
pub const ID_AA64PFR2_EL1_op1: i32 = 0;
pub const ID_AA64PFR2_EL1_CRn: i32 = 0;
pub const ID_AA64PFR2_EL1_CRm: i32 = 4;
pub const ID_AA64PFR2_EL1_op2: i32 = 2;
pub const ID_AA64ZFR0_EL1_op0: i32 = 3;
pub const ID_AA64ZFR0_EL1_op1: i32 = 0;
pub const ID_AA64ZFR0_EL1_CRn: i32 = 0;
pub const ID_AA64ZFR0_EL1_CRm: i32 = 4;
pub const ID_AA64ZFR0_EL1_op2: i32 = 4;
pub const ID_AA64ZFR0_SVEver_SHIFT: i32 = 0;
pub const ID_AA64ZFR0_SVEver_WIDTH: i32 = 4;
pub const ID_AA64ZFR0_AES_SHIFT: i32 = 4;
pub const ID_AA64ZFR0_AES_WIDTH: i32 = 4;
pub const ID_AA64ZFR0_BitPerm_SHIFT: i32 = 16;
pub const ID_AA64ZFR0_BitPerm_WIDTH: i32 = 4;
pub const ID_AA64ZFR0_BF16_SHIFT: i32 = 20;
pub const ID_AA64ZFR0_BF16_WIDTH: i32 = 4;
pub const ID_AA64ZFR0_SHA3_SHIFT: i32 = 32;
pub const ID_AA64ZFR0_SHA3_WIDTH: i32 = 4;
pub const ID_AA64ZFR0_SM4_SHIFT: i32 = 40;
pub const ID_AA64ZFR0_SM4_WIDTH: i32 = 4;
pub const ID_AA64ZFR0_I8MM_SHIFT: i32 = 44;
pub const ID_AA64ZFR0_I8MM_WIDTH: i32 = 4;
pub const ID_AA64ZFR0_F32MM_SHIFT: i32 = 52;
pub const ID_AA64ZFR0_F32MM_WIDTH: i32 = 4;
pub const ID_AA64ZFR0_F64MM_SHIFT: i32 = 56;
pub const ID_AA64ZFR0_F64MM_WIDTH: i32 = 4;
pub const ID_ISAR5_EL1_op0: i32 = 3;
pub const ID_ISAR5_EL1_op1: i32 = 0;
pub const ID_ISAR5_EL1_CRn: i32 = 0;
pub const ID_ISAR5_EL1_CRm: i32 = 2;
pub const ID_ISAR5_EL1_op2: i32 = 5;
pub const ID_ISAR5_SEVL_SHIFT: i32 = 0;
pub const ID_ISAR5_SEVL_WIDTH: i32 = 4;
pub const ID_ISAR5_AES_SHIFT: i32 = 4;
pub const ID_ISAR5_AES_WIDTH: i32 = 4;
pub const ID_ISAR5_SHA1_SHIFT: i32 = 8;
pub const ID_ISAR5_SHA1_WIDTH: i32 = 4;
pub const ID_ISAR5_SHA2_SHIFT: i32 = 12;
pub const ID_ISAR5_SHA2_WIDTH: i32 = 4;
pub const ID_ISAR5_CRC32_SHIFT: i32 = 16;
pub const ID_ISAR5_CRC32_WIDTH: i32 = 4;
pub const ID_ISAR5_RDM_SHIFT: i32 = 24;
pub const ID_ISAR5_RDM_WIDTH: i32 = 4;
pub const ID_ISAR5_VCMA_SHIFT: i32 = 28;
pub const ID_ISAR5_VCMA_WIDTH: i32 = 4;
pub const MAIR_EL1_op0: i32 = 3;
pub const MAIR_EL1_op1: i32 = 0;
pub const MAIR_EL1_CRn: i32 = 10;
pub const MAIR_EL1_CRm: i32 = 2;
pub const MAIR_EL1_op2: i32 = 0;
pub const MAIR_EL12_op0: i32 = 3;
pub const MAIR_EL12_op1: i32 = 5;
pub const MAIR_EL12_CRn: i32 = 10;
pub const MAIR_EL12_CRm: i32 = 2;
pub const MAIR_EL12_op2: i32 = 0;
pub const MDCCINT_EL1_op0: i32 = 2;
pub const MDCCINT_EL1_op1: i32 = 0;
pub const MDCCINT_EL1_CRn: i32 = 0;
pub const MDCCINT_EL1_CRm: i32 = 2;
pub const MDCCINT_EL1_op2: i32 = 0;
pub const MDCCSR_EL0_op0: i32 = 2;
pub const MDCCSR_EL0_op1: i32 = 3;
pub const MDCCSR_EL0_CRn: i32 = 0;
pub const MDCCSR_EL0_CRm: i32 = 1;
pub const MDCCSR_EL0_op2: i32 = 0;
pub const MDSCR_EL1_op0: i32 = 2;
pub const MDSCR_EL1_op1: i32 = 0;
pub const MDSCR_EL1_CRn: i32 = 0;
pub const MDSCR_EL1_CRm: i32 = 2;
pub const MDSCR_EL1_op2: i32 = 2;
pub const MDSCR_SS_SHIFT: i32 = 0;
pub const MDSCR_KDE_SHIFT: i32 = 13;
pub const MDSCR_MDE_SHIFT: i32 = 15;
pub const MIDR_EL1_op0: i32 = 3;
pub const MIDR_EL1_op1: i32 = 0;
pub const MIDR_EL1_CRn: i32 = 0;
pub const MIDR_EL1_CRm: i32 = 0;
pub const MIDR_EL1_op2: i32 = 0;
pub const MPIDR_EL1_op0: i32 = 3;
pub const MPIDR_EL1_op1: i32 = 0;
pub const MPIDR_EL1_CRn: i32 = 0;
pub const MPIDR_EL1_CRm: i32 = 0;
pub const MPIDR_EL1_op2: i32 = 5;
pub const MPIDR_AFF0_SHIFT: i32 = 0;
pub const MPIDR_AFF1_SHIFT: i32 = 8;
pub const MPIDR_AFF2_SHIFT: i32 = 16;
pub const MPIDR_MT_SHIFT: i32 = 24;
pub const MPIDR_U_SHIFT: i32 = 30;
pub const MPIDR_AFF3_SHIFT: i32 = 32;
pub const MVFR0_EL1_op0: i32 = 3;
pub const MVFR0_EL1_op1: i32 = 0;
pub const MVFR0_EL1_CRn: i32 = 0;
pub const MVFR0_EL1_CRm: i32 = 3;
pub const MVFR0_EL1_op2: i32 = 0;
pub const MVFR0_SIMDReg_SHIFT: i32 = 0;
pub const MVFR0_SIMDReg_WIDTH: i32 = 4;
pub const MVFR0_FPSP_SHIFT: i32 = 4;
pub const MVFR0_FPSP_WIDTH: i32 = 4;
pub const MVFR0_FPDP_SHIFT: i32 = 8;
pub const MVFR0_FPDP_WIDTH: i32 = 4;
pub const MVFR0_FPTrap_SHIFT: i32 = 12;
pub const MVFR0_FPTrap_WIDTH: i32 = 4;
pub const MVFR0_FPDivide_SHIFT: i32 = 16;
pub const MVFR0_FPDivide_WIDTH: i32 = 4;
pub const MVFR0_FPSqrt_SHIFT: i32 = 20;
pub const MVFR0_FPSqrt_WIDTH: i32 = 4;
pub const MVFR0_FPShVec_SHIFT: i32 = 24;
pub const MVFR0_FPShVec_WIDTH: i32 = 4;
pub const MVFR0_FPRound_SHIFT: i32 = 28;
pub const MVFR0_FPRound_WIDTH: i32 = 4;
pub const MVFR1_EL1_op0: i32 = 3;
pub const MVFR1_EL1_op1: i32 = 0;
pub const MVFR1_EL1_CRn: i32 = 0;
pub const MVFR1_EL1_CRm: i32 = 3;
pub const MVFR1_EL1_op2: i32 = 1;
pub const MVFR1_FPFtZ_SHIFT: i32 = 0;
pub const MVFR1_FPFtZ_WIDTH: i32 = 4;
pub const MVFR1_FPDNaN_SHIFT: i32 = 4;
pub const MVFR1_FPDNaN_WIDTH: i32 = 4;
pub const MVFR1_SIMDLS_SHIFT: i32 = 8;
pub const MVFR1_SIMDLS_WIDTH: i32 = 4;
pub const MVFR1_SIMDInt_SHIFT: i32 = 12;
pub const MVFR1_SIMDInt_WIDTH: i32 = 4;
pub const MVFR1_SIMDSP_SHIFT: i32 = 16;
pub const MVFR1_SIMDSP_WIDTH: i32 = 4;
pub const MVFR1_SIMDHP_SHIFT: i32 = 20;
pub const MVFR1_SIMDHP_WIDTH: i32 = 4;
pub const MVFR1_FPHP_SHIFT: i32 = 24;
pub const MVFR1_FPHP_WIDTH: i32 = 4;
pub const MVFR1_SIMDFMAC_SHIFT: i32 = 28;
pub const MVFR1_SIMDFMAC_WIDTH: i32 = 4;
pub const OSDLR_EL1_op0: i32 = 2;
pub const OSDLR_EL1_op1: i32 = 0;
pub const OSDLR_EL1_CRn: i32 = 1;
pub const OSDLR_EL1_CRm: i32 = 3;
pub const OSDLR_EL1_op2: i32 = 4;
pub const OSLAR_EL1_op0: i32 = 2;
pub const OSLAR_EL1_op1: i32 = 0;
pub const OSLAR_EL1_CRn: i32 = 1;
pub const OSLAR_EL1_CRm: i32 = 0;
pub const OSLAR_EL1_op2: i32 = 4;
pub const OSLAR_OSLK: i32 = 1;
pub const OSLSR_EL1_op0: i32 = 2;
pub const OSLSR_EL1_op1: i32 = 0;
pub const OSLSR_EL1_CRn: i32 = 1;
pub const OSLSR_EL1_CRm: i32 = 1;
pub const OSLSR_EL1_op2: i32 = 4;
pub const OSLSR_OSLM_1: i32 = 8;
pub const OSLSR_nTT: i32 = 4;
pub const OSLSR_OSLK: i32 = 2;
pub const OSLSR_OSLM_0: i32 = 1;
pub const PAR_F_SHIFT: i32 = 0;
pub const PAR_F: i32 = 1;
pub const PAR_LOW_MASK: i32 = 4095;
pub const PAR_SH_SHIFT: i32 = 7;
pub const PAR_SH_MASK: i32 = 384;
pub const PAR_NS_SHIFT: i32 = 9;
pub const PAR_NS_MASK: i32 = 1536;
pub const PAR_PA_SHIFT: i32 = 12;
pub const PAR_PA_MASK: i64 = 4503599627366400;
pub const PAR_ATTR_SHIFT: i32 = 56;
pub const PAR_ATTR_MASK: i64 = -72057594037927936;
pub const PAR_FST_SHIFT: i32 = 1;
pub const PAR_FST_MASK: i32 = 126;
pub const PAR_PTW_SHIFT: i32 = 8;
pub const PAR_PTW_MASK: i32 = 256;
pub const PAR_S_SHIFT: i32 = 9;
pub const PAR_S_MASK: i32 = 512;
pub const PMBIDR_EL1_op0: i32 = 3;
pub const PMBIDR_EL1_op1: i32 = 0;
pub const PMBIDR_EL1_CRn: i32 = 9;
pub const PMBIDR_EL1_CRm: i32 = 10;
pub const PMBIDR_EL1_op2: i32 = 7;
pub const PMBIDR_Align_SHIFT: i32 = 0;
pub const PMBIDR_P_SHIFT: i32 = 4;
pub const PMBIDR_F_SHIFT: i32 = 5;
pub const PMBLIMITR_EL1_op0: i32 = 3;
pub const PMBLIMITR_EL1_op1: i32 = 0;
pub const PMBLIMITR_EL1_CRn: i32 = 9;
pub const PMBLIMITR_EL1_CRm: i32 = 10;
pub const PMBLIMITR_EL1_op2: i32 = 0;
pub const PMBLIMITR_E_SHIFT: i32 = 0;
pub const PMBLIMITR_FM_SHIFT: i32 = 1;
pub const PMBLIMITR_PMFZ_SHIFT: i32 = 5;
pub const PMBLIMITR_LIMIT_SHIFT: i32 = 12;
pub const PMBPTR_EL1_op0: i32 = 3;
pub const PMBPTR_EL1_op1: i32 = 0;
pub const PMBPTR_EL1_CRn: i32 = 9;
pub const PMBPTR_EL1_CRm: i32 = 10;
pub const PMBPTR_EL1_op2: i32 = 1;
pub const PMBPTR_PTR_SHIFT: i32 = 0;
pub const PMBSR_EL1_op0: i32 = 3;
pub const PMBSR_EL1_op1: i32 = 0;
pub const PMBSR_EL1_CRn: i32 = 9;
pub const PMBSR_EL1_CRm: i32 = 10;
pub const PMBSR_EL1_op2: i32 = 3;
pub const PMBSR_MSS_SHIFT: i32 = 0;
pub const PMBSR_COLL_SHIFT: i32 = 16;
pub const PMBSR_S_SHIFT: i32 = 17;
pub const PMBSR_EA_SHIFT: i32 = 18;
pub const PMBSR_DL_SHIFT: i32 = 19;
pub const PMBSR_EC_SHIFT: i32 = 26;
pub const PMBSR_EC_OTHER_BUF_MGMT: i32 = 0;
pub const PMBSR_EC_GRAN_PROT_CHK: i32 = 30;
pub const PMBSR_EC_STAGE1_DA: i32 = 36;
pub const PMBSR_EC_STAGE2_DA: i32 = 37;
pub const PMCCFILTR_EL0_op0: i32 = 3;
pub const PMCCFILTR_EL0_op1: i32 = 3;
pub const PMCCFILTR_EL0_CRn: i32 = 14;
pub const PMCCFILTR_EL0_CRm: i32 = 15;
pub const PMCCFILTR_EL0_op2: i32 = 7;
pub const PMCCNTR_EL0_op0: i32 = 3;
pub const PMCCNTR_EL0_op1: i32 = 3;
pub const PMCCNTR_EL0_CRn: i32 = 9;
pub const PMCCNTR_EL0_CRm: i32 = 13;
pub const PMCCNTR_EL0_op2: i32 = 0;
pub const PMCEID0_EL0_op0: i32 = 3;
pub const PMCEID0_EL0_op1: i32 = 3;
pub const PMCEID0_EL0_CRn: i32 = 9;
pub const PMCEID0_EL0_CRm: i32 = 12;
pub const PMCEID0_EL0_op2: i32 = 6;
pub const PMCEID1_EL0_op0: i32 = 3;
pub const PMCEID1_EL0_op1: i32 = 3;
pub const PMCEID1_EL0_CRn: i32 = 9;
pub const PMCEID1_EL0_CRm: i32 = 12;
pub const PMCEID1_EL0_op2: i32 = 7;
pub const PMCNTENCLR_EL0_op0: i32 = 3;
pub const PMCNTENCLR_EL0_op1: i32 = 3;
pub const PMCNTENCLR_EL0_CRn: i32 = 9;
pub const PMCNTENCLR_EL0_CRm: i32 = 12;
pub const PMCNTENCLR_EL0_op2: i32 = 2;
pub const PMCNTENSET_EL0_op0: i32 = 3;
pub const PMCNTENSET_EL0_op1: i32 = 3;
pub const PMCNTENSET_EL0_CRn: i32 = 9;
pub const PMCNTENSET_EL0_CRm: i32 = 12;
pub const PMCNTENSET_EL0_op2: i32 = 1;
pub const PMCR_EL0_op0: i32 = 3;
pub const PMCR_EL0_op1: i32 = 3;
pub const PMCR_EL0_CRn: i32 = 9;
pub const PMCR_EL0_CRm: i32 = 12;
pub const PMCR_EL0_op2: i32 = 0;
pub const PMCR_E: i32 = 1;
pub const PMCR_P: i32 = 2;
pub const PMCR_C: i32 = 4;
pub const PMCR_D: i32 = 8;
pub const PMCR_X: i32 = 16;
pub const PMCR_DP: i32 = 32;
pub const PMCR_LC: i32 = 64;
pub const PMCR_LP: i32 = 128;
pub const PMCR_FZO: i32 = 512;
pub const PMCR_N_SHIFT: i32 = 11;
pub const PMCR_N_MASK: i32 = 63488;
pub const PMCR_IDCODE_SHIFT: i32 = 16;
pub const PMCR_IDCODE_MASK: i32 = 16711680;
pub const PMCR_IDCODE_CORTEX_A57: i32 = 1;
pub const PMCR_IDCODE_CORTEX_A72: i32 = 2;
pub const PMCR_IDCODE_CORTEX_A53: i32 = 3;
pub const PMCR_IDCODE_CORTEX_A73: i32 = 4;
pub const PMCR_IDCODE_CORTEX_A35: i32 = 10;
pub const PMCR_IDCODE_CORTEX_A76: i32 = 11;
pub const PMCR_IDCODE_NEOVERSE_N1: i32 = 12;
pub const PMCR_IDCODE_CORTEX_A77: i32 = 16;
pub const PMCR_IDCODE_CORTEX_A55: i32 = 69;
pub const PMCR_IDCODE_NEOVERSE_E1: i32 = 70;
pub const PMCR_IDCODE_CORTEX_A75: i32 = 74;
pub const PMCR_IMP_SHIFT: i32 = 24;
pub const PMCR_IMP_MASK: i64 = 4278190080;
pub const PMCR_IMP_ARM: i32 = 65;
pub const PMCR_FZS: i64 = 4294967296;
pub const PMEVCNTR_EL0_op0: i32 = 3;
pub const PMEVCNTR_EL0_op1: i32 = 3;
pub const PMEVCNTR_EL0_CRn: i32 = 14;
pub const PMEVCNTR_EL0_CRm: i32 = 8;
pub const PMEVTYPER_EL0_op0: i32 = 3;
pub const PMEVTYPER_EL0_op1: i32 = 3;
pub const PMEVTYPER_EL0_CRn: i32 = 14;
pub const PMEVTYPER_EL0_CRm: i32 = 12;
pub const PMEVTYPER_EVTCOUNT_MASK: i32 = 1023;
pub const PMEVTYPER_EVTCOUNT_8_1_MASK: i32 = 65535;
pub const PMEVTYPER_MT: i32 = 33554432;
pub const PMEVTYPER_M: i32 = 67108864;
pub const PMEVTYPER_NSH: i32 = 134217728;
pub const PMEVTYPER_NSU: i32 = 268435456;
pub const PMEVTYPER_NSK: i32 = 536870912;
pub const PMEVTYPER_U: i32 = 1073741824;
pub const PMEVTYPER_P: i64 = 2147483648;
pub const PMINTENCLR_EL1_op0: i32 = 3;
pub const PMINTENCLR_EL1_op1: i32 = 0;
pub const PMINTENCLR_EL1_CRn: i32 = 9;
pub const PMINTENCLR_EL1_CRm: i32 = 14;
pub const PMINTENCLR_EL1_op2: i32 = 2;
pub const PMINTENSET_EL1_op0: i32 = 3;
pub const PMINTENSET_EL1_op1: i32 = 0;
pub const PMINTENSET_EL1_CRn: i32 = 9;
pub const PMINTENSET_EL1_CRm: i32 = 14;
pub const PMINTENSET_EL1_op2: i32 = 1;
pub const PMMIR_EL1_op0: i32 = 3;
pub const PMMIR_EL1_op1: i32 = 0;
pub const PMMIR_EL1_CRn: i32 = 9;
pub const PMMIR_EL1_CRm: i32 = 14;
pub const PMMIR_EL1_op2: i32 = 6;
pub const PMOVSCLR_EL0_op0: i32 = 3;
pub const PMOVSCLR_EL0_op1: i32 = 3;
pub const PMOVSCLR_EL0_CRn: i32 = 9;
pub const PMOVSCLR_EL0_CRm: i32 = 12;
pub const PMOVSCLR_EL0_op2: i32 = 3;
pub const PMOVSSET_EL0_op0: i32 = 3;
pub const PMOVSSET_EL0_op1: i32 = 3;
pub const PMOVSSET_EL0_CRn: i32 = 9;
pub const PMOVSSET_EL0_CRm: i32 = 14;
pub const PMOVSSET_EL0_op2: i32 = 3;
pub const PMSCR_EL1_op0: i32 = 3;
pub const PMSCR_EL1_op1: i32 = 0;
pub const PMSCR_EL1_CRn: i32 = 9;
pub const PMSCR_EL1_CRm: i32 = 9;
pub const PMSCR_EL1_op2: i32 = 0;
pub const PMSCR_E0SPE_SHIFT: i32 = 0;
pub const PMSCR_E1SPE_SHIFT: i32 = 1;
pub const PMSCR_CX_SHIFT: i32 = 3;
pub const PMSCR_PA_SHIFT: i32 = 4;
pub const PMSCR_TS_SHIFT: i32 = 5;
pub const PMSCR_PCT_SHIFT: i32 = 6;
pub const PMSELR_EL0_op0: i32 = 3;
pub const PMSELR_EL0_op1: i32 = 3;
pub const PMSELR_EL0_CRn: i32 = 9;
pub const PMSELR_EL0_CRm: i32 = 12;
pub const PMSELR_EL0_op2: i32 = 5;
pub const PMSELR_SEL_MASK: i32 = 31;
pub const PMSEVFR_EL1_op0: i32 = 3;
pub const PMSEVFR_EL1_op1: i32 = 0;
pub const PMSEVFR_EL1_CRn: i32 = 9;
pub const PMSEVFR_EL1_CRm: i32 = 9;
pub const PMSEVFR_EL1_op2: i32 = 5;
pub const PMSFCR_EL1_op0: i32 = 3;
pub const PMSFCR_EL1_op1: i32 = 0;
pub const PMSFCR_EL1_CRn: i32 = 9;
pub const PMSFCR_EL1_CRm: i32 = 9;
pub const PMSFCR_EL1_op2: i32 = 4;
pub const PMSFCR_FE_SHIFT: i32 = 0;
pub const PMSFCR_FT_SHIFT: i32 = 1;
pub const PMSFCR_FL_SHIFT: i32 = 2;
pub const PMSFCR_FnE_SHIFT: i32 = 3;
pub const PMSFCR_B_SHIFT: i32 = 16;
pub const PMSFCR_LD_SHIFT: i32 = 17;
pub const PMSFCR_ST_SHIFT: i32 = 18;
pub const PMSICR_EL1_op0: i32 = 3;
pub const PMSICR_EL1_op1: i32 = 0;
pub const PMSICR_EL1_CRn: i32 = 9;
pub const PMSICR_EL1_CRm: i32 = 9;
pub const PMSICR_EL1_op2: i32 = 2;
pub const PMSICR_COUNT_SHIFT: i32 = 0;
pub const PMSICR_ECOUNT_SHIFT: i32 = 56;
pub const PMSIDR_EL1_op0: i32 = 3;
pub const PMSIDR_EL1_op1: i32 = 0;
pub const PMSIDR_EL1_CRn: i32 = 9;
pub const PMSIDR_EL1_CRm: i32 = 9;
pub const PMSIDR_EL1_op2: i32 = 7;
pub const PMSIDR_FE_SHIFT: i32 = 0;
pub const PMSIDR_FT_SHIFT: i32 = 1;
pub const PMSIDR_FL_SHIFT: i32 = 2;
pub const PMSIDR_ArchInst_SHIFT: i32 = 3;
pub const PMSIDR_LDS_SHIFT: i32 = 4;
pub const PMSIDR_ERnd_SHIFT: i32 = 5;
pub const PMSIDR_FnE_SHIFT: i32 = 6;
pub const PMSIDR_Interval_SHIFT: i32 = 8;
pub const PMSIDR_Interval_256: i32 = 0;
pub const PMSIDR_Interval_512: i32 = 2;
pub const PMSIDR_Interval_768: i32 = 3;
pub const PMSIDR_Interval_1024: i32 = 4;
pub const PMSIDR_Interval_1536: i32 = 5;
pub const PMSIDR_Interval_2048: i32 = 6;
pub const PMSIDR_Interval_3072: i32 = 7;
pub const PMSIDR_Interval_4096: i32 = 8;
pub const PMSIDR_MaxSize_SHIFT: i32 = 12;
pub const PMSIDR_CountSize_SHIFT: i32 = 16;
pub const PMSIDR_Format_SHIFT: i32 = 20;
pub const PMSIDR_PBT_SHIFT: i32 = 24;
pub const PMSIRR_EL1_op0: i32 = 3;
pub const PMSIRR_EL1_op1: i32 = 0;
pub const PMSIRR_EL1_CRn: i32 = 9;
pub const PMSIRR_EL1_CRm: i32 = 9;
pub const PMSIRR_EL1_op2: i32 = 3;
pub const PMSIRR_RND_SHIFT: i32 = 0;
pub const PMSIRR_INTERVAL_SHIFT: i32 = 8;
pub const PMSLATFR_EL1_op0: i32 = 3;
pub const PMSLATFR_EL1_op1: i32 = 0;
pub const PMSLATFR_EL1_CRn: i32 = 9;
pub const PMSLATFR_EL1_CRm: i32 = 9;
pub const PMSLATFR_EL1_op2: i32 = 6;
pub const PMSLATFR_MINLAT_SHIFT: i32 = 0;
pub const PMSNEVFR_EL1_op0: i32 = 3;
pub const PMSNEVFR_EL1_op1: i32 = 0;
pub const PMSNEVFR_EL1_CRn: i32 = 9;
pub const PMSNEVFR_EL1_CRm: i32 = 9;
pub const PMSNEVFR_EL1_op2: i32 = 1;
pub const PMSWINC_EL0_op0: i32 = 3;
pub const PMSWINC_EL0_op1: i32 = 3;
pub const PMSWINC_EL0_CRn: i32 = 9;
pub const PMSWINC_EL0_CRm: i32 = 12;
pub const PMSWINC_EL0_op2: i32 = 4;
pub const PMUSERENR_EL0_op0: i32 = 3;
pub const PMUSERENR_EL0_op1: i32 = 3;
pub const PMUSERENR_EL0_CRn: i32 = 9;
pub const PMUSERENR_EL0_CRm: i32 = 14;
pub const PMUSERENR_EL0_op2: i32 = 0;
pub const PMXEVCNTR_EL0_op0: i32 = 3;
pub const PMXEVCNTR_EL0_op1: i32 = 3;
pub const PMXEVCNTR_EL0_CRn: i32 = 9;
pub const PMXEVCNTR_EL0_CRm: i32 = 13;
pub const PMXEVCNTR_EL0_op2: i32 = 2;
pub const PMXEVTYPER_EL0_op0: i32 = 3;
pub const PMXEVTYPER_EL0_op1: i32 = 3;
pub const PMXEVTYPER_EL0_CRn: i32 = 9;
pub const PMXEVTYPER_EL0_CRm: i32 = 13;
pub const PMXEVTYPER_EL0_op2: i32 = 1;
pub const RNDRRS_op0: i32 = 3;
pub const RNDRRS_op1: i32 = 3;
pub const RNDRRS_CRn: i32 = 2;
pub const RNDRRS_CRm: i32 = 4;
pub const RNDRRS_op2: i32 = 1;
pub const SCTLR_EL1_op0: i32 = 3;
pub const SCTLR_EL1_op1: i32 = 0;
pub const SCTLR_EL1_CRn: i32 = 1;
pub const SCTLR_EL1_CRm: i32 = 0;
pub const SCTLR_EL1_op2: i32 = 0;
pub const SCTLR_RES1: i32 = 818939904;
pub const SCTLR_EL12_op0: i32 = 3;
pub const SCTLR_EL12_op1: i32 = 5;
pub const SCTLR_EL12_CRn: i32 = 1;
pub const SCTLR_EL12_CRm: i32 = 0;
pub const SCTLR_EL12_op2: i32 = 0;
pub const SPSR_EL1_op0: i32 = 3;
pub const SPSR_EL1_op1: i32 = 0;
pub const SPSR_EL1_CRn: i32 = 4;
pub const SPSR_EL1_CRm: i32 = 0;
pub const SPSR_EL1_op2: i32 = 0;
pub const PSR_M_EL0t: i32 = 0;
pub const PSR_M_EL1t: i32 = 4;
pub const PSR_M_EL1h: i32 = 5;
pub const PSR_M_EL2t: i32 = 8;
pub const PSR_M_EL2h: i32 = 9;
pub const PSR_M_64: i32 = 0;
pub const PSR_M_32: i32 = 16;
pub const PSR_M_MASK: i32 = 15;
pub const PSR_T: i32 = 32;
pub const PSR_AARCH32: i32 = 16;
pub const PSR_F: i32 = 64;
pub const PSR_I: i32 = 128;
pub const PSR_A: i32 = 256;
pub const PSR_D: i32 = 512;
pub const PSR_DAIF: i32 = 960;
pub const PSR_DAIF_DEFAULT: i32 = 0;
pub const PSR_DAIF_INTR: i32 = 192;
pub const PSR_BTYPE: i32 = 3072;
pub const PSR_SSBS: i32 = 4096;
pub const PSR_ALLINT: i32 = 8192;
pub const PSR_IL: i32 = 1048576;
pub const PSR_SS: i32 = 2097152;
pub const PSR_PAN: i32 = 4194304;
pub const PSR_UAO: i32 = 8388608;
pub const PSR_DIT: i32 = 16777216;
pub const PSR_TCO: i32 = 33554432;
pub const PSR_V: i32 = 268435456;
pub const PSR_C: i32 = 536870912;
pub const PSR_Z: i32 = 1073741824;
pub const PSR_N: i64 = 2147483648;
pub const PSR_FLAGS: i64 = 4026531840;
pub const PSR_SETTABLE_32: i64 = 4026531840;
pub const PSR_SETTABLE_64: i64 = 4028628992;
pub const SPSR_EL12_op0: i32 = 3;
pub const SPSR_EL12_op1: i32 = 5;
pub const SPSR_EL12_CRn: i32 = 4;
pub const SPSR_EL12_CRm: i32 = 0;
pub const SPSR_EL12_op2: i32 = 0;
pub const REVIDR_EL1_op0: i32 = 3;
pub const REVIDR_EL1_op1: i32 = 0;
pub const REVIDR_EL1_CRn: i32 = 0;
pub const REVIDR_EL1_CRm: i32 = 0;
pub const REVIDR_EL1_op2: i32 = 6;
pub const TCR_EL1_op0: i32 = 3;
pub const TCR_EL1_op1: i32 = 0;
pub const TCR_EL1_CRn: i32 = 2;
pub const TCR_EL1_CRm: i32 = 0;
pub const TCR_EL1_op2: i32 = 2;
pub const TCR_DS_SHIFT: i32 = 59;
pub const TCR_TCMA1_SHIFT: i32 = 58;
pub const TCR_TCMA0_SHIFT: i32 = 57;
pub const TCR_E0PD1_SHIFT: i32 = 56;
pub const TCR_E0PD0_SHIFT: i32 = 55;
pub const TCR_NFD1_SHIFT: i32 = 54;
pub const TCR_NFD0_SHIFT: i32 = 53;
pub const TCR_TBID1_SHIFT: i32 = 52;
pub const TCR_TBID0_SHIFT: i32 = 51;
pub const TCR_HWU162_SHIFT: i32 = 50;
pub const TCR_HWU161_SHIFT: i32 = 49;
pub const TCR_HWU160_SHIFT: i32 = 48;
pub const TCR_HWU159_SHIFT: i32 = 47;
pub const TCR_HWU062_SHIFT: i32 = 46;
pub const TCR_HWU061_SHIFT: i32 = 45;
pub const TCR_HWU060_SHIFT: i32 = 44;
pub const TCR_HWU059_SHIFT: i32 = 43;
pub const TCR_HPD1_SHIFT: i32 = 42;
pub const TCR_HPD0_SHIFT: i32 = 41;
pub const TCR_HD_SHIFT: i32 = 40;
pub const TCR_HA_SHIFT: i32 = 39;
pub const TCR_TBI1_SHIFT: i32 = 38;
pub const TCR_TBI0_SHIFT: i32 = 37;
pub const TCR_ASID_SHIFT: i32 = 36;
pub const TCR_ASID_WIDTH: i32 = 1;
pub const TCR_IPS_SHIFT: i32 = 32;
pub const TCR_IPS_WIDTH: i32 = 3;
pub const TCR_TG1_SHIFT: i32 = 30;
pub const TCR_SH1_SHIFT: i32 = 28;
pub const TCR_ORGN1_SHIFT: i32 = 26;
pub const TCR_IRGN1_SHIFT: i32 = 24;
pub const TCR_EPD1_SHIFT: i32 = 23;
pub const TCR_A1_SHIFT: i32 = 22;
pub const TCR_T1SZ_SHIFT: i32 = 16;
pub const TCR_TG0_SHIFT: i32 = 14;
pub const TCR_SH0_SHIFT: i32 = 12;
pub const TCR_ORGN0_SHIFT: i32 = 10;
pub const TCR_IRGN0_SHIFT: i32 = 8;
pub const TCR_EPD0_SHIFT: i32 = 7;
pub const TCR_T0SZ_SHIFT: i32 = 0;
pub const TCR_EL12_op0: i32 = 3;
pub const TCR_EL12_op1: i32 = 5;
pub const TCR_EL12_CRn: i32 = 2;
pub const TCR_EL12_CRm: i32 = 0;
pub const TCR_EL12_op2: i32 = 2;
pub const TTBR_ASID_SHIFT: i32 = 48;
pub const TTBR_ASID_MASK: i64 = -281474976710656;
pub const TTBR_BADDR: i64 = 281474976710654;
pub const TTBR_CnP_SHIFT: i32 = 0;
pub const TTBR_CnP: i32 = 1;
pub const TTBR0_EL1_op0: i32 = 3;
pub const TTBR0_EL1_op1: i32 = 0;
pub const TTBR0_EL1_CRn: i32 = 2;
pub const TTBR0_EL1_CRm: i32 = 0;
pub const TTBR0_EL1_op2: i32 = 0;
pub const TTBR0_EL12_op0: i32 = 3;
pub const TTBR0_EL12_op1: i32 = 5;
pub const TTBR0_EL12_CRn: i32 = 2;
pub const TTBR0_EL12_CRm: i32 = 0;
pub const TTBR0_EL12_op2: i32 = 0;
pub const TTBR1_EL1_op0: i32 = 3;
pub const TTBR1_EL1_op1: i32 = 0;
pub const TTBR1_EL1_CRn: i32 = 2;
pub const TTBR1_EL1_CRm: i32 = 0;
pub const TTBR1_EL1_op2: i32 = 1;
pub const TTBR1_EL12_op0: i32 = 3;
pub const TTBR1_EL12_op1: i32 = 5;
pub const TTBR1_EL12_CRn: i32 = 2;
pub const TTBR1_EL12_CRm: i32 = 0;
pub const TTBR1_EL12_op2: i32 = 1;
pub const VBAR_EL1_op0: i32 = 3;
pub const VBAR_EL1_op1: i32 = 0;
pub const VBAR_EL1_CRn: i32 = 12;
pub const VBAR_EL1_CRm: i32 = 0;
pub const VBAR_EL1_op2: i32 = 0;
pub const VBAR_EL12_op0: i32 = 3;
pub const VBAR_EL12_op1: i32 = 5;
pub const VBAR_EL12_CRn: i32 = 12;
pub const VBAR_EL12_CRm: i32 = 0;
pub const VBAR_EL12_op2: i32 = 0;
pub const ZCR_EL1_op0: i32 = 3;
pub const ZCR_EL1_op1: i32 = 0;
pub const ZCR_EL1_CRn: i32 = 1;
pub const ZCR_EL1_CRm: i32 = 2;
pub const ZCR_EL1_op2: i32 = 0;
pub const ZCR_LEN_SHIFT: i32 = 0;
pub const ZCR_LEN_MASK: i32 = 15;
pub const CPU_SETSIZE: i32 = 1024;
pub const CPU_MAXSIZE: i32 = 1024;
pub const LOCK_DEBUG: i32 = 1;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: i32 = 20;
pub const PRIO_PROCESS: i32 = 0;
pub const PRIO_PGRP: i32 = 1;
pub const PRIO_USER: i32 = 2;
pub const RUSAGE_SELF: i32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_THREAD: i32 = 1;
pub const RLIMIT_CPU: i32 = 0;
pub const RLIMIT_FSIZE: i32 = 1;
pub const RLIMIT_DATA: i32 = 2;
pub const RLIMIT_STACK: i32 = 3;
pub const RLIMIT_CORE: i32 = 4;
pub const RLIMIT_RSS: i32 = 5;
pub const RLIMIT_MEMLOCK: i32 = 6;
pub const RLIMIT_NPROC: i32 = 7;
pub const RLIMIT_NOFILE: i32 = 8;
pub const RLIMIT_SBSIZE: i32 = 9;
pub const RLIMIT_VMEM: i32 = 10;
pub const RLIMIT_AS: i32 = 10;
pub const RLIMIT_NPTS: i32 = 11;
pub const RLIMIT_SWAP: i32 = 12;
pub const RLIMIT_KQUEUES: i32 = 13;
pub const RLIMIT_UMTXP: i32 = 14;
pub const RLIMIT_PIPEBUF: i32 = 15;
pub const RLIM_NLIMITS: i32 = 16;
pub const CP_USER: i32 = 0;
pub const CP_NICE: i32 = 1;
pub const CP_SYS: i32 = 2;
pub const CP_INTR: i32 = 3;
pub const CP_IDLE: i32 = 4;
pub const CPUSTATES: i32 = 5;
pub const GETRLIMITUSAGE_EUID: i32 = 1;
pub const SS_ONSTACK: i32 = 1;
pub const SS_DISABLE: i32 = 4;
pub const MINSIGSTKSZ: i32 = 4096;
pub const SIGSTKSZ: i32 = 36864;
pub const SIGHUP: i32 = 1;
pub const SIGINT: i32 = 2;
pub const SIGQUIT: i32 = 3;
pub const SIGILL: i32 = 4;
pub const SIGTRAP: i32 = 5;
pub const SIGABRT: i32 = 6;
pub const SIGIOT: i32 = 6;
pub const SIGEMT: i32 = 7;
pub const SIGFPE: i32 = 8;
pub const SIGKILL: i32 = 9;
pub const SIGBUS: i32 = 10;
pub const SIGSEGV: i32 = 11;
pub const SIGSYS: i32 = 12;
pub const SIGPIPE: i32 = 13;
pub const SIGALRM: i32 = 14;
pub const SIGTERM: i32 = 15;
pub const SIGURG: i32 = 16;
pub const SIGSTOP: i32 = 17;
pub const SIGTSTP: i32 = 18;
pub const SIGCONT: i32 = 19;
pub const SIGCHLD: i32 = 20;
pub const SIGTTIN: i32 = 21;
pub const SIGTTOU: i32 = 22;
pub const SIGIO: i32 = 23;
pub const SIGXCPU: i32 = 24;
pub const SIGXFSZ: i32 = 25;
pub const SIGVTALRM: i32 = 26;
pub const SIGPROF: i32 = 27;
pub const SIGWINCH: i32 = 28;
pub const SIGINFO: i32 = 29;
pub const SIGUSR1: i32 = 30;
pub const SIGUSR2: i32 = 31;
pub const SIGTHR: i32 = 32;
pub const SIGLWP: i32 = 32;
pub const SIGLIBRT: i32 = 33;
pub const SIGRTMIN: i32 = 65;
pub const SIGRTMAX: i32 = 126;
pub const SIGEV_NONE: i32 = 0;
pub const SIGEV_SIGNAL: i32 = 1;
pub const SIGEV_THREAD: i32 = 2;
pub const SIGEV_KEVENT: i32 = 3;
pub const SIGEV_THREAD_ID: i32 = 4;
pub const ILL_ILLOPC: i32 = 1;
pub const ILL_ILLOPN: i32 = 2;
pub const ILL_ILLADR: i32 = 3;
pub const ILL_ILLTRP: i32 = 4;
pub const ILL_PRVOPC: i32 = 5;
pub const ILL_PRVREG: i32 = 6;
pub const ILL_COPROC: i32 = 7;
pub const ILL_BADSTK: i32 = 8;
pub const BUS_ADRALN: i32 = 1;
pub const BUS_ADRERR: i32 = 2;
pub const BUS_OBJERR: i32 = 3;
pub const BUS_OOMERR: i32 = 100;
pub const SEGV_MAPERR: i32 = 1;
pub const SEGV_ACCERR: i32 = 2;
pub const SEGV_PKUERR: i32 = 100;
pub const FPE_INTOVF: i32 = 1;
pub const FPE_INTDIV: i32 = 2;
pub const FPE_FLTDIV: i32 = 3;
pub const FPE_FLTOVF: i32 = 4;
pub const FPE_FLTUND: i32 = 5;
pub const FPE_FLTRES: i32 = 6;
pub const FPE_FLTINV: i32 = 7;
pub const FPE_FLTSUB: i32 = 8;
pub const FPE_FLTIDO: i32 = 9;
pub const TRAP_BRKPT: i32 = 1;
pub const TRAP_TRACE: i32 = 2;
pub const TRAP_DTRACE: i32 = 3;
pub const TRAP_CAP: i32 = 4;
pub const CLD_EXITED: i32 = 1;
pub const CLD_KILLED: i32 = 2;
pub const CLD_DUMPED: i32 = 3;
pub const CLD_TRAPPED: i32 = 4;
pub const CLD_STOPPED: i32 = 5;
pub const CLD_CONTINUED: i32 = 6;
pub const POLL_IN: i32 = 1;
pub const POLL_OUT: i32 = 2;
pub const POLL_MSG: i32 = 3;
pub const POLL_ERR: i32 = 4;
pub const POLL_PRI: i32 = 5;
pub const POLL_HUP: i32 = 6;
pub const SA_NOCLDSTOP: i32 = 8;
pub const SA_ONSTACK: i32 = 1;
pub const SA_RESTART: i32 = 2;
pub const SA_RESETHAND: i32 = 4;
pub const SA_NODEFER: i32 = 16;
pub const SA_NOCLDWAIT: i32 = 32;
pub const SA_SIGINFO: i32 = 64;
pub const NSIG: i32 = 32;
pub const SI_NOINFO: i32 = 0;
pub const SI_USER: i32 = 65537;
pub const SI_QUEUE: i32 = 65538;
pub const SI_TIMER: i32 = 65539;
pub const SI_ASYNCIO: i32 = 65540;
pub const SI_MESGQ: i32 = 65541;
pub const SI_KERNEL: i32 = 65542;
pub const SI_LWP: i32 = 65543;
pub const SI_UNDEFINED: i32 = 0;
pub const SV_ONSTACK: i32 = 1;
pub const SV_INTERRUPT: i32 = 2;
pub const SV_RESETHAND: i32 = 4;
pub const SV_NODEFER: i32 = 16;
pub const SV_NOCLDSTOP: i32 = 8;
pub const SV_SIGINFO: i32 = 64;
pub const __SIGQUEUE_TID: i64 = 2147483648;
pub const __SIGQUEUE_RSRV: i32 = 1073741824;
pub const SIG_BLOCK: i32 = 1;
pub const SIG_UNBLOCK: i32 = 2;
pub const SIG_SETMASK: i32 = 3;
pub const ARM64_CTX_END: i64 = 2779096485;
pub const ARM64_CTX_SVE: i32 = 6649459;
pub const _MC_FP_VALID: i32 = 1;
pub const UCF_SWAPPED: i32 = 1;
pub const GET_MC_CLEAR_RET: i32 = 1;
pub const CPU_AFF0_MASK: i32 = 255;
pub const CPU_AFF1_MASK: i32 = 65280;
pub const CPU_AFF2_MASK: i32 = 16711680;
pub const CPU_AFF3_MASK: i64 = 1095216660480;
pub const CPU_AFF_MASK: i64 = 1095233437695;
pub const CPU_IMPL_ARM: i32 = 65;
pub const CPU_IMPL_BROADCOM: i32 = 66;
pub const CPU_IMPL_CAVIUM: i32 = 67;
pub const CPU_IMPL_DEC: i32 = 68;
pub const CPU_IMPL_FUJITSU: i32 = 70;
pub const CPU_IMPL_HISILICON: i32 = 72;
pub const CPU_IMPL_INFINEON: i32 = 73;
pub const CPU_IMPL_FREESCALE: i32 = 77;
pub const CPU_IMPL_NVIDIA: i32 = 78;
pub const CPU_IMPL_APM: i32 = 80;
pub const CPU_IMPL_QUALCOMM: i32 = 81;
pub const CPU_IMPL_MARVELL: i32 = 86;
pub const CPU_IMPL_APPLE: i32 = 97;
pub const CPU_IMPL_INTEL: i32 = 105;
pub const CPU_IMPL_AMPERE: i32 = 192;
pub const CPU_IMPL_MICROSOFT: i32 = 109;
pub const CPU_PART_FOUNDATION: i32 = 3328;
pub const CPU_PART_CORTEX_A34: i32 = 3330;
pub const CPU_PART_CORTEX_A53: i32 = 3331;
pub const CPU_PART_CORTEX_A35: i32 = 3332;
pub const CPU_PART_CORTEX_A55: i32 = 3333;
pub const CPU_PART_CORTEX_A65: i32 = 3334;
pub const CPU_PART_CORTEX_A57: i32 = 3335;
pub const CPU_PART_CORTEX_A72: i32 = 3336;
pub const CPU_PART_CORTEX_A73: i32 = 3337;
pub const CPU_PART_CORTEX_A75: i32 = 3338;
pub const CPU_PART_CORTEX_A76: i32 = 3339;
pub const CPU_PART_NEOVERSE_N1: i32 = 3340;
pub const CPU_PART_CORTEX_A77: i32 = 3341;
pub const CPU_PART_CORTEX_A76AE: i32 = 3342;
pub const CPU_PART_AEM_V8: i32 = 3343;
pub const CPU_PART_NEOVERSE_V1: i32 = 3392;
pub const CPU_PART_CORTEX_A78: i32 = 3393;
pub const CPU_PART_CORTEX_A78AE: i32 = 3394;
pub const CPU_PART_CORTEX_A65AE: i32 = 3395;
pub const CPU_PART_CORTEX_X1: i32 = 3396;
pub const CPU_PART_CORTEX_A510: i32 = 3398;
pub const CPU_PART_CORTEX_A710: i32 = 3399;
pub const CPU_PART_CORTEX_X2: i32 = 3400;
pub const CPU_PART_NEOVERSE_N2: i32 = 3401;
pub const CPU_PART_NEOVERSE_E1: i32 = 3402;
pub const CPU_PART_CORTEX_A78C: i32 = 3403;
pub const CPU_PART_CORTEX_X1C: i32 = 3404;
pub const CPU_PART_CORTEX_A715: i32 = 3405;
pub const CPU_PART_CORTEX_X3: i32 = 3406;
pub const CPU_PART_NEOVERSE_V2: i32 = 3407;
pub const CPU_PART_CORTEX_A520: i32 = 3456;
pub const CPU_PART_CORTEX_A720: i32 = 3457;
pub const CPU_PART_CORTEX_X4: i32 = 3458;
pub const CPU_PART_NEOVERSE_V3AE: i32 = 3459;
pub const CPU_PART_NEOVERSE_V3: i32 = 3460;
pub const CPU_PART_CORTEX_X925: i32 = 3461;
pub const CPU_PART_CORTEX_A725: i32 = 3463;
pub const CPU_PART_C1_NANO: i32 = 3466;
pub const CPU_PART_C1_PRO: i32 = 3467;
pub const CPU_PART_C1_ULTRA: i32 = 3468;
pub const CPU_PART_NEOVERSE_N3: i32 = 3470;
pub const CPU_PART_C1_PREMIUM: i32 = 3472;
pub const CPU_PART_THUNDERX: i32 = 161;
pub const CPU_PART_THUNDERX_81XX: i32 = 162;
pub const CPU_PART_THUNDERX_83XX: i32 = 163;
pub const CPU_PART_THUNDERX2: i32 = 175;
pub const CPU_REV_THUNDERX_1_0: i32 = 0;
pub const CPU_REV_THUNDERX_1_1: i32 = 1;
pub const CPU_REV_THUNDERX2_0: i32 = 0;
pub const CPU_PART_EMAG8180: i32 = 0;
pub const CPU_PART_AMPERE1: i32 = 2755;
pub const CPU_PART_AMPERE1A: i32 = 2756;
pub const CPU_PART_AZURE_COBALT_100: i32 = 3401;
pub const CPU_PART_KRYO400_GOLD: i32 = 2052;
pub const CPU_PART_KRYO400_SILVER: i32 = 2053;
pub const CPU_PART_M1_ICESTORM: i32 = 34;
pub const CPU_PART_M1_FIRESTORM: i32 = 35;
pub const CPU_PART_M1_ICESTORM_PRO: i32 = 36;
pub const CPU_PART_M1_FIRESTORM_PRO: i32 = 37;
pub const CPU_PART_M1_ICESTORM_MAX: i32 = 40;
pub const CPU_PART_M1_FIRESTORM_MAX: i32 = 41;
pub const CPU_PART_M2_BLIZZARD: i32 = 50;
pub const CPU_PART_M2_AVALANCHE: i32 = 51;
pub const CPU_PART_M2_BLIZZARD_PRO: i32 = 52;
pub const CPU_PART_M2_AVALANCHE_PRO: i32 = 53;
pub const CPU_PART_M2_BLIZZARD_MAX: i32 = 56;
pub const CPU_PART_M2_AVALANCHE_MAX: i32 = 57;
pub const CPU_IMPL_MASK: i64 = 4278190080;
pub const CPU_PART_MASK: i32 = 65520;
pub const CPU_VAR_MASK: i32 = 15728640;
pub const CPU_ARCH_MASK: i32 = 983040;
pub const CPU_REV_MASK: i32 = 15;
pub const CPU_MATCH_ERRATA_CAVIUM_THUNDERX_1_1: i32 = 0;
pub const DPCPU_SETNAME: &[u8; 9] = b"set_pcpu\0";
pub const DPCPU_SYMPREFIX: &[u8; 12] = b"pcpu_entry_\0";
pub const DPCPU_MODMIN: i32 = 2048;
pub const UMA_PCPU_ALLOC_SIZE: i32 = 16384;
pub const HASH_NOWAIT: i32 = 1;
pub const HASH_WAITOK: i32 = 2;
pub const HD_COLUMN_MASK: i32 = 255;
pub const HD_DELIM_MASK: i32 = 65280;
pub const HD_OMIT_COUNT: i32 = 65536;
pub const HD_OMIT_HEX: i32 = 131072;
pub const HD_OMIT_CHARS: i32 = 262144;
pub const GETENV_UNSIGNED: i32 = 0;
pub const GETENV_SIGNED: i32 = 1;
pub const LIBKERN_LEN_BCD2BIN: i32 = 154;
pub const LIBKERN_LEN_BIN2BCD: i32 = 100;
pub const LIBKERN_LEN_HEX2ASCII: i32 = 36;
pub const ARC4_ENTR_NONE: i32 = 0;
pub const ARC4_ENTR_HAVE: i32 = 1;
pub const ARC4_ENTR_SEED: i32 = 2;
pub const FNM_NOMATCH: i32 = 1;
pub const FNM_NOESCAPE: i32 = 1;
pub const FNM_PATHNAME: i32 = 2;
pub const FNM_PERIOD: i32 = 4;
pub const FNM_LEADING_DIR: i32 = 8;
pub const FNM_CASEFOLD: i32 = 16;
pub const FNM_IGNORECASE: i32 = 16;
pub const FNM_FILE_NAME: i32 = 2;
pub const FILTER_STRAY: i32 = 1;
pub const FILTER_HANDLED: i32 = 2;
pub const FILTER_SCHEDULE_THREAD: i32 = 4;
pub const RLE_RESERVED: i32 = 1;
pub const RLE_ALLOCATED: i32 = 2;
pub const RLE_PREFETCH: i32 = 4;
pub const BUS_PROBE_SPECIFIC: i32 = 0;
pub const BUS_PROBE_VENDOR: i32 = -10;
pub const BUS_PROBE_DEFAULT: i32 = -20;
pub const BUS_PROBE_LOW_PRIORITY: i32 = -40;
pub const BUS_PROBE_GENERIC: i32 = -100;
pub const BUS_PROBE_HOOVER: i32 = -1000000;
pub const BUS_PROBE_NOWILDCARD: i32 = -2000000000;
pub const BUS_PASS_ROOT: i32 = 0;
pub const BUS_PASS_BUS: i32 = 10;
pub const BUS_PASS_CPU: i32 = 20;
pub const BUS_PASS_RESOURCE: i32 = 30;
pub const BUS_PASS_INTERRUPT: i32 = 40;
pub const BUS_PASS_TIMER: i32 = 50;
pub const BUS_PASS_SCHEDULER: i32 = 60;
pub const BUS_PASS_SUPPORTDEV: i32 = 100000;
pub const BUS_PASS_DEFAULT: i32 = 2147483647;
pub const BUS_PASS_ORDER_FIRST: i32 = 0;
pub const BUS_PASS_ORDER_EARLY: i32 = 2;
pub const BUS_PASS_ORDER_MIDDLE: i32 = 5;
pub const BUS_PASS_ORDER_LATE: i32 = 7;
pub const BUS_PASS_ORDER_LAST: i32 = 9;
pub const BUS_LOCATOR_ACPI: &[u8; 5] = b"ACPI\0";
pub const BUS_LOCATOR_FREEBSD: &[u8; 8] = b"FreeBSD\0";
pub const BUS_LOCATOR_UEFI: &[u8; 5] = b"UEFI\0";
pub const BUS_LOCATOR_OFW: &[u8; 4] = b"OFW\0";
pub const TS_ENTER: i32 = 0;
pub const TS_EXIT: i32 = 1;
pub const TS_THREAD: i32 = 2;
pub const TS_EVENT: i32 = 3;
pub const DEV_PROP_NAME_IOMMU: &[u8; 11] = b"iommu-unit\0";
pub const CPU_LEVEL_ROOT: i32 = 1;
pub const CPU_LEVEL_CPUSET: i32 = 2;
pub const CPU_LEVEL_WHICH: i32 = 3;
pub const CPU_WHICH_TID: i32 = 1;
pub const CPU_WHICH_PID: i32 = 2;
pub const CPU_WHICH_CPUSET: i32 = 3;
pub const CPU_WHICH_IRQ: i32 = 4;
pub const CPU_WHICH_JAIL: i32 = 5;
pub const CPU_WHICH_DOMAIN: i32 = 6;
pub const CPU_WHICH_INTRHANDLER: i32 = 7;
pub const CPU_WHICH_ITHREAD: i32 = 8;
pub const CPU_WHICH_TIDPID: i32 = 9;
pub const CPUSET_INVALID: i32 = -1;
pub const CPUSET_DEFAULT: i32 = 0;
pub const CPU_SET_ROOT: i32 = 1;
pub const CPU_SET_RDONLY: i32 = 2;
pub const M_NOWAIT: i32 = 1;
pub const M_WAITOK: i32 = 2;
pub const M_NORECLAIM: i32 = 128;
pub const M_ZERO: i32 = 256;
pub const M_NOVM: i32 = 512;
pub const M_USE_RESERVE: i32 = 1024;
pub const M_NODUMP: i32 = 2048;
pub const M_FIRSTFIT: i32 = 4096;
pub const M_BESTFIT: i32 = 8192;
pub const M_EXEC: i32 = 16384;
pub const M_NEXTFIT: i32 = 32768;
pub const M_NEVERFREED: i32 = 65536;
pub const M_VERSION: i32 = 2024073001;
pub const DTMALLOC_PROBE_MALLOC: i32 = 0;
pub const DTMALLOC_PROBE_FREE: i32 = 1;
pub const DTMALLOC_PROBE_MAX: i32 = 2;
pub const MALLOC_TYPE_STREAM_VERSION: i32 = 1;
pub const MALLOC_MAX_NAME: i32 = 32;
pub const VM_MEMATTR_DEVICE_nGnRnE: i32 = 0;
pub const VM_MEMATTR_UNCACHEABLE: i32 = 1;
pub const VM_MEMATTR_WRITE_BACK: i32 = 2;
pub const VM_MEMATTR_WRITE_THROUGH: i32 = 3;
pub const VM_MEMATTR_DEVICE_nGnRE: i32 = 4;
pub const VM_MEMATTR_DEVICE: i32 = 4;
pub const VM_MEMATTR_DEVICE_NP: i32 = 0;
pub const VM_MEMATTR_WRITE_COMBINING: i32 = 3;
pub const VM_MEMATTR_DEFAULT: i32 = 2;
pub const SWAP_RESERVE_FORCE_ON: i32 = 1;
pub const SWAP_RESERVE_RLIMIT_ON: i32 = 2;
pub const SWAP_RESERVE_ALLOW_NONWIRED: i32 = 4;
pub const OFW_STD_DIRECT: &[u8; 8] = b"ofw_std\0";
pub const OFW_STD_REAL: &[u8; 9] = b"ofw_real\0";
pub const OFW_STD_32BIT: &[u8; 10] = b"ofw_32bit\0";
pub const OFW_FDT: &[u8; 8] = b"ofw_fdt\0";
pub const NIRQ: i32 = 16384;
pub const INTR_ROOT_IRQ: i32 = 0;
pub const INTR_ROOT_FIQ: i32 = 1;
pub const INTR_ROOT_COUNT: i32 = 2;
pub const INTR_IRQ_INVALID: i64 = 4294967295;
pub const INTR_ISRC_NAMELEN: i32 = 20;
pub const INTR_ISRCF_IPI: i32 = 1;
pub const INTR_ISRCF_PPI: i32 = 2;
pub const INTR_ISRCF_BOUND: i32 = 4;
pub const ICHS_QUEUED: i32 = 1;
pub const ICHS_RUNNING: i32 = 2;
pub const ICHS_DONE: i32 = 3;
pub const KTR_GEN: i32 = 1;
pub const KTR_NET: i32 = 2;
pub const KTR_DEV: i32 = 4;
pub const KTR_LOCK: i32 = 8;
pub const KTR_SMP: i32 = 16;
pub const KTR_SUBSYS: i32 = 32;
pub const KTR_PMAP: i32 = 64;
pub const KTR_MALLOC: i32 = 128;
pub const KTR_TRAP: i32 = 256;
pub const KTR_INTR: i32 = 512;
pub const KTR_SIG: i32 = 1024;
pub const KTR_SPARE2: i32 = 2048;
pub const KTR_PROC: i32 = 4096;
pub const KTR_SYSC: i32 = 8192;
pub const KTR_INIT: i32 = 16384;
pub const KTR_SPARE3: i32 = 32768;
pub const KTR_SPARE4: i32 = 65536;
pub const KTR_EVH: i32 = 131072;
pub const KTR_VFS: i32 = 262144;
pub const KTR_VOP: i32 = 524288;
pub const KTR_VM: i32 = 1048576;
pub const KTR_INET: i32 = 2097152;
pub const KTR_RUNQ: i32 = 4194304;
pub const KTR_SPARE5: i32 = 8388608;
pub const KTR_UMA: i32 = 16777216;
pub const KTR_CALLOUT: i32 = 33554432;
pub const KTR_GEOM: i32 = 67108864;
pub const KTR_BUSDMA: i32 = 134217728;
pub const KTR_INET6: i32 = 268435456;
pub const KTR_SCHED: i32 = 536870912;
pub const KTR_BUF: i32 = 1073741824;
pub const KTR_PTRACE: i64 = 2147483648;
pub const KTR_ALL: i64 = 4294967295;
pub const KTR_COMPILE: i32 = 0;
pub const LC_SLEEPLOCK: i32 = 1;
pub const LC_SPINLOCK: i32 = 2;
pub const LC_SLEEPABLE: i32 = 4;
pub const LC_RECURSABLE: i32 = 8;
pub const LC_UPGRADABLE: i32 = 16;
pub const LO_CLASSFLAGS: i32 = 65535;
pub const LO_INITIALIZED: i32 = 65536;
pub const LO_WITNESS: i32 = 131072;
pub const LO_QUIET: i32 = 262144;
pub const LO_RECURSABLE: i32 = 524288;
pub const LO_SLEEPABLE: i32 = 1048576;
pub const LO_UPGRADABLE: i32 = 2097152;
pub const LO_DUPOK: i32 = 4194304;
pub const LO_IS_VNODE: i32 = 8388608;
pub const LO_CLASSMASK: i32 = 251658240;
pub const LO_NOPROFILE: i32 = 268435456;
pub const LO_NEW: i32 = 536870912;
pub const LO_CLASSSHIFT: i32 = 24;
pub const LOCK_CLASS_MAX: i32 = 15;
pub const LOP_NEWORDER: i32 = 1;
pub const LOP_QUIET: i32 = 2;
pub const LOP_TRYLOCK: i32 = 4;
pub const LOP_EXCLUSIVE: i32 = 8;
pub const LOP_DUPOK: i32 = 16;
pub const LOP_NOSLEEP: i32 = 32;
pub const LA_MASKASSERT: i32 = 255;
pub const LA_UNLOCKED: i32 = 0;
pub const LA_LOCKED: i32 = 1;
pub const LA_SLOCKED: i32 = 2;
pub const LA_XLOCKED: i32 = 4;
pub const LA_RECURSED: i32 = 8;
pub const LA_NOTRECURSED: i32 = 16;
pub const WARN_GIANTOK: i32 = 1;
pub const WARN_PANIC: i32 = 2;
pub const WARN_SLEEPOK: i32 = 4;
pub const MDT_DEPEND: i32 = 1;
pub const MDT_MODULE: i32 = 2;
pub const MDT_VERSION: i32 = 3;
pub const MDT_PNP_INFO: i32 = 4;
pub const MDT_STRUCT_VERSION: i32 = 1;
pub const MDT_SETNAME: &[u8; 16] = b"modmetadata_set\0";
pub const MAXMODNAMEV1V2: i32 = 32;
pub const MAXMODNAMEV3: i32 = 1024;
pub const MAXMODNAME: i32 = 1024;
pub const _SDT_ASM_PATCH_INSTR: &[u8; 4] = b"nop\0";
pub const _SDT_TRACEPOINT_SECTION: &[u8; 23] = b"set_sdt_tracepoint_set\0";
pub const _SDT_ASM_WORD: &[u8; 6] = b".quad\0";
pub const _SDT_ASM_PROBE_CONSTRAINT: &[u8; 2] = b"i\0";
pub const _SDT_ASM_PROBE_OPERAND: &[u8; 2] = b"c\0";
pub const LOCKSTAT_WRITER: i32 = 0;
pub const LOCKSTAT_READER: i32 = 1;
pub const MTX_DEF: i32 = 0;
pub const MTX_SPIN: i32 = 1;
pub const MTX_RECURSE: i32 = 4;
pub const MTX_NOWITNESS: i32 = 8;
pub const MTX_NOPROFILE: i32 = 32;
pub const MTX_NEW: i32 = 64;
pub const MTX_QUIET: i32 = 2;
pub const MTX_DUPOK: i32 = 16;
pub const MTX_UNOWNED: i32 = 0;
pub const MTX_RECURSED: i32 = 1;
pub const MTX_WAITERS: i32 = 2;
pub const MTX_DESTROYED: i32 = 4;
pub const MTX_FLAGMASK: i32 = 7;
pub const MA_OWNED: i32 = 4;
pub const MA_NOTOWNED: i32 = 0;
pub const MA_RECURSED: i32 = 8;
pub const MA_NOTRECURSED: i32 = 16;
pub const MTX_NETWORK_LOCK: &[u8; 15] = b"network driver\0";
pub const EVFILT_READ: i32 = -1;
pub const EVFILT_WRITE: i32 = -2;
pub const EVFILT_AIO: i32 = -3;
pub const EVFILT_VNODE: i32 = -4;
pub const EVFILT_PROC: i32 = -5;
pub const EVFILT_SIGNAL: i32 = -6;
pub const EVFILT_TIMER: i32 = -7;
pub const EVFILT_PROCDESC: i32 = -8;
pub const EVFILT_FS: i32 = -9;
pub const EVFILT_LIO: i32 = -10;
pub const EVFILT_USER: i32 = -11;
pub const EVFILT_SENDFILE: i32 = -12;
pub const EVFILT_EMPTY: i32 = -13;
pub const EVFILT_JAIL: i32 = -14;
pub const EVFILT_JAILDESC: i32 = -15;
pub const EVFILT_SYSCOUNT: i32 = 15;
pub const EV_ADD: i32 = 1;
pub const EV_DELETE: i32 = 2;
pub const EV_ENABLE: i32 = 4;
pub const EV_DISABLE: i32 = 8;
pub const EV_FORCEONESHOT: i32 = 256;
pub const EV_KEEPUDATA: i32 = 512;
pub const EV_ONESHOT: i32 = 16;
pub const EV_CLEAR: i32 = 32;
pub const EV_RECEIPT: i32 = 64;
pub const EV_DISPATCH: i32 = 128;
pub const EV_SYSFLAGS: i32 = 61440;
pub const EV_DROP: i32 = 4096;
pub const EV_FLAG1: i32 = 8192;
pub const EV_FLAG2: i32 = 16384;
pub const EV_EOF: i32 = 32768;
pub const EV_ERROR: i32 = 16384;
pub const NOTE_FFNOP: i32 = 0;
pub const NOTE_FFAND: i32 = 1073741824;
pub const NOTE_FFOR: i64 = 2147483648;
pub const NOTE_FFCOPY: i64 = 3221225472;
pub const NOTE_FFCTRLMASK: i64 = 3221225472;
pub const NOTE_FFLAGSMASK: i32 = 16777215;
pub const NOTE_TRIGGER: i32 = 16777216;
pub const NOTE_LOWAT: i32 = 1;
pub const NOTE_FILE_POLL: i32 = 2;
pub const NOTE_DELETE: i32 = 1;
pub const NOTE_WRITE: i32 = 2;
pub const NOTE_EXTEND: i32 = 4;
pub const NOTE_ATTRIB: i32 = 8;
pub const NOTE_LINK: i32 = 16;
pub const NOTE_RENAME: i32 = 32;
pub const NOTE_REVOKE: i32 = 64;
pub const NOTE_OPEN: i32 = 128;
pub const NOTE_CLOSE: i32 = 256;
pub const NOTE_CLOSE_WRITE: i32 = 512;
pub const NOTE_READ: i32 = 1024;
pub const NOTE_EXIT: i64 = 2147483648;
pub const NOTE_FORK: i32 = 1073741824;
pub const NOTE_EXEC: i32 = 536870912;
pub const NOTE_PCTRLMASK: i64 = 4026531840;
pub const NOTE_PDATAMASK: i32 = 1048575;
pub const NOTE_TRACK: i32 = 1;
pub const NOTE_TRACKERR: i32 = 2;
pub const NOTE_CHILD: i32 = 4;
pub const NOTE_JAIL_CHILD: i64 = 2147483648;
pub const NOTE_JAIL_SET: i32 = 1073741824;
pub const NOTE_JAIL_ATTACH: i32 = 536870912;
pub const NOTE_JAIL_REMOVE: i32 = 268435456;
pub const NOTE_JAIL_MULTI: i32 = 134217728;
pub const NOTE_JAIL_CTRLMASK: i64 = 4026531840;
pub const NOTE_SECONDS: i32 = 1;
pub const NOTE_MSECONDS: i32 = 2;
pub const NOTE_USECONDS: i32 = 4;
pub const NOTE_NSECONDS: i32 = 8;
pub const NOTE_ABSTIME: i32 = 16;
pub const KQUEUE_CLOEXEC: i32 = 1;
pub const KQUEUE_CPONFORK: i32 = 2;
pub const KNF_LISTLOCKED: i32 = 1;
pub const KNF_NOKQLOCK: i32 = 2;
pub const NOTE_SIGNAL: i32 = 134217728;
pub const EVENT_REGISTER: i32 = 1;
pub const EVENT_PROCESS: i32 = 2;
pub const KN_ACTIVE: i32 = 1;
pub const KN_QUEUED: i32 = 2;
pub const KN_DISABLED: i32 = 4;
pub const KN_DETACHED: i32 = 8;
pub const KN_MARKER: i32 = 32;
pub const KN_KQUEUE: i32 = 64;
pub const KN_SCAN: i32 = 256;
pub const OSD_THREAD: i32 = 0;
pub const OSD_JAIL: i32 = 1;
pub const OSD_KHELP: i32 = 2;
pub const OSD_FIRST: i32 = 0;
pub const OSD_LAST: i32 = 2;
pub const RTP_PRIO_ITHD: i32 = 1;
pub const RTP_PRIO_REALTIME: i32 = 2;
pub const RTP_PRIO_NORMAL: i32 = 3;
pub const RTP_PRIO_IDLE: i32 = 4;
pub const RTP_PRIO_FIFO_BIT: i32 = 8;
pub const RTP_PRIO_FIFO: i32 = 10;
pub const RTP_PRIO_MIN: i32 = 0;
pub const RTP_PRIO_MAX: i32 = 31;
pub const RTP_LOOKUP: i32 = 0;
pub const RTP_SET: i32 = 1;
pub const PS_NOCLDWAIT: i32 = 1;
pub const PS_NOCLDSTOP: i32 = 2;
pub const PS_CLDSIGIGN: i32 = 4;
pub const KSI_TRAP: i32 = 1;
pub const KSI_EXT: i32 = 2;
pub const KSI_INS: i32 = 4;
pub const KSI_SIGQ: i32 = 8;
pub const KSI_HEAD: i32 = 16;
pub const KSI_PTRACE: i32 = 32;
pub const KSI_COPYMASK: i32 = 41;
pub const SQ_INIT: i32 = 1;
pub const SIGFASTBLOCK_SETPTR: i32 = 1;
pub const SIGFASTBLOCK_UNBLOCK: i32 = 2;
pub const SIGFASTBLOCK_UNSETPTR: i32 = 3;
pub const SIGFASTBLOCK_PEND: i32 = 1;
pub const SIGFASTBLOCK_FLAGS: i32 = 15;
pub const SIGFASTBLOCK_INC: i32 = 16;
pub const SIGPROCMASK_OLD: i32 = 1;
pub const SIGPROCMASK_PROC_LOCKED: i32 = 2;
pub const SIGPROCMASK_PS_LOCKED: i32 = 4;
pub const SIGPROCMASK_FASTBLK: i32 = 8;
pub const SIGDEFERSTOP_NOP: i32 = 0;
pub const SIGDEFERSTOP_OFF: i32 = 1;
pub const SIGDEFERSTOP_SILENT: i32 = 2;
pub const SIGDEFERSTOP_EINTR: i32 = 3;
pub const SIGDEFERSTOP_ERESTART: i32 = 4;
pub const SIGDEFERSTOP_VAL_NCHG: i32 = -1;
pub const AUDIT_RECORD_MAGIC: i64 = 2190085915;
pub const MAX_AUDIT_RECORDS: i32 = 20;
pub const MAXAUDITDATA: i32 = 32767;
pub const MAX_AUDIT_RECORD_SIZE: i32 = 32767;
pub const MIN_AUDIT_FILE_SIZE: i32 = 524288;
pub const AUDIT_HARD_LIMIT_FREE_BLOCKS: i32 = 4;
pub const AUDIT_TRIGGER_MIN: i32 = 1;
pub const AUDIT_TRIGGER_LOW_SPACE: i32 = 1;
pub const AUDIT_TRIGGER_ROTATE_KERNEL: i32 = 2;
pub const AUDIT_TRIGGER_READ_FILE: i32 = 3;
pub const AUDIT_TRIGGER_CLOSE_AND_DIE: i32 = 4;
pub const AUDIT_TRIGGER_NO_SPACE: i32 = 5;
pub const AUDIT_TRIGGER_ROTATE_USER: i32 = 6;
pub const AUDIT_TRIGGER_INITIALIZE: i32 = 7;
pub const AUDIT_TRIGGER_EXPIRE_TRAILS: i32 = 8;
pub const AUDIT_TRIGGER_MAX: i32 = 8;
pub const AUDITDEV_FILENAME: &[u8; 6] = b"audit\0";
pub const AUDIT_TRIGGER_FILE: &[u8; 11] = b"/dev/audit\0";
pub const AU_DEFAUDITSID: i32 = 0;
pub const AU_ASSIGN_ASID: i32 = -1;
pub const AUC_UNSET: i32 = 0;
pub const AUC_AUDITING: i32 = 1;
pub const AUC_NOAUDIT: i32 = 2;
pub const AUC_DISABLED: i32 = -1;
pub const A_OLDGETPOLICY: i32 = 2;
pub const A_OLDSETPOLICY: i32 = 3;
pub const A_GETKMASK: i32 = 4;
pub const A_SETKMASK: i32 = 5;
pub const A_OLDGETQCTRL: i32 = 6;
pub const A_OLDSETQCTRL: i32 = 7;
pub const A_GETCWD: i32 = 8;
pub const A_GETCAR: i32 = 9;
pub const A_GETSTAT: i32 = 12;
pub const A_SETSTAT: i32 = 13;
pub const A_SETUMASK: i32 = 14;
pub const A_SETSMASK: i32 = 15;
pub const A_OLDGETCOND: i32 = 20;
pub const A_OLDSETCOND: i32 = 21;
pub const A_GETCLASS: i32 = 22;
pub const A_SETCLASS: i32 = 23;
pub const A_GETPINFO: i32 = 24;
pub const A_SETPMASK: i32 = 25;
pub const A_SETFSIZE: i32 = 26;
pub const A_GETFSIZE: i32 = 27;
pub const A_GETPINFO_ADDR: i32 = 28;
pub const A_GETKAUDIT: i32 = 29;
pub const A_SETKAUDIT: i32 = 30;
pub const A_SENDTRIGGER: i32 = 31;
pub const A_GETSINFO_ADDR: i32 = 32;
pub const A_GETPOLICY: i32 = 33;
pub const A_SETPOLICY: i32 = 34;
pub const A_GETQCTRL: i32 = 35;
pub const A_SETQCTRL: i32 = 36;
pub const A_GETCOND: i32 = 37;
pub const A_SETCOND: i32 = 38;
pub const A_GETEVENT: i32 = 39;
pub const A_SETEVENT: i32 = 40;
pub const AUDIT_CNT: i32 = 1;
pub const AUDIT_AHLT: i32 = 2;
pub const AUDIT_ARGV: i32 = 4;
pub const AUDIT_ARGE: i32 = 8;
pub const AUDIT_SEQ: i32 = 16;
pub const AUDIT_WINDATA: i32 = 32;
pub const AUDIT_USER: i32 = 64;
pub const AUDIT_GROUP: i32 = 128;
pub const AUDIT_TRAIL: i32 = 256;
pub const AUDIT_PATH: i32 = 512;
pub const AUDIT_SCNT: i32 = 1024;
pub const AUDIT_PUBLIC: i32 = 2048;
pub const AUDIT_ZONENAME: i32 = 4096;
pub const AUDIT_PERZONE: i32 = 8192;
pub const AQ_HIWATER: i32 = 100;
pub const AQ_MAXHIGH: i32 = 10000;
pub const AQ_LOWATER: i32 = 10;
pub const AQ_BUFSZ: i32 = 32767;
pub const AQ_MAXBUFSZ: i32 = 1048576;
pub const AU_FS_MINFREE: i32 = 20;
pub const AU_IPv4: i32 = 4;
pub const AU_IPv6: i32 = 16;
pub const EVNAMEMAP_NAME_SIZE: i32 = 64;
pub const CRED_FLAG_CAPMODE: i32 = 1;
pub const CRED_FLAG_GROUPSET: i32 = 2;
pub const CRED_SMALLGROUPS_NB: i32 = 16;
pub const XU_NGROUPS: i32 = 16;
pub const XUCRED_VERSION: i32 = 0;
pub const SETCREDF_UID: i32 = 1;
pub const SETCREDF_RUID: i32 = 2;
pub const SETCREDF_SVUID: i32 = 4;
pub const SETCREDF_GID: i32 = 8;
pub const SETCREDF_RGID: i32 = 16;
pub const SETCREDF_SVGID: i32 = 32;
pub const SETCREDF_SUPP_GROUPS: i32 = 64;
pub const SETCREDF_MAC_LABEL: i32 = 128;
pub const SETCREDF_MASK: i32 = 255;
pub const DOMAINSET_SETSIZE: i32 = 8;
pub const DOMAINSET_MAXSIZE: i32 = 256;
pub const KINFO_PROC_SIZE: i32 = 1088;
pub const KINFO_PROC32_SIZE: i32 = 816;
pub const PGRP_ORPHANED: i32 = 1;
pub const TDF_BORROWING: i32 = 1;
pub const TDF_INPANIC: i32 = 2;
pub const TDF_INMEM: i32 = 4;
pub const TDF_SINTR: i32 = 8;
pub const TDF_TIMEOUT: i32 = 16;
pub const TDF_IDLETD: i32 = 32;
pub const TDF_UNUSED11: i32 = 64;
pub const TDF_SIGWAIT: i32 = 128;
pub const TDF_KTH_SUSP: i32 = 256;
pub const TDF_ALLPROCSUSP: i32 = 512;
pub const TDF_BOUNDARY: i32 = 1024;
pub const TDF_UNUSED1: i32 = 2048;
pub const TDF_UNUSED2: i32 = 4096;
pub const TDF_SBDRY: i32 = 8192;
pub const TDF_UPIBLOCKED: i32 = 16384;
pub const TDF_UNUSED3: i32 = 32768;
pub const TDF_UNUSED4: i32 = 65536;
pub const TDF_UNUSED5: i32 = 131072;
pub const TDF_NOLOAD: i32 = 262144;
pub const TDF_SERESTART: i32 = 524288;
pub const TDF_THRWAKEUP: i32 = 1048576;
pub const TDF_SEINTR: i32 = 2097152;
pub const TDF_UNUSED12: i32 = 4194304;
pub const TDF_UNUSED6: i32 = 8388608;
pub const TDF_SCHED0: i32 = 16777216;
pub const TDF_SCHED1: i32 = 33554432;
pub const TDF_SCHED2: i32 = 67108864;
pub const TDF_SCHED3: i32 = 134217728;
pub const TDF_UNUSED7: i32 = 268435456;
pub const TDF_UNUSED8: i32 = 536870912;
pub const TDF_UNUSED9: i32 = 1073741824;
pub const TDF_UNUSED10: i64 = 2147483648;
pub const TDB_SUSPEND: i32 = 1;
pub const TDB_XSIG: i32 = 2;
pub const TDB_USERWR: i32 = 4;
pub const TDB_SCE: i32 = 8;
pub const TDB_SCX: i32 = 16;
pub const TDB_EXEC: i32 = 32;
pub const TDB_FORK: i32 = 64;
pub const TDB_STOPATFORK: i32 = 128;
pub const TDB_CHILD: i32 = 256;
pub const TDB_BORN: i32 = 512;
pub const TDB_EXIT: i32 = 1024;
pub const TDB_VFORK: i32 = 2048;
pub const TDB_FSTP: i32 = 4096;
pub const TDB_STEP: i32 = 8192;
pub const TDB_SSWITCH: i32 = 16384;
pub const TDB_BOUNDARY: i32 = 32768;
pub const TDB_COREDUMPREQ: i32 = 65536;
pub const TDB_SCREMOTEREQ: i32 = 131072;
pub const TDP_OLDMASK: i32 = 1;
pub const TDP_INKTR: i32 = 2;
pub const TDP_INKTRACE: i32 = 4;
pub const TDP_BUFNEED: i32 = 8;
pub const TDP_COWINPROGRESS: i32 = 16;
pub const TDP_ALTSTACK: i32 = 32;
pub const TDP_DEADLKTREAT: i32 = 64;
pub const TDP_NOFAULTING: i32 = 128;
pub const TDP_SIGFASTBLOCK: i32 = 256;
pub const TDP_OWEUPC: i32 = 512;
pub const TDP_ITHREAD: i32 = 1024;
pub const TDP_SYNCIO: i32 = 2048;
pub const TDP_SCHED1: i32 = 4096;
pub const TDP_SCHED2: i32 = 8192;
pub const TDP_SCHED3: i32 = 16384;
pub const TDP_SCHED4: i32 = 32768;
pub const TDP_GEOM: i32 = 65536;
pub const TDP_SOFTDEP: i32 = 131072;
pub const TDP_NORUNNINGBUF: i32 = 262144;
pub const TDP_WAKEUP: i32 = 524288;
pub const TDP_INBDFLUSH: i32 = 1048576;
pub const TDP_KTHREAD: i32 = 2097152;
pub const TDP_CALLCHAIN: i32 = 4194304;
pub const TDP_IGNSUSP: i32 = 8388608;
pub const TDP_AUDITREC: i32 = 16777216;
pub const TDP_RFPPWAIT: i32 = 33554432;
pub const TDP_RESETSPUR: i32 = 67108864;
pub const TDP_NERRNO: i32 = 134217728;
pub const TDP_UIOHELD: i32 = 268435456;
pub const TDP_EFIRT: i32 = 536870912;
pub const TDP_EXECVMSPC: i32 = 1073741824;
pub const TDP_SIGFASTPENDING: i64 = 2147483648;
pub const TDP2_SBPAGES: i32 = 1;
pub const TDP2_COMPAT32RB: i32 = 2;
pub const TDP2_ACCT: i32 = 4;
pub const TDP2_SAN_QUIET: i32 = 8;
pub const TDP2_EXTERR: i32 = 16;
pub const TDP2_UEXTERR: i32 = 32;
pub const TDI_SUSPENDED: i32 = 1;
pub const TDI_SLEEPING: i32 = 2;
pub const TDI_LOCK: i32 = 8;
pub const TDI_IWAIT: i32 = 16;
pub const NOCPU: i32 = -1;
pub const NOCPU_OLD: i32 = 255;
pub const MAXCPU_OLD: i32 = 254;
pub const P_ADVLOCK: i32 = 1;
pub const P_CONTROLT: i32 = 2;
pub const P_KPROC: i32 = 4;
pub const P_IDLEPROC: i32 = 8;
pub const P_PPWAIT: i32 = 16;
pub const P_PROFIL: i32 = 32;
pub const P_STOPPROF: i32 = 64;
pub const P_HADTHREADS: i32 = 128;
pub const P_SUGID: i32 = 256;
pub const P_SYSTEM: i32 = 512;
pub const P_SINGLE_EXIT: i32 = 1024;
pub const P_TRACED: i32 = 2048;
pub const P_WAITED: i32 = 4096;
pub const P_WEXIT: i32 = 8192;
pub const P_EXEC: i32 = 16384;
pub const P_WKILLED: i32 = 32768;
pub const P_CONTINUED: i32 = 65536;
pub const P_STOPPED_SIG: i32 = 131072;
pub const P_STOPPED_TRACE: i32 = 262144;
pub const P_STOPPED_SINGLE: i32 = 524288;
pub const P_PROTECTED: i32 = 1048576;
pub const P_SIGEVENT: i32 = 2097152;
pub const P_SINGLE_BOUNDARY: i32 = 4194304;
pub const P_HWPMC: i32 = 8388608;
pub const P_JAILED: i32 = 16777216;
pub const P_TOTAL_STOP: i32 = 33554432;
pub const P_INEXEC: i32 = 67108864;
pub const P_STATCHILD: i32 = 134217728;
pub const P_INMEM: i32 = 268435456;
pub const P_UNUSED1: i32 = 536870912;
pub const P_UNUSED2: i32 = 1073741824;
pub const P_PPTRACE: i64 = 2147483648;
pub const P_STOPPED: i32 = 917504;
pub const P2_INHERIT_PROTECTED: i32 = 1;
pub const P2_NOTRACE: i32 = 2;
pub const P2_NOTRACE_EXEC: i32 = 4;
pub const P2_AST_SU: i32 = 8;
pub const P2_PTRACE_FSTP: i32 = 16;
pub const P2_TRAPCAP: i32 = 32;
pub const P2_ASLR_ENABLE: i32 = 64;
pub const P2_ASLR_DISABLE: i32 = 128;
pub const P2_ASLR_IGNSTART: i32 = 256;
pub const P2_PROTMAX_ENABLE: i32 = 512;
pub const P2_PROTMAX_DISABLE: i32 = 1024;
pub const P2_STKGAP_DISABLE: i32 = 2048;
pub const P2_STKGAP_DISABLE_EXEC: i32 = 4096;
pub const P2_ITSTOPPED: i32 = 8192;
pub const P2_PTRACEREQ: i32 = 16384;
pub const P2_NO_NEW_PRIVS: i32 = 32768;
pub const P2_WXORX_DISABLE: i32 = 65536;
pub const P2_WXORX_ENABLE_EXEC: i32 = 131072;
pub const P2_WEXIT: i32 = 262144;
pub const P2_REAPKILLED: i32 = 524288;
pub const P2_MEMBAR_PRIVE: i32 = 1048576;
pub const P2_MEMBAR_PRIVE_SYNCORE: i32 = 2097152;
pub const P2_MEMBAR_GLOBE: i32 = 4194304;
pub const P2_LOGSIGEXIT_ENABLE: i32 = 8388608;
pub const P2_LOGSIGEXIT_CTL: i32 = 16777216;
pub const P2_HWT: i32 = 33554432;
pub const P_TREE_ORPHANED: i32 = 1;
pub const P_TREE_FIRST_ORPHAN: i32 = 2;
pub const P_TREE_REAPER: i32 = 4;
pub const P_TREE_GRPEXITED: i32 = 8;
pub const SIDL: i32 = 1;
pub const SRUN: i32 = 2;
pub const SSLEEP: i32 = 3;
pub const SSTOP: i32 = 4;
pub const SZOMB: i32 = 5;
pub const SWAIT: i32 = 6;
pub const SLOCK: i32 = 7;
pub const P_MAGIC: i64 = 3203398350;
pub const SW_TYPE_MASK: i32 = 255;
pub const SWT_OWEPREEMPT: i32 = 1;
pub const SWT_TURNSTILE: i32 = 2;
pub const SWT_SLEEPQ: i32 = 3;
pub const SWT_RELINQUISH: i32 = 4;
pub const SWT_NEEDRESCHED: i32 = 5;
pub const SWT_IDLE: i32 = 6;
pub const SWT_IWAIT: i32 = 7;
pub const SWT_SUSPEND: i32 = 8;
pub const SWT_REMOTEPREEMPT: i32 = 9;
pub const SWT_REMOTEWAKEIDLE: i32 = 10;
pub const SWT_BIND: i32 = 11;
pub const SWT_COUNT: i32 = 12;
pub const SW_VOL: i32 = 256;
pub const SW_INVOL: i32 = 512;
pub const SW_PREEMPT: i32 = 1024;
pub const SINGLE_NO_EXIT: i32 = 0;
pub const SINGLE_EXIT: i32 = 1;
pub const SINGLE_BOUNDARY: i32 = 2;
pub const SINGLE_ALLPROC: i32 = 3;
pub const PID_MAX: i32 = 99999;
pub const NO_PID: i32 = 100000;
pub const THREAD0_TID: i32 = 100000;
pub const FR2_DROPSIG_CAUGHT: i32 = 1;
pub const FR2_SHARE_PATHS: i32 = 2;
pub const FR2_KPROC: i32 = 4;
pub const PGET_HOLD: i32 = 1;
pub const PGET_CANSEE: i32 = 2;
pub const PGET_CANDEBUG: i32 = 4;
pub const PGET_ISCURRENT: i32 = 8;
pub const PGET_NOTWEXIT: i32 = 16;
pub const PGET_NOTINEXEC: i32 = 32;
pub const PGET_NOTID: i32 = 64;
pub const PGET_WANTREAD: i32 = 21;
pub const ASTR_ASTF_REQUIRED: i32 = 1;
pub const ASTR_TDP: i32 = 2;
pub const ASTR_KCLEAR: i32 = 4;
pub const ASTR_UNCOND: i32 = 8;
pub const PROC_ID_PID: i32 = 0;
pub const PROC_ID_GROUP: i32 = 1;
pub const PROC_ID_SESSION: i32 = 2;
pub const PROC_ID_REAP: i32 = 3;
pub const REFCOUNT_SATURATION_VALUE: i64 = 3221225472;
pub const _SYS_RMAN_H_: i32 = 1;
pub const _MACHINE_RESOURCE_H_: i32 = 1;
pub const SYS_RES_IRQ: i32 = 1;
pub const SYS_RES_DRQ: i32 = 2;
pub const SYS_RES_MEMORY: i32 = 3;
pub const SYS_RES_IOPORT: i32 = 4;
pub const SYS_RES_GPIO: i32 = 5;
pub const PCI_RES_BUS: i32 = 6;
pub const RF_ALLOCATED: i32 = 1;
pub const RF_ACTIVE: i32 = 2;
pub const RF_SHAREABLE: i32 = 4;
pub const RF_SPARE1: i32 = 8;
pub const RF_SPARE2: i32 = 16;
pub const RF_FIRSTSHARE: i32 = 32;
pub const RF_PREFETCHABLE: i32 = 64;
pub const RF_OPTIONAL: i32 = 128;
pub const RF_UNMAPPED: i32 = 256;
pub const RF_ALIGNMENT_SHIFT: i32 = 10;
pub const RF_ALIGNMENT_MASK: i32 = 64512;
pub const RM_TEXTLEN: i32 = 32;
pub const CG_SHARE_NONE: i32 = 0;
pub const CG_SHARE_L1: i32 = 1;
pub const CG_SHARE_L2: i32 = 2;
pub const CG_SHARE_L3: i32 = 3;
pub const MAX_CACHE_LEVELS: i32 = 3;
pub const CG_FLAG_HTT: i32 = 1;
pub const CG_FLAG_SMT: i32 = 2;
pub const CG_FLAG_THREAD: i32 = 3;
pub const CG_FLAG_NODE: i32 = 4;
pub const TASK_ENQUEUED: i32 = 1;
pub const TASK_NOENQUEUE: i32 = 2;
pub const TASK_NETWORK: i32 = 4;
pub const TASKQUEUE_NAMELEN: i32 = 32;
pub const TASKQUEUE_FAIL_IF_PENDING: i32 = 1;
pub const TASKQUEUE_FAIL_IF_CANCELING: i32 = 2;
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 2] = b"d\0";
pub const PRIdFAST32: &[u8; 2] = b"d\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIdMAX: &[u8; 3] = b"jd\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 2] = b"i\0";
pub const PRIiFAST32: &[u8; 2] = b"i\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIiMAX: &[u8; 3] = b"ji\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 2] = b"o\0";
pub const PRIoFAST32: &[u8; 2] = b"o\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIoMAX: &[u8; 3] = b"jo\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 2] = b"u\0";
pub const PRIuFAST32: &[u8; 2] = b"u\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIuMAX: &[u8; 3] = b"ju\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 2] = b"x\0";
pub const PRIxFAST32: &[u8; 2] = b"x\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIxMAX: &[u8; 3] = b"jx\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 2] = b"X\0";
pub const PRIXFAST32: &[u8; 2] = b"X\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIXMAX: &[u8; 3] = b"jX\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 2] = b"d\0";
pub const SCNdFAST16: &[u8; 2] = b"d\0";
pub const SCNdFAST32: &[u8; 2] = b"d\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNdMAX: &[u8; 3] = b"jd\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 2] = b"i\0";
pub const SCNiFAST16: &[u8; 2] = b"i\0";
pub const SCNiFAST32: &[u8; 2] = b"i\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNiMAX: &[u8; 3] = b"ji\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 2] = b"o\0";
pub const SCNoFAST16: &[u8; 2] = b"o\0";
pub const SCNoFAST32: &[u8; 2] = b"o\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNoMAX: &[u8; 3] = b"jo\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 2] = b"u\0";
pub const SCNuFAST16: &[u8; 2] = b"u\0";
pub const SCNuFAST32: &[u8; 2] = b"u\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNuMAX: &[u8; 3] = b"ju\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 2] = b"x\0";
pub const SCNxFAST16: &[u8; 2] = b"x\0";
pub const SCNxFAST32: &[u8; 2] = b"x\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNxMAX: &[u8; 3] = b"jx\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const BUS_SPACE_MAXADDR_24BIT: i32 = 16777215;
pub const BUS_SPACE_MAXADDR_32BIT: i64 = 4294967295;
pub const BUS_SPACE_MAXADDR_36BIT: i64 = 68719476735;
pub const BUS_SPACE_MAXADDR_40BIT: i64 = 1099511627775;
pub const BUS_SPACE_MAXSIZE_24BIT: i32 = 16777215;
pub const BUS_SPACE_MAXSIZE_32BIT: i64 = 4294967295;
pub const BUS_SPACE_MAXSIZE_40BIT: i64 = 1099511627775;
pub const BUS_SPACE_MAXADDR: i32 = -1;
pub const BUS_SPACE_MAXSIZE: i32 = -1;
pub const BUS_SPACE_MAP_CACHEABLE: i32 = 1;
pub const BUS_SPACE_MAP_LINEAR: i32 = 2;
pub const BUS_SPACE_MAP_PREFETCHABLE: i32 = 4;
pub const BUS_SPACE_MAP_NONPOSTED: i32 = 8;
pub const BUS_SPACE_UNRESTRICTED: i32 = -1;
pub const BUS_SPACE_BARRIER_READ: i32 = 1;
pub const BUS_SPACE_BARRIER_WRITE: i32 = 2;
pub const BUS_DMA_WAITOK: i32 = 0;
pub const BUS_DMA_NOWAIT: i32 = 1;
pub const BUS_DMA_ALLOCNOW: i32 = 2;
pub const BUS_DMA_COHERENT: i32 = 4;
pub const BUS_DMA_ZERO: i32 = 8;
pub const BUS_DMA_BUS1: i32 = 16;
pub const BUS_DMA_BUS2: i32 = 32;
pub const BUS_DMA_BUS3: i32 = 64;
pub const BUS_DMA_BUS4: i32 = 128;
pub const BUS_DMA_NOWRITE: i32 = 256;
pub const BUS_DMA_NOCACHE: i32 = 512;
pub const BUS_DMA_KEEP_PG_OFFSET: i32 = 1024;
pub const BUS_DMA_LOAD_MBUF: i32 = 2048;
pub const BUS_DMASYNC_PREREAD: i32 = 1;
pub const BUS_DMASYNC_POSTREAD: i32 = 2;
pub const BUS_DMASYNC_PREWRITE: i32 = 4;
pub const BUS_DMASYNC_POSTWRITE: i32 = 8;
pub const DBG_BRP_MAX: i32 = 16;
pub const DBG_WRP_MAX: i32 = 16;
pub const DBGMON_ENABLED: i32 = 1;
pub const DBGMON_KERNEL: i32 = 2;
pub const VFPCR_AHP: i32 = 67108864;
pub const VFPCR_DN: i32 = 33554432;
pub const VFPCR_FZ: i32 = 16777216;
pub const VFPCR_INIT: i32 = 0;
pub const VFPCR_RMODE_OFF: i32 = 22;
pub const VFPCR_RMODE_MASK: i32 = 12582912;
pub const VFPCR_RMODE_RN: i32 = 0;
pub const VFPCR_RMODE_RPI: i32 = 4194304;
pub const VFPCR_RMODE_RNI: i32 = 8388608;
pub const VFPCR_RMODE_RM: i32 = 12582912;
pub const VFPCR_STRIDE_OFF: i32 = 20;
pub const VFPCR_STRIDE_MASK: i32 = 3145728;
pub const VFPCR_LEN_OFF: i32 = 16;
pub const VFPCR_LEN_MASK: i32 = 458752;
pub const VFPCR_IDE: i32 = 32768;
pub const VFPCR_IXE: i32 = 4096;
pub const VFPCR_UFE: i32 = 2048;
pub const VFPCR_OFE: i32 = 1024;
pub const VFPCR_DZE: i32 = 512;
pub const VFPCR_IOE: i32 = 256;
pub const FPU_KERN_NORMAL: i32 = 0;
pub const FPU_KERN_NOWAIT: i32 = 1;
pub const FPU_KERN_KTHR: i32 = 2;
pub const FPU_KERN_NOCTX: i32 = 4;
pub const PCB_X_START: i32 = 19;
pub const PCB_X19: i32 = 0;
pub const PCB_X20: i32 = 1;
pub const PCB_FP: i32 = 10;
pub const PCB_LR: i32 = 11;
pub const PCB_SINGLE_STEP_SHIFT: i32 = 0;
pub const PCB_SINGLE_STEP: i32 = 1;
pub const PCB_FP_STARTED: i32 = 1;
pub const PCB_FP_SVEVALID: i32 = 2;
pub const PCB_FP_KERN: i32 = 1073741824;
pub const PCB_FP_NOSAVE: i64 = 2147483648;
pub const PCB_FP_USERMASK: i32 = 3;
pub const FDT_INTR_EDGE_RISING: i32 = 1;
pub const FDT_INTR_EDGE_FALLING: i32 = 2;
pub const FDT_INTR_LEVEL_HIGH: i32 = 4;
pub const FDT_INTR_LEVEL_LOW: i32 = 8;
pub const FDT_INTR_LOW_MASK: i32 = 10;
pub const FDT_INTR_EDGE_MASK: i32 = 3;
pub const FDT_INTR_MASK: i32 = 15;
pub const SB_FLAG_NO_RANGES: i32 = 1;
pub const ORIP_NOINT: i32 = -1;
pub const ORIR_NOTFOUND: i64 = 4294967295;
pub const FDTCOMPAT_PNP_DESCR: &[u8; 14] = b"Z:compat;P:#;\0";
pub const GPIOBUS_WAIT: i32 = 1;
pub const GPIOBUS_DONTWAIT: i32 = 2;
pub const DISK_ZONE_MODE_NONE: i32 = 0;
pub const DISK_ZONE_MODE_HOST_AWARE: i32 = 1;
pub const DISK_ZONE_MODE_DRIVE_MANAGED: i32 = 2;
pub const DISK_ZONE_MODE_HOST_MANAGED: i32 = 4;
pub const DISK_ZONE_DISK_URSWRZ: i32 = 1;
pub const DISK_ZONE_OPT_SEQ_SET: i32 = 2;
pub const DISK_ZONE_OPT_NONSEQ_SET: i32 = 4;
pub const DISK_ZONE_MAX_SEQ_SET: i32 = 8;
pub const DISK_ZONE_RZ_SUP: i32 = 16;
pub const DISK_ZONE_OPEN_SUP: i32 = 32;
pub const DISK_ZONE_CLOSE_SUP: i32 = 64;
pub const DISK_ZONE_FINISH_SUP: i32 = 128;
pub const DISK_ZONE_RWP_SUP: i32 = 256;
pub const DISK_ZONE_CMD_SUP_MASK: i32 = 496;
pub const DISK_ZONE_RWP_FLAG_NONE: i32 = 0;
pub const DISK_ZONE_RWP_FLAG_ALL: i32 = 1;
pub const DISK_ZONE_SAME_ALL_DIFFERENT: i32 = 0;
pub const DISK_ZONE_SAME_ALL_SAME: i32 = 1;
pub const DISK_ZONE_SAME_LAST_DIFFERENT: i32 = 2;
pub const DISK_ZONE_SAME_TYPES_DIFFERENT: i32 = 3;
pub const DISK_ZONE_TYPE_CONVENTIONAL: i32 = 1;
pub const DISK_ZONE_TYPE_SEQ_REQUIRED: i32 = 2;
pub const DISK_ZONE_TYPE_SEQ_PREFERRED: i32 = 3;
pub const DISK_ZONE_COND_NOT_WP: i32 = 0;
pub const DISK_ZONE_COND_EMPTY: i32 = 1;
pub const DISK_ZONE_COND_IMPLICIT_OPEN: i32 = 2;
pub const DISK_ZONE_COND_EXPLICIT_OPEN: i32 = 3;
pub const DISK_ZONE_COND_CLOSED: i32 = 4;
pub const DISK_ZONE_COND_READONLY: i32 = 13;
pub const DISK_ZONE_COND_FULL: i32 = 14;
pub const DISK_ZONE_COND_OFFLINE: i32 = 15;
pub const DISK_ZONE_FLAG_RESET: i32 = 1;
pub const DISK_ZONE_FLAG_NON_SEQ: i32 = 2;
pub const DISK_ZONE_REP_ALL: i32 = 0;
pub const DISK_ZONE_REP_EMPTY: i32 = 1;
pub const DISK_ZONE_REP_IMP_OPEN: i32 = 2;
pub const DISK_ZONE_REP_EXP_OPEN: i32 = 3;
pub const DISK_ZONE_REP_CLOSED: i32 = 4;
pub const DISK_ZONE_REP_FULL: i32 = 5;
pub const DISK_ZONE_REP_READONLY: i32 = 6;
pub const DISK_ZONE_REP_OFFLINE: i32 = 7;
pub const DISK_ZONE_REP_RWP: i32 = 16;
pub const DISK_ZONE_REP_NON_SEQ: i32 = 17;
pub const DISK_ZONE_REP_NON_WP: i32 = 63;
pub const DISK_ZONE_OPEN: i32 = 0;
pub const DISK_ZONE_CLOSE: i32 = 1;
pub const DISK_ZONE_FINISH: i32 = 2;
pub const DISK_ZONE_REPORT_ZONES: i32 = 3;
pub const DISK_ZONE_RWP: i32 = 4;
pub const DISK_ZONE_GET_PARAMS: i32 = 5;
pub const BIO_READ: i32 = 1;
pub const BIO_WRITE: i32 = 2;
pub const BIO_DELETE: i32 = 3;
pub const BIO_GETATTR: i32 = 4;
pub const BIO_FLUSH: i32 = 5;
pub const BIO_CMD0: i32 = 6;
pub const BIO_CMD1: i32 = 7;
pub const BIO_CMD2: i32 = 8;
pub const BIO_ZONE: i32 = 9;
pub const BIO_SPEEDUP: i32 = 10;
pub const BIO_ERROR: i32 = 1;
pub const BIO_DONE: i32 = 2;
pub const BIO_ONQUEUE: i32 = 4;
pub const BIO_ORDERED: i32 = 8;
pub const BIO_UNMAPPED: i32 = 16;
pub const BIO_TRANSIENT_MAPPING: i32 = 32;
pub const BIO_VLIST: i32 = 64;
pub const BIO_SWAP: i32 = 512;
pub const BIO_SPEEDUP_WRITE: i32 = 16384;
pub const BIO_SPEEDUP_TRIM: i32 = 32768;
pub const PRINT_BIO_FLAGS : & [u8 ; 94] = b"\x10\x10speedup_trim\x0Fspeedup_write\nswap\x07vlist\x06transient_mapping\x05unmapped\x04ordered\x03onqueue\x02done\x01error\0" ;
pub const MEMDESC_VADDR: i32 = 1;
pub const MEMDESC_PADDR: i32 = 2;
pub const MEMDESC_VLIST: i32 = 3;
pub const MEMDESC_PLIST: i32 = 4;
pub const MEMDESC_UIO: i32 = 6;
pub const MEMDESC_MBUF: i32 = 7;
pub const MEMDESC_VMPAGES: i32 = 8;
pub const UMA_SMALLEST_UNIT: i32 = 8;
pub const UMA_ZONE_UNMANAGED: i32 = 1;
pub const UMA_ZONE_ZINIT: i32 = 2;
pub const UMA_ZONE_CONTIG: i32 = 4;
pub const UMA_ZONE_NOTOUCH: i32 = 8;
pub const UMA_ZONE_MALLOC: i32 = 16;
pub const UMA_ZONE_NOFREE: i32 = 32;
pub const UMA_ZONE_MTXCLASS: i32 = 64;
pub const UMA_ZONE_VM: i32 = 128;
pub const UMA_ZONE_NOTPAGE: i32 = 256;
pub const UMA_ZONE_SECONDARY: i32 = 512;
pub const UMA_ZONE_NOBUCKET: i32 = 1024;
pub const UMA_ZONE_MAXBUCKET: i32 = 2048;
pub const UMA_ZONE_NOTRIM: i32 = 4096;
pub const UMA_ZONE_CACHESPREAD: i32 = 8192;
pub const UMA_ZONE_NODUMP: i32 = 16384;
pub const UMA_ZONE_PCPU: i32 = 32768;
pub const UMA_ZONE_FIRSTTOUCH: i32 = 65536;
pub const UMA_ZONE_ROUNDROBIN: i32 = 131072;
pub const UMA_ZONE_SMR: i32 = 262144;
pub const UMA_ZONE_NOKASAN: i32 = 524288;
pub const UMA_ZONE_INHERIT: i32 = 754104;
pub const UMA_ANYDOMAIN: i32 = -1;
pub const UMA_RECLAIM_DRAIN: i32 = 1;
pub const UMA_RECLAIM_DRAIN_CPU: i32 = 2;
pub const UMA_RECLAIM_TRIM: i32 = 3;
pub const UMA_SLAB_BOOT: i32 = 1;
pub const UMA_SLAB_KERNEL: i32 = 4;
pub const UMA_SLAB_PRIV: i32 = 8;
pub const UMA_STREAM_VERSION: i32 = 1;
pub const UTH_MAX_NAME: i32 = 32;
pub const UTH_ZONE_SECONDARY: i32 = 1;
pub const NVME_HMB_UNITS: i32 = 4096;
pub const NVME_MPS_SHIFT: i32 = 12;
pub const NVME_MIN_ADMIN_ENTRIES: i32 = 2;
pub const NVME_MAX_ADMIN_ENTRIES: i32 = 4096;
pub const NVME_MIN_IO_ENTRIES: i32 = 2;
pub const NVME_MAX_IO_ENTRIES: i32 = 65536;
pub const NVME_CAP_LO_REG_MQES_SHIFT: i32 = 0;
pub const NVME_CAP_LO_REG_MQES_MASK: i32 = 65535;
pub const NVME_CAP_LO_REG_CQR_SHIFT: i32 = 16;
pub const NVME_CAP_LO_REG_CQR_MASK: i32 = 1;
pub const NVME_CAP_LO_REG_AMS_SHIFT: i32 = 17;
pub const NVME_CAP_LO_REG_AMS_MASK: i32 = 3;
pub const NVME_CAP_LO_REG_TO_SHIFT: i32 = 24;
pub const NVME_CAP_LO_REG_TO_MASK: i32 = 255;
pub const NVME_CAP_HI_REG_DSTRD_SHIFT: i32 = 0;
pub const NVME_CAP_HI_REG_DSTRD_MASK: i32 = 15;
pub const NVME_CAP_HI_REG_NSSRS_SHIFT: i32 = 4;
pub const NVME_CAP_HI_REG_NSSRS_MASK: i32 = 1;
pub const NVME_CAP_HI_REG_CSS_SHIFT: i32 = 5;
pub const NVME_CAP_HI_REG_CSS_MASK: i32 = 255;
pub const NVME_CAP_HI_REG_CSS_NVM_SHIFT: i32 = 5;
pub const NVME_CAP_HI_REG_CSS_NVM_MASK: i32 = 1;
pub const NVME_CAP_HI_REG_BPS_SHIFT: i32 = 13;
pub const NVME_CAP_HI_REG_BPS_MASK: i32 = 1;
pub const NVME_CAP_HI_REG_CPS_SHIFT: i32 = 14;
pub const NVME_CAP_HI_REG_CPS_MASK: i32 = 3;
pub const NVME_CAP_HI_REG_MPSMIN_SHIFT: i32 = 16;
pub const NVME_CAP_HI_REG_MPSMIN_MASK: i32 = 15;
pub const NVME_CAP_HI_REG_MPSMAX_SHIFT: i32 = 20;
pub const NVME_CAP_HI_REG_MPSMAX_MASK: i32 = 15;
pub const NVME_CAP_HI_REG_PMRS_SHIFT: i32 = 24;
pub const NVME_CAP_HI_REG_PMRS_MASK: i32 = 1;
pub const NVME_CAP_HI_REG_CMBS_SHIFT: i32 = 25;
pub const NVME_CAP_HI_REG_CMBS_MASK: i32 = 1;
pub const NVME_CAP_HI_REG_NSSS_SHIFT: i32 = 26;
pub const NVME_CAP_HI_REG_NSSS_MASK: i32 = 1;
pub const NVME_CAP_HI_REG_CRWMS_SHIFT: i32 = 27;
pub const NVME_CAP_HI_REG_CRWMS_MASK: i32 = 1;
pub const NVME_CAP_HI_REG_CRIMS_SHIFT: i32 = 28;
pub const NVME_CAP_HI_REG_CRIMS_MASK: i32 = 1;
pub const NVME_CC_REG_EN_SHIFT: i32 = 0;
pub const NVME_CC_REG_EN_MASK: i32 = 1;
pub const NVME_CC_REG_CSS_SHIFT: i32 = 4;
pub const NVME_CC_REG_CSS_MASK: i32 = 7;
pub const NVME_CC_REG_MPS_SHIFT: i32 = 7;
pub const NVME_CC_REG_MPS_MASK: i32 = 15;
pub const NVME_CC_REG_AMS_SHIFT: i32 = 11;
pub const NVME_CC_REG_AMS_MASK: i32 = 7;
pub const NVME_CC_REG_SHN_SHIFT: i32 = 14;
pub const NVME_CC_REG_SHN_MASK: i32 = 3;
pub const NVME_CC_REG_IOSQES_SHIFT: i32 = 16;
pub const NVME_CC_REG_IOSQES_MASK: i32 = 15;
pub const NVME_CC_REG_IOCQES_SHIFT: i32 = 20;
pub const NVME_CC_REG_IOCQES_MASK: i32 = 15;
pub const NVME_CC_REG_CRIME_SHIFT: i32 = 24;
pub const NVME_CC_REG_CRIME_MASK: i32 = 1;
pub const NVME_CSTS_REG_RDY_SHIFT: i32 = 0;
pub const NVME_CSTS_REG_RDY_MASK: i32 = 1;
pub const NVME_CSTS_REG_CFS_SHIFT: i32 = 1;
pub const NVME_CSTS_REG_CFS_MASK: i32 = 1;
pub const NVME_CSTS_REG_SHST_SHIFT: i32 = 2;
pub const NVME_CSTS_REG_SHST_MASK: i32 = 3;
pub const NVME_CSTS_REG_NVSRO_SHIFT: i32 = 4;
pub const NVME_CSTS_REG_NVSRO_MASK: i32 = 1;
pub const NVME_CSTS_REG_PP_SHIFT: i32 = 5;
pub const NVME_CSTS_REG_PP_MASK: i32 = 1;
pub const NVME_CSTS_REG_ST_SHIFT: i32 = 6;
pub const NVME_CSTS_REG_ST_MASK: i32 = 1;
pub const NVME_AQA_REG_ASQS_SHIFT: i32 = 0;
pub const NVME_AQA_REG_ASQS_MASK: i32 = 4095;
pub const NVME_AQA_REG_ACQS_SHIFT: i32 = 16;
pub const NVME_AQA_REG_ACQS_MASK: i32 = 4095;
pub const NVME_PMRCAP_REG_RDS_SHIFT: i32 = 3;
pub const NVME_PMRCAP_REG_RDS_MASK: i32 = 1;
pub const NVME_PMRCAP_REG_WDS_SHIFT: i32 = 4;
pub const NVME_PMRCAP_REG_WDS_MASK: i32 = 1;
pub const NVME_PMRCAP_REG_BIR_SHIFT: i32 = 5;
pub const NVME_PMRCAP_REG_BIR_MASK: i32 = 7;
pub const NVME_PMRCAP_REG_PMRTU_SHIFT: i32 = 8;
pub const NVME_PMRCAP_REG_PMRTU_MASK: i32 = 3;
pub const NVME_PMRCAP_REG_PMRWBM_SHIFT: i32 = 10;
pub const NVME_PMRCAP_REG_PMRWBM_MASK: i32 = 15;
pub const NVME_PMRCAP_REG_PMRTO_SHIFT: i32 = 16;
pub const NVME_PMRCAP_REG_PMRTO_MASK: i32 = 255;
pub const NVME_PMRCAP_REG_CMSS_SHIFT: i32 = 24;
pub const NVME_PMRCAP_REG_CMSS_MASK: i32 = 1;
pub const NVME_CMD_FUSE_SHIFT: i32 = 0;
pub const NVME_CMD_FUSE_MASK: i32 = 3;
pub const NVME_CMD_PSDT_SHIFT: i32 = 6;
pub const NVME_CMD_PSDT_MASK: i32 = 3;
pub const NVME_STATUS_P_SHIFT: i32 = 0;
pub const NVME_STATUS_P_MASK: i32 = 1;
pub const NVME_STATUS_SC_SHIFT: i32 = 1;
pub const NVME_STATUS_SC_MASK: i32 = 255;
pub const NVME_STATUS_SCT_SHIFT: i32 = 9;
pub const NVME_STATUS_SCT_MASK: i32 = 7;
pub const NVME_STATUS_CRD_SHIFT: i32 = 12;
pub const NVME_STATUS_CRD_MASK: i32 = 3;
pub const NVME_STATUS_M_SHIFT: i32 = 14;
pub const NVME_STATUS_M_MASK: i32 = 1;
pub const NVME_STATUS_DNR_SHIFT: i32 = 15;
pub const NVME_STATUS_DNR_MASK: i32 = 1;
pub const NVME_PWR_ST_MPS_SHIFT: i32 = 0;
pub const NVME_PWR_ST_MPS_MASK: i32 = 1;
pub const NVME_PWR_ST_NOPS_SHIFT: i32 = 1;
pub const NVME_PWR_ST_NOPS_MASK: i32 = 1;
pub const NVME_PWR_ST_RRT_SHIFT: i32 = 0;
pub const NVME_PWR_ST_RRT_MASK: i32 = 31;
pub const NVME_PWR_ST_RRL_SHIFT: i32 = 0;
pub const NVME_PWR_ST_RRL_MASK: i32 = 31;
pub const NVME_PWR_ST_RWT_SHIFT: i32 = 0;
pub const NVME_PWR_ST_RWT_MASK: i32 = 31;
pub const NVME_PWR_ST_RWL_SHIFT: i32 = 0;
pub const NVME_PWR_ST_RWL_MASK: i32 = 31;
pub const NVME_PWR_ST_IPS_SHIFT: i32 = 6;
pub const NVME_PWR_ST_IPS_MASK: i32 = 3;
pub const NVME_PWR_ST_APW_SHIFT: i32 = 0;
pub const NVME_PWR_ST_APW_MASK: i32 = 7;
pub const NVME_PWR_ST_APS_SHIFT: i32 = 6;
pub const NVME_PWR_ST_APS_MASK: i32 = 3;
pub const NVME_CTRLR_DATA_MIC_MPORTS_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_MIC_MPORTS_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_MIC_MCTRLRS_SHIFT: i32 = 1;
pub const NVME_CTRLR_DATA_MIC_MCTRLRS_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_MIC_SRIOVVF_SHIFT: i32 = 2;
pub const NVME_CTRLR_DATA_MIC_SRIOVVF_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_MIC_ANAR_SHIFT: i32 = 3;
pub const NVME_CTRLR_DATA_MIC_ANAR_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OAES_NS_ATTR_SHIFT: i32 = 8;
pub const NVME_CTRLR_DATA_OAES_NS_ATTR_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OAES_FW_ACTIVATE_SHIFT: i32 = 9;
pub const NVME_CTRLR_DATA_OAES_FW_ACTIVATE_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OAES_ASYM_NS_CHANGE_SHIFT: i32 = 11;
pub const NVME_CTRLR_DATA_OAES_ASYM_NS_CHANGE_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OAES_PREDICT_LATENCY_SHIFT: i32 = 12;
pub const NVME_CTRLR_DATA_OAES_PREDICT_LATENCY_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OAES_LBA_STATUS_SHIFT: i32 = 13;
pub const NVME_CTRLR_DATA_OAES_LBA_STATUS_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OAES_ENDURANCE_GROUP_SHIFT: i32 = 14;
pub const NVME_CTRLR_DATA_OAES_ENDURANCE_GROUP_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OAES_NORMAL_SHUTDOWN_SHIFT: i32 = 15;
pub const NVME_CTRLR_DATA_OAES_NORMAL_SHUTDOWN_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OAES_ZONE_DESC_CHANGE_SHIFT: i32 = 27;
pub const NVME_CTRLR_DATA_OAES_ZONE_DESC_CHANGE_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OAES_LOG_PAGE_CHANGE_SHIFT: i32 = 31;
pub const NVME_CTRLR_DATA_OAES_LOG_PAGE_CHANGE_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_CTRATT_128BIT_HOSTID_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_CTRATT_128BIT_HOSTID_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_CTRATT_NONOP_POWER_STATE_SHIFT: i32 = 1;
pub const NVME_CTRLR_DATA_CTRATT_NONOP_POWER_STATE_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_CTRATT_NVM_SETS_SHIFT: i32 = 2;
pub const NVME_CTRLR_DATA_CTRATT_NVM_SETS_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_CTRATT_READ_RECOVERY_LVLS_SHIFT: i32 = 3;
pub const NVME_CTRLR_DATA_CTRATT_READ_RECOVERY_LVLS_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_CTRATT_ENDURANCE_GROUPS_SHIFT: i32 = 4;
pub const NVME_CTRLR_DATA_CTRATT_ENDURANCE_GROUPS_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_CTRATT_PREDICTABLE_LATENCY_SHIFT: i32 = 5;
pub const NVME_CTRLR_DATA_CTRATT_PREDICTABLE_LATENCY_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_CTRATT_TBKAS_SHIFT: i32 = 6;
pub const NVME_CTRLR_DATA_CTRATT_TBKAS_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_CTRATT_NAMESPACE_GRANULARITY_SHIFT: i32 = 7;
pub const NVME_CTRLR_DATA_CTRATT_NAMESPACE_GRANULARITY_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_CTRATT_SQ_ASSOCIATIONS_SHIFT: i32 = 8;
pub const NVME_CTRLR_DATA_CTRATT_SQ_ASSOCIATIONS_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_CTRATT_UUID_LIST_SHIFT: i32 = 9;
pub const NVME_CTRLR_DATA_CTRATT_UUID_LIST_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OACS_SECURITY_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_OACS_SECURITY_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OACS_FORMAT_SHIFT: i32 = 1;
pub const NVME_CTRLR_DATA_OACS_FORMAT_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OACS_FIRMWARE_SHIFT: i32 = 2;
pub const NVME_CTRLR_DATA_OACS_FIRMWARE_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OACS_NSMGMT_SHIFT: i32 = 3;
pub const NVME_CTRLR_DATA_OACS_NSMGMT_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OACS_SELFTEST_SHIFT: i32 = 4;
pub const NVME_CTRLR_DATA_OACS_SELFTEST_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OACS_DIRECTIVES_SHIFT: i32 = 5;
pub const NVME_CTRLR_DATA_OACS_DIRECTIVES_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OACS_NVMEMI_SHIFT: i32 = 6;
pub const NVME_CTRLR_DATA_OACS_NVMEMI_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OACS_VM_SHIFT: i32 = 7;
pub const NVME_CTRLR_DATA_OACS_VM_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OACS_DBBUFFER_SHIFT: i32 = 8;
pub const NVME_CTRLR_DATA_OACS_DBBUFFER_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OACS_GETLBA_SHIFT: i32 = 9;
pub const NVME_CTRLR_DATA_OACS_GETLBA_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_FRMW_SLOT1_RO_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_FRMW_SLOT1_RO_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_FRMW_NUM_SLOTS_SHIFT: i32 = 1;
pub const NVME_CTRLR_DATA_FRMW_NUM_SLOTS_MASK: i32 = 7;
pub const NVME_CTRLR_DATA_FRMW_ACT_WO_RESET_SHIFT: i32 = 4;
pub const NVME_CTRLR_DATA_FRMW_ACT_WO_RESET_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_LPA_NS_SMART_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_LPA_NS_SMART_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_LPA_CMD_EFFECTS_SHIFT: i32 = 1;
pub const NVME_CTRLR_DATA_LPA_CMD_EFFECTS_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_LPA_EXT_DATA_SHIFT: i32 = 2;
pub const NVME_CTRLR_DATA_LPA_EXT_DATA_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_LPA_TELEMETRY_SHIFT: i32 = 3;
pub const NVME_CTRLR_DATA_LPA_TELEMETRY_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_LPA_PERSISTENT_EVENT_SHIFT: i32 = 4;
pub const NVME_CTRLR_DATA_LPA_PERSISTENT_EVENT_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_LPA_LOG_PAGES_PAGE_SHIFT: i32 = 5;
pub const NVME_CTRLR_DATA_LPA_LOG_PAGES_PAGE_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_LPA_DA4_TELEMETRY_SHIFT: i32 = 6;
pub const NVME_CTRLR_DATA_LPA_DA4_TELEMETRY_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_AVSCC_SPEC_FORMAT_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_AVSCC_SPEC_FORMAT_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_APSTA_APST_SUPP_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_APSTA_APST_SUPP_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_SANICAP_CES_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_SANICAP_CES_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_SANICAP_BES_SHIFT: i32 = 1;
pub const NVME_CTRLR_DATA_SANICAP_BES_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_SANICAP_OWS_SHIFT: i32 = 2;
pub const NVME_CTRLR_DATA_SANICAP_OWS_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_SANICAP_NDI_SHIFT: i32 = 29;
pub const NVME_CTRLR_DATA_SANICAP_NDI_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_SANICAP_NODMMAS_SHIFT: i32 = 30;
pub const NVME_CTRLR_DATA_SANICAP_NODMMAS_MASK: i32 = 3;
pub const NVME_CTRLR_DATA_SANICAP_NODMMAS_UNDEF: i32 = 0;
pub const NVME_CTRLR_DATA_SANICAP_NODMMAS_NO: i32 = 1;
pub const NVME_CTRLR_DATA_SANICAP_NODMMAS_YES: i32 = 2;
pub const NVME_CTRLR_DATA_SQES_MIN_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_SQES_MIN_MASK: i32 = 15;
pub const NVME_CTRLR_DATA_SQES_MAX_SHIFT: i32 = 4;
pub const NVME_CTRLR_DATA_SQES_MAX_MASK: i32 = 15;
pub const NVME_CTRLR_DATA_CQES_MIN_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_CQES_MIN_MASK: i32 = 15;
pub const NVME_CTRLR_DATA_CQES_MAX_SHIFT: i32 = 4;
pub const NVME_CTRLR_DATA_CQES_MAX_MASK: i32 = 15;
pub const NVME_CTRLR_DATA_ONCS_COMPARE_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_ONCS_COMPARE_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_ONCS_WRITE_UNC_SHIFT: i32 = 1;
pub const NVME_CTRLR_DATA_ONCS_WRITE_UNC_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_ONCS_DSM_SHIFT: i32 = 2;
pub const NVME_CTRLR_DATA_ONCS_DSM_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_ONCS_WRZERO_SHIFT: i32 = 3;
pub const NVME_CTRLR_DATA_ONCS_WRZERO_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_ONCS_SAVEFEAT_SHIFT: i32 = 4;
pub const NVME_CTRLR_DATA_ONCS_SAVEFEAT_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_ONCS_RESERV_SHIFT: i32 = 5;
pub const NVME_CTRLR_DATA_ONCS_RESERV_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_ONCS_TIMESTAMP_SHIFT: i32 = 6;
pub const NVME_CTRLR_DATA_ONCS_TIMESTAMP_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_ONCS_VERIFY_SHIFT: i32 = 7;
pub const NVME_CTRLR_DATA_ONCS_VERIFY_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_FUSES_CNW_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_FUSES_CNW_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_FNA_FORMAT_ALL_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_FNA_FORMAT_ALL_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_FNA_ERASE_ALL_SHIFT: i32 = 1;
pub const NVME_CTRLR_DATA_FNA_ERASE_ALL_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_FNA_CRYPTO_ERASE_SHIFT: i32 = 2;
pub const NVME_CTRLR_DATA_FNA_CRYPTO_ERASE_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_VWC_PRESENT_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_VWC_PRESENT_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_VWC_ALL_SHIFT: i32 = 1;
pub const NVME_CTRLR_DATA_VWC_ALL_MASK: i32 = 3;
pub const NVME_CTRLR_DATA_VWC_ALL_UNKNOWN: i32 = 0;
pub const NVME_CTRLR_DATA_VWC_ALL_NO: i32 = 2;
pub const NVME_CTRLR_DATA_VWC_ALL_YES: i32 = 3;
pub const NVME_CTRLR_DATA_SGLS_NVM_COMMAND_SET_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_SGLS_NVM_COMMAND_SET_MASK: i32 = 3;
pub const NVME_CTRLR_DATA_SGLS_KEYED_DATA_BLOCK_SHIFT: i32 = 2;
pub const NVME_CTRLR_DATA_SGLS_KEYED_DATA_BLOCK_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_SGLS_BIT_BUCKET_SHIFT: i32 = 16;
pub const NVME_CTRLR_DATA_SGLS_BIT_BUCKET_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_SGLS_CONTIG_MPTR_SHIFT: i32 = 17;
pub const NVME_CTRLR_DATA_SGLS_CONTIG_MPTR_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_SGLS_OVERSIZED_SHIFT: i32 = 18;
pub const NVME_CTRLR_DATA_SGLS_OVERSIZED_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_SGLS_MPTR_SGL_SHIFT: i32 = 19;
pub const NVME_CTRLR_DATA_SGLS_MPTR_SGL_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_SGLS_ADDRESS_AS_OFFSET_SHIFT: i32 = 20;
pub const NVME_CTRLR_DATA_SGLS_ADDRESS_AS_OFFSET_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_SGLS_TRANSPORT_DATA_BLOCK_SHIFT: i32 = 21;
pub const NVME_CTRLR_DATA_SGLS_TRANSPORT_DATA_BLOCK_MASK: i32 = 1;
pub const NVME_NS_DATA_NSFEAT_THIN_PROV_SHIFT: i32 = 0;
pub const NVME_NS_DATA_NSFEAT_THIN_PROV_MASK: i32 = 1;
pub const NVME_NS_DATA_NSFEAT_NA_FIELDS_SHIFT: i32 = 1;
pub const NVME_NS_DATA_NSFEAT_NA_FIELDS_MASK: i32 = 1;
pub const NVME_NS_DATA_NSFEAT_DEALLOC_SHIFT: i32 = 2;
pub const NVME_NS_DATA_NSFEAT_DEALLOC_MASK: i32 = 1;
pub const NVME_NS_DATA_NSFEAT_NO_ID_REUSE_SHIFT: i32 = 3;
pub const NVME_NS_DATA_NSFEAT_NO_ID_REUSE_MASK: i32 = 1;
pub const NVME_NS_DATA_NSFEAT_NPVALID_SHIFT: i32 = 4;
pub const NVME_NS_DATA_NSFEAT_NPVALID_MASK: i32 = 1;
pub const NVME_NS_DATA_FLBAS_FORMAT_SHIFT: i32 = 0;
pub const NVME_NS_DATA_FLBAS_FORMAT_MASK: i32 = 15;
pub const NVME_NS_DATA_FLBAS_EXTENDED_SHIFT: i32 = 4;
pub const NVME_NS_DATA_FLBAS_EXTENDED_MASK: i32 = 1;
pub const NVME_NS_DATA_MC_EXTENDED_SHIFT: i32 = 0;
pub const NVME_NS_DATA_MC_EXTENDED_MASK: i32 = 1;
pub const NVME_NS_DATA_MC_POINTER_SHIFT: i32 = 1;
pub const NVME_NS_DATA_MC_POINTER_MASK: i32 = 1;
pub const NVME_NS_DATA_DPC_PIT1_SHIFT: i32 = 0;
pub const NVME_NS_DATA_DPC_PIT1_MASK: i32 = 1;
pub const NVME_NS_DATA_DPC_PIT2_SHIFT: i32 = 1;
pub const NVME_NS_DATA_DPC_PIT2_MASK: i32 = 1;
pub const NVME_NS_DATA_DPC_PIT3_SHIFT: i32 = 2;
pub const NVME_NS_DATA_DPC_PIT3_MASK: i32 = 1;
pub const NVME_NS_DATA_DPC_MD_START_SHIFT: i32 = 3;
pub const NVME_NS_DATA_DPC_MD_START_MASK: i32 = 1;
pub const NVME_NS_DATA_DPC_MD_END_SHIFT: i32 = 4;
pub const NVME_NS_DATA_DPC_MD_END_MASK: i32 = 1;
pub const NVME_NS_DATA_DPS_PIT_SHIFT: i32 = 0;
pub const NVME_NS_DATA_DPS_PIT_MASK: i32 = 7;
pub const NVME_NS_DATA_DPS_MD_START_SHIFT: i32 = 3;
pub const NVME_NS_DATA_DPS_MD_START_MASK: i32 = 1;
pub const NVME_NS_DATA_NMIC_MAY_BE_SHARED_SHIFT: i32 = 0;
pub const NVME_NS_DATA_NMIC_MAY_BE_SHARED_MASK: i32 = 1;
pub const NVME_NS_DATA_RESCAP_PTPL_SHIFT: i32 = 0;
pub const NVME_NS_DATA_RESCAP_PTPL_MASK: i32 = 1;
pub const NVME_NS_DATA_RESCAP_WR_EX_SHIFT: i32 = 1;
pub const NVME_NS_DATA_RESCAP_WR_EX_MASK: i32 = 1;
pub const NVME_NS_DATA_RESCAP_EX_AC_SHIFT: i32 = 2;
pub const NVME_NS_DATA_RESCAP_EX_AC_MASK: i32 = 1;
pub const NVME_NS_DATA_RESCAP_WR_EX_RO_SHIFT: i32 = 3;
pub const NVME_NS_DATA_RESCAP_WR_EX_RO_MASK: i32 = 1;
pub const NVME_NS_DATA_RESCAP_EX_AC_RO_SHIFT: i32 = 4;
pub const NVME_NS_DATA_RESCAP_EX_AC_RO_MASK: i32 = 1;
pub const NVME_NS_DATA_RESCAP_WR_EX_AR_SHIFT: i32 = 5;
pub const NVME_NS_DATA_RESCAP_WR_EX_AR_MASK: i32 = 1;
pub const NVME_NS_DATA_RESCAP_EX_AC_AR_SHIFT: i32 = 6;
pub const NVME_NS_DATA_RESCAP_EX_AC_AR_MASK: i32 = 1;
pub const NVME_NS_DATA_RESCAP_IEKEY13_SHIFT: i32 = 7;
pub const NVME_NS_DATA_RESCAP_IEKEY13_MASK: i32 = 1;
pub const NVME_NS_DATA_FPI_PERC_SHIFT: i32 = 0;
pub const NVME_NS_DATA_FPI_PERC_MASK: i32 = 127;
pub const NVME_NS_DATA_FPI_SUPP_SHIFT: i32 = 7;
pub const NVME_NS_DATA_FPI_SUPP_MASK: i32 = 1;
pub const NVME_NS_DATA_DLFEAT_READ_SHIFT: i32 = 0;
pub const NVME_NS_DATA_DLFEAT_READ_MASK: i32 = 7;
pub const NVME_NS_DATA_DLFEAT_READ_NR: i32 = 0;
pub const NVME_NS_DATA_DLFEAT_READ_00: i32 = 1;
pub const NVME_NS_DATA_DLFEAT_READ_FF: i32 = 2;
pub const NVME_NS_DATA_DLFEAT_DWZ_SHIFT: i32 = 3;
pub const NVME_NS_DATA_DLFEAT_DWZ_MASK: i32 = 1;
pub const NVME_NS_DATA_DLFEAT_GCRC_SHIFT: i32 = 4;
pub const NVME_NS_DATA_DLFEAT_GCRC_MASK: i32 = 1;
pub const NVME_NS_DATA_LBAF_MS_SHIFT: i32 = 0;
pub const NVME_NS_DATA_LBAF_MS_MASK: i32 = 65535;
pub const NVME_NS_DATA_LBAF_LBADS_SHIFT: i32 = 16;
pub const NVME_NS_DATA_LBAF_LBADS_MASK: i32 = 255;
pub const NVME_NS_DATA_LBAF_RP_SHIFT: i32 = 24;
pub const NVME_NS_DATA_LBAF_RP_MASK: i32 = 3;
pub const NVME_CRIT_WARN_ST_RESERVED_MASK: i32 = 192;
pub const NVME_ASYNC_EVENT_NS_ATTRIBUTE: i32 = 256;
pub const NVME_ASYNC_EVENT_FW_ACTIVATE: i32 = 512;
pub const NVME_ASYNC_EVENT_TELEMETRY_LOG: i32 = 1024;
pub const NVME_ASYNC_EVENT_ASYM_NS_ACC: i32 = 2048;
pub const NVME_ASYNC_EVENT_PRED_LAT_DELTA: i32 = 4096;
pub const NVME_ASYNC_EVENT_LBA_STATUS: i32 = 8192;
pub const NVME_ASYNC_EVENT_ENDURANCE_DELTA: i32 = 16384;
pub const NVME_ASYNC_EVENT_NVM_SHUTDOWN: i32 = 32768;
pub const NVME_ASYNC_EVENT_ZONE_DELTA: i32 = 134217728;
pub const NVME_ASYNC_EVENT_DISCOVERY_DELTA: i64 = 2147483648;
pub const NVME_FIRMWARE_PAGE_AFI_SLOT_SHIFT: i32 = 0;
pub const NVME_FIRMWARE_PAGE_AFI_SLOT_MASK: i32 = 7;
pub const NVME_CE_PAGE_CSUP_SHIFT: i32 = 0;
pub const NVME_CE_PAGE_CSUP_MASK: i32 = 1;
pub const NVME_CE_PAGE_LBCC_SHIFT: i32 = 1;
pub const NVME_CE_PAGE_LBCC_MASK: i32 = 1;
pub const NVME_CE_PAGE_NCC_SHIFT: i32 = 2;
pub const NVME_CE_PAGE_NCC_MASK: i32 = 1;
pub const NVME_CE_PAGE_NIC_SHIFT: i32 = 3;
pub const NVME_CE_PAGE_NIC_MASK: i32 = 1;
pub const NVME_CE_PAGE_CCC_SHIFT: i32 = 4;
pub const NVME_CE_PAGE_CCC_MASK: i32 = 1;
pub const NVME_CE_PAGE_CSE_SHIFT: i32 = 16;
pub const NVME_CE_PAGE_CSE_MASK: i32 = 7;
pub const NVME_CE_PAGE_UUID_SHIFT: i32 = 19;
pub const NVME_CE_PAGE_UUID_MASK: i32 = 1;
pub const NVME_SS_PAGE_SSTAT_STATUS_SHIFT: i32 = 0;
pub const NVME_SS_PAGE_SSTAT_STATUS_MASK: i32 = 7;
pub const NVME_SS_PAGE_SSTAT_STATUS_NEVER: i32 = 0;
pub const NVME_SS_PAGE_SSTAT_STATUS_COMPLETED: i32 = 1;
pub const NVME_SS_PAGE_SSTAT_STATUS_INPROG: i32 = 2;
pub const NVME_SS_PAGE_SSTAT_STATUS_FAILED: i32 = 3;
pub const NVME_SS_PAGE_SSTAT_STATUS_COMPLETEDWD: i32 = 4;
pub const NVME_SS_PAGE_SSTAT_PASSES_SHIFT: i32 = 3;
pub const NVME_SS_PAGE_SSTAT_PASSES_MASK: i32 = 31;
pub const NVME_SS_PAGE_SSTAT_GDE_SHIFT: i32 = 8;
pub const NVME_SS_PAGE_SSTAT_GDE_MASK: i32 = 1;
pub const NVME_FEAT_GET_SEL_SHIFT: i32 = 8;
pub const NVME_FEAT_GET_SEL_MASK: i32 = 7;
pub const NVME_FEAT_GET_FID_SHIFT: i32 = 0;
pub const NVME_FEAT_GET_FID_MASK: i32 = 255;
pub const NVME_FEAT_SET_SV_SHIFT: i32 = 31;
pub const NVME_FEAT_SET_SV_MASK: i32 = 1;
pub const NVME_FEAT_SET_FID_SHIFT: i32 = 0;
pub const NVME_FEAT_SET_FID_MASK: i32 = 255;
pub const NVME_ASYNC_EVENT_TYPE_SHIFT: i32 = 0;
pub const NVME_ASYNC_EVENT_TYPE_MASK: i32 = 7;
pub const NVME_ASYNC_EVENT_INFO_SHIFT: i32 = 8;
pub const NVME_ASYNC_EVENT_INFO_MASK: i32 = 255;
pub const NVME_ASYNC_EVENT_LOG_PAGE_ID_SHIFT: i32 = 16;
pub const NVME_ASYNC_EVENT_LOG_PAGE_ID_MASK: i32 = 255;
pub const NVME_SGL_SUBTYPE_SHIFT: i32 = 0;
pub const NVME_SGL_SUBTYPE_MASK: i32 = 15;
pub const NVME_SGL_TYPE_SHIFT: i32 = 4;
pub const NVME_SGL_TYPE_MASK: i32 = 15;
pub const NVME_MAX_DSM_TRIM: i32 = 4096;
pub const NVME_SERIAL_NUMBER_LENGTH: i32 = 20;
pub const NVME_MODEL_NUMBER_LENGTH: i32 = 40;
pub const NVME_FIRMWARE_REVISION_LENGTH: i32 = 8;
pub const NVME_TEST_MAX_THREADS: i32 = 128;
pub const IDT32_PCI_ID: i64 = 2161119517;
pub const IDT8_PCI_ID: i64 = 2161250589;
pub const NVME_ADMIN_TRACKERS: i32 = 16;
pub const NVME_ADMIN_ENTRIES: i32 = 128;
pub const NVME_IO_ENTRIES: i32 = 256;
pub const NVME_IO_TRACKERS: i32 = 128;
pub const NVME_MIN_IO_TRACKERS: i32 = 4;
pub const NVME_MAX_IO_TRACKERS: i32 = 1024;
pub const NVME_INT_COAL_TIME: i32 = 0;
pub const NVME_INT_COAL_THRESHOLD: i32 = 0;
pub const NVME_MAX_NAMESPACES: i32 = 16;
pub const NVME_MAX_CONSUMERS: i32 = 2;
pub const NVME_MAX_ASYNC_EVENTS: i32 = 8;
pub const NVME_ADMIN_TIMEOUT_PERIOD: i32 = 60;
pub const NVME_DEFAULT_TIMEOUT_PERIOD: i32 = 30;
pub const NVME_MIN_TIMEOUT_PERIOD: i32 = 5;
pub const NVME_MAX_TIMEOUT_PERIOD: i32 = 120;
pub const NVME_DEFAULT_RETRY_COUNT: i32 = 4;
pub const NVME_MAX_AER_LOG_SIZE: i32 = 4096;
pub const NVME_GONE: i64 = 4294967295;
pub const QUIRK_DELAY_B4_CHK_RDY: i32 = 1;
pub const QUIRK_DISABLE_TIMEOUT: i32 = 2;
pub const QUIRK_INTEL_ALIGNMENT: i32 = 4;
pub const QUIRK_AHCI: i32 = 8;
pub const QUIRK_ANS: i32 = 16;
pub const IRQ_TYPE_NONE: i32 = 0;
pub const IRQ_TYPE_EDGE_RISING: i32 = 1;
pub const IRQ_TYPE_EDGE_FALLING: i32 = 2;
pub const IRQ_TYPE_EDGE_BOTH: i32 = 3;
pub const IRQ_TYPE_LEVEL_HIGH: i32 = 4;
pub const IRQ_TYPE_LEVEL_LOW: i32 = 8;
pub const AIC_IRQ: i32 = 0;
pub const AIC_FIQ: i32 = 1;
pub const AIC_TMR_HV_PHYS: i32 = 0;
pub const AIC_TMR_HV_VIRT: i32 = 1;
pub const AIC_TMR_GUEST_PHYS: i32 = 2;
pub const AIC_TMR_GUEST_VIRT: i32 = 3;
pub const AIC_CPU_PMU_E: i32 = 4;
pub const AIC_CPU_PMU_P: i32 = 5;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_long;
pub type __uint64_t = ::core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __int_least16_t = __int16_t;
pub type __int_least32_t = __int32_t;
pub type __int_least64_t = __int64_t;
pub type __intmax_t = __int64_t;
pub type __uint_least8_t = __uint8_t;
pub type __uint_least16_t = __uint16_t;
pub type __uint_least32_t = __uint32_t;
pub type __uint_least64_t = __uint64_t;
pub type __uintmax_t = __uint64_t;
pub type __intptr_t = __int64_t;
pub type __intfptr_t = __int64_t;
pub type __uintptr_t = __uint64_t;
pub type __uintfptr_t = __uint64_t;
pub type __vm_offset_t = __uint64_t;
pub type __vm_size_t = __uint64_t;
pub type __size_t = __uint64_t;
pub type __ssize_t = __int64_t;
pub type __ptrdiff_t = __int64_t;
pub type __clock_t = __int32_t;
pub type __critical_t = __int64_t;
pub type __double_t = f64;
pub type __float_t = f32;
pub type __int_fast8_t = __int32_t;
pub type __int_fast16_t = __int32_t;
pub type __int_fast32_t = __int32_t;
pub type __int_fast64_t = __int64_t;
pub type __register_t = __int64_t;
pub type __segsz_t = __int64_t;
pub type __time_t = __int64_t;
pub type __uint_fast8_t = __uint32_t;
pub type __uint_fast16_t = __uint32_t;
pub type __uint_fast32_t = __uint32_t;
pub type __uint_fast64_t = __uint64_t;
pub type __u_register_t = __uint64_t;
pub type __vm_paddr_t = __uint64_t;
pub type ___wchar_t = ::core::ffi::c_uint;
pub type __blksize_t = __int32_t;
pub type __blkcnt_t = __int64_t;
pub type __clockid_t = __int32_t;
pub type __fflags_t = __uint32_t;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint64_t;
pub type __gid_t = __uint32_t;
pub type __id_t = __int64_t;
pub type __ino_t = __uint64_t;
pub type __key_t = ::core::ffi::c_long;
pub type __lwpid_t = __int32_t;
pub type __mode_t = __uint16_t;
pub type __accmode_t = ::core::ffi::c_int;
pub type __nl_item = ::core::ffi::c_int;
pub type __nlink_t = __uint64_t;
pub type __off_t = __int64_t;
pub type __off64_t = __int64_t;
pub type __pid_t = __int32_t;
pub type __sbintime_t = __int64_t;
pub type __rlim_t = __int64_t;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __suseconds_t = ::core::ffi::c_long;
#[repr(C)]
#[derive(Debug)]
pub struct __timer {
    _unused: [u8; 0],
}
pub type __timer_t = *mut __timer;
#[repr(C)]
#[derive(Debug)]
pub struct __mq {
    _unused: [u8; 0],
}
pub type __mqd_t = *mut __mq;
pub type __uid_t = __uint32_t;
pub type __useconds_t = ::core::ffi::c_uint;
pub type __cpuwhich_t = ::core::ffi::c_int;
pub type __cpulevel_t = ::core::ffi::c_int;
pub type __cpusetid_t = ::core::ffi::c_int;
pub type __daddr_t = __int64_t;
pub type __ct_rune_t = ::core::ffi::c_int;
pub type __rune_t = __ct_rune_t;
pub type __wint_t = __ct_rune_t;
pub type __char16_t = __uint_least16_t;
pub type __char32_t = __uint_least32_t;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default)]
pub struct __max_align_t {
    pub __max_align1: ::core::ffi::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align2: u128,
}
pub type __acl_tag_t = __uint32_t;
pub type __acl_perm_t = __uint32_t;
pub type __acl_entry_type_t = __uint16_t;
pub type __acl_flag_t = __uint16_t;
pub type __acl_type_t = __uint32_t;
pub type __acl_permset_t = *mut __uint32_t;
pub type __acl_flagset_t = *mut __uint16_t;
pub type __dev_t = __uint64_t;
pub type __fixpt_t = __uint32_t;
#[repr(C)]
pub struct __mbstate_t {
    pub __mbstate8: __BindgenUnionField<[::core::ffi::c_char; 128usize]>,
    pub _mbstateL: __BindgenUnionField<__int64_t>,
    pub bindgen_union_field: [u64; 16usize],
}
impl Default for __mbstate_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __rman_res_t = __uintmax_t;
pub type __gnuc_va_list = __va_list;
#[repr(C)]
#[derive(Debug)]
pub struct pthread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct pthread_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct pthread_cond {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct pthread_cond_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct pthread_mutex {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct pthread_mutex_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct pthread_rwlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct pthread_rwlockattr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct pthread_barrier {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct pthread_barrier_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct pthread_spinlock {
    _unused: [u8; 0],
}
pub type pthread_t = *mut pthread;
pub type pthread_attr_t = *mut pthread_attr;
pub type pthread_mutex_t = *mut pthread_mutex;
pub type pthread_mutexattr_t = *mut pthread_mutex_attr;
pub type pthread_cond_t = *mut pthread_cond;
pub type pthread_condattr_t = *mut pthread_cond_attr;
pub type pthread_key_t = ::core::ffi::c_int;
pub type pthread_once_t = pthread_once;
pub type pthread_rwlock_t = *mut pthread_rwlock;
pub type pthread_rwlockattr_t = *mut pthread_rwlockattr;
pub type pthread_barrier_t = *mut pthread_barrier;
#[repr(C)]
#[derive(Debug)]
pub struct pthread_barrierattr {
    _unused: [u8; 0],
}
pub type pthread_barrierattr_t = *mut pthread_barrierattr;
pub type pthread_spinlock_t = *mut pthread_spinlock;
pub type pthread_addr_t = *mut ::core::ffi::c_void;
pub type pthread_startroutine_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void,
>;
#[repr(C)]
#[derive(Debug)]
pub struct pthread_once {
    pub state: ::core::ffi::c_int,
    pub mutex: pthread_mutex_t,
}
impl Default for pthread_once {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type u_char = ::core::ffi::c_uchar;
pub type u_short = ::core::ffi::c_ushort;
pub type u_int = ::core::ffi::c_uint;
pub type u_long = ::core::ffi::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type u_quad_t = __uint64_t;
pub type quad_t = __int64_t;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::core::ffi::c_char;
pub type c_caddr_t = *const ::core::ffi::c_char;
pub type blksize_t = __blksize_t;
pub type cpuwhich_t = __cpuwhich_t;
pub type cpulevel_t = __cpulevel_t;
pub type cpusetid_t = __cpusetid_t;
pub type blkcnt_t = __blkcnt_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type critical_t = __critical_t;
pub type daddr_t = __daddr_t;
pub type dev_t = __dev_t;
pub type fflags_t = __fflags_t;
pub type fixpt_t = __fixpt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type gid_t = __gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type key_t = __key_t;
pub type lwpid_t = __lwpid_t;
pub type mode_t = __mode_t;
pub type accmode_t = __accmode_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type register_t = __register_t;
pub type rlim_t = __rlim_t;
pub type sbintime_t = __sbintime_t;
pub type segsz_t = __segsz_t;
pub type suseconds_t = __suseconds_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type mqd_t = __mqd_t;
pub type u_register_t = __u_register_t;
pub type uid_t = __uid_t;
pub type useconds_t = __useconds_t;
pub type cap_ioctl_t = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug)]
pub struct cap_rights {
    _unused: [u8; 0],
}
pub type cap_rights_t = cap_rights;
pub type kpaddr_t = __uint64_t;
pub type kvaddr_t = __uint64_t;
pub type ksize_t = __uint64_t;
pub type kssize_t = __int64_t;
pub type vm_offset_t = __vm_offset_t;
pub type vm_ooffset_t = __uint64_t;
pub type vm_paddr_t = __vm_paddr_t;
pub type vm_pindex_t = __uint64_t;
pub type vm_size_t = __vm_size_t;
pub type rman_res_t = __rman_res_t;
pub type syscallarg_t = __register_t;
pub type boolean_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct _device {
    _unused: [u8; 0],
}
pub type intfptr_t = __intfptr_t;
pub type intrmask_t = __uint32_t;
pub type uintfptr_t = __uintfptr_t;
pub type uoff_t = __uint64_t;
pub type vm_memattr_t = ::core::ffi::c_char;
#[repr(C)]
#[derive(Debug)]
pub struct vm_page {
    _unused: [u8; 0],
}
pub type vm_page_t = *mut vm_page;
pub type bool_ = bool;
#[repr(C)]
#[derive(Debug, Default)]
pub struct __sigset {
    pub __bits: [__uint32_t; 4usize],
}
pub type __sigset_t = __sigset;
#[repr(C)]
#[derive(Debug, Default)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
pub type __fd_mask = ::core::ffi::c_ulong;
pub type fd_mask = __fd_mask;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct timezone {
    pub tz_minuteswest: ::core::ffi::c_int,
    pub tz_dsttime: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct bintime {
    pub sec: time_t,
    pub frac: u64,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct clockinfo {
    pub hz: ::core::ffi::c_int,
    pub tick: ::core::ffi::c_int,
    pub spare: ::core::ffi::c_int,
    pub stathz: ::core::ffi::c_int,
    pub profhz: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct priority {
    pub pri_class: u_char,
    pub pri_level: u_char,
    pub pri_native: u_char,
    pub pri_user: u_char,
}
pub type bus_addr_t = u_long;
pub type bus_size_t = u_long;
pub type bus_space_handle_t = u_long;
pub type bus_space_tag_t = *mut bus_space;
pub type bus_dmasync_op_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug)]
pub struct bus_dma_tag {
    _unused: [u8; 0],
}
pub type bus_dma_tag_t = *mut bus_dma_tag;
#[repr(C)]
#[derive(Debug)]
pub struct bus_dmamap {
    _unused: [u8; 0],
}
pub type bus_dmamap_t = *mut bus_dmamap;
pub const BUS_DMA_LOCK: bus_dma_lock_op_t = 1;
pub const BUS_DMA_UNLOCK: bus_dma_lock_op_t = 2;
pub type bus_dma_lock_op_t = ::core::ffi::c_uint;
pub type bus_dma_lock_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: bus_dma_lock_op_t),
>;
#[doc = " @brief Interface information structure."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct u_businfo {
    #[doc = "< @brief interface version"]
    pub ub_version: ::core::ffi::c_int,
    #[doc = "< @brief generation count"]
    pub ub_generation: ::core::ffi::c_int,
}
#[doc = "< @brief not probed or probe failed"]
pub const DS_NOTPRESENT: device_state = 10;
#[doc = "< @brief probe succeeded"]
pub const DS_ALIVE: device_state = 20;
#[doc = "< @brief currently attaching"]
pub const DS_ATTACHING: device_state = 25;
#[doc = "< @brief attach method called"]
pub const DS_ATTACHED: device_state = 30;
#[doc = " @brief State of the device."]
pub type device_state = ::core::ffi::c_uint;
#[doc = " @brief State of the device."]
pub use self::device_state as device_state_t;
pub const DEVICE_PROP_ANY: device_property_type = 0;
pub const DEVICE_PROP_BUFFER: device_property_type = 1;
pub const DEVICE_PROP_UINT32: device_property_type = 2;
pub const DEVICE_PROP_UINT64: device_property_type = 3;
pub const DEVICE_PROP_HANDLE: device_property_type = 4;
#[doc = " @brief Device proprty types.\n\n Those are used by bus logic to encode requested properties,\n e.g. in DT all properties are stored as BE and need to be converted\n to host endianness."]
pub type device_property_type = ::core::ffi::c_uint;
#[doc = " @brief Device proprty types.\n\n Those are used by bus logic to encode requested properties,\n e.g. in DT all properties are stored as BE and need to be converted\n to host endianness."]
pub use self::device_property_type as device_property_type_t;
#[repr(C)]
#[derive(Debug)]
pub struct u_device {
    pub dv_handle: usize,
    pub dv_parent: usize,
    #[doc = "< @brief API Flags for device"]
    pub dv_devflags: u32,
    #[doc = "< @brief flags for dev state"]
    pub dv_flags: u16,
    #[doc = "< @brief State of attachment"]
    pub dv_state: device_state_t,
    #[doc = "< @brief NUL terminated fields"]
    pub dv_fields: [::core::ffi::c_char; 3072usize],
}
impl Default for u_device {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Device request structure used for ioctl's.\n\n Used for ioctl's on /dev/devctl2.  All device ioctl's\n must have parameter definitions which begin with dr_name."]
#[repr(C)]
#[derive(Debug)]
pub struct devreq_buffer {
    pub buffer: *mut ::core::ffi::c_void,
    pub length: usize,
}
impl Default for devreq_buffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct devreq {
    pub dr_name: [::core::ffi::c_char; 128usize],
    pub dr_flags: ::core::ffi::c_int,
    pub dr_dru: devreq__bindgen_ty_1,
}
#[repr(C)]
pub struct devreq__bindgen_ty_1 {
    pub dru_buffer: __BindgenUnionField<devreq_buffer>,
    pub dru_data: __BindgenUnionField<*mut ::core::ffi::c_void>,
    pub bindgen_union_field: [u64; 2usize],
}
impl Default for devreq__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for devreq {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry {
    pub ee_link: eventhandler_entry__bindgen_ty_1,
    pub ee_priority: ::core::ffi::c_int,
    pub ee_arg: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry__bindgen_ty_1 {
    pub tqe_next: *mut eventhandler_entry,
    pub tqe_prev: *mut *mut eventhandler_entry,
}
impl Default for eventhandler_entry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for eventhandler_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type eventhandler_tag = *mut eventhandler_entry;
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_list {
    _unused: [u8; 0],
}
pub type kobj_t = *mut kobj;
pub type kobj_class_t = *mut kobj_class;
pub type kobj_method_t = kobj_method;
pub type kobjop_t = ::core::option::Option<unsafe extern "C" fn()>;
pub type kobj_ops_t = *mut kobj_ops;
pub type kobjop_desc_t = *mut kobjop_desc;
#[repr(C)]
#[derive(Debug)]
pub struct kobj_method {
    pub desc: kobjop_desc_t,
    pub func: kobjop_t,
}
impl Default for kobj_method {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct kobj_class {
    pub name: *const ::core::ffi::c_char,
    pub methods: *const kobj_method,
    pub size: usize,
    pub baseclasses: *mut kobj_class_t,
    pub refs: u_int,
    pub ops: kobj_ops_t,
}
impl Default for kobj_class {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct kobj {
    pub ops: kobj_ops_t,
}
impl Default for kobj {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct kobj_ops {
    pub cache: [*const kobj_method; 256usize],
    pub cls: kobj_class_t,
}
impl Default for kobj_ops {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct kobjop_desc {
    pub id: ::core::ffi::c_uint,
    pub deflt: kobj_method_t,
}
impl Default for kobjop_desc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct callout_list {
    pub lh_first: *mut callout,
}
impl Default for callout_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct callout_slist {
    pub slh_first: *mut callout,
}
impl Default for callout_slist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct callout_tailq {
    pub tqh_first: *mut callout,
    pub tqh_last: *mut *mut callout,
}
impl Default for callout_tailq {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type callout_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
#[repr(C)]
pub struct callout {
    pub c_links: callout__bindgen_ty_1,
    pub c_time: __sbintime_t,
    pub c_precision: __sbintime_t,
    pub c_arg: *mut ::core::ffi::c_void,
    pub c_func: callout_func_t,
    pub c_lock: *mut lock_object,
    pub c_flags: ::core::ffi::c_short,
    pub c_iflags: ::core::ffi::c_short,
    pub c_cpu: ::core::ffi::c_int,
}
#[repr(C)]
pub struct callout__bindgen_ty_1 {
    pub le: __BindgenUnionField<callout__bindgen_ty_1__bindgen_ty_1>,
    pub sle: __BindgenUnionField<callout__bindgen_ty_1__bindgen_ty_2>,
    pub tqe: __BindgenUnionField<callout__bindgen_ty_1__bindgen_ty_3>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct callout__bindgen_ty_1__bindgen_ty_1 {
    pub le_next: *mut callout,
    pub le_prev: *mut *mut callout,
}
impl Default for callout__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct callout__bindgen_ty_1__bindgen_ty_2 {
    pub sle_next: *mut callout,
}
impl Default for callout__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct callout__bindgen_ty_1__bindgen_ty_3 {
    pub tqe_next: *mut callout,
    pub tqe_prev: *mut *mut callout,
}
impl Default for callout__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for callout__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for callout {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = __int_fast8_t;
pub type int_fast16_t = __int_fast16_t;
pub type int_fast32_t = __int_fast32_t;
pub type int_fast64_t = __int_fast64_t;
pub type uint_fast8_t = __uint_fast8_t;
pub type uint_fast16_t = __uint_fast16_t;
pub type uint_fast32_t = __uint_fast32_t;
pub type uint_fast64_t = __uint_fast64_t;
pub const VM_GUEST_NO: VM_GUEST = 0;
pub const VM_GUEST_VM: VM_GUEST = 1;
pub const VM_GUEST_XEN: VM_GUEST = 2;
pub const VM_GUEST_HV: VM_GUEST = 3;
pub const VM_GUEST_VMWARE: VM_GUEST = 4;
pub const VM_GUEST_KVM: VM_GUEST = 5;
pub const VM_GUEST_BHYVE: VM_GUEST = 6;
pub const VM_GUEST_VBOX: VM_GUEST = 7;
pub const VM_GUEST_PARALLELS: VM_GUEST = 8;
pub const VM_GUEST_NVMM: VM_GUEST = 9;
pub const VM_GUEST_LAST: VM_GUEST = 10;
pub type VM_GUEST = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default)]
pub struct bitset {
    pub __bits: [::core::ffi::c_ulong; 1usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct _cpuset {
    pub __bits: [::core::ffi::c_ulong; 16usize],
}
pub type cpuset_t = _cpuset;
#[repr(C)]
#[derive(Debug)]
pub struct lock_object {
    pub lo_name: *const ::core::ffi::c_char,
    pub lo_flags: ::core::ffi::c_uint,
    pub lo_data: ::core::ffi::c_uint,
    pub lo_witness: *mut witness,
}
impl Default for lock_object {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct mtx {
    pub lock_object: lock_object,
    pub mtx_lock: __uintptr_t,
}
impl Default for mtx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(128))]
#[derive(Debug)]
pub struct mtx_padalign {
    pub lock_object: lock_object,
    pub mtx_lock: __uintptr_t,
}
impl Default for mtx_padalign {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct sx {
    pub lock_object: lock_object,
    pub sx_lock: __uintptr_t,
}
impl Default for sx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct rmpriolist {
    pub lh_first: *mut rm_priotracker,
}
impl Default for rmpriolist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct rm_queue {
    pub rmq_next: *mut rm_queue,
    pub rmq_prev: *mut rm_queue,
}
impl Default for rm_queue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct rmlock {
    pub lock_object: lock_object,
    pub rm_writecpus: cpuset_t,
    pub rm_activeReaders: rmlock__bindgen_ty_1,
    pub _rm_lock: rmlock__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug)]
pub struct rmlock__bindgen_ty_1 {
    pub lh_first: *mut rm_priotracker,
}
impl Default for rmlock__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct rmlock__bindgen_ty_2 {
    pub _rm_wlock_object: __BindgenUnionField<lock_object>,
    pub _rm_lock_mtx: __BindgenUnionField<mtx>,
    pub _rm_lock_sx: __BindgenUnionField<sx>,
    pub bindgen_union_field: [u64; 4usize],
}
impl Default for rmlock__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for rmlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct rm_priotracker {
    pub rmp_cpuQueue: rm_queue,
    pub rmp_rmlock: *mut rmlock,
    pub rmp_thread: *mut thread,
    pub rmp_flags: ::core::ffi::c_int,
    pub rmp_qentry: rm_priotracker__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug)]
pub struct rm_priotracker__bindgen_ty_1 {
    pub le_next: *mut rm_priotracker,
    pub le_prev: *mut *mut rm_priotracker,
}
impl Default for rm_priotracker__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for rm_priotracker {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct rmslock_pcpu {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct rmslock {
    pub mtx: mtx,
    pub owner: *mut thread,
    pub pcpu: *mut rmslock_pcpu,
    pub writers: ::core::ffi::c_int,
    pub readers: ::core::ffi::c_int,
    pub debug_readers: ::core::ffi::c_int,
}
impl Default for rmslock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::core::ffi::c_long,
    pub ru_ixrss: ::core::ffi::c_long,
    pub ru_idrss: ::core::ffi::c_long,
    pub ru_isrss: ::core::ffi::c_long,
    pub ru_minflt: ::core::ffi::c_long,
    pub ru_majflt: ::core::ffi::c_long,
    pub ru_nswap: ::core::ffi::c_long,
    pub ru_inblock: ::core::ffi::c_long,
    pub ru_oublock: ::core::ffi::c_long,
    pub ru_msgsnd: ::core::ffi::c_long,
    pub ru_msgrcv: ::core::ffi::c_long,
    pub ru_nsignals: ::core::ffi::c_long,
    pub ru_nvcsw: ::core::ffi::c_long,
    pub ru_nivcsw: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __wrusage {
    pub wru_self: rusage,
    pub wru_children: rusage,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct orlimit {
    pub rlim_cur: __int32_t,
    pub rlim_max: __int32_t,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct loadavg {
    pub ldavg: [__fixpt_t; 3usize],
    pub fscale: ::core::ffi::c_long,
}
pub type stack_t = sigaltstack;
#[repr(C)]
#[derive(Debug)]
pub struct sigaltstack {
    pub ss_sp: *mut ::core::ffi::c_void,
    pub ss_size: __size_t,
    pub ss_flags: ::core::ffi::c_int,
}
impl Default for sigaltstack {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct sigval {
    pub sival_int: __BindgenUnionField<::core::ffi::c_int>,
    pub sival_ptr: __BindgenUnionField<*mut ::core::ffi::c_void>,
    pub sigval_int: __BindgenUnionField<::core::ffi::c_int>,
    pub sigval_ptr: __BindgenUnionField<*mut ::core::ffi::c_void>,
    pub bindgen_union_field: u64,
}
impl Default for sigval {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct sigval32 {
    pub sival_int: __BindgenUnionField<::core::ffi::c_int>,
    pub sival_ptr: __BindgenUnionField<__uint32_t>,
    pub sigval_int: __BindgenUnionField<::core::ffi::c_int>,
    pub sigval_ptr: __BindgenUnionField<__uint32_t>,
    pub bindgen_union_field: u32,
}
impl Default for sigval32 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sig_atomic_t = ::core::ffi::c_long;
#[repr(C)]
#[derive(Debug, Default)]
pub struct sigcontext {
    pub _dummy: ::core::ffi::c_int,
}
pub type __sighandler_t = ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>;
#[repr(C)]
pub struct sigevent {
    pub sigev_notify: ::core::ffi::c_int,
    pub sigev_signo: ::core::ffi::c_int,
    pub sigev_value: sigval,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
pub struct sigevent__bindgen_ty_1 {
    pub _threadid: __BindgenUnionField<__lwpid_t>,
    pub _sigev_thread: __BindgenUnionField<sigevent__bindgen_ty_1__bindgen_ty_1>,
    pub _kevent_flags: __BindgenUnionField<::core::ffi::c_ushort>,
    pub __spare__: __BindgenUnionField<[::core::ffi::c_long; 8usize]>,
    pub bindgen_union_field: [u64; 8usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::core::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub _attribute: *mut *mut pthread_attr,
}
impl Default for sigevent__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sigevent__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sigevent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct __siginfo {
    pub si_signo: ::core::ffi::c_int,
    pub si_errno: ::core::ffi::c_int,
    pub si_code: ::core::ffi::c_int,
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::core::ffi::c_int,
    pub si_addr: *mut ::core::ffi::c_void,
    pub si_value: sigval,
    pub _reason: __siginfo__bindgen_ty_1,
}
#[repr(C)]
pub struct __siginfo__bindgen_ty_1 {
    pub _fault: __BindgenUnionField<__siginfo__bindgen_ty_1__bindgen_ty_1>,
    pub _timer: __BindgenUnionField<__siginfo__bindgen_ty_1__bindgen_ty_2>,
    pub _mesgq: __BindgenUnionField<__siginfo__bindgen_ty_1__bindgen_ty_3>,
    pub _poll: __BindgenUnionField<__siginfo__bindgen_ty_1__bindgen_ty_4>,
    pub _capsicum: __BindgenUnionField<__siginfo__bindgen_ty_1__bindgen_ty_5>,
    pub __spare__: __BindgenUnionField<__siginfo__bindgen_ty_1__bindgen_ty_6>,
    pub bindgen_union_field: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_1 {
    pub _trapno: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_2 {
    pub _timerid: ::core::ffi::c_int,
    pub _overrun: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_3 {
    pub _mqd: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_4 {
    pub _band: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_5 {
    pub _syscall: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_6 {
    pub __spare1__: ::core::ffi::c_long,
    pub __spare2__: [::core::ffi::c_int; 7usize],
}
impl Default for __siginfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __siginfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type siginfo_t = __siginfo;
#[repr(C)]
pub struct __siginfo32 {
    pub si_signo: ::core::ffi::c_int,
    pub si_errno: ::core::ffi::c_int,
    pub si_code: ::core::ffi::c_int,
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::core::ffi::c_int,
    pub si_addr: u32,
    pub si_value: sigval32,
    pub _reason: __siginfo32__bindgen_ty_1,
}
#[repr(C)]
pub struct __siginfo32__bindgen_ty_1 {
    pub _fault: __BindgenUnionField<__siginfo32__bindgen_ty_1__bindgen_ty_1>,
    pub _timer: __BindgenUnionField<__siginfo32__bindgen_ty_1__bindgen_ty_2>,
    pub _mesgq: __BindgenUnionField<__siginfo32__bindgen_ty_1__bindgen_ty_3>,
    pub _poll: __BindgenUnionField<__siginfo32__bindgen_ty_1__bindgen_ty_4>,
    pub __spare__: __BindgenUnionField<__siginfo32__bindgen_ty_1__bindgen_ty_5>,
    pub bindgen_union_field: [u32; 8usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __siginfo32__bindgen_ty_1__bindgen_ty_1 {
    pub _trapno: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __siginfo32__bindgen_ty_1__bindgen_ty_2 {
    pub _timerid: ::core::ffi::c_int,
    pub _overrun: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __siginfo32__bindgen_ty_1__bindgen_ty_3 {
    pub _mqd: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __siginfo32__bindgen_ty_1__bindgen_ty_4 {
    pub _band: i32,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __siginfo32__bindgen_ty_1__bindgen_ty_5 {
    pub __spare1__: i32,
    pub __spare2__: [::core::ffi::c_int; 7usize],
}
impl Default for __siginfo32__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __siginfo32 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct sigaction {
    pub __sigaction_u: sigaction__bindgen_ty_1,
    pub sa_flags: ::core::ffi::c_int,
    pub sa_mask: sigset_t,
}
#[repr(C)]
pub struct sigaction__bindgen_ty_1 {
    pub __sa_handler:
        __BindgenUnionField<::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>>,
    pub __sa_sigaction: __BindgenUnionField<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: ::core::ffi::c_int,
                arg2: *mut __siginfo,
                arg3: *mut ::core::ffi::c_void,
            ),
        >,
    >,
    pub bindgen_union_field: u64,
}
impl Default for sigaction__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sigaction {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sig_t = __sighandler_t;
pub type __siginfohandler_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: ::core::ffi::c_int,
        arg2: *mut __siginfo,
        arg3: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Default)]
pub struct sigvec {
    pub sv_handler: __sighandler_t,
    pub sv_mask: ::core::ffi::c_int,
    pub sv_flags: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct sigstack {
    pub ss_sp: *mut ::core::ffi::c_void,
    pub ss_onstack: ::core::ffi::c_int,
}
impl Default for sigstack {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct gpregs {
    pub gp_x: [__register_t; 30usize],
    pub gp_lr: __register_t,
    pub gp_sp: __register_t,
    pub gp_elr: __register_t,
    pub gp_spsr: __uint64_t,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default)]
pub struct fpregs {
    pub fp_q: [__uint128_t; 32usize],
    pub fp_sr: __uint32_t,
    pub fp_cr: __uint32_t,
    pub fp_flags: ::core::ffi::c_int,
    pub fp_pad: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct arm64_reg_context {
    pub ctx_id: __uint32_t,
    pub ctx_size: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct sve_context {
    pub sve_ctx: arm64_reg_context,
    pub sve_vector_len: __uint16_t,
    pub sve_flags: __uint16_t,
    pub sve_reserved: [__uint16_t; 2usize],
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default)]
pub struct __mcontext {
    pub mc_gpregs: gpregs,
    pub mc_fpregs: fpregs,
    pub mc_flags: ::core::ffi::c_int,
    pub mc_pad: ::core::ffi::c_int,
    pub mc_ptr: __uint64_t,
    pub mc_spare: [__uint64_t; 7usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct sigaltstack32 {
    pub ss_sp: u32,
    pub ss_size: u32,
    pub ss_flags: ::core::ffi::c_int,
}
#[repr(C)]
pub struct osigevent32 {
    pub sigev_notify: ::core::ffi::c_int,
    pub __sigev_u: osigevent32__bindgen_ty_1,
    pub sigev_value: sigval32,
}
#[repr(C)]
pub struct osigevent32__bindgen_ty_1 {
    pub __sigev_signo: __BindgenUnionField<::core::ffi::c_int>,
    pub __sigev_notify_kqueue: __BindgenUnionField<::core::ffi::c_int>,
    pub bindgen_union_field: u32,
}
impl Default for osigevent32__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for osigevent32 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct sigevent32 {
    pub sigev_notify: ::core::ffi::c_int,
    pub sigev_signo: ::core::ffi::c_int,
    pub sigev_value: sigval32,
    pub _sigev_un: sigevent32__bindgen_ty_1,
}
#[repr(C)]
pub struct sigevent32__bindgen_ty_1 {
    pub _threadid: __BindgenUnionField<__lwpid_t>,
    pub _sigev_thread: __BindgenUnionField<sigevent32__bindgen_ty_1__bindgen_ty_1>,
    pub _kevent_flags: __BindgenUnionField<::core::ffi::c_ushort>,
    pub __spare__: __BindgenUnionField<[u32; 8usize]>,
    pub bindgen_union_field: [u32; 8usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct sigevent32__bindgen_ty_1__bindgen_ty_1 {
    pub _function: u32,
    pub _attribute: u32,
}
impl Default for sigevent32__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sigevent32 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct __mcontext32 {
    pub mc_gregset: [u32; 17usize],
    pub mc_vfp_size: u32,
    pub mc_vfp_ptr: u32,
    pub mc_spare: [u32; 33usize],
}
impl Default for __mcontext32 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mcontext32_t = __mcontext32;
#[repr(C)]
#[derive(Debug)]
pub struct __ucontext32 {
    pub uc_sigmask: sigset_t,
    pub uc_mcontext: mcontext32_t,
    pub uc_link: u_int32_t,
    pub uc_stack: sigaltstack32,
    pub uc_flags: u_int32_t,
    pub __spare__: [u_int32_t; 4usize],
}
impl Default for __ucontext32 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ucontext32_t = __ucontext32;
#[repr(C)]
#[derive(Debug, Default)]
pub struct __mcontext32_vfp {
    pub mcv_reg: [__uint64_t; 32usize],
    pub mcv_fpscr: __uint32_t,
}
pub type mcontext32_vfp_t = __mcontext32_vfp;
#[repr(C)]
#[repr(align(16))]
pub struct __ucontext {
    pub uc_sigmask: __sigset_t,
    pub uc_mcontext: mcontext_t,
    pub uc_link: *mut __ucontext,
    pub uc_stack: sigaltstack,
    pub uc_flags: ::core::ffi::c_int,
    pub __spare__: [::core::ffi::c_int; 4usize],
}
impl Default for __ucontext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ucontext_t = __ucontext;
#[repr(C)]
#[derive(Debug, Default)]
pub struct trapframe {
    pub tf_sp: u64,
    pub tf_lr: u64,
    pub tf_elr: u64,
    pub tf_spsr: u64,
    pub tf_esr: u64,
    pub tf_far: u64,
    pub tf_x: [u64; 30usize],
}
#[repr(C)]
#[repr(align(16))]
pub struct sigframe {
    pub sf_si: siginfo_t,
    pub sf_uc: ucontext_t,
}
impl Default for sigframe {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct frame {
    pub dummy: ::core::ffi::c_int,
}
#[repr(C)]
pub struct sigframe32 {
    pub sf_si: __siginfo32,
    pub sf_uc: ucontext32_t,
    pub sf_vfp: mcontext32_vfp_t,
}
impl Default for sigframe32 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct arm64_addr_mask {
    _unused: [u8; 0],
}
pub type cpu_reset_hook_t = ::core::option::Option<unsafe extern "C" fn()>;
pub type pcpu_bp_harden = ::core::option::Option<unsafe extern "C" fn() -> ::core::ffi::c_int>;
pub type pcpu_ssbd =
    ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int>;
#[repr(C)]
#[repr(align(128))]
pub struct pcpu {
    pub pc_curthread: *mut thread,
    pub pc_idlethread: *mut thread,
    pub pc_fpcurthread: *mut thread,
    pub pc_deadthread: *mut thread,
    pub pc_curpcb: *mut pcb,
    pub pc_sched: *mut ::core::ffi::c_void,
    pub pc_switchtime: u64,
    pub pc_switchticks: ::core::ffi::c_int,
    pub pc_cpuid: u_int,
    pub pc_allcpu: pcpu__bindgen_ty_1,
    pub pc_spinlocks: *mut lock_list_entry,
    pub pc_cp_time: [::core::ffi::c_long; 5usize],
    pub pc_device: *mut _device,
    pub pc_netisr: *mut ::core::ffi::c_void,
    pub pc_vfs_freevnodes: i8,
    pub pc_unused1: [::core::ffi::c_char; 3usize],
    pub pc_domain: ::core::ffi::c_int,
    pub pc_rm_queue: rm_queue,
    pub pc_dynamic: usize,
    pub pc_early_dummy_counter: u64,
    pub pc_zpcpu_offset: usize,
    pub pc_acpi_id: u_int,
    pub pc_midr: u_int,
    pub pc_clock: u64,
    pub pc_bp_harden: pcpu_bp_harden,
    pub pc_ssbd: pcpu_ssbd,
    pub pc_curpmap: *mut pmap,
    pub pc_curvmpmap: *mut pmap,
    pub pc_mpidr: u64,
    pub pc_bcast_tlbi_workaround: u_int,
    pub __pad: [::core::ffi::c_char; 197usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct pcpu__bindgen_ty_1 {
    pub stqe_next: *mut pcpu,
}
impl Default for pcpu__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for pcpu {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cpuhead {
    pub stqh_first: *mut pcpu,
    pub stqh_last: *mut *mut pcpu,
}
impl Default for cpuhead {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct thread_lite {
    pub pad_td_owepreempt: [u_char; 312usize],
    pub td_owepreempt: u_char,
    pub pad_td_pinned: [u_char; 67usize],
    pub td_pinned: ::core::ffi::c_int,
    pub pad_td_priority: [u_char; 634usize],
    pub td_priority: u_char,
    pub pad_td_critnest: [u_char; 257usize],
    pub td_critnest: u_int,
}
impl Default for thread_lite {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct inpcb {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct socket {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct tty {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct uio {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct _jmp_buf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct eventtimer {
    _unused: [u8; 0],
}
pub type cpu_tick_f = ::core::option::Option<unsafe extern "C" fn() -> u64>;
#[repr(C)]
#[derive(Debug)]
pub struct cdev {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct root_hold_token {
    pub flags: ::core::ffi::c_int,
    pub who: *const ::core::ffi::c_char,
    pub list: root_hold_token__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug)]
pub struct root_hold_token__bindgen_ty_1 {
    pub tqe_next: *mut root_hold_token,
    pub tqe_prev: *mut *mut root_hold_token,
}
impl Default for root_hold_token__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for root_hold_token {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct unrhdr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct unrhdr64 {
    pub counter: u64,
}
#[repr(C)]
#[derive(Debug)]
pub struct sbuf {
    _unused: [u8; 0],
}
pub type send_event_f = ::core::option::Option<
    unsafe extern "C" fn(
        system: *const ::core::ffi::c_char,
        subsystem: *const ::core::ffi::c_char,
        type_: *const ::core::ffi::c_char,
        data: *const ::core::ffi::c_char,
    ),
>;
#[doc = " Device name parsers.  Hook to allow device enumerators to map\n scheme-specific names to a device."]
pub type dev_lookup_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::core::ffi::c_void,
        name: *const ::core::ffi::c_char,
        result: *mut device_t,
    ),
>;
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_dev_lookup {
    pub ee: eventhandler_entry,
    pub eh_func: dev_lookup_fn,
}
impl Default for eventhandler_entry_dev_lookup {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct __hack {
    _unused: [u8; 0],
}
#[doc = " @brief A device driver.\n\n Provides an abstraction layer for driver dispatch."]
pub type driver_t = kobj_class;
#[repr(C)]
#[derive(Debug)]
pub struct devclass {
    _unused: [u8; 0],
}
#[doc = " @brief A device class\n\n The devclass object has two main functions in the system. The first\n is to manage the allocation of unit numbers for device instances\n and the second is to hold the list of device drivers for a\n particular bus type. Each devclass has a name and there cannot be\n two devclasses with the same name. This ensures that unique unit\n numbers are allocated to device instances.\n\n Drivers that support several different bus attachments (e.g. isa,\n pci, pccard) should all use the same devclass to ensure that unit\n numbers do not conflict.\n\n Each devclass may also have a parent devclass. This is used when\n searching for device drivers to allow a form of inheritance. When\n matching drivers with devices, first the driver list of the parent\n device's devclass is searched. If no driver is found in that list,\n the search continues in the parent devclass (if any)."]
pub type devclass_t = *mut devclass;
#[doc = " @brief Driver interrupt service routines\n\n The filter routine is run in primary interrupt context and may not\n block or use regular mutexes.  It may only use spin mutexes for\n synchronization.  The filter may either completely handle the\n interrupt or it may perform some of the work and defer more\n expensive work to the regular interrupt handler.  If a filter\n routine is not registered by the driver, then the regular interrupt\n handler is always used to handle interrupts from this device.\n\n The regular interrupt handler executes in its own thread context\n and may use regular mutexes.  However, it is prohibited from\n sleeping on a sleep queue."]
pub type driver_filter_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
>;
pub type driver_intr_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
pub const INTR_TYPE_TTY: intr_type = 1;
pub const INTR_TYPE_BIO: intr_type = 2;
pub const INTR_TYPE_NET: intr_type = 4;
pub const INTR_TYPE_CAM: intr_type = 8;
pub const INTR_TYPE_MISC: intr_type = 16;
pub const INTR_TYPE_CLK: intr_type = 32;
pub const INTR_TYPE_AV: intr_type = 64;
pub const INTR_EXCL: intr_type = 256;
pub const INTR_MPSAFE: intr_type = 512;
pub const INTR_ENTROPY: intr_type = 1024;
pub const INTR_SLEEPABLE: intr_type = 2048;
pub const INTR_MD1: intr_type = 4096;
pub const INTR_MD2: intr_type = 8192;
pub const INTR_MD3: intr_type = 16384;
pub const INTR_MD4: intr_type = 32768;
#[doc = " @brief Interrupt type bits.\n\n These flags may be passed by drivers to bus_setup_intr(9) when\n registering a new interrupt handler. The field is overloaded to\n specify both the interrupt's type and any special properties.\n\n The INTR_TYPE* bits will be passed to intr_priority(9) to determine\n the scheduling priority of the handler's ithread. Historically, each\n type was assigned a unique scheduling preference, but now only\n INTR_TYPE_CLK receives a default priority higher than other\n interrupts. See sys/priority.h.\n\n Buses may choose to modify or augment these flags as appropriate,\n e.g. nexus may apply INTR_EXCL."]
pub type intr_type = ::core::ffi::c_uint;
pub const INTR_TRIGGER_INVALID: intr_trigger = -1;
pub const INTR_TRIGGER_CONFORM: intr_trigger = 0;
pub const INTR_TRIGGER_EDGE: intr_trigger = 1;
pub const INTR_TRIGGER_LEVEL: intr_trigger = 2;
pub type intr_trigger = ::core::ffi::c_int;
pub const INTR_POLARITY_CONFORM: intr_polarity = 0;
pub const INTR_POLARITY_HIGH: intr_polarity = 1;
pub const INTR_POLARITY_LOW: intr_polarity = 2;
pub type intr_polarity = ::core::ffi::c_uint;
pub const LOCAL_CPUS: cpu_sets = 0;
pub const INTR_CPUS: cpu_sets = 1;
#[doc = " CPU sets supported by bus_get_cpus().  Note that not all sets may be\n supported for a given device.  If a request is not supported by a\n device (or its parents), then bus_get_cpus() will fail with EINVAL."]
pub type cpu_sets = ::core::ffi::c_uint;
#[doc = " @brief A resource mapping."]
#[repr(C)]
#[derive(Debug)]
pub struct resource_map {
    pub r_bustag: bus_space_tag_t,
    pub r_bushandle: bus_space_handle_t,
    pub r_size: bus_size_t,
    pub r_vaddr: *mut ::core::ffi::c_void,
}
impl Default for resource_map {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Optional properties of a resource mapping request."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct resource_map_request {
    pub size: usize,
    pub offset: rman_res_t,
    pub length: rman_res_t,
    pub memattr: vm_memattr_t,
}
#[doc = " @brief An entry for a single resource in a resource list."]
#[repr(C)]
#[derive(Debug)]
pub struct resource_list_entry {
    pub link: resource_list_entry__bindgen_ty_1,
    #[doc = "< @brief type argument to alloc_resource"]
    pub type_: ::core::ffi::c_int,
    #[doc = "< @brief resource identifier"]
    pub rid: ::core::ffi::c_int,
    #[doc = "< @brief resource flags"]
    pub flags: ::core::ffi::c_int,
    #[doc = "< @brief the real resource when allocated"]
    pub res: *mut resource,
    #[doc = "< @brief start of resource range"]
    pub start: rman_res_t,
    #[doc = "< @brief end of resource range"]
    pub end: rman_res_t,
    #[doc = "< @brief count within range"]
    pub count: rman_res_t,
}
#[repr(C)]
#[derive(Debug)]
pub struct resource_list_entry__bindgen_ty_1 {
    pub stqe_next: *mut resource_list_entry,
}
impl Default for resource_list_entry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for resource_list_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct resource_list {
    pub stqh_first: *mut resource_list_entry,
    pub stqh_last: *mut *mut resource_list_entry,
}
impl Default for resource_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct resource_spec {
    pub type_: ::core::ffi::c_int,
    pub rid: ::core::ffi::c_int,
    pub flags: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct sysctl_ctx_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct sysctl_oid {
    _unused: [u8; 0],
}
#[doc = " @brief A function implementing the DEVICE_PROBE() method"]
pub type device_probe_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t) -> ::core::ffi::c_int>;
#[doc = " @brief A function implementing the DEVICE_IDENTIFY() method"]
pub type device_identify_t =
    ::core::option::Option<unsafe extern "C" fn(driver: *mut driver_t, parent: device_t)>;
#[doc = " @brief A function implementing the DEVICE_ATTACH() method"]
pub type device_attach_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t) -> ::core::ffi::c_int>;
#[doc = " @brief A function implementing the DEVICE_DETACH() method"]
pub type device_detach_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t) -> ::core::ffi::c_int>;
#[doc = " @brief A function implementing the DEVICE_SHUTDOWN() method"]
pub type device_shutdown_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t) -> ::core::ffi::c_int>;
#[doc = " @brief A function implementing the DEVICE_SUSPEND() method"]
pub type device_suspend_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t) -> ::core::ffi::c_int>;
#[doc = " @brief A function implementing the DEVICE_RESUME() method"]
pub type device_resume_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t) -> ::core::ffi::c_int>;
#[doc = " @brief A function implementing the DEVICE_QUIESCE() method"]
pub type device_quiesce_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t) -> ::core::ffi::c_int>;
#[doc = " @brief A function implementing the DEVICE_REGISTER() method"]
pub type device_register_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t) -> *mut ::core::ffi::c_void>;
#[doc = " @brief A function implementing the BUS_PRINT_CHILD() method"]
pub type bus_print_child_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_PROBE_NOMATCH() method"]
pub type bus_probe_nomatch_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t, _child: device_t)>;
#[doc = " @brief A function implementing the BUS_READ_IVAR() method"]
pub type bus_read_ivar_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _index: ::core::ffi::c_int,
        _result: *mut usize,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_WRITE_IVAR() method"]
pub type bus_write_ivar_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _indx: ::core::ffi::c_int,
        _value: usize,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_CHILD_DELETED() method"]
pub type bus_child_deleted_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t, _child: device_t)>;
#[doc = " @brief A function implementing the BUS_CHILD_DETACHED() method"]
pub type bus_child_detached_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t, _child: device_t)>;
#[doc = " @brief A function implementing the BUS_DRIVER_ADDED() method"]
pub type bus_driver_added_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t, _driver: *mut driver_t)>;
#[doc = " @brief A function implementing the BUS_ADD_CHILD() method"]
pub type bus_add_child_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _order: u_int,
        _name: *const ::core::ffi::c_char,
        _unit: ::core::ffi::c_int,
    ) -> device_t,
>;
#[doc = " @brief A function implementing the BUS_RESCAN() method"]
pub type bus_rescan_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t) -> ::core::ffi::c_int>;
#[doc = " @brief A function implementing the BUS_ALLOC_RESOURCE() method"]
pub type bus_alloc_resource_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _type: ::core::ffi::c_int,
        _rid: *mut ::core::ffi::c_int,
        _start: rman_res_t,
        _end: rman_res_t,
        _count: rman_res_t,
        _flags: u_int,
    ) -> *mut resource,
>;
#[doc = " @brief A function implementing the BUS_ACTIVATE_RESOURCE() method"]
pub type bus_activate_resource_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t, _r: *mut resource) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_MAP_RESOURCE() method"]
pub type bus_map_resource_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _r: *mut resource,
        _args: *mut resource_map_request,
        _map: *mut resource_map,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_UNMAP_RESOURCE() method"]
pub type bus_unmap_resource_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _r: *mut resource,
        _map: *mut resource_map,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_DEACTIVATE_RESOURCE() method"]
pub type bus_deactivate_resource_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t, _r: *mut resource) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_ADJUST_RESOURCE() method"]
pub type bus_adjust_resource_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _res: *mut resource,
        _start: rman_res_t,
        _end: rman_res_t,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_TRANSLATE_RESOURCE() method"]
pub type bus_translate_resource_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _type: ::core::ffi::c_int,
        _start: rman_res_t,
        _newstart: *mut rman_res_t,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_RELEASE_RESOURCE() method"]
pub type bus_release_resource_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _res: *mut resource,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_SETUP_INTR() method"]
pub type bus_setup_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _irq: *mut resource,
        _flags: ::core::ffi::c_int,
        _filter: driver_filter_t,
        _intr: driver_intr_t,
        _arg: *mut ::core::ffi::c_void,
        _cookiep: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_TEARDOWN_INTR() method"]
pub type bus_teardown_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _irq: *mut resource,
        _cookie: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_SUSPEND_INTR() method"]
pub type bus_suspend_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _irq: *mut resource,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_RESUME_INTR() method"]
pub type bus_resume_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _irq: *mut resource,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_SET_RESOURCE() method"]
pub type bus_set_resource_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _type: ::core::ffi::c_int,
        _rid: ::core::ffi::c_int,
        _start: rman_res_t,
        _count: rman_res_t,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_GET_RESOURCE() method"]
pub type bus_get_resource_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _type: ::core::ffi::c_int,
        _rid: ::core::ffi::c_int,
        _startp: *mut rman_res_t,
        _countp: *mut rman_res_t,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_DELETE_RESOURCE() method"]
pub type bus_delete_resource_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _type: ::core::ffi::c_int,
        _rid: ::core::ffi::c_int,
    ),
>;
#[doc = " @brief A function implementing the BUS_GET_RESOURCE_LIST() method"]
pub type bus_get_resource_list_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t) -> *mut resource_list,
>;
#[doc = " @brief A function implementing the BUS_GET_RMAN() method"]
pub type bus_get_rman_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _type: ::core::ffi::c_int, _flags: u_int) -> *mut rman,
>;
#[doc = " @brief A function implementing the BUS_CHILD_PRESENT() method"]
pub type bus_child_present_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_CHILD_PNPINFO() method"]
pub type bus_child_pnpinfo_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t, _sb: *mut sbuf) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_CHILD_LOCATION() method"]
pub type bus_child_location_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t, _sb: *mut sbuf) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_BIND_INTR() method"]
pub type bus_bind_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _irq: *mut resource,
        _cpu: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_CONFIG_INTR() method"]
pub type bus_config_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _irq: ::core::ffi::c_int,
        _trig: intr_trigger,
        _pol: intr_polarity,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_DESCRIBE_INTR() method"]
pub type bus_describe_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _irq: *mut resource,
        _cookie: *mut ::core::ffi::c_void,
        _descr: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_HINTED_CHILD() method"]
pub type bus_hinted_child_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _dname: *const ::core::ffi::c_char,
        _dunit: ::core::ffi::c_int,
    ),
>;
#[doc = " @brief A function implementing the BUS_GET_DMA_TAG() method"]
pub type bus_get_dma_tag_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t, _child: device_t) -> bus_dma_tag_t>;
#[doc = " @brief A function implementing the BUS_GET_BUS_TAG() method"]
pub type bus_get_bus_tag_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t) -> bus_space_tag_t,
>;
#[doc = " @brief A function implementing the BUS_HINT_DEVICE_UNIT() method"]
pub type bus_hint_device_unit_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _name: *const ::core::ffi::c_char,
        _unitp: *mut ::core::ffi::c_int,
    ),
>;
#[doc = " @brief A function implementing the BUS_NEW_PASS() method"]
pub type bus_new_pass_t = ::core::option::Option<unsafe extern "C" fn(_dev: device_t)>;
#[doc = " @brief A function implementing the BUS_REMAP_INTR() method"]
pub type bus_remap_intr_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t, _irq: u_int) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_SUSPEND_CHILD() method"]
pub type bus_suspend_child_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_RESUME_CHILD() method"]
pub type bus_resume_child_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_GET_DOMAIN() method"]
pub type bus_get_domain_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _domain: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_GET_CPUS() method"]
pub type bus_get_cpus_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _op: cpu_sets,
        _setsize: usize,
        _cpuset: *mut _cpuset,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_RESET_PREPARE() method"]
pub type bus_reset_prepare_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_RESET_POST() method"]
pub type bus_reset_post_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_RESET_CHILD() method"]
pub type bus_reset_child_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_GET_PROPERTY() method"]
pub type bus_get_property_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _propname: *const ::core::ffi::c_char,
        _propvalue: *mut ::core::ffi::c_void,
        _size: usize,
        type_: device_property_type_t,
    ) -> isize,
>;
#[doc = " @brief A function implementing the BUS_GET_DEVICE_PATH() method"]
pub type bus_get_device_path_t = ::core::option::Option<
    unsafe extern "C" fn(
        _bus: device_t,
        _child: device_t,
        _locator: *const ::core::ffi::c_char,
        _sb: *mut sbuf,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug)]
pub struct module {
    _unused: [u8; 0],
}
#[doc = " Module support for automatically adding drivers to buses."]
#[repr(C)]
#[derive(Debug)]
pub struct driver_module_data {
    pub dmd_chainevh: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut module,
            arg2: ::core::ffi::c_int,
            arg3: *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    pub dmd_chainarg: *mut ::core::ffi::c_void,
    pub dmd_busname: *const ::core::ffi::c_char,
    pub dmd_driver: kobj_class_t,
    pub dmd_devclass: *mut devclass_t,
    pub dmd_pass: ::core::ffi::c_int,
}
impl Default for driver_module_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct device_location_cache {
    _unused: [u8; 0],
}
pub type device_location_cache_t = device_location_cache;
pub type device_prop_dtr_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: device_t,
        name: *const ::core::ffi::c_char,
        val: *mut ::core::ffi::c_void,
        dtr_ctx: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug)]
pub struct setlist {
    pub lh_first: *mut cpuset,
}
impl Default for setlist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cpuset {
    pub cs_ref: u_int,
    pub cs_flags: ::core::ffi::c_int,
    pub cs_link: cpuset__bindgen_ty_1,
    pub cs_siblings: cpuset__bindgen_ty_2,
    pub cs_children: setlist,
    pub cs_domain: *mut domainset,
    pub cs_id: cpusetid_t,
    pub cs_parent: *mut cpuset,
    pub cs_mask: cpuset_t,
}
#[repr(C)]
#[derive(Debug)]
pub struct cpuset__bindgen_ty_1 {
    pub le_next: *mut cpuset,
    pub le_prev: *mut *mut cpuset,
}
impl Default for cpuset__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cpuset__bindgen_ty_2 {
    pub le_next: *mut cpuset,
    pub le_prev: *mut *mut cpuset,
}
impl Default for cpuset__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for cpuset {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct prison {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct cpuset_copy_cb {
    pub cpuset_copyin: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::core::ffi::c_void,
            arg2: *mut ::core::ffi::c_void,
            arg3: usize,
        ) -> ::core::ffi::c_int,
    >,
    pub cpuset_copyout: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::core::ffi::c_void,
            arg2: *mut ::core::ffi::c_void,
            arg3: usize,
        ) -> ::core::ffi::c_int,
    >,
}
pub type ihandle_t = u32;
pub type phandle_t = u32;
pub type pcell_t = u32;
#[repr(C)]
#[derive(Debug, Default)]
pub struct malloc_type_stats {
    pub mts_memalloced: u64,
    pub mts_memfreed: u64,
    pub mts_numallocs: u64,
    pub mts_numfrees: u64,
    pub mts_size: u64,
    pub _mts_reserved1: u64,
    pub _mts_reserved2: u64,
    pub _mts_reserved3: u64,
}
#[repr(C)]
#[derive(Debug)]
pub struct malloc_type_internal {
    pub mti_probes: [u32; 2usize],
    pub mti_zone: u_char,
    pub mti_stats: *mut malloc_type_stats,
    pub mti_spare: [u_long; 8usize],
}
impl Default for malloc_type_internal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct malloc_type {
    pub ks_next: *mut malloc_type,
    pub ks_version: u_long,
    pub ks_shortdesc: *const ::core::ffi::c_char,
    pub ks_mti: malloc_type_internal,
}
impl Default for malloc_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct malloc_type_stream_header {
    pub mtsh_version: u32,
    pub mtsh_maxcpus: u32,
    pub mtsh_count: u32,
    pub _mtsh_pad: u32,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct malloc_type_header {
    pub mth_name: [::core::ffi::c_char; 32usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct domainset {
    _unused: [u8; 0],
}
pub type malloc_type_list_func_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut malloc_type, arg2: *mut ::core::ffi::c_void),
>;
pub type vm_inherit_t = ::core::ffi::c_char;
pub type vm_prot_t = u_char;
pub const OBJT_RESERVED: obj_type = 0;
pub const OBJT_SWAP: obj_type = 1;
pub const OBJT_DEFAULT: obj_type = 1;
pub const OBJT_VNODE: obj_type = 2;
pub const OBJT_DEVICE: obj_type = 3;
pub const OBJT_PHYS: obj_type = 4;
pub const OBJT_DEAD: obj_type = 5;
pub const OBJT_SG: obj_type = 6;
pub const OBJT_MGTDEVICE: obj_type = 7;
pub const OBJT_FIRST_DYN: obj_type = 8;
pub type obj_type = ::core::ffi::c_uint;
pub type objtype_t = u_char;
#[repr(C)]
pub struct vm_map_object {
    _unused: [u8; 0],
}
pub type vm_map_object_t = vm_map_object;
#[repr(C)]
#[derive(Debug)]
pub struct vm_map_entry {
    _unused: [u8; 0],
}
pub type vm_map_entry_t = *mut vm_map_entry;
#[repr(C)]
#[derive(Debug)]
pub struct vm_map {
    _unused: [u8; 0],
}
pub type vm_map_t = *mut vm_map;
#[repr(C)]
#[derive(Debug)]
pub struct vm_object {
    _unused: [u8; 0],
}
pub type vm_object_t = *mut vm_object;
#[repr(C)]
#[derive(Debug)]
pub struct vm_reserv {
    _unused: [u8; 0],
}
pub type vm_reserv_t = *mut vm_reserv;
#[repr(C)]
#[derive(Debug, Default)]
pub struct kva_md_info {
    pub buffer_sva: vm_offset_t,
    pub buffer_eva: vm_offset_t,
    pub clean_sva: vm_offset_t,
    pub clean_eva: vm_offset_t,
}
pub type cell_t = u32;
#[repr(C)]
#[derive(Debug, Default)]
pub struct mem_region {
    pub mr_start: vm_offset_t,
    pub mr_size: vm_size_t,
}
pub const INTR_MAP_DATA_ACPI: intr_map_data_type = 0;
pub const INTR_MAP_DATA_FDT: intr_map_data_type = 1;
pub const INTR_MAP_DATA_GPIO: intr_map_data_type = 2;
pub const INTR_MAP_DATA_MSI: intr_map_data_type = 3;
pub const INTR_MAP_DATA_PLAT_1: intr_map_data_type = 1000;
pub const INTR_MAP_DATA_PLAT_2: intr_map_data_type = 1001;
pub const INTR_MAP_DATA_PLAT_3: intr_map_data_type = 1002;
pub const INTR_MAP_DATA_PLAT_4: intr_map_data_type = 1003;
pub const INTR_MAP_DATA_PLAT_5: intr_map_data_type = 1004;
pub type intr_map_data_type = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct intr_map_data {
    pub len: usize,
    pub type_: intr_map_data_type,
}
impl Default for intr_map_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct intr_map_data_msi {
    pub hdr: intr_map_data,
    pub isrc: *mut intr_irqsrc,
}
impl Default for intr_map_data_msi {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type intr_irq_filter_t = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
>;
pub type intr_child_irq_filter_t = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, irq: usize) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug)]
pub struct intr_pic {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct intr_irqsrc {
    pub isrc_dev: device_t,
    pub isrc_irq: u_int,
    pub isrc_flags: u_int,
    pub isrc_name: [::core::ffi::c_char; 20usize],
    pub isrc_cpu: cpuset_t,
    pub isrc_index: u_int,
    pub isrc_count: *mut u_long,
    pub isrc_handlers: u_int,
    pub isrc_event: *mut intr_event,
    pub isrc_iommu: *mut ::core::ffi::c_void,
}
impl Default for intr_irqsrc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type intr_ipi_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
pub const SI_SUB_DUMMY: sysinit_sub_id = 0;
pub const SI_SUB_TUNABLES: sysinit_sub_id = 7340032;
pub const SI_SUB_COPYRIGHT: sysinit_sub_id = 8388609;
pub const SI_SUB_VM: sysinit_sub_id = 16777216;
pub const SI_SUB_COUNTER: sysinit_sub_id = 17825792;
pub const SI_SUB_KMEM: sysinit_sub_id = 25165824;
pub const SI_SUB_HYPERVISOR: sysinit_sub_id = 27525120;
pub const SI_SUB_WITNESS: sysinit_sub_id = 27787264;
pub const SI_SUB_MTX_POOL_DYNAMIC: sysinit_sub_id = 28049408;
pub const SI_SUB_LOCK: sysinit_sub_id = 28311552;
pub const SI_SUB_EVENTHANDLER: sysinit_sub_id = 29360128;
pub const SI_SUB_VNET_PRELINK: sysinit_sub_id = 31457280;
pub const SI_SUB_KLD: sysinit_sub_id = 33554432;
pub const SI_SUB_KHELP: sysinit_sub_id = 34078720;
pub const SI_SUB_CPU: sysinit_sub_id = 34603008;
pub const SI_SUB_RACCT: sysinit_sub_id = 34668544;
pub const SI_SUB_KDTRACE: sysinit_sub_id = 34865152;
pub const SI_SUB_RANDOM: sysinit_sub_id = 34996224;
pub const SI_SUB_MAC: sysinit_sub_id = 35127296;
pub const SI_SUB_MAC_POLICY: sysinit_sub_id = 35389440;
pub const SI_SUB_MAC_LATE: sysinit_sub_id = 35454976;
pub const SI_SUB_VNET: sysinit_sub_id = 35520512;
pub const SI_SUB_INTRINSIC: sysinit_sub_id = 35651584;
pub const SI_SUB_VM_CONF: sysinit_sub_id = 36700160;
pub const SI_SUB_DDB_SERVICES: sysinit_sub_id = 37224448;
pub const SI_SUB_RUN_QUEUE: sysinit_sub_id = 37748736;
pub const SI_SUB_KTRACE: sysinit_sub_id = 38273024;
pub const SI_SUB_OPENSOLARIS: sysinit_sub_id = 38338560;
pub const SI_SUB_AUDIT: sysinit_sub_id = 38535168;
pub const SI_SUB_CREATE_INIT: sysinit_sub_id = 38797312;
pub const SI_SUB_SCHED_IDLE: sysinit_sub_id = 39845888;
pub const SI_SUB_MBUF: sysinit_sub_id = 40894464;
pub const SI_SUB_INTR: sysinit_sub_id = 41943040;
pub const SI_SUB_TASKQ: sysinit_sub_id = 42467328;
pub const SI_SUB_EPOCH: sysinit_sub_id = 42500096;
pub const SI_SUB_SOFTINTR: sysinit_sub_id = 44040192;
pub const SI_SUB_DEVFS: sysinit_sub_id = 49283072;
pub const SI_SUB_INIT_IF: sysinit_sub_id = 50331648;
pub const SI_SUB_NETGRAPH: sysinit_sub_id = 50397184;
pub const SI_SUB_DTRACE: sysinit_sub_id = 50462720;
pub const SI_SUB_DTRACE_PROVIDER: sysinit_sub_id = 50626560;
pub const SI_SUB_DTRACE_ANON: sysinit_sub_id = 50905088;
pub const SI_SUB_DRIVERS: sysinit_sub_id = 51380224;
pub const SI_SUB_CONFIGURE: sysinit_sub_id = 58720256;
pub const SI_SUB_VFS: sysinit_sub_id = 67108864;
pub const SI_SUB_CLOCKS: sysinit_sub_id = 75497472;
pub const SI_SUB_SYSV_SHM: sysinit_sub_id = 104857600;
pub const SI_SUB_SYSV_SEM: sysinit_sub_id = 109051904;
pub const SI_SUB_SYSV_MSG: sysinit_sub_id = 113246208;
pub const SI_SUB_P1003_1B: sysinit_sub_id = 115343360;
pub const SI_SUB_PSEUDO: sysinit_sub_id = 117440512;
pub const SI_SUB_EXEC: sysinit_sub_id = 121634816;
pub const SI_SUB_PROTO_BEGIN: sysinit_sub_id = 134217728;
pub const SI_SUB_PROTO_PFIL: sysinit_sub_id = 135266304;
pub const SI_SUB_PROTO_IF: sysinit_sub_id = 138412032;
pub const SI_SUB_PROTO_DOMAININIT: sysinit_sub_id = 140509184;
pub const SI_SUB_PROTO_MC: sysinit_sub_id = 141557760;
pub const SI_SUB_PROTO_DOMAIN: sysinit_sub_id = 142606336;
pub const SI_SUB_PROTO_FIREWALL: sysinit_sub_id = 142630912;
pub const SI_SUB_PROTO_IFATTACHDOMAIN: sysinit_sub_id = 142639104;
pub const SI_SUB_PROTO_END: sysinit_sub_id = 150994943;
pub const SI_SUB_KPROF: sysinit_sub_id = 150994944;
pub const SI_SUB_KICK_SCHEDULER: sysinit_sub_id = 167772160;
pub const SI_SUB_INT_CONFIG_HOOKS: sysinit_sub_id = 176160768;
pub const SI_SUB_ROOT_CONF: sysinit_sub_id = 184549376;
pub const SI_SUB_INTRINSIC_POST: sysinit_sub_id = 218103808;
pub const SI_SUB_SYSCALLS: sysinit_sub_id = 226492416;
pub const SI_SUB_VNET_DONE: sysinit_sub_id = 230686720;
pub const SI_SUB_KTHREAD_INIT: sysinit_sub_id = 234881024;
pub const SI_SUB_KTHREAD_PAGE: sysinit_sub_id = 239075328;
pub const SI_SUB_KTHREAD_VM: sysinit_sub_id = 243269632;
pub const SI_SUB_KTHREAD_BUF: sysinit_sub_id = 245366784;
pub const SI_SUB_KTHREAD_UPDATE: sysinit_sub_id = 247463936;
pub const SI_SUB_KTHREAD_IDLE: sysinit_sub_id = 249561088;
pub const SI_SUB_SMP: sysinit_sub_id = 251658240;
pub const SI_SUB_RACCTD: sysinit_sub_id = 252706816;
pub const SI_SUB_LAST: sysinit_sub_id = 268435455;
pub type sysinit_sub_id = ::core::ffi::c_uint;
pub const SI_ORDER_FIRST: sysinit_elem_order = 0;
pub const SI_ORDER_SECOND: sysinit_elem_order = 1;
pub const SI_ORDER_THIRD: sysinit_elem_order = 2;
pub const SI_ORDER_FOURTH: sysinit_elem_order = 3;
pub const SI_ORDER_FIFTH: sysinit_elem_order = 4;
pub const SI_ORDER_SIXTH: sysinit_elem_order = 5;
pub const SI_ORDER_SEVENTH: sysinit_elem_order = 6;
pub const SI_ORDER_EIGHTH: sysinit_elem_order = 7;
pub const SI_ORDER_MIDDLE: sysinit_elem_order = 16777216;
pub const SI_ORDER_ANY: sysinit_elem_order = 268435455;
pub type sysinit_elem_order = ::core::ffi::c_uint;
pub type sysinit_nfunc_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
pub type sysinit_cfunc_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *const ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug)]
pub struct sysinit {
    pub subsystem: sysinit_sub_id,
    pub order: sysinit_elem_order,
    pub next: sysinit__bindgen_ty_1,
    pub func: sysinit_cfunc_t,
    pub udata: *const ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug)]
pub struct sysinit__bindgen_ty_1 {
    pub stqe_next: *mut sysinit,
}
impl Default for sysinit__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sysinit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct tunable_int {
    pub path: *const ::core::ffi::c_char,
    pub var: *mut ::core::ffi::c_int,
}
impl Default for tunable_int {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct tunable_long {
    pub path: *const ::core::ffi::c_char,
    pub var: *mut ::core::ffi::c_long,
}
impl Default for tunable_long {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct tunable_ulong {
    pub path: *const ::core::ffi::c_char,
    pub var: *mut ::core::ffi::c_ulong,
}
impl Default for tunable_ulong {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct tunable_int64 {
    pub path: *const ::core::ffi::c_char,
    pub var: *mut i64,
}
impl Default for tunable_int64 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct tunable_uint64 {
    pub path: *const ::core::ffi::c_char,
    pub var: *mut u64,
}
impl Default for tunable_uint64 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct tunable_quad {
    pub path: *const ::core::ffi::c_char,
    pub var: *mut quad_t,
}
impl Default for tunable_quad {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct tunable_bool {
    pub path: *const ::core::ffi::c_char,
    pub var: *mut bool_,
}
impl Default for tunable_bool {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct tunable_str {
    pub path: *const ::core::ffi::c_char,
    pub var: *mut ::core::ffi::c_char,
    pub size: ::core::ffi::c_int,
}
impl Default for tunable_str {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ich_func_t = ::core::option::Option<unsafe extern "C" fn(_arg: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug)]
pub struct intr_config_hook {
    pub ich_links: intr_config_hook__bindgen_ty_1,
    pub ich_state: usize,
    pub ich_func: ich_func_t,
    pub ich_arg: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug)]
pub struct intr_config_hook__bindgen_ty_1 {
    pub stqe_next: *mut intr_config_hook,
}
impl Default for intr_config_hook__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for intr_config_hook {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct lock_list_entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct lock_class {
    pub lc_name: *const ::core::ffi::c_char,
    pub lc_flags: u_int,
    pub lc_assert: ::core::option::Option<
        unsafe extern "C" fn(lock: *const lock_object, what: ::core::ffi::c_int),
    >,
    pub lc_ddb_show: ::core::option::Option<unsafe extern "C" fn(lock: *const lock_object)>,
    pub lc_lock: ::core::option::Option<unsafe extern "C" fn(lock: *mut lock_object, how: usize)>,
    pub lc_owner: ::core::option::Option<
        unsafe extern "C" fn(
            lock: *const lock_object,
            owner: *mut *mut thread,
        ) -> ::core::ffi::c_int,
    >,
    pub lc_unlock: ::core::option::Option<unsafe extern "C" fn(lock: *mut lock_object) -> usize>,
    pub lc_trylock: ::core::option::Option<
        unsafe extern "C" fn(lock: *mut lock_object, how: usize) -> ::core::ffi::c_int,
    >,
}
impl Default for lock_class {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct lock_delay_config {
    pub base: u_short,
    pub max: u_short,
}
#[repr(C)]
#[derive(Debug)]
pub struct lock_delay_arg {
    pub config: *mut lock_delay_config,
    pub delay: u_int,
    pub spin_cnt: u_int,
}
impl Default for lock_delay_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const MOD_LOAD: modeventtype = 0;
pub const MOD_UNLOAD: modeventtype = 1;
pub const MOD_SHUTDOWN: modeventtype = 2;
pub const MOD_QUIESCE: modeventtype = 3;
pub type modeventtype = ::core::ffi::c_uint;
pub use self::modeventtype as modeventtype_t;
pub type module_t = *mut module;
pub type modeventhand_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: module_t,
        arg2: ::core::ffi::c_int,
        arg3: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug)]
pub struct moduledata {
    pub name: *const ::core::ffi::c_char,
    pub evhand: modeventhand_t,
    pub priv_: *mut ::core::ffi::c_void,
}
impl Default for moduledata {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type moduledata_t = moduledata;
#[repr(C)]
pub struct modspecific {
    pub intval: __BindgenUnionField<::core::ffi::c_int>,
    pub uintval: __BindgenUnionField<u_int>,
    pub longval: __BindgenUnionField<::core::ffi::c_long>,
    pub ulongval: __BindgenUnionField<u_long>,
    pub bindgen_union_field: u64,
}
impl Default for modspecific {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type modspecific_t = modspecific;
#[repr(C)]
#[derive(Debug, Default)]
pub struct mod_depend {
    pub md_ver_minimum: ::core::ffi::c_int,
    pub md_ver_preferred: ::core::ffi::c_int,
    pub md_ver_maximum: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct mod_version {
    pub mv_version: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct mod_metadata {
    pub md_version: ::core::ffi::c_int,
    pub md_type: ::core::ffi::c_int,
    pub md_data: *const ::core::ffi::c_void,
    pub md_cval: *const ::core::ffi::c_char,
}
impl Default for mod_metadata {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct mod_pnp_match_info {
    pub descr: *const ::core::ffi::c_char,
    pub bus: *const ::core::ffi::c_char,
    pub table: *const ::core::ffi::c_void,
    pub entry_len: ::core::ffi::c_int,
    pub num_entry: ::core::ffi::c_int,
}
impl Default for mod_pnp_match_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct linker_file {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct module_stat {
    pub version: ::core::ffi::c_int,
    pub name: [::core::ffi::c_char; 1024usize],
    pub refs: ::core::ffi::c_int,
    pub id: ::core::ffi::c_int,
    pub data: modspecific_t,
}
impl Default for module_stat {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct lock_profile_object {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct lpohead {
    pub lh_first: *mut lock_profile_object,
}
impl Default for lpohead {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct sdt_tracepoint {
    pub probe: *mut sdt_probe,
    pub patchpoint: usize,
    pub target: usize,
    pub tracepoint_entry: sdt_tracepoint__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug)]
pub struct sdt_tracepoint__bindgen_ty_1 {
    pub stqe_next: *mut sdt_tracepoint,
}
impl Default for sdt_tracepoint__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sdt_tracepoint {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sdt_probe_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: u32,
        arg0: usize,
        arg1: usize,
        arg2: usize,
        arg3: usize,
        arg4: usize,
        arg5: usize,
    ),
>;
#[repr(C)]
#[derive(Debug)]
pub struct sdt_argtype {
    pub ndx: ::core::ffi::c_int,
    pub type_: *const ::core::ffi::c_char,
    pub xtype: *const ::core::ffi::c_char,
    pub argtype_entry: sdt_argtype__bindgen_ty_1,
    pub probe: *mut sdt_probe,
}
#[repr(C)]
#[derive(Debug)]
pub struct sdt_argtype__bindgen_ty_1 {
    pub tqe_next: *mut sdt_argtype,
    pub tqe_prev: *mut *mut sdt_argtype,
}
impl Default for sdt_argtype__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sdt_argtype {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct sdt_probe {
    pub version: ::core::ffi::c_int,
    pub prov: *mut sdt_provider,
    pub probe_entry: sdt_probe__bindgen_ty_1,
    pub argtype_list: sdt_probe__bindgen_ty_2,
    pub tracepoint_list: sdt_probe__bindgen_ty_3,
    pub mod_: *const ::core::ffi::c_char,
    pub func: *const ::core::ffi::c_char,
    pub name: *const ::core::ffi::c_char,
    pub id: id_t,
    pub n_args: ::core::ffi::c_int,
    pub sdtp_lf: *mut linker_file,
}
#[repr(C)]
#[derive(Debug)]
pub struct sdt_probe__bindgen_ty_1 {
    pub tqe_next: *mut sdt_probe,
    pub tqe_prev: *mut *mut sdt_probe,
}
impl Default for sdt_probe__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct sdt_probe__bindgen_ty_2 {
    pub tqh_first: *mut sdt_argtype,
    pub tqh_last: *mut *mut sdt_argtype,
}
impl Default for sdt_probe__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct sdt_probe__bindgen_ty_3 {
    pub stqh_first: *mut sdt_tracepoint,
    pub stqh_last: *mut *mut sdt_tracepoint,
}
impl Default for sdt_probe__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sdt_probe {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct sdt_provider {
    pub name: *mut ::core::ffi::c_char,
    pub prov_entry: sdt_provider__bindgen_ty_1,
    pub id: usize,
    pub sdt_refs: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct sdt_provider__bindgen_ty_1 {
    pub tqe_next: *mut sdt_provider,
    pub tqe_prev: *mut *mut sdt_provider,
}
impl Default for sdt_provider__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sdt_provider {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct mtx_pool {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct mtx_args {
    pub ma_mtx: *mut ::core::ffi::c_void,
    pub ma_desc: *const ::core::ffi::c_char,
    pub ma_opts: ::core::ffi::c_int,
}
impl Default for mtx_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct kevent {
    pub ident: __uintptr_t,
    pub filter: ::core::ffi::c_short,
    pub flags: ::core::ffi::c_ushort,
    pub fflags: ::core::ffi::c_uint,
    pub data: __int64_t,
    pub udata: *mut ::core::ffi::c_void,
    pub ext: [__uint64_t; 4usize],
}
impl Default for kevent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct kevent32 {
    pub ident: __uint32_t,
    pub filter: ::core::ffi::c_short,
    pub flags: ::core::ffi::c_ushort,
    pub fflags: ::core::ffi::c_uint,
    pub pad0: __uint32_t,
    pub data1: __uint32_t,
    pub data2: __uint32_t,
    pub udata: __uint32_t,
    pub pad1: __uint32_t,
    pub ext64: [__uint32_t; 8usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct klist {
    pub slh_first: *mut knote,
}
impl Default for klist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct kqueue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct kqlist {
    pub tqh_first: *mut kqueue,
    pub tqh_last: *mut *mut kqueue,
}
impl Default for kqlist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct knlist {
    pub kl_list: klist,
    pub kl_lock: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
    pub kl_unlock: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
    pub kl_assert_lock: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: ::core::ffi::c_int),
    >,
    pub kl_lockarg: *mut ::core::ffi::c_void,
    pub kl_autodestroy: ::core::ffi::c_int,
}
impl Default for knlist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct kinfo_knote {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct filterops {
    pub f_isfd: ::core::ffi::c_int,
    pub f_attach:
        ::core::option::Option<unsafe extern "C" fn(kn: *mut knote) -> ::core::ffi::c_int>,
    pub f_detach: ::core::option::Option<unsafe extern "C" fn(kn: *mut knote)>,
    pub f_event: ::core::option::Option<
        unsafe extern "C" fn(kn: *mut knote, hint: ::core::ffi::c_long) -> ::core::ffi::c_int,
    >,
    pub f_touch: ::core::option::Option<
        unsafe extern "C" fn(kn: *mut knote, kev: *mut kevent, type_: u_long),
    >,
    pub f_userdump: ::core::option::Option<
        unsafe extern "C" fn(
            p: *mut proc_,
            kn: *mut knote,
            kin: *mut kinfo_knote,
        ) -> ::core::ffi::c_int,
    >,
    pub f_copy: ::core::option::Option<
        unsafe extern "C" fn(kn: *mut knote, p1: *mut proc_) -> ::core::ffi::c_int,
    >,
}
#[repr(C)]
pub struct knote {
    pub kn_link: knote__bindgen_ty_1,
    pub kn_selnext: knote__bindgen_ty_2,
    pub kn_knlist: *mut knlist,
    pub kn_tqe: knote__bindgen_ty_3,
    pub kn_kq: *mut kqueue,
    pub kn_kevent: kevent,
    pub kn_hook: *mut ::core::ffi::c_void,
    pub kn_hookid: ::core::ffi::c_int,
    pub kn_status: ::core::ffi::c_int,
    pub kn_influx: ::core::ffi::c_int,
    pub kn_sfflags: ::core::ffi::c_int,
    pub kn_sdata: i64,
    pub kn_ptr: knote__bindgen_ty_4,
    pub kn_fop: *const filterops,
}
#[repr(C)]
#[derive(Debug)]
pub struct knote__bindgen_ty_1 {
    pub sle_next: *mut knote,
}
impl Default for knote__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct knote__bindgen_ty_2 {
    pub sle_next: *mut knote,
}
impl Default for knote__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct knote__bindgen_ty_3 {
    pub tqe_next: *mut knote,
    pub tqe_prev: *mut *mut knote,
}
impl Default for knote__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct knote__bindgen_ty_4 {
    pub p_fp: __BindgenUnionField<*mut file>,
    pub p_proc: __BindgenUnionField<*mut proc_>,
    pub p_aio: __BindgenUnionField<*mut kaiocb>,
    pub p_lio: __BindgenUnionField<*mut aioliojob>,
    pub p_prison: __BindgenUnionField<*mut prison>,
    pub p_v: __BindgenUnionField<*mut ::core::ffi::c_void>,
    pub bindgen_union_field: u64,
}
impl Default for knote__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for knote {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct kevent_copyops {
    pub arg: *mut ::core::ffi::c_void,
    pub k_copyout: ::core::option::Option<
        unsafe extern "C" fn(
            arg: *mut ::core::ffi::c_void,
            kevp: *mut kevent,
            count: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub k_copyin: ::core::option::Option<
        unsafe extern "C" fn(
            arg: *mut ::core::ffi::c_void,
            kevp: *mut kevent,
            count: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub kevent_size: usize,
}
impl Default for kevent_copyops {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct rwlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct kexterr {
    pub error: ::core::ffi::c_int,
    pub msg: *const ::core::ffi::c_char,
    pub p1: __uint64_t,
    pub p2: __uint64_t,
    pub cat: ::core::ffi::c_uint,
    pub src_line: ::core::ffi::c_uint,
}
impl Default for kexterr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cv {
    pub cv_description: *const ::core::ffi::c_char,
    pub cv_waiters: ::core::ffi::c_int,
}
impl Default for cv {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct osd {
    pub osd_nslots: u_int,
    pub osd_slots: *mut *mut ::core::ffi::c_void,
    pub osd_next: osd__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug)]
pub struct osd__bindgen_ty_1 {
    pub le_next: *mut osd,
    pub le_prev: *mut *mut osd,
}
impl Default for osd__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for osd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type osd_destructor_t =
    ::core::option::Option<unsafe extern "C" fn(value: *mut ::core::ffi::c_void)>;
pub type osd_method_t = ::core::option::Option<
    unsafe extern "C" fn(
        obj: *mut ::core::ffi::c_void,
        data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Default)]
pub struct rtprio {
    pub type_: u_short,
    pub prio: u_short,
}
#[repr(C)]
pub struct sigio {
    pub sio_u: sigio__bindgen_ty_1,
    pub sio_pgsigio: sigio__bindgen_ty_2,
    pub sio_myref: *mut *mut sigio,
    pub sio_ucred: *mut ucred,
    pub sio_pgid: pid_t,
}
#[repr(C)]
pub struct sigio__bindgen_ty_1 {
    pub siu_proc: __BindgenUnionField<*mut proc_>,
    pub siu_pgrp: __BindgenUnionField<*mut pgrp>,
    pub bindgen_union_field: u64,
}
impl Default for sigio__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct sigio__bindgen_ty_2 {
    pub sle_next: *mut sigio,
}
impl Default for sigio__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sigio {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct sigiolst {
    pub slh_first: *mut sigio,
}
impl Default for sigiolst {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct sigacts {
    pub ps_sigact: [sig_t; 128usize],
    pub ps_catchmask: [sigset_t; 128usize],
    pub ps_sigonstack: sigset_t,
    pub ps_sigintr: sigset_t,
    pub ps_sigreset: sigset_t,
    pub ps_signodefer: sigset_t,
    pub ps_siginfo: sigset_t,
    pub ps_sigignore: sigset_t,
    pub ps_sigcatch: sigset_t,
    pub ps_freebsd4: sigset_t,
    pub ps_osigset: sigset_t,
    pub ps_usertramp: sigset_t,
    pub ps_flag: ::core::ffi::c_int,
    pub ps_refcnt: u_int,
    pub ps_mtx: mtx,
}
impl Default for sigacts {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ksiginfo {
    pub ksi_link: ksiginfo__bindgen_ty_1,
    pub ksi_info: siginfo_t,
    pub ksi_flags: ::core::ffi::c_int,
    pub ksi_sigq: *mut sigqueue,
}
#[repr(C)]
#[derive(Debug)]
pub struct ksiginfo__bindgen_ty_1 {
    pub tqe_next: *mut ksiginfo,
    pub tqe_prev: *mut *mut ksiginfo,
}
impl Default for ksiginfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ksiginfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ksiginfo_t = ksiginfo;
#[repr(C)]
#[derive(Debug)]
pub struct sigqueue {
    pub sq_signals: sigset_t,
    pub sq_kill: sigset_t,
    pub sq_ptrace: sigset_t,
    pub sq_list: sigqueue__bindgen_ty_1,
    pub sq_proc: *mut proc_,
    pub sq_flags: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct sigqueue__bindgen_ty_1 {
    pub tqh_first: *mut ksiginfo,
    pub tqh_last: *mut *mut ksiginfo,
}
impl Default for sigqueue__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sigqueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sigqueue_t = sigqueue;
pub type au_id_t = uid_t;
pub type au_asid_t = pid_t;
pub type au_event_t = u_int16_t;
pub type au_emod_t = u_int16_t;
pub type au_class_t = u_int32_t;
pub type au_asflgs_t = u_int64_t;
#[repr(C)]
#[derive(Debug, Default)]
pub struct au_tid {
    pub port: u_int32_t,
    pub machine: u_int32_t,
}
pub type au_tid_t = au_tid;
#[repr(C)]
#[derive(Debug, Default)]
pub struct au_tid_addr {
    pub at_port: u_int32_t,
    pub at_type: u_int32_t,
    pub at_addr: [u_int32_t; 4usize],
}
pub type au_tid_addr_t = au_tid_addr;
#[repr(C)]
#[derive(Debug, Default)]
pub struct au_mask {
    pub am_success: ::core::ffi::c_uint,
    pub am_failure: ::core::ffi::c_uint,
}
pub type au_mask_t = au_mask;
#[repr(C)]
#[derive(Debug, Default)]
pub struct auditinfo {
    pub ai_auid: au_id_t,
    pub ai_mask: au_mask_t,
    pub ai_termid: au_tid_t,
    pub ai_asid: au_asid_t,
}
pub type auditinfo_t = auditinfo;
#[repr(C)]
#[derive(Debug, Default)]
pub struct auditinfo_addr {
    pub ai_auid: au_id_t,
    pub ai_mask: au_mask_t,
    pub ai_termid: au_tid_addr_t,
    pub ai_asid: au_asid_t,
    pub ai_flags: au_asflgs_t,
}
pub type auditinfo_addr_t = auditinfo_addr;
#[repr(C)]
#[derive(Debug, Default)]
pub struct auditpinfo {
    pub ap_pid: pid_t,
    pub ap_auid: au_id_t,
    pub ap_mask: au_mask_t,
    pub ap_termid: au_tid_t,
    pub ap_asid: au_asid_t,
}
pub type auditpinfo_t = auditpinfo;
#[repr(C)]
#[derive(Debug, Default)]
pub struct auditpinfo_addr {
    pub ap_pid: pid_t,
    pub ap_auid: au_id_t,
    pub ap_mask: au_mask_t,
    pub ap_termid: au_tid_addr_t,
    pub ap_asid: au_asid_t,
    pub ap_flags: au_asflgs_t,
}
pub type auditpinfo_addr_t = auditpinfo_addr;
#[repr(C)]
#[derive(Debug)]
pub struct au_session {
    pub as_aia_p: *mut auditinfo_addr_t,
    pub as_mask: au_mask_t,
}
impl Default for au_session {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type au_session_t = au_session;
#[repr(C)]
#[derive(Debug)]
pub struct au_token {
    _unused: [u8; 0],
}
pub type token_t = au_token;
#[repr(C)]
#[derive(Debug, Default)]
pub struct au_qctrl {
    pub aq_hiwater: ::core::ffi::c_int,
    pub aq_lowater: ::core::ffi::c_int,
    pub aq_bufsz: ::core::ffi::c_int,
    pub aq_delay: ::core::ffi::c_int,
    pub aq_minfree: ::core::ffi::c_int,
}
pub type au_qctrl_t = au_qctrl;
#[repr(C)]
#[derive(Debug, Default)]
pub struct audit_stat {
    pub as_version: ::core::ffi::c_uint,
    pub as_numevent: ::core::ffi::c_uint,
    pub as_generated: ::core::ffi::c_int,
    pub as_nonattrib: ::core::ffi::c_int,
    pub as_kernel: ::core::ffi::c_int,
    pub as_audit: ::core::ffi::c_int,
    pub as_auditctl: ::core::ffi::c_int,
    pub as_enqueue: ::core::ffi::c_int,
    pub as_written: ::core::ffi::c_int,
    pub as_wblocked: ::core::ffi::c_int,
    pub as_rblocked: ::core::ffi::c_int,
    pub as_dropped: ::core::ffi::c_int,
    pub as_totalsize: ::core::ffi::c_int,
    pub as_memused: ::core::ffi::c_uint,
}
pub type au_stat_t = audit_stat;
#[repr(C)]
#[derive(Debug, Default)]
pub struct audit_fstat {
    pub af_filesz: u_int64_t,
    pub af_currsz: u_int64_t,
}
pub type au_fstat_t = audit_fstat;
#[repr(C)]
#[derive(Debug, Default)]
pub struct au_evclass_map {
    pub ec_number: au_event_t,
    pub ec_class: au_class_t,
}
pub type au_evclass_map_t = au_evclass_map;
#[repr(C)]
#[derive(Debug)]
pub struct au_evname_map {
    pub en_number: au_event_t,
    pub en_name: [::core::ffi::c_char; 64usize],
}
impl Default for au_evname_map {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type au_evname_map_t = au_evname_map;
#[repr(C)]
#[derive(Debug)]
pub struct label {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct loginclass {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct uidinfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ucred {
    pub cr_mtx: mtx,
    pub cr_ref: ::core::ffi::c_long,
    pub cr_users: u_int,
    pub cr_flags: u_int,
    pub cr_audit: auditinfo_addr,
    pub cr_ngroups: ::core::ffi::c_int,
    pub cr_uid: uid_t,
    pub cr_ruid: uid_t,
    pub cr_svuid: uid_t,
    pub cr_gid: gid_t,
    pub cr_rgid: gid_t,
    pub cr_svgid: gid_t,
    pub cr_uidinfo: *mut uidinfo,
    pub cr_ruidinfo: *mut uidinfo,
    pub cr_prison: *mut prison,
    pub cr_loginclass: *mut loginclass,
    pub cr_pspare2: [*mut ::core::ffi::c_void; 2usize],
    pub cr_label: *mut label,
    pub cr_groups: *mut gid_t,
    pub cr_agroups: ::core::ffi::c_int,
    pub cr_smallgroups: [gid_t; 16usize],
}
impl Default for ucred {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct xucred {
    pub cr_version: u_int,
    pub cr_uid: uid_t,
    pub cr_ngroups: ::core::ffi::c_short,
    pub __bindgen_anon_1: xucred__bindgen_ty_1,
    pub __bindgen_anon_2: xucred__bindgen_ty_2,
}
#[repr(C)]
pub struct xucred__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<xucred__bindgen_ty_1__bindgen_ty_1>,
    pub cr_groups: __BindgenUnionField<[gid_t; 16usize]>,
    pub bindgen_union_field: [u32; 16usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct xucred__bindgen_ty_1__bindgen_ty_1 {
    pub cr_gid: gid_t,
    pub cr_sgroups: [gid_t; 15usize],
}
impl Default for xucred__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct xucred__bindgen_ty_2 {
    pub _cr_unused1: __BindgenUnionField<*mut ::core::ffi::c_void>,
    pub cr_pid: __BindgenUnionField<pid_t>,
    pub bindgen_union_field: u64,
}
impl Default for xucred__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for xucred {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct mac {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct setcred {
    pub sc_uid: uid_t,
    pub sc_ruid: uid_t,
    pub sc_svuid: uid_t,
    pub sc_gid: gid_t,
    pub sc_rgid: gid_t,
    pub sc_svgid: gid_t,
    pub sc_pad: u_int,
    pub sc_supp_groups_nb: u_int,
    pub sc_supp_groups: *mut gid_t,
    pub sc_label: *mut mac,
}
impl Default for setcred {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct setcred32 {
    pub sc_uid: uid_t,
    pub sc_ruid: uid_t,
    pub sc_svuid: uid_t,
    pub sc_gid: gid_t,
    pub sc_rgid: gid_t,
    pub sc_svgid: gid_t,
    pub sc_pad: u_int,
    pub sc_supp_groups_nb: u_int,
    pub sc_supp_groups: u32,
    pub sc_label: u32,
}
#[repr(C)]
#[derive(Debug)]
pub struct credbatch {
    pub cred: *mut ucred,
    pub users: u_int,
    pub ref_: ::core::ffi::c_long,
}
impl Default for credbatch {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct _domainset {
    pub __bits: [::core::ffi::c_ulong; 1usize],
}
pub type domainset_t = _domainset;
#[repr(C)]
#[derive(Debug)]
pub struct domainset_ref {
    pub dr_policy: *mut domainset,
    pub dr_iter: ::core::ffi::c_uint,
}
impl Default for domainset_ref {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct ptrauth_key {
    pub pa_key_lo: u64,
    pub pa_key_hi: u64,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct mdthread {
    pub md_spinlock_count: ::core::ffi::c_int,
    pub md_saved_daif: register_t,
    pub md_canary: usize,
    pub md_ptrauth_user: mdthread__bindgen_ty_1,
    pub md_ptrauth_kern: mdthread__bindgen_ty_2,
    pub md_efirt_tmp: u64,
    pub md_efirt_dis_pf: ::core::ffi::c_int,
    pub md_reserved0: ::core::ffi::c_int,
    pub md_reserved: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct mdthread__bindgen_ty_1 {
    pub apia: ptrauth_key,
    pub apib: ptrauth_key,
    pub apda: ptrauth_key,
    pub apdb: ptrauth_key,
    pub apga: ptrauth_key,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct mdthread__bindgen_ty_2 {
    pub apia: ptrauth_key,
}
#[repr(C)]
#[derive(Default)]
pub struct mdproc {
    pub md_tcr: u64,
    pub md_reserved: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct session {
    pub s_count: u_int,
    pub s_leader: *mut proc_,
    pub s_ttyvp: *mut vnode,
    pub s_ttydp: *mut cdev_priv,
    pub s_ttyp: *mut tty,
    pub s_sid: pid_t,
    pub s_login: [::core::ffi::c_char; 40usize],
    pub s_mtx: mtx,
}
impl Default for session {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pgrp {
    pub pg_hash: pgrp__bindgen_ty_1,
    pub pg_members: pgrp__bindgen_ty_2,
    pub pg_session: *mut session,
    pub pg_sigiolst: sigiolst,
    pub pg_id: pid_t,
    pub pg_mtx: mtx,
    pub pg_flags: ::core::ffi::c_int,
    pub pg_killsx: sx,
}
#[repr(C)]
#[derive(Debug)]
pub struct pgrp__bindgen_ty_1 {
    pub le_next: *mut pgrp,
    pub le_prev: *mut *mut pgrp,
}
impl Default for pgrp__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pgrp__bindgen_ty_2 {
    pub lh_first: *mut proc_,
}
impl Default for pgrp__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for pgrp {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct pargs {
    pub ar_ref: u_int,
    pub ar_length: u_int,
    pub ar_args: [u_char; 1usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct filecaps {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct filemon {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct kaioinfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct kaudit_record {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct kcov_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct kdtrace_proc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct kdtrace_thread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct kmsan_td {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct kq_timer_cb_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct mqueue_notifier {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct p_sched {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct procdesc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct racct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct sleepqueue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct td_sched {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct turnstile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct epoch_tracker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct syscall_args {
    pub code: u_int,
    pub original_code: u_int,
    pub callp: *mut sysent,
    pub args: [register_t; 8usize],
}
impl Default for syscall_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct rusage_ext {
    pub rux_runtime: u64,
    pub rux_uticks: u64,
    pub rux_sticks: u64,
    pub rux_iticks: u64,
    pub rux_uu: u64,
    pub rux_su: u64,
    pub rux_tu: u64,
}
#[repr(C)]
pub struct thread {
    pub td_lock: *mut mtx,
    pub td_proc: *mut proc_,
    pub td_plist: thread__bindgen_ty_1,
    pub td_runq: thread__bindgen_ty_2,
    pub __bindgen_anon_1: thread__bindgen_ty_3,
    pub td_lockq: thread__bindgen_ty_4,
    pub td_hash: thread__bindgen_ty_5,
    pub td_cpuset: *mut cpuset,
    pub td_domain: domainset_ref,
    pub td_sel: *mut seltd,
    pub td_sleepqueue: *mut sleepqueue,
    pub td_turnstile: *mut turnstile,
    pub td_pad1: *mut ::core::ffi::c_void,
    pub td_umtxq: *mut umtx_q,
    pub td_tid: lwpid_t,
    pub td_sigqueue: sigqueue_t,
    pub td_lend_user_pri: u_char,
    pub td_allocdomain: u_char,
    pub td_base_ithread_pri: u_char,
    pub td_kmsan: *mut kmsan_td,
    pub td_flags: ::core::ffi::c_int,
    pub td_ast: ::core::ffi::c_int,
    pub td_inhibitors: ::core::ffi::c_int,
    pub td_pflags: ::core::ffi::c_int,
    pub td_pflags2: ::core::ffi::c_int,
    pub td_dupfd: ::core::ffi::c_int,
    pub td_sqqueue: ::core::ffi::c_int,
    pub td_wchan: *const ::core::ffi::c_void,
    pub td_wmesg: *const ::core::ffi::c_char,
    pub td_owepreempt: u_char,
    pub td_tsqueue: u_char,
    pub _td_pad0: [u_char; 2usize],
    pub td_locks: ::core::ffi::c_int,
    pub td_rw_rlocks: ::core::ffi::c_int,
    pub td_sx_slocks: ::core::ffi::c_int,
    pub td_lk_slocks: ::core::ffi::c_int,
    pub td_wantedlock: *mut lock_object,
    pub td_blocked: *mut turnstile,
    pub td_lockname: *const ::core::ffi::c_char,
    pub td_contested: thread__bindgen_ty_6,
    pub td_sleeplocks: *mut lock_list_entry,
    pub td_intr_nesting_level: ::core::ffi::c_int,
    pub td_pinned: ::core::ffi::c_int,
    pub td_realucred: *mut ucred,
    pub td_ucred: *mut ucred,
    pub td_limit: *mut plimit,
    pub td_slptick: ::core::ffi::c_int,
    pub td_blktick: ::core::ffi::c_int,
    pub td_swvoltick: ::core::ffi::c_int,
    pub td_swinvoltick: ::core::ffi::c_int,
    pub td_cow: u_int,
    pub td_ru: rusage,
    pub td_rux: rusage_ext,
    pub td_incruntime: u64,
    pub td_runtime: u64,
    pub td_pticks: u_int,
    pub td_sticks: u_int,
    pub td_iticks: u_int,
    pub td_uticks: u_int,
    pub td_intrval: ::core::ffi::c_int,
    pub td_oldsigmask: sigset_t,
    pub td_generation: u_int,
    pub td_sigstk: stack_t,
    pub td_xsig: ::core::ffi::c_int,
    pub td_profil_addr: u_long,
    pub td_profil_ticks: u_int,
    pub td_name: [::core::ffi::c_char; 20usize],
    pub td_fpop: *mut file,
    pub td_dbgflags: ::core::ffi::c_int,
    pub td_si: siginfo_t,
    pub td_ng_outbound: ::core::ffi::c_int,
    pub td_osd: osd,
    pub td_map_def_user: *mut vm_map_entry,
    pub td_dbg_forked: pid_t,
    pub td_no_sleeping: u_int,
    pub td_vp_reserved: *mut vnode,
    pub td_su: *mut ::core::ffi::c_void,
    pub td_sleeptimo: sbintime_t,
    pub td_rtcgen: ::core::ffi::c_int,
    pub td_errno: ::core::ffi::c_int,
    pub td_vslock_sz: usize,
    pub td_kcov_info: *mut kcov_info,
    pub td_ucredref: ::core::ffi::c_long,
    pub td_kexterr: kexterr,
    pub td_sigmask: sigset_t,
    pub td_rqindex: u_char,
    pub td_base_pri: u_char,
    pub td_priority: u_char,
    pub td_pri_class: u_char,
    pub td_user_pri: u_char,
    pub td_base_user_pri: u_char,
    pub td_rb_list: usize,
    pub td_rbp_list: usize,
    pub td_rb_inact: usize,
    pub td_sa: syscall_args,
    pub td_sigblock_ptr: *mut ::core::ffi::c_void,
    pub td_sigblock_val: u32,
    pub td_exterr_ptr: *mut ::core::ffi::c_void,
    pub td_pcb: *mut pcb,
    pub td_state: thread_td_states,
    pub td_uretoff: thread__bindgen_ty_7,
    pub td_cowgen: u_int,
    pub td_slpcallout: callout,
    pub td_frame: *mut trapframe,
    pub td_kstack: vm_offset_t,
    pub td_kstack_pages: u_short,
    pub td_kstack_domain: u_short,
    pub td_critnest: u_int,
    pub td_md: mdthread,
    pub td_ar: *mut kaudit_record,
    pub td_lprof: [lpohead; 2usize],
    pub td_dtrace: *mut kdtrace_thread,
    pub td_vnet: *mut vnet,
    pub td_vnet_lpush: *const ::core::ffi::c_char,
    pub td_intr_frame: *mut trapframe,
    pub td_rfppwait_p: *mut proc_,
    pub td_ma: *mut *mut vm_page,
    pub td_ma_cnt: ::core::ffi::c_int,
    pub td_emuldata: *mut ::core::ffi::c_void,
    pub td_lastcpu: ::core::ffi::c_int,
    pub td_oncpu: ::core::ffi::c_int,
    pub td_lkpi_task: *mut ::core::ffi::c_void,
    pub td_pmcpend: ::core::ffi::c_int,
    pub td_remotereq: *mut ::core::ffi::c_void,
    pub td_ktr_io_lim: off_t,
}
#[repr(C)]
#[derive(Debug)]
pub struct thread__bindgen_ty_1 {
    pub tqe_next: *mut thread,
    pub tqe_prev: *mut *mut thread,
}
impl Default for thread__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct thread__bindgen_ty_2 {
    pub tqe_next: *mut thread,
    pub tqe_prev: *mut *mut thread,
}
impl Default for thread__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct thread__bindgen_ty_3 {
    pub td_slpq: __BindgenUnionField<thread__bindgen_ty_3__bindgen_ty_1>,
    pub td_zombie: __BindgenUnionField<*mut thread>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct thread__bindgen_ty_3__bindgen_ty_1 {
    pub tqe_next: *mut thread,
    pub tqe_prev: *mut *mut thread,
}
impl Default for thread__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for thread__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct thread__bindgen_ty_4 {
    pub tqe_next: *mut thread,
    pub tqe_prev: *mut *mut thread,
}
impl Default for thread__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct thread__bindgen_ty_5 {
    pub le_next: *mut thread,
    pub le_prev: *mut *mut thread,
}
impl Default for thread__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct thread__bindgen_ty_6 {
    pub lh_first: *mut turnstile,
}
impl Default for thread__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const TDS_INACTIVE: thread_td_states = 0;
pub const TDS_INHIBITED: thread_td_states = 1;
pub const TDS_CAN_RUN: thread_td_states = 2;
pub const TDS_RUNQ: thread_td_states = 3;
pub const TDS_RUNNING: thread_td_states = 4;
pub type thread_td_states = ::core::ffi::c_uint;
#[repr(C)]
pub struct thread__bindgen_ty_7 {
    pub tdu_retval: __BindgenUnionField<[syscallarg_t; 2usize]>,
    pub tdu_off: __BindgenUnionField<off_t>,
    pub bindgen_union_field: [u64; 2usize],
}
impl Default for thread__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for thread {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct thread0_storage {
    pub t0st_thread: thread,
    pub t0st_sched: [u64; 10usize],
}
impl Default for thread0_storage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const TDA_AST: _bindgen_ty_1 = 0;
pub const TDA_OWEUPC: _bindgen_ty_1 = 1;
pub const TDA_HWPMC: _bindgen_ty_1 = 2;
pub const TDA_VFORK: _bindgen_ty_1 = 3;
pub const TDA_ALRM: _bindgen_ty_1 = 4;
pub const TDA_PROF: _bindgen_ty_1 = 5;
pub const TDA_MAC: _bindgen_ty_1 = 6;
pub const TDA_SCHED: _bindgen_ty_1 = 7;
pub const TDA_UFS: _bindgen_ty_1 = 8;
pub const TDA_GEOM: _bindgen_ty_1 = 9;
pub const TDA_KQUEUE: _bindgen_ty_1 = 10;
pub const TDA_RACCT: _bindgen_ty_1 = 11;
pub const TDA_MOD1: _bindgen_ty_1 = 12;
pub const TDA_MOD2: _bindgen_ty_1 = 13;
pub const TDA_PSELECT: _bindgen_ty_1 = 14;
pub const TDA_SIG: _bindgen_ty_1 = 15;
pub const TDA_KTRACE: _bindgen_ty_1 = 16;
pub const TDA_SUSPEND: _bindgen_ty_1 = 17;
pub const TDA_SIGSUSPEND: _bindgen_ty_1 = 18;
pub const TDA_MOD3: _bindgen_ty_1 = 19;
pub const TDA_MOD4: _bindgen_ty_1 = 20;
pub const TDA_MAX: _bindgen_ty_1 = 21;
pub type _bindgen_ty_1 = ::core::ffi::c_uint;
#[repr(C)]
pub struct proc_ {
    pub p_list: proc__bindgen_ty_1,
    pub p_threads: proc__bindgen_ty_2,
    pub p_slock: mtx,
    pub p_ucred: *mut ucred,
    pub p_fd: *mut filedesc,
    pub p_fdtol: *mut filedesc_to_leader,
    pub p_pd: *mut pwddesc,
    pub p_stats: *mut pstats,
    pub p_limit: *mut plimit,
    pub p_limco: callout,
    pub p_sigacts: *mut sigacts,
    pub p_flag: ::core::ffi::c_int,
    pub p_flag2: ::core::ffi::c_int,
    pub p_state: proc_p_states,
    pub p_pid: pid_t,
    pub p_hash: proc__bindgen_ty_3,
    pub p_pglist: proc__bindgen_ty_4,
    pub p_pptr: *mut proc_,
    pub p_sibling: proc__bindgen_ty_5,
    pub p_children: proc__bindgen_ty_6,
    pub p_reaper: *mut proc_,
    pub p_reaplist: proc__bindgen_ty_7,
    pub p_reapsibling: proc__bindgen_ty_8,
    pub p_mtx: mtx,
    pub p_statmtx: mtx,
    pub p_itimmtx: mtx,
    pub p_profmtx: mtx,
    pub p_ksi: *mut ksiginfo,
    pub p_sigqueue: sigqueue_t,
    pub p_oppid: pid_t,
    pub p_vmspace: *mut vmspace,
    pub p_swtick: u_int,
    pub p_cowgen: u_int,
    pub p_realtimer: itimerval,
    pub p_ru: rusage,
    pub p_rux: rusage_ext,
    pub p_crux: rusage_ext,
    pub p_profthreads: ::core::ffi::c_int,
    pub p_exitthreads: ::core::ffi::c_int,
    pub p_traceflag: ::core::ffi::c_int,
    pub p_ktrioparms: *mut ktr_io_params,
    pub p_textvp: *mut vnode,
    pub p_textdvp: *mut vnode,
    pub p_binname: *mut ::core::ffi::c_char,
    pub p_lock: u_int,
    pub p_sigiolst: sigiolst,
    pub p_sigparent: ::core::ffi::c_int,
    pub p_sig: ::core::ffi::c_int,
    pub p_ptevents: u_int,
    pub p_aioinfo: *mut kaioinfo,
    pub p_singlethread: *mut thread,
    pub p_suspcount: ::core::ffi::c_int,
    pub p_xthread: *mut thread,
    pub p_boundary_count: ::core::ffi::c_int,
    pub p_pendingcnt: ::core::ffi::c_int,
    pub p_itimers: *mut itimers,
    pub p_procdesc: *mut procdesc,
    pub p_treeflag: u_int,
    pub p_pendingexits: ::core::ffi::c_int,
    pub p_filemon: *mut filemon,
    pub p_pdeathsig: ::core::ffi::c_int,
    pub p_magic: u_int,
    pub p_osrel: ::core::ffi::c_int,
    pub p_fctl0: u32,
    pub p_comm: [::core::ffi::c_char; 20usize],
    pub p_sysent: *mut sysentvec,
    pub p_args: *mut pargs,
    pub p_cpulimit: rlim_t,
    pub p_nice: ::core::ffi::c_schar,
    pub p_fibnum: ::core::ffi::c_int,
    pub p_reapsubtree: pid_t,
    pub p_elf_flags: u64,
    pub p_elf_brandinfo: *const ::core::ffi::c_void,
    pub p_umtx_min_timeout: sbintime_t,
    pub p_xexit: u_int,
    pub p_xsig: u_int,
    pub p_pgrp: *mut pgrp,
    pub p_klist: *mut knlist,
    pub p_numthreads: ::core::ffi::c_int,
    pub p_md: mdproc,
    pub p_itcallout: callout,
    pub p_acflag: u_short,
    pub p_peers: *mut proc_,
    pub p_leader: *mut proc_,
    pub p_emuldata: *mut ::core::ffi::c_void,
    pub p_label: *mut label,
    pub p_ktr: proc__bindgen_ty_9,
    pub p_mqnotifier: proc__bindgen_ty_10,
    pub p_dtrace: *mut kdtrace_proc,
    pub p_pwait: cv,
    pub p_racct: *mut racct,
    pub p_throttled: ::core::ffi::c_int,
    pub p_orphan: proc__bindgen_ty_11,
    pub p_orphans: proc__bindgen_ty_12,
    pub p_kqtim_stop: proc__bindgen_ty_13,
    pub p_jaillist: proc__bindgen_ty_14,
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_1 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
impl Default for proc__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_2 {
    pub tqh_first: *mut thread,
    pub tqh_last: *mut *mut thread,
}
impl Default for proc__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const PRS_NEW: proc_p_states = 0;
pub const PRS_NORMAL: proc_p_states = 1;
pub const PRS_ZOMBIE: proc_p_states = 2;
pub type proc_p_states = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_3 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
impl Default for proc__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_4 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
impl Default for proc__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_5 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
impl Default for proc__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_6 {
    pub lh_first: *mut proc_,
}
impl Default for proc__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_7 {
    pub lh_first: *mut proc_,
}
impl Default for proc__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_8 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
impl Default for proc__bindgen_ty_8 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_9 {
    pub stqh_first: *mut ktr_request,
    pub stqh_last: *mut *mut ktr_request,
}
impl Default for proc__bindgen_ty_9 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_10 {
    pub lh_first: *mut mqueue_notifier,
}
impl Default for proc__bindgen_ty_10 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_11 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
impl Default for proc__bindgen_ty_11 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_12 {
    pub lh_first: *mut proc_,
}
impl Default for proc__bindgen_ty_12 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_13 {
    pub tqh_first: *mut kq_timer_cb_data,
    pub tqh_last: *mut *mut kq_timer_cb_data,
}
impl Default for proc__bindgen_ty_13 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_14 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
impl Default for proc__bindgen_ty_14 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for proc_ {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pidhashhead {
    pub lh_first: *mut proc_,
}
impl Default for pidhashhead {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pgrphashhead {
    pub lh_first: *mut pgrp,
}
impl Default for pgrphashhead {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct vmspace {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct proclist {
    pub lh_first: *mut proc_,
}
impl Default for proclist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct procqueue {
    pub tqh_first: *mut proc_,
    pub tqh_last: *mut *mut proc_,
}
impl Default for procqueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct threadqueue {
    pub tqh_first: *mut thread,
    pub tqh_last: *mut *mut thread,
}
impl Default for threadqueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct uma_zone {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct fork_req {
    pub fr_flags: ::core::ffi::c_int,
    pub fr_pages: ::core::ffi::c_int,
    pub fr_pidp: *mut ::core::ffi::c_int,
    pub fr_procp: *mut *mut proc_,
    pub fr_pd_fd: *mut ::core::ffi::c_int,
    pub fr_pd_flags: ::core::ffi::c_int,
    pub fr_pd_fcaps: *mut filecaps,
    pub fr_flags2: ::core::ffi::c_int,
}
impl Default for fork_req {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const RMAN_UNINIT: rman_type = 0;
pub const RMAN_GAUGE: rman_type = 1;
pub const RMAN_ARRAY: rman_type = 2;
pub type rman_type = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default)]
pub struct u_resource {
    pub r_handle: usize,
    pub r_parent: usize,
    pub r_device: usize,
    pub r_devname: [::core::ffi::c_char; 32usize],
    pub r_start: rman_res_t,
    pub r_size: rman_res_t,
    pub r_flags: u_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct u_rman {
    pub rm_handle: usize,
    pub rm_descr: [::core::ffi::c_char; 32usize],
    pub rm_start: rman_res_t,
    pub rm_size: rman_res_t,
    pub rm_type: rman_type,
}
impl Default for u_rman {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct resource {
    pub __r_i: *mut resource_i,
    pub r_bustag: bus_space_tag_t,
    pub r_bushandle: bus_space_handle_t,
}
impl Default for resource {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct resource_i {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct resource_head {
    pub tqh_first: *mut resource_i,
    pub tqh_last: *mut *mut resource_i,
}
impl Default for resource_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct rman {
    pub rm_list: resource_head,
    pub rm_mtx: *mut mtx,
    pub rm_link: rman__bindgen_ty_1,
    pub rm_start: rman_res_t,
    pub rm_end: rman_res_t,
    pub rm_type: rman_type,
    pub rm_descr: *const ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug)]
pub struct rman__bindgen_ty_1 {
    pub tqe_next: *mut rman,
    pub tqe_prev: *mut *mut rman,
}
impl Default for rman__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for rman {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct rman_head {
    pub tqh_first: *mut rman,
    pub tqh_last: *mut *mut rman,
}
impl Default for rman_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const TOPO_TYPE_DUMMY: topo_node_type = 0;
pub const TOPO_TYPE_PU: topo_node_type = 1;
pub const TOPO_TYPE_CORE: topo_node_type = 2;
pub const TOPO_TYPE_CACHE: topo_node_type = 3;
pub const TOPO_TYPE_PKG: topo_node_type = 4;
pub const TOPO_TYPE_NODE: topo_node_type = 5;
pub const TOPO_TYPE_GROUP: topo_node_type = 6;
pub const TOPO_TYPE_SYSTEM: topo_node_type = 7;
pub type topo_node_type = ::core::ffi::c_uint;
pub type hwid_t = ::core::ffi::c_uint;
pub type cpuid_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug)]
pub struct topo_node {
    pub parent: *mut topo_node,
    pub children: topo_node_topo_children,
    pub siblings: topo_node__bindgen_ty_1,
    pub cpuset: cpuset_t,
    pub type_: topo_node_type,
    pub subtype: usize,
    pub hwid: hwid_t,
    pub id: cpuid_t,
    pub nchildren: ::core::ffi::c_int,
    pub cpu_count: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct topo_node_topo_children {
    pub tqh_first: *mut topo_node,
    pub tqh_last: *mut *mut topo_node,
}
impl Default for topo_node_topo_children {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct topo_node__bindgen_ty_1 {
    pub tqe_next: *mut topo_node,
    pub tqe_prev: *mut *mut topo_node,
}
impl Default for topo_node__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for topo_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cpu_group {
    pub cg_parent: *mut cpu_group,
    pub cg_child: *mut cpu_group,
    pub cg_mask: cpuset_t,
    pub cg_count: i32,
    pub cg_first: i32,
    pub cg_last: i32,
    pub cg_children: i16,
    pub cg_level: i8,
    pub cg_flags: i8,
}
impl Default for cpu_group {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cpu_group_t = *mut cpu_group;
pub const TOPO_LEVEL_PKG: topo_level = 0;
pub const TOPO_LEVEL_GROUP: topo_level = 1;
pub const TOPO_LEVEL_CACHEGROUP: topo_level = 2;
pub const TOPO_LEVEL_CORE: topo_level = 3;
pub const TOPO_LEVEL_THREAD: topo_level = 4;
pub const TOPO_LEVEL_COUNT: topo_level = 5;
pub type topo_level = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default)]
pub struct topo_analysis {
    pub entities: [::core::ffi::c_int; 5usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct smp_rendezvous_cpus_retry_arg {
    pub cpus: cpuset_t,
}
pub type task_fn_t = ::core::option::Option<
    unsafe extern "C" fn(context: *mut ::core::ffi::c_void, pending: ::core::ffi::c_int),
>;
#[repr(C)]
#[derive(Debug)]
pub struct task {
    pub ta_link: task__bindgen_ty_1,
    pub ta_pending: u16,
    pub ta_priority: u8,
    pub ta_flags: u8,
    pub ta_func: task_fn_t,
    pub ta_context: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug)]
pub struct task__bindgen_ty_1 {
    pub stqe_next: *mut task,
}
impl Default for task__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for task {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct taskqueue {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct timeout_task {
    pub q: *mut taskqueue,
    pub t: task,
    pub c: callout,
    pub f: ::core::ffi::c_int,
}
impl Default for timeout_task {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type gtask_fn_t =
    ::core::option::Option<unsafe extern "C" fn(context: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug)]
pub struct gtask {
    pub ta_link: gtask__bindgen_ty_1,
    pub ta_flags: u16,
    pub ta_priority: u_short,
    pub ta_func: gtask_fn_t,
    pub ta_context: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug)]
pub struct gtask__bindgen_ty_1 {
    pub stqe_next: *mut gtask,
}
impl Default for gtask__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for gtask {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct taskqgroup {
    _unused: [u8; 0],
}
pub const TASKQUEUE_CALLBACK_TYPE_INIT: taskqueue_callback_type = 0;
pub const TASKQUEUE_CALLBACK_TYPE_SHUTDOWN: taskqueue_callback_type = 1;
pub type taskqueue_callback_type = ::core::ffi::c_uint;
pub type taskqueue_callback_fn =
    ::core::option::Option<unsafe extern "C" fn(context: *mut ::core::ffi::c_void)>;
pub type taskqueue_enqueue_fn =
    ::core::option::Option<unsafe extern "C" fn(context: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug)]
pub struct bus_space {
    pub bs_cookie: *mut ::core::ffi::c_void,
    pub bs_map: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_addr_t,
            arg3: bus_size_t,
            arg4: ::core::ffi::c_int,
            arg5: *mut bus_space_handle_t,
        ) -> ::core::ffi::c_int,
    >,
    pub bs_unmap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
        ),
    >,
    pub bs_subregion: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: bus_size_t,
            arg5: *mut bus_space_handle_t,
        ) -> ::core::ffi::c_int,
    >,
    pub bs_alloc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_addr_t,
            arg3: bus_addr_t,
            arg4: bus_size_t,
            arg5: bus_size_t,
            arg6: bus_size_t,
            arg7: ::core::ffi::c_int,
            arg8: *mut bus_addr_t,
            arg9: *mut bus_space_handle_t,
        ) -> ::core::ffi::c_int,
    >,
    pub bs_free: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
        ),
    >,
    pub bs_barrier: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: bus_size_t,
            arg5: ::core::ffi::c_int,
        ),
    >,
    pub bs_r_1: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
        ) -> u_int8_t,
    >,
    pub bs_r_2: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
        ) -> u_int16_t,
    >,
    pub bs_r_4: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
        ) -> u_int32_t,
    >,
    pub bs_r_8: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
        ) -> u_int64_t,
    >,
    pub bs_rm_1: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int8_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rm_2: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int16_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rm_4: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int32_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rm_8: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int64_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rr_1: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int8_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rr_2: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int16_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rr_4: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int32_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rr_8: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int64_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_w_1: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int8_t,
        ),
    >,
    pub bs_w_2: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int16_t,
        ),
    >,
    pub bs_w_4: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int32_t,
        ),
    >,
    pub bs_w_8: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int64_t,
        ),
    >,
    pub bs_wm_1: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int8_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wm_2: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int16_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wm_4: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int32_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wm_8: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int64_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wr_1: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int8_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wr_2: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int16_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wr_4: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int32_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wr_8: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int64_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_sm_1: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int8_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_sm_2: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int16_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_sm_4: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int32_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_sm_8: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int64_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_sr_1: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int8_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_sr_2: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int16_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_sr_4: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int32_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_sr_8: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int64_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_c_1: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: bus_space_handle_t,
            arg5: bus_size_t,
            arg6: bus_size_t,
        ),
    >,
    pub bs_c_2: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: bus_space_handle_t,
            arg5: bus_size_t,
            arg6: bus_size_t,
        ),
    >,
    pub bs_c_4: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: bus_space_handle_t,
            arg5: bus_size_t,
            arg6: bus_size_t,
        ),
    >,
    pub bs_c_8: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: bus_space_handle_t,
            arg5: bus_size_t,
            arg6: bus_size_t,
        ),
    >,
    pub bs_r_1_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
        ) -> u_int8_t,
    >,
    pub bs_r_2_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
        ) -> u_int16_t,
    >,
    pub bs_r_4_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
        ) -> u_int32_t,
    >,
    pub bs_r_8_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
        ) -> u_int64_t,
    >,
    pub bs_rm_1_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int8_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rm_2_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int16_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rm_4_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int32_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rm_8_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int64_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rr_1_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int8_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rr_2_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int16_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rr_4_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int32_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rr_8_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int64_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_w_1_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int8_t,
        ),
    >,
    pub bs_w_2_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int16_t,
        ),
    >,
    pub bs_w_4_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int32_t,
        ),
    >,
    pub bs_w_8_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int64_t,
        ),
    >,
    pub bs_wm_1_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int8_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wm_2_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int16_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wm_4_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int32_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wm_8_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int64_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wr_1_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int8_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wr_2_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int16_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wr_4_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int32_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wr_8_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int64_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_peek_1: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u8,
        ) -> ::core::ffi::c_int,
    >,
    pub bs_peek_2: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u16,
        ) -> ::core::ffi::c_int,
    >,
    pub bs_peek_4: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u32,
        ) -> ::core::ffi::c_int,
    >,
    pub bs_peek_8: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u64,
        ) -> ::core::ffi::c_int,
    >,
    pub bs_poke_1: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u8,
        ) -> ::core::ffi::c_int,
    >,
    pub bs_poke_2: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u16,
        ) -> ::core::ffi::c_int,
    >,
    pub bs_poke_4: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u32,
        ) -> ::core::ffi::c_int,
    >,
    pub bs_poke_8: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u64,
        ) -> ::core::ffi::c_int,
    >,
}
impl Default for bus_space {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ccb {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct crypto_buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct cryptop {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct mbuf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct pmap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct bus_dma_segment {
    pub ds_addr: bus_addr_t,
    pub ds_len: bus_size_t,
}
pub type bus_dma_segment_t = bus_dma_segment;
pub type bus_dma_filter_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: bus_addr_t) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug)]
pub struct bus_dma_template_t {
    pub parent: bus_dma_tag_t,
    pub alignment: bus_size_t,
    pub boundary: bus_addr_t,
    pub lowaddr: bus_addr_t,
    pub highaddr: bus_addr_t,
    pub maxsize: bus_size_t,
    pub nsegments: ::core::ffi::c_int,
    pub maxsegsize: bus_size_t,
    pub flags: ::core::ffi::c_int,
    pub lockfunc: bus_dma_lock_t,
    pub lockfuncarg: *mut ::core::ffi::c_void,
    pub name: *const ::core::ffi::c_char,
}
impl Default for bus_dma_template_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const BD_PARAM_INVALID: bus_dma_param_key_t = 0;
pub const BD_PARAM_PARENT: bus_dma_param_key_t = 1;
pub const BD_PARAM_ALIGNMENT: bus_dma_param_key_t = 2;
pub const BD_PARAM_BOUNDARY: bus_dma_param_key_t = 3;
pub const BD_PARAM_LOWADDR: bus_dma_param_key_t = 4;
pub const BD_PARAM_HIGHADDR: bus_dma_param_key_t = 5;
pub const BD_PARAM_MAXSIZE: bus_dma_param_key_t = 6;
pub const BD_PARAM_NSEGMENTS: bus_dma_param_key_t = 7;
pub const BD_PARAM_MAXSEGSIZE: bus_dma_param_key_t = 8;
pub const BD_PARAM_FLAGS: bus_dma_param_key_t = 9;
pub const BD_PARAM_LOCKFUNC: bus_dma_param_key_t = 10;
pub const BD_PARAM_LOCKFUNCARG: bus_dma_param_key_t = 11;
pub const BD_PARAM_NAME: bus_dma_param_key_t = 12;
pub type bus_dma_param_key_t = ::core::ffi::c_uint;
#[repr(C)]
pub struct bus_dma_param_t {
    pub key: bus_dma_param_key_t,
    pub __bindgen_anon_1: bus_dma_param_t__bindgen_ty_1,
}
#[repr(C)]
pub struct bus_dma_param_t__bindgen_ty_1 {
    pub ptr: __BindgenUnionField<*mut ::core::ffi::c_void>,
    pub pa: __BindgenUnionField<vm_paddr_t>,
    pub num: __BindgenUnionField<uintmax_t>,
    pub bindgen_union_field: u64,
}
impl Default for bus_dma_param_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bus_dma_param_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type bus_dmamap_callback_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut bus_dma_segment_t,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
    ),
>;
pub type bus_dmamap_callback2_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut bus_dma_segment_t,
        arg3: ::core::ffi::c_int,
        arg4: bus_size_t,
        arg5: ::core::ffi::c_int,
    ),
>;
#[repr(C)]
#[derive(Debug)]
pub struct bus_dma_tag_common {
    pub impl_: *mut bus_dma_impl,
    pub alignment: bus_size_t,
    pub boundary: bus_addr_t,
    pub lowaddr: bus_addr_t,
    pub highaddr: bus_addr_t,
    pub maxsize: bus_size_t,
    pub nsegments: u_int,
    pub maxsegsz: bus_size_t,
    pub flags: ::core::ffi::c_int,
    pub lockfunc: bus_dma_lock_t,
    pub lockfuncarg: *mut ::core::ffi::c_void,
    pub domain: ::core::ffi::c_int,
}
impl Default for bus_dma_tag_common {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct bus_dma_impl {
    pub tag_create: ::core::option::Option<
        unsafe extern "C" fn(
            parent: bus_dma_tag_t,
            alignment: bus_size_t,
            boundary: bus_addr_t,
            lowaddr: bus_addr_t,
            highaddr: bus_addr_t,
            maxsize: bus_size_t,
            nsegments: ::core::ffi::c_int,
            maxsegsz: bus_size_t,
            flags: ::core::ffi::c_int,
            lockfunc: bus_dma_lock_t,
            lockfuncarg: *mut ::core::ffi::c_void,
            dmat: *mut bus_dma_tag_t,
        ) -> ::core::ffi::c_int,
    >,
    pub tag_destroy:
        ::core::option::Option<unsafe extern "C" fn(dmat: bus_dma_tag_t) -> ::core::ffi::c_int>,
    pub tag_set_domain:
        ::core::option::Option<unsafe extern "C" fn(arg1: bus_dma_tag_t) -> ::core::ffi::c_int>,
    pub id_mapped: ::core::option::Option<
        unsafe extern "C" fn(arg1: bus_dma_tag_t, arg2: vm_paddr_t, arg3: bus_size_t) -> bool_,
    >,
    pub map_create: ::core::option::Option<
        unsafe extern "C" fn(
            dmat: bus_dma_tag_t,
            flags: ::core::ffi::c_int,
            mapp: *mut bus_dmamap_t,
        ) -> ::core::ffi::c_int,
    >,
    pub map_destroy: ::core::option::Option<
        unsafe extern "C" fn(dmat: bus_dma_tag_t, map: bus_dmamap_t) -> ::core::ffi::c_int,
    >,
    pub mem_alloc: ::core::option::Option<
        unsafe extern "C" fn(
            dmat: bus_dma_tag_t,
            vaddr: *mut *mut ::core::ffi::c_void,
            flags: ::core::ffi::c_int,
            mapp: *mut bus_dmamap_t,
        ) -> ::core::ffi::c_int,
    >,
    pub mem_free: ::core::option::Option<
        unsafe extern "C" fn(
            dmat: bus_dma_tag_t,
            vaddr: *mut ::core::ffi::c_void,
            map: bus_dmamap_t,
        ),
    >,
    pub load_ma: ::core::option::Option<
        unsafe extern "C" fn(
            dmat: bus_dma_tag_t,
            map: bus_dmamap_t,
            ma: *mut *mut vm_page,
            tlen: bus_size_t,
            ma_offs: ::core::ffi::c_int,
            flags: ::core::ffi::c_int,
            segs: *mut bus_dma_segment_t,
            segp: *mut ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub load_phys: ::core::option::Option<
        unsafe extern "C" fn(
            dmat: bus_dma_tag_t,
            map: bus_dmamap_t,
            buf: vm_paddr_t,
            buflen: bus_size_t,
            flags: ::core::ffi::c_int,
            segs: *mut bus_dma_segment_t,
            segp: *mut ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub load_buffer: ::core::option::Option<
        unsafe extern "C" fn(
            dmat: bus_dma_tag_t,
            map: bus_dmamap_t,
            buf: *mut ::core::ffi::c_void,
            buflen: bus_size_t,
            pmap: *mut pmap,
            flags: ::core::ffi::c_int,
            segs: *mut bus_dma_segment_t,
            segp: *mut ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub map_waitok: ::core::option::Option<
        unsafe extern "C" fn(
            dmat: bus_dma_tag_t,
            map: bus_dmamap_t,
            mem: *mut memdesc,
            callback: bus_dmamap_callback_t,
            callback_arg: *mut ::core::ffi::c_void,
        ),
    >,
    pub map_complete: ::core::option::Option<
        unsafe extern "C" fn(
            dmat: bus_dma_tag_t,
            map: bus_dmamap_t,
            segs: *mut bus_dma_segment_t,
            nsegs: ::core::ffi::c_int,
            error: ::core::ffi::c_int,
        ) -> *mut bus_dma_segment_t,
    >,
    pub map_unload:
        ::core::option::Option<unsafe extern "C" fn(dmat: bus_dma_tag_t, map: bus_dmamap_t)>,
    pub map_sync: ::core::option::Option<
        unsafe extern "C" fn(dmat: bus_dma_tag_t, map: bus_dmamap_t, op: bus_dmasync_op_t),
    >,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct arm64_bootparams {
    pub modulep: vm_offset_t,
    pub kern_stack: vm_offset_t,
    pub kern_ttbr0: vm_paddr_t,
    pub boot_el: ::core::ffi::c_int,
    pub pad: ::core::ffi::c_int,
}
pub const ARM64_BUS_NONE: arm64_bus = 0;
pub const ARM64_BUS_FDT: arm64_bus = 1;
pub const ARM64_BUS_ACPI: arm64_bus = 2;
pub type arm64_bus = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default)]
pub struct debug_monitor_state {
    pub dbg_enable_count: u32,
    pub dbg_flags: u32,
    pub dbg_bcr: [u64; 16usize],
    pub dbg_bvr: [u64; 16usize],
    pub dbg_wcr: [u64; 16usize],
    pub dbg_wvr: [u64; 16usize],
}
pub const HW_BREAKPOINT_X: dbg_access_t = 0;
pub const HW_BREAKPOINT_R: dbg_access_t = 1;
pub const HW_BREAKPOINT_W: dbg_access_t = 2;
pub const HW_BREAKPOINT_RW: dbg_access_t = 3;
pub type dbg_access_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct fpu_kern_ctx {
    _unused: [u8; 0],
}
pub const IPI_AST: _bindgen_ty_2 = 0;
pub const IPI_PREEMPT: _bindgen_ty_2 = 1;
pub const IPI_RENDEZVOUS: _bindgen_ty_2 = 2;
pub const IPI_STOP: _bindgen_ty_2 = 3;
pub const IPI_STOP_HARD: _bindgen_ty_2 = 4;
pub const IPI_HARDCLOCK: _bindgen_ty_2 = 5;
pub const INTR_IPI_COUNT: _bindgen_ty_2 = 6;
pub type _bindgen_ty_2 = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct ofw_bus_devinfo {
    pub obd_node: phandle_t,
    pub obd_compat: *mut ::core::ffi::c_char,
    pub obd_model: *mut ::core::ffi::c_char,
    pub obd_name: *mut ::core::ffi::c_char,
    pub obd_type: *mut ::core::ffi::c_char,
    pub obd_status: *mut ::core::ffi::c_char,
}
impl Default for ofw_bus_devinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief A function implementing the OFW_BUS_GET_DEVINFO() method"]
pub type ofw_bus_get_devinfo_t = ::core::option::Option<
    unsafe extern "C" fn(bus: device_t, dev: device_t) -> *const ofw_bus_devinfo,
>;
#[doc = " @brief A function implementing the OFW_BUS_GET_COMPAT() method"]
pub type ofw_bus_get_compat_t = ::core::option::Option<
    unsafe extern "C" fn(bus: device_t, dev: device_t) -> *const ::core::ffi::c_char,
>;
#[doc = " @brief A function implementing the OFW_BUS_GET_MODEL() method"]
pub type ofw_bus_get_model_t = ::core::option::Option<
    unsafe extern "C" fn(bus: device_t, dev: device_t) -> *const ::core::ffi::c_char,
>;
#[doc = " @brief A function implementing the OFW_BUS_GET_NAME() method"]
pub type ofw_bus_get_name_t = ::core::option::Option<
    unsafe extern "C" fn(bus: device_t, dev: device_t) -> *const ::core::ffi::c_char,
>;
#[doc = " @brief A function implementing the OFW_BUS_GET_NODE() method"]
pub type ofw_bus_get_node_t =
    ::core::option::Option<unsafe extern "C" fn(bus: device_t, dev: device_t) -> phandle_t>;
#[doc = " @brief A function implementing the OFW_BUS_GET_TYPE() method"]
pub type ofw_bus_get_type_t = ::core::option::Option<
    unsafe extern "C" fn(bus: device_t, dev: device_t) -> *const ::core::ffi::c_char,
>;
#[doc = " @brief A function implementing the OFW_BUS_MAP_INTR() method"]
pub type ofw_bus_map_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        bus: device_t,
        dev: device_t,
        iparent: phandle_t,
        icells: ::core::ffi::c_int,
        interrupt: *mut pcell_t,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Default)]
pub struct simplebus_range {
    pub bus: u64,
    pub host: u64,
    pub size: u64,
}
#[repr(C)]
pub struct simplebus_softc {
    pub dev: device_t,
    pub node: phandle_t,
    pub ranges: *mut simplebus_range,
    pub nranges: ::core::ffi::c_int,
    pub flags: ::core::ffi::c_int,
    pub acells: pcell_t,
    pub scells: pcell_t,
}
impl Default for simplebus_softc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct simplebus_devinfo {
    pub obdinfo: ofw_bus_devinfo,
    pub rl: resource_list,
}
impl Default for simplebus_devinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct ofw_bus_iinfo {
    pub opi_imap: *mut u8,
    pub opi_imapmsk: *mut u8,
    pub opi_imapsz: ::core::ffi::c_int,
    pub opi_addrc: pcell_t,
}
impl Default for ofw_bus_iinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct ofw_compat_data {
    pub ocd_str: *const ::core::ffi::c_char,
    pub ocd_data: usize,
}
impl Default for ofw_compat_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct intr_map_data_fdt {
    pub hdr: intr_map_data,
    pub iparent: phandle_t,
    pub ncells: u_int,
    pub cells: __IncompleteArrayField<pcell_t>,
}
impl Default for intr_map_data_fdt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief A function implementing the GPIO_GET_BUS() method"]
pub type gpio_get_bus_t = ::core::option::Option<unsafe extern "C" fn(dev: device_t) -> device_t>;
#[doc = " @brief A function implementing the GPIO_PIN_MAX() method"]
pub type gpio_pin_max_t = ::core::option::Option<
    unsafe extern "C" fn(dev: device_t, maxpin: *mut ::core::ffi::c_int) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the GPIO_PIN_SET() method"]
pub type gpio_pin_set_t = ::core::option::Option<
    unsafe extern "C" fn(dev: device_t, pin_num: u32, pin_value: u32) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the GPIO_PIN_GET() method"]
pub type gpio_pin_get_t = ::core::option::Option<
    unsafe extern "C" fn(dev: device_t, pin_num: u32, pin_value: *mut u32) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the GPIO_PIN_TOGGLE() method"]
pub type gpio_pin_toggle_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t, pin_num: u32) -> ::core::ffi::c_int>;
#[doc = " @brief A function implementing the GPIO_PIN_GETCAPS() method"]
pub type gpio_pin_getcaps_t = ::core::option::Option<
    unsafe extern "C" fn(dev: device_t, pin_num: u32, caps: *mut u32) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the GPIO_PIN_GETFLAGS() method"]
pub type gpio_pin_getflags_t = ::core::option::Option<
    unsafe extern "C" fn(dev: device_t, pin_num: u32, flags: *mut u32) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the GPIO_PIN_GETNAME() method"]
pub type gpio_pin_getname_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: device_t,
        pin_num: u32,
        name: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the GPIO_PIN_SETFLAGS() method"]
pub type gpio_pin_setflags_t = ::core::option::Option<
    unsafe extern "C" fn(dev: device_t, pin_num: u32, flags: u32) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the GPIO_MAP_GPIOS() method"]
pub type gpio_map_gpios_t = ::core::option::Option<
    unsafe extern "C" fn(
        bus: device_t,
        dev: phandle_t,
        gparent: phandle_t,
        gcells: ::core::ffi::c_int,
        gpios: *mut pcell_t,
        pin: *mut u32,
        flags: *mut u32,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the GPIO_PIN_ACCESS_32() method"]
pub type gpio_pin_access_32_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: device_t,
        first_pin: u32,
        clear_pins: u32,
        change_pins: u32,
        orig_pins: *mut u32,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the GPIO_PIN_CONFIG_32() method"]
pub type gpio_pin_config_32_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: device_t,
        first_pin: u32,
        num_pins: u32,
        pin_flags: *mut u32,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the GPIO_GET_PIN_LIST() method"]
pub type gpio_get_pin_list_t = ::core::option::Option<
    unsafe extern "C" fn(dev: device_t, pin_list: *mut u32) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug)]
pub struct gpiobus_pin_data {
    pub mapped: ::core::ffi::c_int,
    pub name: *mut ::core::ffi::c_char,
}
impl Default for gpiobus_pin_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct intr_map_data_gpio {
    pub hdr: intr_map_data,
    pub gpio_pin_num: u_int,
    pub gpio_pin_flags: u_int,
    pub gpio_intr_mode: u_int,
}
impl Default for intr_map_data_gpio {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct gpiobus_softc {
    pub sc_mtx: mtx,
    pub sc_intr_rman: rman,
    pub sc_busdev: device_t,
    pub sc_owner: device_t,
    pub sc_dev: device_t,
    pub sc_npins: ::core::ffi::c_int,
    pub sc_pins: *mut gpiobus_pin_data,
}
impl Default for gpiobus_softc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct gpiobus_pin {
    pub dev: device_t,
    pub flags: u32,
    pub pin: u32,
}
impl Default for gpiobus_pin {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type gpio_pin_t = *mut gpiobus_pin;
#[repr(C)]
#[derive(Debug)]
pub struct gpiobus_ivar {
    pub rl: resource_list,
    pub npins: u32,
    pub pins: *mut u32,
}
impl Default for gpiobus_ivar {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const GPIOBUS_IVAR_NPINS: gpiobus_ivars = 10500;
pub const GPIOBUS_IVAR_PINS: gpiobus_ivars = 10501;
pub type gpiobus_ivars = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct ofw_gpiobus_devinfo {
    pub opd_dinfo: gpiobus_ivar,
    pub opd_obdinfo: ofw_bus_devinfo,
}
impl Default for ofw_gpiobus_devinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct disk_zone_disk_params {
    pub zone_mode: u32,
    pub flags: u64,
    pub optimal_seq_zones: u64,
    pub optimal_nonseq_zones: u64,
    pub max_seq_zones: u64,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct disk_zone_rwp {
    pub id: u64,
    pub flags: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct disk_zone_rep_header {
    pub same: u8,
    pub maximum_lba: u64,
    pub reserved: [u8; 64usize],
}
impl Default for disk_zone_rep_header {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct disk_zone_rep_entry {
    pub zone_type: u8,
    pub zone_condition: u8,
    pub zone_flags: u8,
    pub zone_length: u64,
    pub zone_start_lba: u64,
    pub write_pointer_lba: u64,
    pub reserved: [u8; 32usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct disk_zone_report {
    pub starting_id: u64,
    pub rep_options: u8,
    pub header: disk_zone_rep_header,
    pub entries_allocated: u32,
    pub entries_filled: u32,
    pub entries_available: u32,
    pub entries: *mut disk_zone_rep_entry,
}
impl Default for disk_zone_report {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct disk_zone_params {
    pub disk_params: __BindgenUnionField<disk_zone_disk_params>,
    pub rwp: __BindgenUnionField<disk_zone_rwp>,
    pub report: __BindgenUnionField<disk_zone_report>,
    pub bindgen_union_field: [u64; 15usize],
}
impl Default for disk_zone_params {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct disk_zone_args {
    pub zone_cmd: u8,
    pub zone_params: disk_zone_params,
}
impl Default for disk_zone_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct disk {
    _unused: [u8; 0],
}
pub type bio_task_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
#[repr(C)]
pub struct bio {
    pub bio_cmd: u16,
    pub bio_flags: u16,
    pub bio_cflags: u16,
    pub bio_pflags: u16,
    pub bio_dev: *mut cdev,
    pub bio_disk: *mut disk,
    pub bio_offset: off_t,
    pub bio_bcount: ::core::ffi::c_long,
    pub bio_data: caddr_t,
    pub bio_ma: *mut *mut vm_page,
    pub bio_ma_offset: ::core::ffi::c_int,
    pub bio_ma_n: ::core::ffi::c_int,
    pub bio_error: ::core::ffi::c_int,
    pub bio_resid: ::core::ffi::c_long,
    pub bio_done: ::core::option::Option<unsafe extern "C" fn(arg1: *mut bio)>,
    pub bio_driver1: *mut ::core::ffi::c_void,
    pub bio_driver2: *mut ::core::ffi::c_void,
    pub bio_caller1: *mut ::core::ffi::c_void,
    pub bio_caller2: *mut ::core::ffi::c_void,
    pub bio_queue: bio__bindgen_ty_1,
    pub bio_attribute: *const ::core::ffi::c_char,
    pub bio_zone: disk_zone_args,
    pub bio_from: *mut g_consumer,
    pub bio_to: *mut g_provider,
    pub bio_length: off_t,
    pub bio_completed: off_t,
    pub bio_children: u_int,
    pub bio_inbed: u_int,
    pub bio_parent: *mut bio,
    pub bio_t0: bintime,
    pub bio_task: bio_task_t,
    pub bio_task_arg: *mut ::core::ffi::c_void,
    pub bio_spare1: *mut ::core::ffi::c_void,
    pub bio_spare2: *mut ::core::ffi::c_void,
    pub bio_track_bp: *mut buf,
    pub bio_pblkno: daddr_t,
}
#[repr(C)]
#[derive(Debug)]
pub struct bio__bindgen_ty_1 {
    pub tqe_next: *mut bio,
    pub tqe_prev: *mut *mut bio,
}
impl Default for bio__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bio {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct devstat {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct bio_queue_head {
    pub queue: bio_queue_head_bio_queue,
    pub last_offset: off_t,
    pub insert_point: *mut bio,
    pub total: ::core::ffi::c_int,
    pub batched: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct bio_queue_head_bio_queue {
    pub tqh_first: *mut bio,
    pub tqh_last: *mut *mut bio,
}
impl Default for bio_queue_head_bio_queue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bio_queue_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type counter_u64_t = *mut u64;
#[repr(C)]
#[derive(Debug)]
pub struct counter_rate {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct memdesc {
    pub u: memdesc__bindgen_ty_1,
    pub __bindgen_anon_1: memdesc__bindgen_ty_2,
    pub __bindgen_anon_2: memdesc__bindgen_ty_3,
    pub md_type: u32,
}
#[repr(C)]
pub struct memdesc__bindgen_ty_1 {
    pub md_vaddr: __BindgenUnionField<*mut ::core::ffi::c_void>,
    pub md_paddr: __BindgenUnionField<vm_paddr_t>,
    pub md_list: __BindgenUnionField<*mut bus_dma_segment>,
    pub md_uio: __BindgenUnionField<*mut uio>,
    pub md_mbuf: __BindgenUnionField<*mut mbuf>,
    pub md_ma: __BindgenUnionField<*mut *mut vm_page>,
    pub bindgen_union_field: u64,
}
impl Default for memdesc__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct memdesc__bindgen_ty_2 {
    pub md_len: __BindgenUnionField<usize>,
    pub md_nseg: __BindgenUnionField<::core::ffi::c_int>,
    pub bindgen_union_field: u64,
}
impl Default for memdesc__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct memdesc__bindgen_ty_3 {
    pub md_offset: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
impl Default for memdesc__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for memdesc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type memdesc_alloc_ext_mbuf_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::core::ffi::c_int,
        arg3: *mut ::core::ffi::c_void,
        arg4: usize,
    ) -> *mut mbuf,
>;
pub type memdesc_alloc_extpg_mbuf_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: ::core::ffi::c_int) -> *mut mbuf,
>;
pub type smr_seq_t = u32;
pub type smr_delta_t = i32;
#[repr(C)]
#[derive(Debug)]
pub struct smr {
    _unused: [u8; 0],
}
pub type smr_t = *mut smr;
pub type uma_zone_t = *mut uma_zone;
pub type uma_ctor = ::core::option::Option<
    unsafe extern "C" fn(
        mem: *mut ::core::ffi::c_void,
        size: ::core::ffi::c_int,
        arg: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
pub type uma_dtor = ::core::option::Option<
    unsafe extern "C" fn(
        mem: *mut ::core::ffi::c_void,
        size: ::core::ffi::c_int,
        arg: *mut ::core::ffi::c_void,
    ),
>;
pub type uma_init = ::core::option::Option<
    unsafe extern "C" fn(
        mem: *mut ::core::ffi::c_void,
        size: ::core::ffi::c_int,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
pub type uma_fini = ::core::option::Option<
    unsafe extern "C" fn(mem: *mut ::core::ffi::c_void, size: ::core::ffi::c_int),
>;
pub type uma_import = ::core::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::core::ffi::c_void,
        store: *mut *mut ::core::ffi::c_void,
        count: ::core::ffi::c_int,
        domain: ::core::ffi::c_int,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
pub type uma_release = ::core::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::core::ffi::c_void,
        store: *mut *mut ::core::ffi::c_void,
        count: ::core::ffi::c_int,
    ),
>;
pub type uma_alloc = ::core::option::Option<
    unsafe extern "C" fn(
        zone: uma_zone_t,
        size: vm_size_t,
        domain: ::core::ffi::c_int,
        pflag: *mut u8,
        wait: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void,
>;
pub type uma_free = ::core::option::Option<
    unsafe extern "C" fn(item: *mut ::core::ffi::c_void, size: vm_size_t, pflag: u8),
>;
pub type uma_maxaction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: uma_zone_t, arg2: ::core::ffi::c_int)>;
#[repr(C)]
#[derive(Debug, Default)]
pub struct uma_stream_header {
    pub ush_version: u32,
    pub ush_maxcpus: u32,
    pub ush_count: u32,
    pub _ush_pad: u32,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct uma_type_header {
    pub uth_name: [::core::ffi::c_char; 32usize],
    pub uth_align: u32,
    pub uth_size: u32,
    pub uth_rsize: u32,
    pub uth_maxpages: u32,
    pub uth_limit: u32,
    pub uth_pages: u32,
    pub uth_keg_free: u32,
    pub uth_zone_free: u32,
    pub uth_bucketsize: u32,
    pub uth_zone_flags: u32,
    pub uth_allocs: u64,
    pub uth_frees: u64,
    pub uth_fails: u64,
    pub uth_sleeps: u64,
    pub uth_xdomain: u64,
    pub _uth_reserved1: [u64; 1usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct uma_percpu_stat {
    pub ups_allocs: u64,
    pub ups_frees: u64,
    pub ups_cache_free: u64,
    pub _ups_reserved: [u64; 5usize],
}
pub const NVME_FUSE_NORMAL: nvme_fuse = 0;
pub const NVME_FUSE_FIRST: nvme_fuse = 1;
pub const NVME_FUSE_SECOND: nvme_fuse = 2;
pub type nvme_fuse = ::core::ffi::c_uint;
pub const NVME_PSDT_PRP: nvme_psdt = 0;
pub const NVME_PSDT_SGL: nvme_psdt = 1;
pub const NVME_PSDT_SGL_MPTR: nvme_psdt = 2;
pub type nvme_psdt = ::core::ffi::c_uint;
pub const NVME_CRIT_WARN_ST_AVAILABLE_SPARE: nvme_critical_warning_state = 1;
pub const NVME_CRIT_WARN_ST_TEMPERATURE: nvme_critical_warning_state = 2;
pub const NVME_CRIT_WARN_ST_DEVICE_RELIABILITY: nvme_critical_warning_state = 4;
pub const NVME_CRIT_WARN_ST_READ_ONLY: nvme_critical_warning_state = 8;
pub const NVME_CRIT_WARN_ST_VOLATILE_MEMORY_BACKUP: nvme_critical_warning_state = 16;
pub const NVME_CRIT_WARN_ST_PERSISTENT_MEMORY_REGION: nvme_critical_warning_state = 32;
pub type nvme_critical_warning_state = ::core::ffi::c_uint;
pub const NVME_SHN_NORMAL: shn_value = 1;
pub const NVME_SHN_ABRUPT: shn_value = 2;
pub type shn_value = ::core::ffi::c_uint;
pub const NVME_SHST_NORMAL: shst_value = 0;
pub const NVME_SHST_OCCURRING: shst_value = 1;
pub const NVME_SHST_COMPLETE: shst_value = 2;
pub type shst_value = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct nvme_registers {
    pub cap_lo: u32,
    pub cap_hi: u32,
    pub vs: u32,
    pub intms: u32,
    pub intmc: u32,
    pub cc: u32,
    pub reserved1: u32,
    pub csts: u32,
    pub nssr: u32,
    pub aqa: u32,
    pub asq: u64,
    pub acq: u64,
    pub cmbloc: u32,
    pub cmbsz: u32,
    pub bpinfo: u32,
    pub bprsel: u32,
    pub bpmbl: u64,
    pub cmbmsc: u64,
    pub cmbsts: u32,
    pub cmbebs: u32,
    pub cmbswtp: u32,
    pub nssd: u32,
    pub crto: u32,
    pub reserved3: [u8; 3476usize],
    pub pmrcap: u32,
    pub pmrctl: u32,
    pub pmrsts: u32,
    pub pmrebs: u32,
    pub pmrswtp: u32,
    pub pmrmsc_lo: u32,
    pub pmrmsc_hi: u32,
    pub reserved4: [u8; 484usize],
    pub doorbell: [nvme_registers__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct nvme_registers__bindgen_ty_1 {
    pub sq_tdbl: u32,
    pub cq_hdbl: u32,
}
impl Default for nvme_registers {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const NVME_SGL_TYPE_DATA_BLOCK: nvme_sgl_type = 0;
pub const NVME_SGL_TYPE_BIT_BUCKET: nvme_sgl_type = 1;
pub const NVME_SGL_TYPE_SEGMENT: nvme_sgl_type = 2;
pub const NVME_SGL_TYPE_LAST_SEGMENT: nvme_sgl_type = 3;
pub const NVME_SGL_TYPE_KEYED_DATA_BLOCK: nvme_sgl_type = 4;
pub const NVME_SGL_TYPE_TRANSPORT_DATA_BLOCK: nvme_sgl_type = 5;
pub type nvme_sgl_type = ::core::ffi::c_uint;
pub const NVME_SGL_SUBTYPE_ADDRESS: nvme_sgl_subtype = 0;
pub const NVME_SGL_SUBTYPE_OFFSET: nvme_sgl_subtype = 1;
pub const NVME_SGL_SUBTYPE_TRANSPORT: nvme_sgl_subtype = 10;
pub type nvme_sgl_subtype = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default)]
pub struct nvme_sgl_descriptor {
    pub address: u64,
    pub length: u32,
    pub reserved: [u8; 3usize],
    pub type_: u8,
}
#[repr(C)]
pub struct nvme_command {
    pub opc: u8,
    pub fuse: u8,
    pub cid: u16,
    pub nsid: u32,
    pub rsvd2: u32,
    pub rsvd3: u32,
    pub mptr: u64,
    pub __bindgen_anon_1: nvme_command__bindgen_ty_1,
    pub cdw10: u32,
    pub cdw11: u32,
    pub cdw12: u32,
    pub cdw13: u32,
    pub cdw14: u32,
    pub cdw15: u32,
}
#[repr(C)]
pub struct nvme_command__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<nvme_command__bindgen_ty_1__bindgen_ty_1>,
    pub sgl: __BindgenUnionField<nvme_sgl_descriptor>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct nvme_command__bindgen_ty_1__bindgen_ty_1 {
    pub prp1: u64,
    pub prp2: u64,
}
impl Default for nvme_command__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for nvme_command {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default)]
pub struct nvme_completion {
    pub cdw0: u32,
    pub rsvd1: u32,
    pub sqhd: u16,
    pub sqid: u16,
    pub cid: u16,
    pub status: u16,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct nvme_dsm_range {
    pub attributes: u32,
    pub length: u32,
    pub starting_lba: u64,
}
pub const NVME_SCT_GENERIC: nvme_status_code_type = 0;
pub const NVME_SCT_COMMAND_SPECIFIC: nvme_status_code_type = 1;
pub const NVME_SCT_MEDIA_ERROR: nvme_status_code_type = 2;
pub const NVME_SCT_PATH_RELATED: nvme_status_code_type = 3;
pub const NVME_SCT_VENDOR_SPECIFIC: nvme_status_code_type = 7;
pub type nvme_status_code_type = ::core::ffi::c_uint;
pub const NVME_SC_SUCCESS: nvme_generic_command_status_code = 0;
pub const NVME_SC_INVALID_OPCODE: nvme_generic_command_status_code = 1;
pub const NVME_SC_INVALID_FIELD: nvme_generic_command_status_code = 2;
pub const NVME_SC_COMMAND_ID_CONFLICT: nvme_generic_command_status_code = 3;
pub const NVME_SC_DATA_TRANSFER_ERROR: nvme_generic_command_status_code = 4;
pub const NVME_SC_ABORTED_POWER_LOSS: nvme_generic_command_status_code = 5;
pub const NVME_SC_INTERNAL_DEVICE_ERROR: nvme_generic_command_status_code = 6;
pub const NVME_SC_ABORTED_BY_REQUEST: nvme_generic_command_status_code = 7;
pub const NVME_SC_ABORTED_SQ_DELETION: nvme_generic_command_status_code = 8;
pub const NVME_SC_ABORTED_FAILED_FUSED: nvme_generic_command_status_code = 9;
pub const NVME_SC_ABORTED_MISSING_FUSED: nvme_generic_command_status_code = 10;
pub const NVME_SC_INVALID_NAMESPACE_OR_FORMAT: nvme_generic_command_status_code = 11;
pub const NVME_SC_COMMAND_SEQUENCE_ERROR: nvme_generic_command_status_code = 12;
pub const NVME_SC_INVALID_SGL_SEGMENT_DESCR: nvme_generic_command_status_code = 13;
pub const NVME_SC_INVALID_NUMBER_OF_SGL_DESCR: nvme_generic_command_status_code = 14;
pub const NVME_SC_DATA_SGL_LENGTH_INVALID: nvme_generic_command_status_code = 15;
pub const NVME_SC_METADATA_SGL_LENGTH_INVALID: nvme_generic_command_status_code = 16;
pub const NVME_SC_SGL_DESCRIPTOR_TYPE_INVALID: nvme_generic_command_status_code = 17;
pub const NVME_SC_INVALID_USE_OF_CMB: nvme_generic_command_status_code = 18;
pub const NVME_SC_PRP_OFFET_INVALID: nvme_generic_command_status_code = 19;
pub const NVME_SC_ATOMIC_WRITE_UNIT_EXCEEDED: nvme_generic_command_status_code = 20;
pub const NVME_SC_OPERATION_DENIED: nvme_generic_command_status_code = 21;
pub const NVME_SC_SGL_OFFSET_INVALID: nvme_generic_command_status_code = 22;
pub const NVME_SC_HOST_ID_INCONSISTENT_FORMAT: nvme_generic_command_status_code = 24;
pub const NVME_SC_KEEP_ALIVE_TIMEOUT_EXPIRED: nvme_generic_command_status_code = 25;
pub const NVME_SC_KEEP_ALIVE_TIMEOUT_INVALID: nvme_generic_command_status_code = 26;
pub const NVME_SC_ABORTED_DUE_TO_PREEMPT: nvme_generic_command_status_code = 27;
pub const NVME_SC_SANITIZE_FAILED: nvme_generic_command_status_code = 28;
pub const NVME_SC_SANITIZE_IN_PROGRESS: nvme_generic_command_status_code = 29;
pub const NVME_SC_SGL_DATA_BLOCK_GRAN_INVALID: nvme_generic_command_status_code = 30;
pub const NVME_SC_NOT_SUPPORTED_IN_CMB: nvme_generic_command_status_code = 31;
pub const NVME_SC_NAMESPACE_IS_WRITE_PROTECTED: nvme_generic_command_status_code = 32;
pub const NVME_SC_COMMAND_INTERRUPTED: nvme_generic_command_status_code = 33;
pub const NVME_SC_TRANSIENT_TRANSPORT_ERROR: nvme_generic_command_status_code = 34;
pub const NVME_SC_LBA_OUT_OF_RANGE: nvme_generic_command_status_code = 128;
pub const NVME_SC_CAPACITY_EXCEEDED: nvme_generic_command_status_code = 129;
pub const NVME_SC_NAMESPACE_NOT_READY: nvme_generic_command_status_code = 130;
pub const NVME_SC_RESERVATION_CONFLICT: nvme_generic_command_status_code = 131;
pub const NVME_SC_FORMAT_IN_PROGRESS: nvme_generic_command_status_code = 132;
pub type nvme_generic_command_status_code = ::core::ffi::c_uint;
pub const NVME_SC_COMPLETION_QUEUE_INVALID: nvme_command_specific_status_code = 0;
pub const NVME_SC_INVALID_QUEUE_IDENTIFIER: nvme_command_specific_status_code = 1;
pub const NVME_SC_MAXIMUM_QUEUE_SIZE_EXCEEDED: nvme_command_specific_status_code = 2;
pub const NVME_SC_ABORT_COMMAND_LIMIT_EXCEEDED: nvme_command_specific_status_code = 3;
pub const NVME_SC_ASYNC_EVENT_REQUEST_LIMIT_EXCEEDED: nvme_command_specific_status_code = 5;
pub const NVME_SC_INVALID_FIRMWARE_SLOT: nvme_command_specific_status_code = 6;
pub const NVME_SC_INVALID_FIRMWARE_IMAGE: nvme_command_specific_status_code = 7;
pub const NVME_SC_INVALID_INTERRUPT_VECTOR: nvme_command_specific_status_code = 8;
pub const NVME_SC_INVALID_LOG_PAGE: nvme_command_specific_status_code = 9;
pub const NVME_SC_INVALID_FORMAT: nvme_command_specific_status_code = 10;
pub const NVME_SC_FIRMWARE_REQUIRES_RESET: nvme_command_specific_status_code = 11;
pub const NVME_SC_INVALID_QUEUE_DELETION: nvme_command_specific_status_code = 12;
pub const NVME_SC_FEATURE_NOT_SAVEABLE: nvme_command_specific_status_code = 13;
pub const NVME_SC_FEATURE_NOT_CHANGEABLE: nvme_command_specific_status_code = 14;
pub const NVME_SC_FEATURE_NOT_NS_SPECIFIC: nvme_command_specific_status_code = 15;
pub const NVME_SC_FW_ACT_REQUIRES_NVMS_RESET: nvme_command_specific_status_code = 16;
pub const NVME_SC_FW_ACT_REQUIRES_RESET: nvme_command_specific_status_code = 17;
pub const NVME_SC_FW_ACT_REQUIRES_TIME: nvme_command_specific_status_code = 18;
pub const NVME_SC_FW_ACT_PROHIBITED: nvme_command_specific_status_code = 19;
pub const NVME_SC_OVERLAPPING_RANGE: nvme_command_specific_status_code = 20;
pub const NVME_SC_NS_INSUFFICIENT_CAPACITY: nvme_command_specific_status_code = 21;
pub const NVME_SC_NS_ID_UNAVAILABLE: nvme_command_specific_status_code = 22;
pub const NVME_SC_NS_ALREADY_ATTACHED: nvme_command_specific_status_code = 24;
pub const NVME_SC_NS_IS_PRIVATE: nvme_command_specific_status_code = 25;
pub const NVME_SC_NS_NOT_ATTACHED: nvme_command_specific_status_code = 26;
pub const NVME_SC_THIN_PROV_NOT_SUPPORTED: nvme_command_specific_status_code = 27;
pub const NVME_SC_CTRLR_LIST_INVALID: nvme_command_specific_status_code = 28;
pub const NVME_SC_SELF_TEST_IN_PROGRESS: nvme_command_specific_status_code = 29;
pub const NVME_SC_BOOT_PART_WRITE_PROHIB: nvme_command_specific_status_code = 30;
pub const NVME_SC_INVALID_CTRLR_ID: nvme_command_specific_status_code = 31;
pub const NVME_SC_INVALID_SEC_CTRLR_STATE: nvme_command_specific_status_code = 32;
pub const NVME_SC_INVALID_NUM_OF_CTRLR_RESRC: nvme_command_specific_status_code = 33;
pub const NVME_SC_INVALID_RESOURCE_ID: nvme_command_specific_status_code = 34;
pub const NVME_SC_SANITIZE_PROHIBITED_WPMRE: nvme_command_specific_status_code = 35;
pub const NVME_SC_ANA_GROUP_ID_INVALID: nvme_command_specific_status_code = 36;
pub const NVME_SC_ANA_ATTACH_FAILED: nvme_command_specific_status_code = 37;
pub const NVME_SC_CONFLICTING_ATTRIBUTES: nvme_command_specific_status_code = 128;
pub const NVME_SC_INVALID_PROTECTION_INFO: nvme_command_specific_status_code = 129;
pub const NVME_SC_ATTEMPTED_WRITE_TO_RO_PAGE: nvme_command_specific_status_code = 130;
pub type nvme_command_specific_status_code = ::core::ffi::c_uint;
pub const NVME_SC_WRITE_FAULTS: nvme_media_error_status_code = 128;
pub const NVME_SC_UNRECOVERED_READ_ERROR: nvme_media_error_status_code = 129;
pub const NVME_SC_GUARD_CHECK_ERROR: nvme_media_error_status_code = 130;
pub const NVME_SC_APPLICATION_TAG_CHECK_ERROR: nvme_media_error_status_code = 131;
pub const NVME_SC_REFERENCE_TAG_CHECK_ERROR: nvme_media_error_status_code = 132;
pub const NVME_SC_COMPARE_FAILURE: nvme_media_error_status_code = 133;
pub const NVME_SC_ACCESS_DENIED: nvme_media_error_status_code = 134;
pub const NVME_SC_DEALLOCATED_OR_UNWRITTEN: nvme_media_error_status_code = 135;
pub type nvme_media_error_status_code = ::core::ffi::c_uint;
pub const NVME_SC_INTERNAL_PATH_ERROR: nvme_path_related_status_code = 0;
pub const NVME_SC_ASYMMETRIC_ACCESS_PERSISTENT_LOSS: nvme_path_related_status_code = 1;
pub const NVME_SC_ASYMMETRIC_ACCESS_INACCESSIBLE: nvme_path_related_status_code = 2;
pub const NVME_SC_ASYMMETRIC_ACCESS_TRANSITION: nvme_path_related_status_code = 3;
pub const NVME_SC_CONTROLLER_PATHING_ERROR: nvme_path_related_status_code = 96;
pub const NVME_SC_HOST_PATHING_ERROR: nvme_path_related_status_code = 112;
pub const NVME_SC_COMMAND_ABORTED_BY_HOST: nvme_path_related_status_code = 113;
pub type nvme_path_related_status_code = ::core::ffi::c_uint;
pub const NVME_OPC_DELETE_IO_SQ: nvme_admin_opcode = 0;
pub const NVME_OPC_CREATE_IO_SQ: nvme_admin_opcode = 1;
pub const NVME_OPC_GET_LOG_PAGE: nvme_admin_opcode = 2;
pub const NVME_OPC_DELETE_IO_CQ: nvme_admin_opcode = 4;
pub const NVME_OPC_CREATE_IO_CQ: nvme_admin_opcode = 5;
pub const NVME_OPC_IDENTIFY: nvme_admin_opcode = 6;
pub const NVME_OPC_ABORT: nvme_admin_opcode = 8;
pub const NVME_OPC_SET_FEATURES: nvme_admin_opcode = 9;
pub const NVME_OPC_GET_FEATURES: nvme_admin_opcode = 10;
pub const NVME_OPC_ASYNC_EVENT_REQUEST: nvme_admin_opcode = 12;
pub const NVME_OPC_NAMESPACE_MANAGEMENT: nvme_admin_opcode = 13;
pub const NVME_OPC_FIRMWARE_ACTIVATE: nvme_admin_opcode = 16;
pub const NVME_OPC_FIRMWARE_IMAGE_DOWNLOAD: nvme_admin_opcode = 17;
pub const NVME_OPC_DEVICE_SELF_TEST: nvme_admin_opcode = 20;
pub const NVME_OPC_NAMESPACE_ATTACHMENT: nvme_admin_opcode = 21;
pub const NVME_OPC_KEEP_ALIVE: nvme_admin_opcode = 24;
pub const NVME_OPC_DIRECTIVE_SEND: nvme_admin_opcode = 25;
pub const NVME_OPC_DIRECTIVE_RECEIVE: nvme_admin_opcode = 26;
pub const NVME_OPC_VIRTUALIZATION_MANAGEMENT: nvme_admin_opcode = 28;
pub const NVME_OPC_NVME_MI_SEND: nvme_admin_opcode = 29;
pub const NVME_OPC_NVME_MI_RECEIVE: nvme_admin_opcode = 30;
pub const NVME_OPC_CAPACITY_MANAGEMENT: nvme_admin_opcode = 32;
pub const NVME_OPC_LOCKDOWN: nvme_admin_opcode = 36;
pub const NVME_OPC_DOORBELL_BUFFER_CONFIG: nvme_admin_opcode = 124;
pub const NVME_OPC_FABRICS_COMMANDS: nvme_admin_opcode = 127;
pub const NVME_OPC_FORMAT_NVM: nvme_admin_opcode = 128;
pub const NVME_OPC_SECURITY_SEND: nvme_admin_opcode = 129;
pub const NVME_OPC_SECURITY_RECEIVE: nvme_admin_opcode = 130;
pub const NVME_OPC_SANITIZE: nvme_admin_opcode = 132;
pub const NVME_OPC_GET_LBA_STATUS: nvme_admin_opcode = 134;
pub type nvme_admin_opcode = ::core::ffi::c_uint;
pub const NVME_OPC_FLUSH: nvme_nvm_opcode = 0;
pub const NVME_OPC_WRITE: nvme_nvm_opcode = 1;
pub const NVME_OPC_READ: nvme_nvm_opcode = 2;
pub const NVME_OPC_WRITE_UNCORRECTABLE: nvme_nvm_opcode = 4;
pub const NVME_OPC_COMPARE: nvme_nvm_opcode = 5;
pub const NVME_OPC_WRITE_ZEROES: nvme_nvm_opcode = 8;
pub const NVME_OPC_DATASET_MANAGEMENT: nvme_nvm_opcode = 9;
pub const NVME_OPC_VERIFY: nvme_nvm_opcode = 12;
pub const NVME_OPC_RESERVATION_REGISTER: nvme_nvm_opcode = 13;
pub const NVME_OPC_RESERVATION_REPORT: nvme_nvm_opcode = 14;
pub const NVME_OPC_RESERVATION_ACQUIRE: nvme_nvm_opcode = 17;
pub const NVME_OPC_RESERVATION_RELEASE: nvme_nvm_opcode = 21;
pub const NVME_OPC_COPY: nvme_nvm_opcode = 25;
pub type nvme_nvm_opcode = ::core::ffi::c_uint;
pub const NVME_FEAT_ARBITRATION: nvme_feature = 1;
pub const NVME_FEAT_POWER_MANAGEMENT: nvme_feature = 2;
pub const NVME_FEAT_LBA_RANGE_TYPE: nvme_feature = 3;
pub const NVME_FEAT_TEMPERATURE_THRESHOLD: nvme_feature = 4;
pub const NVME_FEAT_ERROR_RECOVERY: nvme_feature = 5;
pub const NVME_FEAT_VOLATILE_WRITE_CACHE: nvme_feature = 6;
pub const NVME_FEAT_NUMBER_OF_QUEUES: nvme_feature = 7;
pub const NVME_FEAT_INTERRUPT_COALESCING: nvme_feature = 8;
pub const NVME_FEAT_INTERRUPT_VECTOR_CONFIGURATION: nvme_feature = 9;
pub const NVME_FEAT_WRITE_ATOMICITY: nvme_feature = 10;
pub const NVME_FEAT_ASYNC_EVENT_CONFIGURATION: nvme_feature = 11;
pub const NVME_FEAT_AUTONOMOUS_POWER_STATE_TRANSITION: nvme_feature = 12;
pub const NVME_FEAT_HOST_MEMORY_BUFFER: nvme_feature = 13;
pub const NVME_FEAT_TIMESTAMP: nvme_feature = 14;
pub const NVME_FEAT_KEEP_ALIVE_TIMER: nvme_feature = 15;
pub const NVME_FEAT_HOST_CONTROLLED_THERMAL_MGMT: nvme_feature = 16;
pub const NVME_FEAT_NON_OP_POWER_STATE_CONFIG: nvme_feature = 17;
pub const NVME_FEAT_READ_RECOVERY_LEVEL_CONFIG: nvme_feature = 18;
pub const NVME_FEAT_PREDICTABLE_LATENCY_MODE_CONFIG: nvme_feature = 19;
pub const NVME_FEAT_PREDICTABLE_LATENCY_MODE_WINDOW: nvme_feature = 20;
pub const NVME_FEAT_LBA_STATUS_INFORMATION_ATTRIBUTES: nvme_feature = 21;
pub const NVME_FEAT_HOST_BEHAVIOR_SUPPORT: nvme_feature = 22;
pub const NVME_FEAT_SANITIZE_CONFIG: nvme_feature = 23;
pub const NVME_FEAT_ENDURANCE_GROUP_EVENT_CONFIGURATION: nvme_feature = 24;
pub const NVME_FEAT_SOFTWARE_PROGRESS_MARKER: nvme_feature = 128;
pub const NVME_FEAT_HOST_IDENTIFIER: nvme_feature = 129;
pub const NVME_FEAT_RESERVATION_NOTIFICATION_MASK: nvme_feature = 130;
pub const NVME_FEAT_RESERVATION_PERSISTENCE: nvme_feature = 131;
pub const NVME_FEAT_NAMESPACE_WRITE_PROTECTION_CONFIG: nvme_feature = 132;
pub type nvme_feature = ::core::ffi::c_uint;
pub const NVME_DSM_ATTR_INTEGRAL_READ: nvme_dsm_attribute = 1;
pub const NVME_DSM_ATTR_INTEGRAL_WRITE: nvme_dsm_attribute = 2;
pub const NVME_DSM_ATTR_DEALLOCATE: nvme_dsm_attribute = 4;
pub type nvme_dsm_attribute = ::core::ffi::c_uint;
pub const NVME_AA_REPLACE_NO_ACTIVATE: nvme_activate_action = 0;
pub const NVME_AA_REPLACE_ACTIVATE: nvme_activate_action = 1;
pub const NVME_AA_ACTIVATE: nvme_activate_action = 2;
pub type nvme_activate_action = ::core::ffi::c_uint;
#[repr(C, packed)]
pub struct nvme_power_state {
    #[doc = " Maximum Power"]
    pub mp: u16,
    pub ps_rsvd1: u8,
    pub mps_nops: u8,
    pub enlat: u32,
    pub exlat: u32,
    pub rrt: u8,
    pub rrl: u8,
    pub rwt: u8,
    pub rwl: u8,
    pub idlp: u16,
    pub ips: u8,
    pub ps_rsvd8: u8,
    pub actp: u16,
    pub apw_aps: u8,
    pub ps_rsvd10: [u8; 9usize],
}
impl Default for nvme_power_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct nvme_controller_data {
    #[doc = " pci vendor id"]
    pub vid: u16,
    #[doc = " pci subsystem vendor id"]
    pub ssvid: u16,
    #[doc = " serial number"]
    pub sn: [u8; 20usize],
    #[doc = " model number"]
    pub mn: [u8; 40usize],
    #[doc = " firmware revision"]
    pub fr: [u8; 8usize],
    #[doc = " recommended arbitration burst"]
    pub rab: u8,
    #[doc = " ieee oui identifier"]
    pub ieee: [u8; 3usize],
    #[doc = " multi-interface capabilities"]
    pub mic: u8,
    #[doc = " maximum data transfer size"]
    pub mdts: u8,
    #[doc = " Controller ID"]
    pub ctrlr_id: u16,
    #[doc = " Version"]
    pub ver: u32,
    #[doc = " RTD3 Resume Latency"]
    pub rtd3r: u32,
    #[doc = " RTD3 Enter Latency"]
    pub rtd3e: u32,
    #[doc = " Optional Asynchronous Events Supported"]
    pub oaes: u32,
    #[doc = " Controller Attributes"]
    pub ctratt: u32,
    #[doc = " Read Recovery Levels Supported"]
    pub rrls: u16,
    pub reserved1: [u8; 9usize],
    #[doc = " Controller Type"]
    pub cntrltype: u8,
    #[doc = " FRU Globally Unique Identifier"]
    pub fguid: [u8; 16usize],
    #[doc = " Command Retry Delay Time 1"]
    pub crdt1: u16,
    #[doc = " Command Retry Delay Time 2"]
    pub crdt2: u16,
    #[doc = " Command Retry Delay Time 3"]
    pub crdt3: u16,
    pub reserved2: [u8; 122usize],
    #[doc = " optional admin command support"]
    pub oacs: u16,
    #[doc = " abort command limit"]
    pub acl: u8,
    #[doc = " asynchronous event request limit"]
    pub aerl: u8,
    #[doc = " firmware updates"]
    pub frmw: u8,
    #[doc = " log page attributes"]
    pub lpa: u8,
    #[doc = " error log page entries"]
    pub elpe: u8,
    #[doc = " number of power states supported"]
    pub npss: u8,
    #[doc = " admin vendor specific command configuration"]
    pub avscc: u8,
    #[doc = " Autonomous Power State Transition Attributes"]
    pub apsta: u8,
    #[doc = " Warning Composite Temperature Threshold"]
    pub wctemp: u16,
    #[doc = " Critical Composite Temperature Threshold"]
    pub cctemp: u16,
    #[doc = " Maximum Time for Firmware Activation"]
    pub mtfa: u16,
    #[doc = " Host Memory Buffer Preferred Size"]
    pub hmpre: u32,
    #[doc = " Host Memory Buffer Minimum Size"]
    pub hmmin: u32,
    pub untncap: nvme_controller_data__bindgen_ty_1,
    #[doc = " Replay Protected Memory Block Support"]
    pub rpmbs: u32,
    #[doc = " Extended Device Self-test Time"]
    pub edstt: u16,
    #[doc = " Device Self-test Options"]
    pub dsto: u8,
    #[doc = " Firmware Update Granularity"]
    pub fwug: u8,
    #[doc = " Keep Alive Support"]
    pub kas: u16,
    #[doc = " Host Controlled Thermal Management Attributes"]
    pub hctma: u16,
    #[doc = " Minimum Thermal Management Temperature"]
    pub mntmt: u16,
    #[doc = " Maximum Thermal Management Temperature"]
    pub mxtmt: u16,
    #[doc = " Sanitize Capabilities"]
    pub sanicap: u32,
    #[doc = " Host Memory Buffer Minimum Descriptor Entry Size"]
    pub hmminds: u32,
    #[doc = " Host Memory Maximum Descriptors Entries"]
    pub hmmaxd: u16,
    #[doc = " NVM Set Identifier Maximum"]
    pub nsetidmax: u16,
    #[doc = " Endurance Group Identifier Maximum"]
    pub endgidmax: u16,
    #[doc = " ANA Transition Time"]
    pub anatt: u8,
    #[doc = " Asymmetric Namespace Access Capabilities"]
    pub anacap: u8,
    #[doc = " ANA Group Identifier Maximum"]
    pub anagrpmax: u32,
    #[doc = " Number of ANA Group Identifiers"]
    pub nanagrpid: u32,
    #[doc = " Persistent Event Log Size"]
    pub pels: u32,
    pub reserved3: [u8; 156usize],
    #[doc = " submission queue entry size"]
    pub sqes: u8,
    #[doc = " completion queue entry size"]
    pub cqes: u8,
    #[doc = " Maximum Outstanding Commands"]
    pub maxcmd: u16,
    #[doc = " number of namespaces"]
    pub nn: u32,
    #[doc = " optional nvm command support"]
    pub oncs: u16,
    #[doc = " fused operation support"]
    pub fuses: u16,
    #[doc = " format nvm attributes"]
    pub fna: u8,
    #[doc = " volatile write cache"]
    pub vwc: u8,
    #[doc = " Atomic Write Unit Normal"]
    pub awun: u16,
    #[doc = " Atomic Write Unit Power Fail"]
    pub awupf: u16,
    #[doc = " NVM Vendor Specific Command Configuration"]
    pub nvscc: u8,
    #[doc = " Namespace Write Protection Capabilities"]
    pub nwpc: u8,
    #[doc = " Atomic Compare & Write Unit"]
    pub acwu: u16,
    pub reserved6: u16,
    #[doc = " SGL Support"]
    pub sgls: u32,
    #[doc = " Maximum Number of Allowed Namespaces"]
    pub mnan: u32,
    pub reserved7: [u8; 224usize],
    #[doc = " NVM Subsystem NVMe Qualified Name"]
    pub subnqn: [u8; 256usize],
    pub reserved8: [u8; 768usize],
    pub ioccsz: u32,
    pub iorcsz: u32,
    pub icdoff: u16,
    pub fcatt: u8,
    pub msdbd: u8,
    pub ofcs: u16,
    pub reserved9: [u8; 242usize],
    pub power_state: [nvme_power_state; 32usize],
    pub vs: [u8; 1024usize],
}
#[doc = " Name space capabilities"]
#[repr(C, packed)]
pub struct nvme_controller_data__bindgen_ty_1 {
    pub tnvmcap: [u8; 16usize],
    pub unvmcap: [u8; 16usize],
}
impl Default for nvme_controller_data__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for nvme_controller_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct nvme_namespace_data {
    #[doc = " namespace size"]
    pub nsze: u64,
    #[doc = " namespace capacity"]
    pub ncap: u64,
    #[doc = " namespace utilization"]
    pub nuse: u64,
    #[doc = " namespace features"]
    pub nsfeat: u8,
    #[doc = " number of lba formats"]
    pub nlbaf: u8,
    #[doc = " formatted lba size"]
    pub flbas: u8,
    #[doc = " metadata capabilities"]
    pub mc: u8,
    #[doc = " end-to-end data protection capabilities"]
    pub dpc: u8,
    #[doc = " end-to-end data protection type settings"]
    pub dps: u8,
    #[doc = " Namespace Multi-path I/O and Namespace Sharing Capabilities"]
    pub nmic: u8,
    #[doc = " Reservation Capabilities"]
    pub rescap: u8,
    #[doc = " Format Progress Indicator"]
    pub fpi: u8,
    #[doc = " Deallocate Logical Block Features"]
    pub dlfeat: u8,
    #[doc = " Namespace Atomic Write Unit Normal"]
    pub nawun: u16,
    #[doc = " Namespace Atomic Write Unit Power Fail"]
    pub nawupf: u16,
    #[doc = " Namespace Atomic Compare & Write Unit"]
    pub nacwu: u16,
    #[doc = " Namespace Atomic Boundary Size Normal"]
    pub nabsn: u16,
    #[doc = " Namespace Atomic Boundary Offset"]
    pub nabo: u16,
    #[doc = " Namespace Atomic Boundary Size Power Fail"]
    pub nabspf: u16,
    #[doc = " Namespace Optimal IO Boundary"]
    pub noiob: u16,
    #[doc = " NVM Capacity"]
    pub nvmcap: [u8; 16usize],
    #[doc = " Namespace Preferred Write Granularity"]
    pub npwg: u16,
    #[doc = " Namespace Preferred Write Alignment"]
    pub npwa: u16,
    #[doc = " Namespace Preferred Deallocate Granularity"]
    pub npdg: u16,
    #[doc = " Namespace Preferred Deallocate Alignment"]
    pub npda: u16,
    #[doc = " Namespace Optimal Write Size"]
    pub nows: u16,
    pub reserved5: [u8; 18usize],
    #[doc = " ANA Group Identifier"]
    pub anagrpid: u32,
    pub reserved6: [u8; 3usize],
    #[doc = " Namespace Attributes"]
    pub nsattr: u8,
    #[doc = " NVM Set Identifier"]
    pub nvmsetid: u16,
    #[doc = " Endurance Group Identifier"]
    pub endgid: u16,
    #[doc = " Namespace Globally Unique Identifier"]
    pub nguid: [u8; 16usize],
    #[doc = " IEEE Extended Unique Identifier"]
    pub eui64: [u8; 8usize],
    #[doc = " lba format support"]
    pub lbaf: [u32; 64usize],
    pub vendor_specific: [u8; 3712usize],
}
impl Default for nvme_namespace_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const NVME_LOG_ERROR: nvme_log_page = 1;
pub const NVME_LOG_HEALTH_INFORMATION: nvme_log_page = 2;
pub const NVME_LOG_FIRMWARE_SLOT: nvme_log_page = 3;
pub const NVME_LOG_CHANGED_NAMESPACE: nvme_log_page = 4;
pub const NVME_LOG_COMMAND_EFFECT: nvme_log_page = 5;
pub const NVME_LOG_DEVICE_SELF_TEST: nvme_log_page = 6;
pub const NVME_LOG_TELEMETRY_HOST_INITIATED: nvme_log_page = 7;
pub const NVME_LOG_TELEMETRY_CONTROLLER_INITIATED: nvme_log_page = 8;
pub const NVME_LOG_ENDURANCE_GROUP_INFORMATION: nvme_log_page = 9;
pub const NVME_LOG_PREDICTABLE_LATENCY_PER_NVM_SET: nvme_log_page = 10;
pub const NVME_LOG_PREDICTABLE_LATENCY_EVENT_AGGREGATE: nvme_log_page = 11;
pub const NVME_LOG_ASYMMETRIC_NAMESPACE_ACCESS: nvme_log_page = 12;
pub const NVME_LOG_PERSISTENT_EVENT_LOG: nvme_log_page = 13;
pub const NVME_LOG_LBA_STATUS_INFORMATION: nvme_log_page = 14;
pub const NVME_LOG_ENDURANCE_GROUP_EVENT_AGGREGATE: nvme_log_page = 15;
pub const NVME_LOG_DISCOVERY: nvme_log_page = 112;
pub const NVME_LOG_RES_NOTIFICATION: nvme_log_page = 128;
pub const NVME_LOG_SANITIZE_STATUS: nvme_log_page = 129;
pub const INTEL_LOG_READ_LAT_LOG: nvme_log_page = 193;
pub const INTEL_LOG_WRITE_LAT_LOG: nvme_log_page = 194;
pub const INTEL_LOG_TEMP_STATS: nvme_log_page = 197;
pub const INTEL_LOG_ADD_SMART: nvme_log_page = 202;
pub const INTEL_LOG_DRIVE_MKT_NAME: nvme_log_page = 221;
pub const HGST_INFO_LOG: nvme_log_page = 193;
pub type nvme_log_page = ::core::ffi::c_uint;
#[repr(C, packed(4))]
pub struct nvme_error_information_entry {
    pub error_count: u64,
    pub sqid: u16,
    pub cid: u16,
    pub status: u16,
    pub error_location: u16,
    pub lba: u64,
    pub nsid: u32,
    pub vendor_specific: u8,
    pub trtype: u8,
    pub reserved30: u16,
    pub csi: u64,
    pub ttsi: u16,
    pub reserved: [u8; 22usize],
}
impl Default for nvme_error_information_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(8))]
pub struct nvme_health_information_page {
    pub critical_warning: u8,
    pub temperature: u16,
    pub available_spare: u8,
    pub available_spare_threshold: u8,
    pub percentage_used: u8,
    pub reserved: [u8; 26usize],
    pub data_units_read: [u64; 2usize],
    pub data_units_written: [u64; 2usize],
    pub host_read_commands: [u64; 2usize],
    pub host_write_commands: [u64; 2usize],
    pub controller_busy_time: [u64; 2usize],
    pub power_cycles: [u64; 2usize],
    pub power_on_hours: [u64; 2usize],
    pub unsafe_shutdowns: [u64; 2usize],
    pub media_errors: [u64; 2usize],
    pub num_error_info_log_entries: [u64; 2usize],
    pub warning_temp_time: u32,
    pub error_temp_time: u32,
    pub temp_sensor: [u16; 8usize],
    pub tmt1tc: u32,
    pub tmt2tc: u32,
    pub ttftmt1: u32,
    pub ttftmt2: u32,
    pub reserved2: [u8; 280usize],
}
impl Default for nvme_health_information_page {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(4))]
pub struct nvme_firmware_page {
    pub afi: u8,
    pub reserved: [u8; 7usize],
    pub revision: [[u8; 8usize]; 7usize],
    pub reserved2: [u8; 448usize],
}
impl Default for nvme_firmware_page {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct nvme_ns_list {
    pub ns: [u32; 1024usize],
}
impl Default for nvme_ns_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct nvme_command_effects_page {
    pub acs: [u32; 256usize],
    pub iocs: [u32; 256usize],
    pub reserved: [u8; 2048usize],
}
impl Default for nvme_command_effects_page {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(4))]
pub struct nvme_device_self_test_page {
    pub curr_operation: u8,
    pub curr_compl: u8,
    pub rsvd2: [u8; 2usize],
    pub result: [nvme_device_self_test_page__bindgen_ty_1; 20usize],
}
#[repr(C, packed)]
pub struct nvme_device_self_test_page__bindgen_ty_1 {
    pub status: u8,
    pub segment_num: u8,
    pub valid_diag_info: u8,
    pub rsvd3: u8,
    pub poh: u64,
    pub nsid: u32,
    pub failing_lba: [u8; 8usize],
    pub status_code_type: u8,
    pub status_code: u8,
    pub vendor_specific: [u8; 2usize],
}
impl Default for nvme_device_self_test_page__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for nvme_device_self_test_page {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct nvme_telemetry_log_page {
    pub identifier: u8,
    pub rsvd: [u8; 4usize],
    pub oui: [u8; 3usize],
    pub da1_last: u16,
    pub da2_last: u16,
    pub da3_last: u16,
    pub rsvd2: [u8; 2usize],
    pub da4_last: u32,
    pub rsvd3: [u8; 361usize],
    pub hi_gen: u8,
    pub ci_avail: u8,
    pub ci_gen: u8,
    pub reason: [u8; 128usize],
}
impl Default for nvme_telemetry_log_page {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(4))]
pub struct nvme_discovery_log_entry {
    pub trtype: u8,
    pub adrfam: u8,
    pub subtype: u8,
    pub treq: u8,
    pub portid: u16,
    pub cntlid: u16,
    pub aqsz: u16,
    pub reserved1: [u8; 22usize],
    pub trsvcid: [u8; 32usize],
    pub reserved2: [u8; 192usize],
    pub subnqn: [u8; 256usize],
    pub traddr: [u8; 256usize],
    pub tsas: nvme_discovery_log_entry__bindgen_ty_1,
}
#[repr(C)]
pub struct nvme_discovery_log_entry__bindgen_ty_1 {
    pub rdma: __BindgenUnionField<nvme_discovery_log_entry__bindgen_ty_1__bindgen_ty_1>,
    pub tcp: __BindgenUnionField<nvme_discovery_log_entry__bindgen_ty_1__bindgen_ty_2>,
    pub reserved: __BindgenUnionField<[u8; 256usize]>,
    pub bindgen_union_field: [u16; 128usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct nvme_discovery_log_entry__bindgen_ty_1__bindgen_ty_1 {
    pub rdma_qptype: u8,
    pub rdma_prtype: u8,
    pub rdma_cms: u8,
    pub reserved: [u8; 5usize],
    pub rdma_pkey: u16,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct nvme_discovery_log_entry__bindgen_ty_1__bindgen_ty_2 {
    pub sectype: u8,
}
impl Default for nvme_discovery_log_entry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for nvme_discovery_log_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct nvme_discovery_log {
    pub genctr: u64,
    pub numrec: u64,
    pub recfmt: u16,
    pub reserved: [u8; 1006usize],
    pub entries: __IncompleteArrayField<nvme_discovery_log_entry>,
}
impl Default for nvme_discovery_log {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct nvme_res_notification_page {
    pub log_page_count: u64,
    pub log_page_type: u8,
    pub available_log_pages: u8,
    pub reserved2: u8,
    pub nsid: u32,
    pub reserved: [u8; 48usize],
}
impl Default for nvme_res_notification_page {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct nvme_sanitize_status_page {
    pub sprog: u16,
    pub sstat: u16,
    pub scdw10: u32,
    pub etfo: u32,
    pub etfbe: u32,
    pub etfce: u32,
    pub etfownd: u32,
    pub etfbewnd: u32,
    pub etfcewnd: u32,
    pub reserved: [u8; 480usize],
}
impl Default for nvme_sanitize_status_page {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct intel_log_temp_stats {
    pub current: u64,
    pub overtemp_flag_last: u64,
    pub overtemp_flag_life: u64,
    pub max_temp: u64,
    pub min_temp: u64,
    pub _rsvd: [u64; 5usize],
    pub max_oper_temp: u64,
    pub min_oper_temp: u64,
    pub est_offset: u64,
}
impl Default for intel_log_temp_stats {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct nvme_resv_reg_ctrlr {
    pub ctrlr_id: u16,
    pub rcsts: u8,
    pub reserved3: [u8; 5usize],
    pub hostid: u64,
    pub rkey: u64,
}
impl Default for nvme_resv_reg_ctrlr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct nvme_resv_reg_ctrlr_ext {
    pub ctrlr_id: u16,
    pub rcsts: u8,
    pub reserved3: [u8; 5usize],
    pub rkey: u64,
    pub hostid: [u64; 2usize],
    pub reserved32: [u8; 32usize],
}
impl Default for nvme_resv_reg_ctrlr_ext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct nvme_resv_status {
    pub gen_: u32,
    pub rtype: u8,
    pub regctl: [u8; 2usize],
    pub reserved7: [u8; 2usize],
    pub ptpls: u8,
    pub reserved10: [u8; 14usize],
    pub ctrlr: __IncompleteArrayField<nvme_resv_reg_ctrlr>,
}
impl Default for nvme_resv_status {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct nvme_resv_status_ext {
    pub gen_: u32,
    pub rtype: u8,
    pub regctl: [u8; 2usize],
    pub reserved7: [u8; 2usize],
    pub ptpls: u8,
    pub reserved10: [u8; 14usize],
    pub reserved24: [u8; 40usize],
    pub ctrlr: __IncompleteArrayField<nvme_resv_reg_ctrlr_ext>,
}
impl Default for nvme_resv_status_ext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nvme_io_test {
    pub opc: nvme_nvm_opcode,
    pub size: u32,
    pub time: u32,
    pub num_threads: u32,
    pub flags: u32,
    pub io_completed: [u64; 128usize],
}
impl Default for nvme_io_test {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const NVME_TEST_FLAG_REFTHREAD: nvme_io_test_flags = 1;
pub type nvme_io_test_flags = ::core::ffi::c_uint;
#[repr(C)]
pub struct nvme_pt_command {
    pub cmd: nvme_command,
    pub cpl: nvme_completion,
    pub buf: *mut ::core::ffi::c_void,
    pub len: u32,
    pub is_read: u32,
    pub driver_lock: *mut mtx,
}
impl Default for nvme_pt_command {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nvme_get_nsid {
    pub cdev: [::core::ffi::c_char; 256usize],
    pub nsid: u32,
}
impl Default for nvme_get_nsid {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct nvme_hmb_desc {
    pub addr: u64,
    pub size: u32,
    pub reserved: u32,
}
#[repr(C)]
#[derive(Debug)]
pub struct nvme_consumer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct nvme_passthru_cmd {
    _unused: [u8; 0],
}
pub type nvme_cb_fn_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *const nvme_completion),
>;
pub type nvme_cons_ns_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nvme_namespace,
        arg2: *mut ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void,
>;
pub type nvme_cons_ctrlr_fn_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut nvme_controller) -> *mut ::core::ffi::c_void,
>;
pub type nvme_cons_async_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const nvme_completion,
        arg3: u32,
        arg4: *mut ::core::ffi::c_void,
        arg5: u32,
    ),
>;
pub type nvme_cons_fail_fn_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
pub const NVME_NS_DEALLOCATE_SUPPORTED: nvme_namespace_flags = 1;
pub const NVME_NS_FLUSH_SUPPORTED: nvme_namespace_flags = 2;
pub type nvme_namespace_flags = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default)]
pub struct nvme_completion_poll_status {
    pub cpl: nvme_completion,
    pub done: ::core::ffi::c_int,
}
#[repr(C)]
pub struct nvme_request {
    pub cmd: nvme_command,
    pub qpair: *mut nvme_qpair,
    pub payload: memdesc,
    pub cb_fn: nvme_cb_fn_t,
    pub cb_arg: *mut ::core::ffi::c_void,
    pub retries: i32,
    pub payload_valid: bool_,
    pub timeout: bool_,
    pub spare: [bool_; 2usize],
    pub stailq: nvme_request__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug)]
pub struct nvme_request__bindgen_ty_1 {
    pub stqe_next: *mut nvme_request,
}
impl Default for nvme_request__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for nvme_request {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nvme_async_event_request {
    pub ctrlr: *mut nvme_controller,
    pub req: *mut nvme_request,
    pub task: task,
    pub mtx: mtx,
    pub cpl: nvme_completion,
    pub log_page_id: u32,
    pub log_page_size: u32,
    pub log_page_buffer: [u8; 4096usize],
}
impl Default for nvme_async_event_request {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nvme_tracker {
    pub tailq: nvme_tracker__bindgen_ty_1,
    pub req: *mut nvme_request,
    pub qpair: *mut nvme_qpair,
    pub deadline: sbintime_t,
    pub payload_dma_map: bus_dmamap_t,
    pub cid: u16,
    pub prp: *mut u64,
    pub prp_bus_addr: bus_addr_t,
}
#[repr(C)]
#[derive(Debug)]
pub struct nvme_tracker__bindgen_ty_1 {
    pub tqe_next: *mut nvme_tracker,
    pub tqe_prev: *mut *mut nvme_tracker,
}
impl Default for nvme_tracker__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for nvme_tracker {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const RECOVERY_NONE: nvme_recovery = 0;
pub const RECOVERY_WAITING: nvme_recovery = 1;
pub type nvme_recovery = ::core::ffi::c_uint;
#[repr(C)]
#[repr(align(128))]
pub struct nvme_qpair {
    pub ctrlr: *mut nvme_controller,
    pub id: u32,
    pub domain: ::core::ffi::c_int,
    pub cpu: ::core::ffi::c_int,
    pub vector: u16,
    pub rid: ::core::ffi::c_int,
    pub res: *mut resource,
    pub tag: *mut ::core::ffi::c_void,
    pub timer: callout,
    pub timer_armed: bool_,
    pub recovery_state: nvme_recovery,
    pub num_entries: u32,
    pub num_trackers: u32,
    pub sq_tdbl_off: u32,
    pub cq_hdbl_off: u32,
    pub phase: u32,
    pub sq_head: u32,
    pub sq_tail: u32,
    pub cq_head: u32,
    pub num_cmds: i64,
    pub num_intr_handler_calls: i64,
    pub num_retries: i64,
    pub num_failures: i64,
    pub num_ignored: i64,
    pub num_recovery_nolock: i64,
    pub cmd: *mut nvme_command,
    pub cpl: *mut nvme_completion,
    pub dma_tag: bus_dma_tag_t,
    pub dma_tag_payload: bus_dma_tag_t,
    pub queuemem_map: bus_dmamap_t,
    pub cmd_bus_addr: u64,
    pub cpl_bus_addr: u64,
    pub free_tr: nvme_qpair__bindgen_ty_1,
    pub outstanding_tr: nvme_qpair__bindgen_ty_2,
    pub queued_req: nvme_qpair__bindgen_ty_3,
    pub act_tr: *mut *mut nvme_tracker,
    pub __bindgen_padding_0: [u64; 9usize],
    pub lock: mtx_padalign,
    pub recovery: mtx_padalign,
}
#[repr(C)]
#[derive(Debug)]
pub struct nvme_qpair__bindgen_ty_1 {
    pub tqh_first: *mut nvme_tracker,
    pub tqh_last: *mut *mut nvme_tracker,
}
impl Default for nvme_qpair__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nvme_qpair__bindgen_ty_2 {
    pub tqh_first: *mut nvme_tracker,
    pub tqh_last: *mut *mut nvme_tracker,
}
impl Default for nvme_qpair__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nvme_qpair__bindgen_ty_3 {
    pub stqh_first: *mut nvme_request,
    pub stqh_last: *mut *mut nvme_request,
}
impl Default for nvme_qpair__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for nvme_qpair {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct nvme_namespace {
    pub ctrlr: *mut nvme_controller,
    pub data: nvme_namespace_data,
    pub id: u32,
    pub flags: u32,
    pub cdev: *mut cdev,
    pub cons_cookie: [*mut ::core::ffi::c_void; 2usize],
    pub boundary: u32,
    pub lock: mtx,
}
impl Default for nvme_namespace {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(128))]
pub struct nvme_controller {
    pub dev: device_t,
    pub lock: mtx,
    pub domain: ::core::ffi::c_int,
    pub ready_timeout_in_ms: u32,
    pub quirks: u32,
    pub bus_tag: bus_space_tag_t,
    pub bus_handle: bus_space_handle_t,
    pub resource_id: ::core::ffi::c_int,
    pub resource: *mut resource,
    pub bar4_resource_id: ::core::ffi::c_int,
    pub bar4_resource: *mut resource,
    pub msi_count: ::core::ffi::c_int,
    pub enable_aborts: u32,
    pub num_io_queues: u32,
    pub max_hw_pend_io: u32,
    pub config_hook: intr_config_hook,
    pub ns_identified: u32,
    pub queues_created: u32,
    pub reset_task: task,
    pub taskqueue: *mut taskqueue,
    pub rid: ::core::ffi::c_int,
    pub res: *mut resource,
    pub tag: *mut ::core::ffi::c_void,
    #[doc = " maximum i/o size in bytes"]
    pub max_xfer_size: u32,
    #[doc = " LO and HI capacity mask"]
    pub cap_lo: u32,
    pub cap_hi: u32,
    #[doc = " Page size and log2(page_size) - 12 that we're currently using"]
    pub page_size: u32,
    pub mps: u32,
    #[doc = " interrupt coalescing time period (in microseconds)"]
    pub int_coal_time: u32,
    #[doc = " interrupt coalescing threshold"]
    pub int_coal_threshold: u32,
    #[doc = " timeout period in seconds"]
    pub admin_timeout_period: u32,
    pub timeout_period: u32,
    #[doc = " doorbell stride"]
    pub dstrd: u32,
    pub __bindgen_padding_0: [u64; 15usize],
    pub adminq: nvme_qpair,
    pub ioq: *mut nvme_qpair,
    pub regs: *mut nvme_registers,
    pub cdata: nvme_controller_data,
    pub ns: [nvme_namespace; 16usize],
    pub cdev: *mut cdev,
    #[doc = " bit mask of event types currently enabled for async events"]
    pub async_event_config: u32,
    pub num_aers: u32,
    pub aer: [nvme_async_event_request; 8usize],
    pub cons_cookie: [*mut ::core::ffi::c_void; 2usize],
    pub is_resetting: u32,
    pub notification_sent: u32,
    pub fail_on_reset: u_int,
    pub is_failed: bool_,
    pub is_failed_admin: bool_,
    pub is_dying: bool_,
    pub isr_warned: bool_,
    pub is_initialized: bool_,
    pub hmb_nchunks: ::core::ffi::c_int,
    pub hmb_chunk: usize,
    pub hmb_tag: bus_dma_tag_t,
    pub hmb_chunks: *mut nvme_controller_nvme_hmb_chunk,
    pub hmb_desc_tag: bus_dma_tag_t,
    pub hmb_desc_map: bus_dmamap_t,
    pub hmb_desc_vaddr: *mut nvme_hmb_desc,
    pub hmb_desc_paddr: u64,
    pub alignment_splits: counter_u64_t,
}
#[repr(C)]
#[derive(Debug)]
pub struct nvme_controller_nvme_hmb_chunk {
    pub hmbc_map: bus_dmamap_t,
    pub hmbc_vaddr: *mut ::core::ffi::c_void,
    pub hmbc_paddr: u64,
}
impl Default for nvme_controller_nvme_hmb_chunk {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for nvme_controller {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief A function implementing the NVME_DELAYED_ATTACH() method"]
pub type nvme_delayed_attach_t = ::core::option::Option<
    unsafe extern "C" fn(dev: device_t, ctrlr: *mut nvme_controller) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the NVME_ENABLE() method"]
pub type nvme_enable_t = ::core::option::Option<unsafe extern "C" fn(dev: device_t)>;
#[doc = " @brief A function implementing the NVME_SQ_ENTER() method"]
pub type nvme_sq_enter_t = ::core::option::Option<
    unsafe extern "C" fn(dev: device_t, qpair: *mut nvme_qpair, tr: *mut nvme_tracker) -> u32,
>;
#[doc = " @brief A function implementing the NVME_SQ_LEAVE() method"]
pub type nvme_sq_leave_t = ::core::option::Option<
    unsafe extern "C" fn(dev: device_t, qpair: *mut nvme_qpair, tr: *mut nvme_tracker),
>;
#[doc = " @brief A function implementing the NVME_CQ_DONE() method"]
pub type nvme_cq_done_t = ::core::option::Option<
    unsafe extern "C" fn(dev: device_t, qpair: *mut nvme_qpair, tr: *mut nvme_tracker),
>;
#[doc = " @brief A function implementing the NVME_QPAIR_CONSTRUCT() method"]
pub type nvme_qpair_construct_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: device_t,
        qpair: *mut nvme_qpair,
        num_entries: u32,
        num_trackers: u32,
        ctrlr: *mut nvme_controller,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the PIC_ACTIVATE_INTR() method"]
pub type pic_activate_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: device_t,
        isrc: *mut intr_irqsrc,
        res: *mut resource,
        data: *mut intr_map_data,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the PIC_BIND_INTR() method"]
pub type pic_bind_intr_t = ::core::option::Option<
    unsafe extern "C" fn(dev: device_t, isrc: *mut intr_irqsrc) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the PIC_DISABLE_INTR() method"]
pub type pic_disable_intr_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t, isrc: *mut intr_irqsrc)>;
#[doc = " @brief A function implementing the PIC_ENABLE_INTR() method"]
pub type pic_enable_intr_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t, isrc: *mut intr_irqsrc)>;
#[doc = " @brief A function implementing the PIC_MAP_INTR() method"]
pub type pic_map_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: device_t,
        data: *mut intr_map_data,
        isrcp: *mut *mut intr_irqsrc,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the PIC_DEACTIVATE_INTR() method"]
pub type pic_deactivate_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: device_t,
        isrc: *mut intr_irqsrc,
        res: *mut resource,
        data: *mut intr_map_data,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the PIC_SETUP_INTR() method"]
pub type pic_setup_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: device_t,
        isrc: *mut intr_irqsrc,
        res: *mut resource,
        data: *mut intr_map_data,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the PIC_TEARDOWN_INTR() method"]
pub type pic_teardown_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: device_t,
        isrc: *mut intr_irqsrc,
        res: *mut resource,
        data: *mut intr_map_data,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the PIC_POST_FILTER() method"]
pub type pic_post_filter_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t, isrc: *mut intr_irqsrc)>;
#[doc = " @brief A function implementing the PIC_POST_ITHREAD() method"]
pub type pic_post_ithread_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t, isrc: *mut intr_irqsrc)>;
#[doc = " @brief A function implementing the PIC_PRE_ITHREAD() method"]
pub type pic_pre_ithread_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t, isrc: *mut intr_irqsrc)>;
#[doc = " @brief A function implementing the PIC_INIT_SECONDARY() method"]
pub type pic_init_secondary_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t, rootnum: u32)>;
#[doc = " @brief A function implementing the PIC_IPI_SEND() method"]
pub type pic_ipi_send_t = ::core::option::Option<
    unsafe extern "C" fn(dev: device_t, isrc: *mut intr_irqsrc, cpus: cpuset_t, ipi: u_int),
>;
#[doc = " @brief A function implementing the PIC_IPI_SETUP() method"]
pub type pic_ipi_setup_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: device_t,
        ipi: u_int,
        isrcp: *mut *mut intr_irqsrc,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Default)]
pub struct witness {
    pub _address: u8,
}
pub type __uint128_t = u128;
#[repr(C)]
#[derive(Debug, Default)]
pub struct intr_event {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct file {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct kaiocb {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct aioliojob {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct vnode {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct cdev_priv {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct sysent {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct seltd {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct umtx_q {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct plimit {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct vnet {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct filedesc {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct filedesc_to_leader {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct pwddesc {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct pstats {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct ktr_io_params {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct itimers {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct sysentvec {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct ktr_request {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct g_consumer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct g_provider {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct buf {
    pub _address: u8,
}
unsafe extern "C" {
    #[link_name = "__bitcount16__extern"]
    pub fn __bitcount16(_x: __uint16_t) -> __uint16_t;
    #[link_name = "__bitcount32__extern"]
    pub fn __bitcount32(_x: __uint32_t) -> __uint32_t;
    #[link_name = "__bitcount64__extern"]
    pub fn __bitcount64(_x: __uint64_t) -> __uint64_t;
    #[link_name = "__major__extern"]
    pub fn __major(_d: dev_t) -> ::core::ffi::c_int;
    #[link_name = "__minor__extern"]
    pub fn __minor(_d: dev_t) -> ::core::ffi::c_int;
    #[link_name = "__makedev__extern"]
    pub fn __makedev(_Major: ::core::ffi::c_int, _Minor: ::core::ffi::c_int) -> dev_t;
    #[link_name = "bintime_addx__extern"]
    pub fn bintime_addx(_bt: *mut bintime, _x: u64);
    #[link_name = "bintime_add__extern"]
    pub fn bintime_add(_bt: *mut bintime, _bt2: *const bintime);
    #[link_name = "bintime_sub__extern"]
    pub fn bintime_sub(_bt: *mut bintime, _bt2: *const bintime);
    #[link_name = "bintime_mul__extern"]
    pub fn bintime_mul(_bt: *mut bintime, _x: u_int);
    #[link_name = "bintime_shift__extern"]
    pub fn bintime_shift(_bt: *mut bintime, _exp: ::core::ffi::c_int);
    #[link_name = "sbintime_getsec__extern"]
    pub fn sbintime_getsec(_sbt: sbintime_t) -> ::core::ffi::c_int;
    #[link_name = "bttosbt__extern"]
    pub fn bttosbt(_bt: bintime) -> sbintime_t;
    #[link_name = "sbttobt__extern"]
    pub fn sbttobt(_sbt: sbintime_t) -> bintime;
    #[link_name = "__stime64_scale32_ceil__extern"]
    pub fn __stime64_scale32_ceil(x: i64, factor: i32, divisor: i32) -> i64;
    #[link_name = "__stime64_scale32_floor__extern"]
    pub fn __stime64_scale32_floor(x: i64, factor: i32, divisor: i32) -> i64;
    #[link_name = "__utime64_scale32_ceil__extern"]
    pub fn __utime64_scale32_ceil(x: u64, factor: u32, divisor: u32) -> u64;
    #[link_name = "__utime64_scale32_floor__extern"]
    pub fn __utime64_scale32_floor(x: u64, factor: u32, divisor: u32) -> u64;
    #[link_name = "__stime64_scale64_ceil__extern"]
    pub fn __stime64_scale64_ceil(x: i64, factor: i64, divisor: i64) -> i64;
    #[link_name = "__stime64_scale64_floor__extern"]
    pub fn __stime64_scale64_floor(x: i64, factor: i64, divisor: i64) -> i64;
    #[link_name = "__utime64_scale64_ceil__extern"]
    pub fn __utime64_scale64_ceil(x: u64, factor: u64, divisor: u64) -> u64;
    #[link_name = "__utime64_scale64_floor__extern"]
    pub fn __utime64_scale64_floor(x: u64, factor: u64, divisor: u64) -> u64;
    #[link_name = "sbttons__extern"]
    pub fn sbttons(sbt: sbintime_t) -> i64;
    #[link_name = "nstosbt__extern"]
    pub fn nstosbt(ns: i64) -> sbintime_t;
    #[link_name = "sbttous__extern"]
    pub fn sbttous(sbt: sbintime_t) -> i64;
    #[link_name = "ustosbt__extern"]
    pub fn ustosbt(us: i64) -> sbintime_t;
    #[link_name = "sbttoms__extern"]
    pub fn sbttoms(sbt: sbintime_t) -> i64;
    #[link_name = "mstosbt__extern"]
    pub fn mstosbt(ms: i64) -> sbintime_t;
    #[link_name = "bintime2timespec__extern"]
    pub fn bintime2timespec(_bt: *const bintime, _ts: *mut timespec);
    #[link_name = "bintime2ns__extern"]
    pub fn bintime2ns(_bt: *const bintime) -> u64;
    #[link_name = "timespec2bintime__extern"]
    pub fn timespec2bintime(_ts: *const timespec, _bt: *mut bintime);
    #[link_name = "bintime2timeval__extern"]
    pub fn bintime2timeval(_bt: *const bintime, _tv: *mut timeval);
    #[link_name = "timeval2bintime__extern"]
    pub fn timeval2bintime(_tv: *const timeval, _bt: *mut bintime);
    #[link_name = "sbttots__extern"]
    pub fn sbttots(_sbt: sbintime_t) -> timespec;
    #[link_name = "tstosbt__extern"]
    pub fn tstosbt(_ts: timespec) -> sbintime_t;
    #[link_name = "sbttotv__extern"]
    pub fn sbttotv(_sbt: sbintime_t) -> timeval;
    #[link_name = "tvtosbt__extern"]
    pub fn tvtosbt(_tv: timeval) -> sbintime_t;
    pub fn inittodr(base: time_t);
    pub fn resettodr();
    pub static mut time_second: time_t;
    pub static mut time_uptime: time_t;
    pub static mut tc_tick_bt: bintime;
    pub static mut tc_tick_sbt: sbintime_t;
    pub static mut tick_seconds_max: time_t;
    pub static mut tick_bt: bintime;
    pub static mut tick_sbt: sbintime_t;
    pub static mut tc_precexp: ::core::ffi::c_int;
    pub static mut tc_timepercentage: ::core::ffi::c_int;
    pub static mut bt_timethreshold: bintime;
    pub static mut bt_tickthreshold: bintime;
    pub static mut sbt_timethreshold: sbintime_t;
    pub static mut sbt_tickthreshold: sbintime_t;
    pub static mut rtc_generation: ::core::ffi::c_int;
    pub fn binuptime(bt: *mut bintime);
    pub fn nanouptime(tsp: *mut timespec);
    pub fn microuptime(tvp: *mut timeval);
    #[link_name = "sbinuptime__extern"]
    pub fn sbinuptime() -> sbintime_t;
    pub fn bintime(bt: *mut bintime);
    pub fn nanotime(tsp: *mut timespec);
    pub fn microtime(tvp: *mut timeval);
    pub fn getbinuptime(bt: *mut bintime);
    pub fn getnanouptime(tsp: *mut timespec);
    pub fn getmicrouptime(tvp: *mut timeval);
    #[link_name = "getsbinuptime__extern"]
    pub fn getsbinuptime() -> sbintime_t;
    pub fn getbintime(bt: *mut bintime);
    pub fn getnanotime(tsp: *mut timespec);
    pub fn getmicrotime(tvp: *mut timeval);
    pub fn getboottime(boottime: *mut timeval);
    pub fn getboottimebin(boottimebin: *mut bintime);
    pub fn itimerdecr(itp: *mut itimerval, usec: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn itimerfix(tv: *mut timeval) -> ::core::ffi::c_int;
    pub fn eventratecheck(
        arg1: *mut timeval,
        arg2: *mut ::core::ffi::c_int,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn ratecheck(arg1: *mut timeval, arg2: *const timeval) -> ::core::ffi::c_int;
    pub fn timevaladd(t1: *mut timeval, t2: *const timeval);
    pub fn timevalsub(t1: *mut timeval, t2: *const timeval);
    pub fn tvtohz(tv: *mut timeval) -> ::core::ffi::c_int;
    pub fn htonl(arg1: __uint32_t) -> __uint32_t;
    pub fn htons(arg1: __uint16_t) -> __uint16_t;
    pub fn ntohl(arg1: __uint32_t) -> __uint32_t;
    pub fn ntohs(arg1: __uint16_t) -> __uint16_t;
    pub static mut panicstr: *const ::core::ffi::c_char;
    pub static mut poisoned_buf: *mut ::core::ffi::c_void;
    pub fn panic(arg1: *const ::core::ffi::c_char, ...) -> !;
    pub fn vpanic(arg1: *const ::core::ffi::c_char, arg2: __va_list) -> !;
    pub fn kobj_class_compile(cls: kobj_class_t);
    pub fn kobj_class_compile_static(cls: kobj_class_t, ops: kobj_ops_t);
    pub fn kobj_class_free(cls: kobj_class_t);
    pub fn kobj_create(
        cls: kobj_class_t,
        mtype: *mut malloc_type,
        mflags: ::core::ffi::c_int,
    ) -> kobj_t;
    pub fn kobj_init(obj: kobj_t, cls: kobj_class_t);
    pub fn kobj_init_static(obj: kobj_t, cls: kobj_class_t);
    pub fn kobj_delete(obj: kobj_t, mtype: *mut malloc_type);
    pub fn kobj_lookup_method(
        cls: kobj_class_t,
        cep: *mut *const kobj_method,
        desc: kobjop_desc_t,
    ) -> *const kobj_method;
    pub fn kobj_error_method() -> ::core::ffi::c_int;
    pub fn callout_init(arg1: *mut callout, arg2: ::core::ffi::c_int);
    pub fn _callout_init_lock(arg1: *mut callout, arg2: *mut lock_object, arg3: ::core::ffi::c_int);
    pub fn callout_reset_sbt_on(
        arg1: *mut callout,
        arg2: sbintime_t,
        arg3: sbintime_t,
        arg4: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg5: *mut ::core::ffi::c_void,
        arg6: ::core::ffi::c_int,
        arg7: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn callout_schedule(arg1: *mut callout, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn callout_schedule_on(
        arg1: *mut callout,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn _callout_stop_safe(arg1: *mut callout, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn callout_process(now: sbintime_t);
    pub fn callout_when(
        sbt: sbintime_t,
        precision: sbintime_t,
        flags: ::core::ffi::c_int,
        sbt_res: *mut sbintime_t,
        prec_res: *mut sbintime_t,
    );
    pub static mut lse_supported: bool;
    #[link_name = "atomic_add_8_llsc__extern"]
    pub fn atomic_add_8_llsc(p: *mut u8, val: u8);
    #[link_name = "atomic_add_8_lse__extern"]
    pub fn atomic_add_8_lse(p: *mut u8, val: u8);
    #[link_name = "atomic_add_8__extern"]
    pub fn atomic_add_8(p: *mut u8, val: u8);
    #[link_name = "atomic_add_16_llsc__extern"]
    pub fn atomic_add_16_llsc(p: *mut u16, val: u16);
    #[link_name = "atomic_add_16_lse__extern"]
    pub fn atomic_add_16_lse(p: *mut u16, val: u16);
    #[link_name = "atomic_add_16__extern"]
    pub fn atomic_add_16(p: *mut u16, val: u16);
    #[link_name = "atomic_add_32_llsc__extern"]
    pub fn atomic_add_32_llsc(p: *mut u32, val: u32);
    #[link_name = "atomic_add_32_lse__extern"]
    pub fn atomic_add_32_lse(p: *mut u32, val: u32);
    #[link_name = "atomic_add_32__extern"]
    pub fn atomic_add_32(p: *mut u32, val: u32);
    #[link_name = "atomic_add_64_llsc__extern"]
    pub fn atomic_add_64_llsc(p: *mut u64, val: u64);
    #[link_name = "atomic_add_64_lse__extern"]
    pub fn atomic_add_64_lse(p: *mut u64, val: u64);
    #[link_name = "atomic_add_64__extern"]
    pub fn atomic_add_64(p: *mut u64, val: u64);
    #[link_name = "atomic_add_acq_8_llsc__extern"]
    pub fn atomic_add_acq_8_llsc(p: *mut u8, val: u8);
    #[link_name = "atomic_add_acq_8_lse__extern"]
    pub fn atomic_add_acq_8_lse(p: *mut u8, val: u8);
    #[link_name = "atomic_add_acq_8__extern"]
    pub fn atomic_add_acq_8(p: *mut u8, val: u8);
    #[link_name = "atomic_add_acq_16_llsc__extern"]
    pub fn atomic_add_acq_16_llsc(p: *mut u16, val: u16);
    #[link_name = "atomic_add_acq_16_lse__extern"]
    pub fn atomic_add_acq_16_lse(p: *mut u16, val: u16);
    #[link_name = "atomic_add_acq_16__extern"]
    pub fn atomic_add_acq_16(p: *mut u16, val: u16);
    #[link_name = "atomic_add_acq_32_llsc__extern"]
    pub fn atomic_add_acq_32_llsc(p: *mut u32, val: u32);
    #[link_name = "atomic_add_acq_32_lse__extern"]
    pub fn atomic_add_acq_32_lse(p: *mut u32, val: u32);
    #[link_name = "atomic_add_acq_32__extern"]
    pub fn atomic_add_acq_32(p: *mut u32, val: u32);
    #[link_name = "atomic_add_acq_64_llsc__extern"]
    pub fn atomic_add_acq_64_llsc(p: *mut u64, val: u64);
    #[link_name = "atomic_add_acq_64_lse__extern"]
    pub fn atomic_add_acq_64_lse(p: *mut u64, val: u64);
    #[link_name = "atomic_add_acq_64__extern"]
    pub fn atomic_add_acq_64(p: *mut u64, val: u64);
    #[link_name = "atomic_add_rel_8_llsc__extern"]
    pub fn atomic_add_rel_8_llsc(p: *mut u8, val: u8);
    #[link_name = "atomic_add_rel_8_lse__extern"]
    pub fn atomic_add_rel_8_lse(p: *mut u8, val: u8);
    #[link_name = "atomic_add_rel_8__extern"]
    pub fn atomic_add_rel_8(p: *mut u8, val: u8);
    #[link_name = "atomic_add_rel_16_llsc__extern"]
    pub fn atomic_add_rel_16_llsc(p: *mut u16, val: u16);
    #[link_name = "atomic_add_rel_16_lse__extern"]
    pub fn atomic_add_rel_16_lse(p: *mut u16, val: u16);
    #[link_name = "atomic_add_rel_16__extern"]
    pub fn atomic_add_rel_16(p: *mut u16, val: u16);
    #[link_name = "atomic_add_rel_32_llsc__extern"]
    pub fn atomic_add_rel_32_llsc(p: *mut u32, val: u32);
    #[link_name = "atomic_add_rel_32_lse__extern"]
    pub fn atomic_add_rel_32_lse(p: *mut u32, val: u32);
    #[link_name = "atomic_add_rel_32__extern"]
    pub fn atomic_add_rel_32(p: *mut u32, val: u32);
    #[link_name = "atomic_add_rel_64_llsc__extern"]
    pub fn atomic_add_rel_64_llsc(p: *mut u64, val: u64);
    #[link_name = "atomic_add_rel_64_lse__extern"]
    pub fn atomic_add_rel_64_lse(p: *mut u64, val: u64);
    #[link_name = "atomic_add_rel_64__extern"]
    pub fn atomic_add_rel_64(p: *mut u64, val: u64);
    #[link_name = "atomic_clear_8_llsc__extern"]
    pub fn atomic_clear_8_llsc(p: *mut u8, val: u8);
    #[link_name = "atomic_clear_8_lse__extern"]
    pub fn atomic_clear_8_lse(p: *mut u8, val: u8);
    #[link_name = "atomic_clear_8__extern"]
    pub fn atomic_clear_8(p: *mut u8, val: u8);
    #[link_name = "atomic_clear_16_llsc__extern"]
    pub fn atomic_clear_16_llsc(p: *mut u16, val: u16);
    #[link_name = "atomic_clear_16_lse__extern"]
    pub fn atomic_clear_16_lse(p: *mut u16, val: u16);
    #[link_name = "atomic_clear_16__extern"]
    pub fn atomic_clear_16(p: *mut u16, val: u16);
    #[link_name = "atomic_clear_32_llsc__extern"]
    pub fn atomic_clear_32_llsc(p: *mut u32, val: u32);
    #[link_name = "atomic_clear_32_lse__extern"]
    pub fn atomic_clear_32_lse(p: *mut u32, val: u32);
    #[link_name = "atomic_clear_32__extern"]
    pub fn atomic_clear_32(p: *mut u32, val: u32);
    #[link_name = "atomic_clear_64_llsc__extern"]
    pub fn atomic_clear_64_llsc(p: *mut u64, val: u64);
    #[link_name = "atomic_clear_64_lse__extern"]
    pub fn atomic_clear_64_lse(p: *mut u64, val: u64);
    #[link_name = "atomic_clear_64__extern"]
    pub fn atomic_clear_64(p: *mut u64, val: u64);
    #[link_name = "atomic_clear_acq_8_llsc__extern"]
    pub fn atomic_clear_acq_8_llsc(p: *mut u8, val: u8);
    #[link_name = "atomic_clear_acq_8_lse__extern"]
    pub fn atomic_clear_acq_8_lse(p: *mut u8, val: u8);
    #[link_name = "atomic_clear_acq_8__extern"]
    pub fn atomic_clear_acq_8(p: *mut u8, val: u8);
    #[link_name = "atomic_clear_acq_16_llsc__extern"]
    pub fn atomic_clear_acq_16_llsc(p: *mut u16, val: u16);
    #[link_name = "atomic_clear_acq_16_lse__extern"]
    pub fn atomic_clear_acq_16_lse(p: *mut u16, val: u16);
    #[link_name = "atomic_clear_acq_16__extern"]
    pub fn atomic_clear_acq_16(p: *mut u16, val: u16);
    #[link_name = "atomic_clear_acq_32_llsc__extern"]
    pub fn atomic_clear_acq_32_llsc(p: *mut u32, val: u32);
    #[link_name = "atomic_clear_acq_32_lse__extern"]
    pub fn atomic_clear_acq_32_lse(p: *mut u32, val: u32);
    #[link_name = "atomic_clear_acq_32__extern"]
    pub fn atomic_clear_acq_32(p: *mut u32, val: u32);
    #[link_name = "atomic_clear_acq_64_llsc__extern"]
    pub fn atomic_clear_acq_64_llsc(p: *mut u64, val: u64);
    #[link_name = "atomic_clear_acq_64_lse__extern"]
    pub fn atomic_clear_acq_64_lse(p: *mut u64, val: u64);
    #[link_name = "atomic_clear_acq_64__extern"]
    pub fn atomic_clear_acq_64(p: *mut u64, val: u64);
    #[link_name = "atomic_clear_rel_8_llsc__extern"]
    pub fn atomic_clear_rel_8_llsc(p: *mut u8, val: u8);
    #[link_name = "atomic_clear_rel_8_lse__extern"]
    pub fn atomic_clear_rel_8_lse(p: *mut u8, val: u8);
    #[link_name = "atomic_clear_rel_8__extern"]
    pub fn atomic_clear_rel_8(p: *mut u8, val: u8);
    #[link_name = "atomic_clear_rel_16_llsc__extern"]
    pub fn atomic_clear_rel_16_llsc(p: *mut u16, val: u16);
    #[link_name = "atomic_clear_rel_16_lse__extern"]
    pub fn atomic_clear_rel_16_lse(p: *mut u16, val: u16);
    #[link_name = "atomic_clear_rel_16__extern"]
    pub fn atomic_clear_rel_16(p: *mut u16, val: u16);
    #[link_name = "atomic_clear_rel_32_llsc__extern"]
    pub fn atomic_clear_rel_32_llsc(p: *mut u32, val: u32);
    #[link_name = "atomic_clear_rel_32_lse__extern"]
    pub fn atomic_clear_rel_32_lse(p: *mut u32, val: u32);
    #[link_name = "atomic_clear_rel_32__extern"]
    pub fn atomic_clear_rel_32(p: *mut u32, val: u32);
    #[link_name = "atomic_clear_rel_64_llsc__extern"]
    pub fn atomic_clear_rel_64_llsc(p: *mut u64, val: u64);
    #[link_name = "atomic_clear_rel_64_lse__extern"]
    pub fn atomic_clear_rel_64_lse(p: *mut u64, val: u64);
    #[link_name = "atomic_clear_rel_64__extern"]
    pub fn atomic_clear_rel_64(p: *mut u64, val: u64);
    #[link_name = "atomic_set_8_llsc__extern"]
    pub fn atomic_set_8_llsc(p: *mut u8, val: u8);
    #[link_name = "atomic_set_8_lse__extern"]
    pub fn atomic_set_8_lse(p: *mut u8, val: u8);
    #[link_name = "atomic_set_8__extern"]
    pub fn atomic_set_8(p: *mut u8, val: u8);
    #[link_name = "atomic_set_16_llsc__extern"]
    pub fn atomic_set_16_llsc(p: *mut u16, val: u16);
    #[link_name = "atomic_set_16_lse__extern"]
    pub fn atomic_set_16_lse(p: *mut u16, val: u16);
    #[link_name = "atomic_set_16__extern"]
    pub fn atomic_set_16(p: *mut u16, val: u16);
    #[link_name = "atomic_set_32_llsc__extern"]
    pub fn atomic_set_32_llsc(p: *mut u32, val: u32);
    #[link_name = "atomic_set_32_lse__extern"]
    pub fn atomic_set_32_lse(p: *mut u32, val: u32);
    #[link_name = "atomic_set_32__extern"]
    pub fn atomic_set_32(p: *mut u32, val: u32);
    #[link_name = "atomic_set_64_llsc__extern"]
    pub fn atomic_set_64_llsc(p: *mut u64, val: u64);
    #[link_name = "atomic_set_64_lse__extern"]
    pub fn atomic_set_64_lse(p: *mut u64, val: u64);
    #[link_name = "atomic_set_64__extern"]
    pub fn atomic_set_64(p: *mut u64, val: u64);
    #[link_name = "atomic_set_acq_8_llsc__extern"]
    pub fn atomic_set_acq_8_llsc(p: *mut u8, val: u8);
    #[link_name = "atomic_set_acq_8_lse__extern"]
    pub fn atomic_set_acq_8_lse(p: *mut u8, val: u8);
    #[link_name = "atomic_set_acq_8__extern"]
    pub fn atomic_set_acq_8(p: *mut u8, val: u8);
    #[link_name = "atomic_set_acq_16_llsc__extern"]
    pub fn atomic_set_acq_16_llsc(p: *mut u16, val: u16);
    #[link_name = "atomic_set_acq_16_lse__extern"]
    pub fn atomic_set_acq_16_lse(p: *mut u16, val: u16);
    #[link_name = "atomic_set_acq_16__extern"]
    pub fn atomic_set_acq_16(p: *mut u16, val: u16);
    #[link_name = "atomic_set_acq_32_llsc__extern"]
    pub fn atomic_set_acq_32_llsc(p: *mut u32, val: u32);
    #[link_name = "atomic_set_acq_32_lse__extern"]
    pub fn atomic_set_acq_32_lse(p: *mut u32, val: u32);
    #[link_name = "atomic_set_acq_32__extern"]
    pub fn atomic_set_acq_32(p: *mut u32, val: u32);
    #[link_name = "atomic_set_acq_64_llsc__extern"]
    pub fn atomic_set_acq_64_llsc(p: *mut u64, val: u64);
    #[link_name = "atomic_set_acq_64_lse__extern"]
    pub fn atomic_set_acq_64_lse(p: *mut u64, val: u64);
    #[link_name = "atomic_set_acq_64__extern"]
    pub fn atomic_set_acq_64(p: *mut u64, val: u64);
    #[link_name = "atomic_set_rel_8_llsc__extern"]
    pub fn atomic_set_rel_8_llsc(p: *mut u8, val: u8);
    #[link_name = "atomic_set_rel_8_lse__extern"]
    pub fn atomic_set_rel_8_lse(p: *mut u8, val: u8);
    #[link_name = "atomic_set_rel_8__extern"]
    pub fn atomic_set_rel_8(p: *mut u8, val: u8);
    #[link_name = "atomic_set_rel_16_llsc__extern"]
    pub fn atomic_set_rel_16_llsc(p: *mut u16, val: u16);
    #[link_name = "atomic_set_rel_16_lse__extern"]
    pub fn atomic_set_rel_16_lse(p: *mut u16, val: u16);
    #[link_name = "atomic_set_rel_16__extern"]
    pub fn atomic_set_rel_16(p: *mut u16, val: u16);
    #[link_name = "atomic_set_rel_32_llsc__extern"]
    pub fn atomic_set_rel_32_llsc(p: *mut u32, val: u32);
    #[link_name = "atomic_set_rel_32_lse__extern"]
    pub fn atomic_set_rel_32_lse(p: *mut u32, val: u32);
    #[link_name = "atomic_set_rel_32__extern"]
    pub fn atomic_set_rel_32(p: *mut u32, val: u32);
    #[link_name = "atomic_set_rel_64_llsc__extern"]
    pub fn atomic_set_rel_64_llsc(p: *mut u64, val: u64);
    #[link_name = "atomic_set_rel_64_lse__extern"]
    pub fn atomic_set_rel_64_lse(p: *mut u64, val: u64);
    #[link_name = "atomic_set_rel_64__extern"]
    pub fn atomic_set_rel_64(p: *mut u64, val: u64);
    #[link_name = "atomic_subtract_8_llsc__extern"]
    pub fn atomic_subtract_8_llsc(p: *mut u8, val: u8);
    #[link_name = "atomic_subtract_8_lse__extern"]
    pub fn atomic_subtract_8_lse(p: *mut u8, val: u8);
    #[link_name = "atomic_subtract_8__extern"]
    pub fn atomic_subtract_8(p: *mut u8, val: u8);
    #[link_name = "atomic_subtract_16_llsc__extern"]
    pub fn atomic_subtract_16_llsc(p: *mut u16, val: u16);
    #[link_name = "atomic_subtract_16_lse__extern"]
    pub fn atomic_subtract_16_lse(p: *mut u16, val: u16);
    #[link_name = "atomic_subtract_16__extern"]
    pub fn atomic_subtract_16(p: *mut u16, val: u16);
    #[link_name = "atomic_subtract_32_llsc__extern"]
    pub fn atomic_subtract_32_llsc(p: *mut u32, val: u32);
    #[link_name = "atomic_subtract_32_lse__extern"]
    pub fn atomic_subtract_32_lse(p: *mut u32, val: u32);
    #[link_name = "atomic_subtract_32__extern"]
    pub fn atomic_subtract_32(p: *mut u32, val: u32);
    #[link_name = "atomic_subtract_64_llsc__extern"]
    pub fn atomic_subtract_64_llsc(p: *mut u64, val: u64);
    #[link_name = "atomic_subtract_64_lse__extern"]
    pub fn atomic_subtract_64_lse(p: *mut u64, val: u64);
    #[link_name = "atomic_subtract_64__extern"]
    pub fn atomic_subtract_64(p: *mut u64, val: u64);
    #[link_name = "atomic_subtract_acq_8_llsc__extern"]
    pub fn atomic_subtract_acq_8_llsc(p: *mut u8, val: u8);
    #[link_name = "atomic_subtract_acq_8_lse__extern"]
    pub fn atomic_subtract_acq_8_lse(p: *mut u8, val: u8);
    #[link_name = "atomic_subtract_acq_8__extern"]
    pub fn atomic_subtract_acq_8(p: *mut u8, val: u8);
    #[link_name = "atomic_subtract_acq_16_llsc__extern"]
    pub fn atomic_subtract_acq_16_llsc(p: *mut u16, val: u16);
    #[link_name = "atomic_subtract_acq_16_lse__extern"]
    pub fn atomic_subtract_acq_16_lse(p: *mut u16, val: u16);
    #[link_name = "atomic_subtract_acq_16__extern"]
    pub fn atomic_subtract_acq_16(p: *mut u16, val: u16);
    #[link_name = "atomic_subtract_acq_32_llsc__extern"]
    pub fn atomic_subtract_acq_32_llsc(p: *mut u32, val: u32);
    #[link_name = "atomic_subtract_acq_32_lse__extern"]
    pub fn atomic_subtract_acq_32_lse(p: *mut u32, val: u32);
    #[link_name = "atomic_subtract_acq_32__extern"]
    pub fn atomic_subtract_acq_32(p: *mut u32, val: u32);
    #[link_name = "atomic_subtract_acq_64_llsc__extern"]
    pub fn atomic_subtract_acq_64_llsc(p: *mut u64, val: u64);
    #[link_name = "atomic_subtract_acq_64_lse__extern"]
    pub fn atomic_subtract_acq_64_lse(p: *mut u64, val: u64);
    #[link_name = "atomic_subtract_acq_64__extern"]
    pub fn atomic_subtract_acq_64(p: *mut u64, val: u64);
    #[link_name = "atomic_subtract_rel_8_llsc__extern"]
    pub fn atomic_subtract_rel_8_llsc(p: *mut u8, val: u8);
    #[link_name = "atomic_subtract_rel_8_lse__extern"]
    pub fn atomic_subtract_rel_8_lse(p: *mut u8, val: u8);
    #[link_name = "atomic_subtract_rel_8__extern"]
    pub fn atomic_subtract_rel_8(p: *mut u8, val: u8);
    #[link_name = "atomic_subtract_rel_16_llsc__extern"]
    pub fn atomic_subtract_rel_16_llsc(p: *mut u16, val: u16);
    #[link_name = "atomic_subtract_rel_16_lse__extern"]
    pub fn atomic_subtract_rel_16_lse(p: *mut u16, val: u16);
    #[link_name = "atomic_subtract_rel_16__extern"]
    pub fn atomic_subtract_rel_16(p: *mut u16, val: u16);
    #[link_name = "atomic_subtract_rel_32_llsc__extern"]
    pub fn atomic_subtract_rel_32_llsc(p: *mut u32, val: u32);
    #[link_name = "atomic_subtract_rel_32_lse__extern"]
    pub fn atomic_subtract_rel_32_lse(p: *mut u32, val: u32);
    #[link_name = "atomic_subtract_rel_32__extern"]
    pub fn atomic_subtract_rel_32(p: *mut u32, val: u32);
    #[link_name = "atomic_subtract_rel_64_llsc__extern"]
    pub fn atomic_subtract_rel_64_llsc(p: *mut u64, val: u64);
    #[link_name = "atomic_subtract_rel_64_lse__extern"]
    pub fn atomic_subtract_rel_64_lse(p: *mut u64, val: u64);
    #[link_name = "atomic_subtract_rel_64__extern"]
    pub fn atomic_subtract_rel_64(p: *mut u64, val: u64);
    #[link_name = "atomic_cmpset_8_llsc__extern"]
    pub fn atomic_cmpset_8_llsc(p: *mut u8, cmpval: u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_8_lse__extern"]
    pub fn atomic_cmpset_8_lse(p: *mut u8, cmpval: u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_8__extern"]
    pub fn atomic_cmpset_8(p: *mut u8, cmpval: u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_8_llsc__extern"]
    pub fn atomic_fcmpset_8_llsc(p: *mut u8, cmpval: *mut u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_8_lse__extern"]
    pub fn atomic_fcmpset_8_lse(p: *mut u8, cmpval: *mut u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_8__extern"]
    pub fn atomic_fcmpset_8(p: *mut u8, cmpval: *mut u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_16_llsc__extern"]
    pub fn atomic_cmpset_16_llsc(p: *mut u16, cmpval: u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_16_lse__extern"]
    pub fn atomic_cmpset_16_lse(p: *mut u16, cmpval: u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_16__extern"]
    pub fn atomic_cmpset_16(p: *mut u16, cmpval: u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_16_llsc__extern"]
    pub fn atomic_fcmpset_16_llsc(p: *mut u16, cmpval: *mut u16, newval: u16)
        -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_16_lse__extern"]
    pub fn atomic_fcmpset_16_lse(p: *mut u16, cmpval: *mut u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_16__extern"]
    pub fn atomic_fcmpset_16(p: *mut u16, cmpval: *mut u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_32_llsc__extern"]
    pub fn atomic_cmpset_32_llsc(p: *mut u32, cmpval: u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_32_lse__extern"]
    pub fn atomic_cmpset_32_lse(p: *mut u32, cmpval: u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_32__extern"]
    pub fn atomic_cmpset_32(p: *mut u32, cmpval: u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_32_llsc__extern"]
    pub fn atomic_fcmpset_32_llsc(p: *mut u32, cmpval: *mut u32, newval: u32)
        -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_32_lse__extern"]
    pub fn atomic_fcmpset_32_lse(p: *mut u32, cmpval: *mut u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_32__extern"]
    pub fn atomic_fcmpset_32(p: *mut u32, cmpval: *mut u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_64_llsc__extern"]
    pub fn atomic_cmpset_64_llsc(p: *mut u64, cmpval: u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_64_lse__extern"]
    pub fn atomic_cmpset_64_lse(p: *mut u64, cmpval: u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_64__extern"]
    pub fn atomic_cmpset_64(p: *mut u64, cmpval: u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_64_llsc__extern"]
    pub fn atomic_fcmpset_64_llsc(p: *mut u64, cmpval: *mut u64, newval: u64)
        -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_64_lse__extern"]
    pub fn atomic_fcmpset_64_lse(p: *mut u64, cmpval: *mut u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_64__extern"]
    pub fn atomic_fcmpset_64(p: *mut u64, cmpval: *mut u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_acq_8_llsc__extern"]
    pub fn atomic_cmpset_acq_8_llsc(p: *mut u8, cmpval: u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_acq_8_lse__extern"]
    pub fn atomic_cmpset_acq_8_lse(p: *mut u8, cmpval: u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_acq_8__extern"]
    pub fn atomic_cmpset_acq_8(p: *mut u8, cmpval: u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_acq_8_llsc__extern"]
    pub fn atomic_fcmpset_acq_8_llsc(p: *mut u8, cmpval: *mut u8, newval: u8)
        -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_acq_8_lse__extern"]
    pub fn atomic_fcmpset_acq_8_lse(p: *mut u8, cmpval: *mut u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_acq_8__extern"]
    pub fn atomic_fcmpset_acq_8(p: *mut u8, cmpval: *mut u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_acq_16_llsc__extern"]
    pub fn atomic_cmpset_acq_16_llsc(p: *mut u16, cmpval: u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_acq_16_lse__extern"]
    pub fn atomic_cmpset_acq_16_lse(p: *mut u16, cmpval: u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_acq_16__extern"]
    pub fn atomic_cmpset_acq_16(p: *mut u16, cmpval: u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_acq_16_llsc__extern"]
    pub fn atomic_fcmpset_acq_16_llsc(
        p: *mut u16,
        cmpval: *mut u16,
        newval: u16,
    ) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_acq_16_lse__extern"]
    pub fn atomic_fcmpset_acq_16_lse(
        p: *mut u16,
        cmpval: *mut u16,
        newval: u16,
    ) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_acq_16__extern"]
    pub fn atomic_fcmpset_acq_16(p: *mut u16, cmpval: *mut u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_acq_32_llsc__extern"]
    pub fn atomic_cmpset_acq_32_llsc(p: *mut u32, cmpval: u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_acq_32_lse__extern"]
    pub fn atomic_cmpset_acq_32_lse(p: *mut u32, cmpval: u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_acq_32__extern"]
    pub fn atomic_cmpset_acq_32(p: *mut u32, cmpval: u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_acq_32_llsc__extern"]
    pub fn atomic_fcmpset_acq_32_llsc(
        p: *mut u32,
        cmpval: *mut u32,
        newval: u32,
    ) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_acq_32_lse__extern"]
    pub fn atomic_fcmpset_acq_32_lse(
        p: *mut u32,
        cmpval: *mut u32,
        newval: u32,
    ) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_acq_32__extern"]
    pub fn atomic_fcmpset_acq_32(p: *mut u32, cmpval: *mut u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_acq_64_llsc__extern"]
    pub fn atomic_cmpset_acq_64_llsc(p: *mut u64, cmpval: u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_acq_64_lse__extern"]
    pub fn atomic_cmpset_acq_64_lse(p: *mut u64, cmpval: u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_acq_64__extern"]
    pub fn atomic_cmpset_acq_64(p: *mut u64, cmpval: u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_acq_64_llsc__extern"]
    pub fn atomic_fcmpset_acq_64_llsc(
        p: *mut u64,
        cmpval: *mut u64,
        newval: u64,
    ) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_acq_64_lse__extern"]
    pub fn atomic_fcmpset_acq_64_lse(
        p: *mut u64,
        cmpval: *mut u64,
        newval: u64,
    ) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_acq_64__extern"]
    pub fn atomic_fcmpset_acq_64(p: *mut u64, cmpval: *mut u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_rel_8_llsc__extern"]
    pub fn atomic_cmpset_rel_8_llsc(p: *mut u8, cmpval: u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_rel_8_lse__extern"]
    pub fn atomic_cmpset_rel_8_lse(p: *mut u8, cmpval: u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_rel_8__extern"]
    pub fn atomic_cmpset_rel_8(p: *mut u8, cmpval: u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_rel_8_llsc__extern"]
    pub fn atomic_fcmpset_rel_8_llsc(p: *mut u8, cmpval: *mut u8, newval: u8)
        -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_rel_8_lse__extern"]
    pub fn atomic_fcmpset_rel_8_lse(p: *mut u8, cmpval: *mut u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_rel_8__extern"]
    pub fn atomic_fcmpset_rel_8(p: *mut u8, cmpval: *mut u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_rel_16_llsc__extern"]
    pub fn atomic_cmpset_rel_16_llsc(p: *mut u16, cmpval: u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_rel_16_lse__extern"]
    pub fn atomic_cmpset_rel_16_lse(p: *mut u16, cmpval: u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_rel_16__extern"]
    pub fn atomic_cmpset_rel_16(p: *mut u16, cmpval: u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_rel_16_llsc__extern"]
    pub fn atomic_fcmpset_rel_16_llsc(
        p: *mut u16,
        cmpval: *mut u16,
        newval: u16,
    ) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_rel_16_lse__extern"]
    pub fn atomic_fcmpset_rel_16_lse(
        p: *mut u16,
        cmpval: *mut u16,
        newval: u16,
    ) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_rel_16__extern"]
    pub fn atomic_fcmpset_rel_16(p: *mut u16, cmpval: *mut u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_rel_32_llsc__extern"]
    pub fn atomic_cmpset_rel_32_llsc(p: *mut u32, cmpval: u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_rel_32_lse__extern"]
    pub fn atomic_cmpset_rel_32_lse(p: *mut u32, cmpval: u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_rel_32__extern"]
    pub fn atomic_cmpset_rel_32(p: *mut u32, cmpval: u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_rel_32_llsc__extern"]
    pub fn atomic_fcmpset_rel_32_llsc(
        p: *mut u32,
        cmpval: *mut u32,
        newval: u32,
    ) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_rel_32_lse__extern"]
    pub fn atomic_fcmpset_rel_32_lse(
        p: *mut u32,
        cmpval: *mut u32,
        newval: u32,
    ) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_rel_32__extern"]
    pub fn atomic_fcmpset_rel_32(p: *mut u32, cmpval: *mut u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_rel_64_llsc__extern"]
    pub fn atomic_cmpset_rel_64_llsc(p: *mut u64, cmpval: u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_rel_64_lse__extern"]
    pub fn atomic_cmpset_rel_64_lse(p: *mut u64, cmpval: u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_rel_64__extern"]
    pub fn atomic_cmpset_rel_64(p: *mut u64, cmpval: u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_rel_64_llsc__extern"]
    pub fn atomic_fcmpset_rel_64_llsc(
        p: *mut u64,
        cmpval: *mut u64,
        newval: u64,
    ) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_rel_64_lse__extern"]
    pub fn atomic_fcmpset_rel_64_lse(
        p: *mut u64,
        cmpval: *mut u64,
        newval: u64,
    ) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_rel_64__extern"]
    pub fn atomic_fcmpset_rel_64(p: *mut u64, cmpval: *mut u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_fetchadd_32_llsc__extern"]
    pub fn atomic_fetchadd_32_llsc(p: *mut u32, val: u32) -> u32;
    #[link_name = "atomic_fetchadd_32_lse__extern"]
    pub fn atomic_fetchadd_32_lse(p: *mut u32, val: u32) -> u32;
    #[link_name = "atomic_fetchadd_32__extern"]
    pub fn atomic_fetchadd_32(p: *mut u32, val: u32) -> u32;
    #[link_name = "atomic_fetchadd_64_llsc__extern"]
    pub fn atomic_fetchadd_64_llsc(p: *mut u64, val: u64) -> u64;
    #[link_name = "atomic_fetchadd_64_lse__extern"]
    pub fn atomic_fetchadd_64_lse(p: *mut u64, val: u64) -> u64;
    #[link_name = "atomic_fetchadd_64__extern"]
    pub fn atomic_fetchadd_64(p: *mut u64, val: u64) -> u64;
    #[link_name = "atomic_swap_32_llsc__extern"]
    pub fn atomic_swap_32_llsc(p: *mut u32, val: u32) -> u32;
    #[link_name = "atomic_swap_32_lse__extern"]
    pub fn atomic_swap_32_lse(p: *mut u32, val: u32) -> u32;
    #[link_name = "atomic_swap_32__extern"]
    pub fn atomic_swap_32(p: *mut u32, val: u32) -> u32;
    #[link_name = "atomic_readandclear_32_llsc__extern"]
    pub fn atomic_readandclear_32_llsc(p: *mut u32) -> u32;
    #[link_name = "atomic_readandclear_32_lse__extern"]
    pub fn atomic_readandclear_32_lse(p: *mut u32) -> u32;
    #[link_name = "atomic_readandclear_32__extern"]
    pub fn atomic_readandclear_32(p: *mut u32) -> u32;
    #[link_name = "atomic_swap_64_llsc__extern"]
    pub fn atomic_swap_64_llsc(p: *mut u64, val: u64) -> u64;
    #[link_name = "atomic_swap_64_lse__extern"]
    pub fn atomic_swap_64_lse(p: *mut u64, val: u64) -> u64;
    #[link_name = "atomic_swap_64__extern"]
    pub fn atomic_swap_64(p: *mut u64, val: u64) -> u64;
    #[link_name = "atomic_readandclear_64_llsc__extern"]
    pub fn atomic_readandclear_64_llsc(p: *mut u64) -> u64;
    #[link_name = "atomic_readandclear_64_lse__extern"]
    pub fn atomic_readandclear_64_lse(p: *mut u64) -> u64;
    #[link_name = "atomic_readandclear_64__extern"]
    pub fn atomic_readandclear_64(p: *mut u64) -> u64;
    #[link_name = "atomic_testandclear_32_llsc__extern"]
    pub fn atomic_testandclear_32_llsc(p: *mut u32, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandclear_32_lse__extern"]
    pub fn atomic_testandclear_32_lse(p: *mut u32, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandclear_32__extern"]
    pub fn atomic_testandclear_32(p: *mut u32, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandclear_acq_32_llsc__extern"]
    pub fn atomic_testandclear_acq_32_llsc(p: *mut u32, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandclear_acq_32_lse__extern"]
    pub fn atomic_testandclear_acq_32_lse(p: *mut u32, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandclear_acq_32__extern"]
    pub fn atomic_testandclear_acq_32(p: *mut u32, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandclear_64_llsc__extern"]
    pub fn atomic_testandclear_64_llsc(p: *mut u64, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandclear_64_lse__extern"]
    pub fn atomic_testandclear_64_lse(p: *mut u64, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandclear_64__extern"]
    pub fn atomic_testandclear_64(p: *mut u64, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandclear_acq_64_llsc__extern"]
    pub fn atomic_testandclear_acq_64_llsc(p: *mut u64, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandclear_acq_64_lse__extern"]
    pub fn atomic_testandclear_acq_64_lse(p: *mut u64, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandclear_acq_64__extern"]
    pub fn atomic_testandclear_acq_64(p: *mut u64, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandset_32_llsc__extern"]
    pub fn atomic_testandset_32_llsc(p: *mut u32, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandset_32_lse__extern"]
    pub fn atomic_testandset_32_lse(p: *mut u32, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandset_32__extern"]
    pub fn atomic_testandset_32(p: *mut u32, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandset_acq_32_llsc__extern"]
    pub fn atomic_testandset_acq_32_llsc(p: *mut u32, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandset_acq_32_lse__extern"]
    pub fn atomic_testandset_acq_32_lse(p: *mut u32, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandset_acq_32__extern"]
    pub fn atomic_testandset_acq_32(p: *mut u32, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandset_64_llsc__extern"]
    pub fn atomic_testandset_64_llsc(p: *mut u64, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandset_64_lse__extern"]
    pub fn atomic_testandset_64_lse(p: *mut u64, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandset_64__extern"]
    pub fn atomic_testandset_64(p: *mut u64, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandset_acq_64_llsc__extern"]
    pub fn atomic_testandset_acq_64_llsc(p: *mut u64, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandset_acq_64_lse__extern"]
    pub fn atomic_testandset_acq_64_lse(p: *mut u64, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandset_acq_64__extern"]
    pub fn atomic_testandset_acq_64(p: *mut u64, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_load_acq_8__extern"]
    pub fn atomic_load_acq_8(p: *const u8) -> u8;
    #[link_name = "atomic_load_acq_16__extern"]
    pub fn atomic_load_acq_16(p: *const u16) -> u16;
    #[link_name = "atomic_load_acq_32__extern"]
    pub fn atomic_load_acq_32(p: *const u32) -> u32;
    #[link_name = "atomic_load_acq_64__extern"]
    pub fn atomic_load_acq_64(p: *const u64) -> u64;
    #[link_name = "atomic_store_rel_8__extern"]
    pub fn atomic_store_rel_8(p: *mut u8, val: u8);
    #[link_name = "atomic_store_rel_16__extern"]
    pub fn atomic_store_rel_16(p: *mut u16, val: u16);
    #[link_name = "atomic_store_rel_32__extern"]
    pub fn atomic_store_rel_32(p: *mut u32, val: u32);
    #[link_name = "atomic_store_rel_64__extern"]
    pub fn atomic_store_rel_64(p: *mut u64, val: u64);
    #[link_name = "atomic_thread_fence_acq__extern"]
    pub fn atomic_thread_fence_acq();
    #[link_name = "atomic_thread_fence_rel__extern"]
    pub fn atomic_thread_fence_rel();
    #[link_name = "atomic_thread_fence_acq_rel__extern"]
    pub fn atomic_thread_fence_acq_rel();
    #[link_name = "atomic_thread_fence_seq_cst__extern"]
    pub fn atomic_thread_fence_seq_cst();
    #[link_name = "breakpoint__extern"]
    pub fn breakpoint();
    #[link_name = "dbg_disable__extern"]
    pub fn dbg_disable() -> register_t;
    #[link_name = "dbg_enable__extern"]
    pub fn dbg_enable();
    #[link_name = "intr_disable__extern"]
    pub fn intr_disable() -> register_t;
    #[link_name = "intr_restore__extern"]
    pub fn intr_restore(s: register_t);
    #[link_name = "intr_enable__extern"]
    pub fn intr_enable();
    #[link_name = "serror_enable__extern"]
    pub fn serror_enable();
    #[link_name = "get_midr__extern"]
    pub fn get_midr() -> register_t;
    #[link_name = "get_mpidr__extern"]
    pub fn get_mpidr() -> register_t;
    #[link_name = "clrex__extern"]
    pub fn clrex();
    #[link_name = "set_ttbr0__extern"]
    pub fn set_ttbr0(ttbr0: u64);
    #[link_name = "invalidate_icache__extern"]
    pub fn invalidate_icache();
    #[link_name = "invalidate_local_icache__extern"]
    pub fn invalidate_local_icache();
    #[link_name = "wfet__extern"]
    pub fn wfet(val: u64);
    #[link_name = "wfit__extern"]
    pub fn wfit(val: u64);
    pub static mut icache_aliasing: bool_;
    pub static mut icache_vmid: bool_;
    pub static mut dcache_line_size: i64;
    pub static mut icache_line_size: i64;
    pub static mut idcache_line_size: i64;
    pub static mut dczva_line_size: i64;
    pub static mut arm64_icache_sync_range: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: vm_size_t),
    >;
    pub fn arm64_nullop();
    pub fn arm64_tlb_flushID();
    pub fn arm64_dic_idc_icache_sync_range(arg1: *mut ::core::ffi::c_void, arg2: vm_size_t);
    pub fn arm64_idc_aliasing_icache_sync_range(arg1: *mut ::core::ffi::c_void, arg2: vm_size_t);
    pub fn arm64_aliasing_icache_sync_range(arg1: *mut ::core::ffi::c_void, arg2: vm_size_t);
    pub fn arm64_icache_sync_range_checked(
        arg1: *mut ::core::ffi::c_void,
        arg2: vm_size_t,
    ) -> ::core::ffi::c_int;
    pub fn arm64_dcache_wbinv_range(arg1: *mut ::core::ffi::c_void, arg2: vm_size_t);
    pub fn arm64_dcache_inv_range(arg1: *mut ::core::ffi::c_void, arg2: vm_size_t);
    pub fn arm64_dcache_wb_range(arg1: *mut ::core::ffi::c_void, arg2: vm_size_t);
    pub fn arm64_get_writable_addr(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut *mut ::core::ffi::c_void,
    ) -> bool_;
    pub static mut cold: ::core::ffi::c_int;
    pub static mut suspend_blocked: ::core::ffi::c_int;
    pub static mut rebooting: ::core::ffi::c_int;
    pub static version: [::core::ffi::c_char; 0usize];
    pub static compiler_version: [::core::ffi::c_char; 0usize];
    pub static copyright: [::core::ffi::c_char; 0usize];
    pub static mut kstack_pages: ::core::ffi::c_int;
    pub static mut pagesizes: [u_long; 0usize];
    pub static mut physmem: ::core::ffi::c_long;
    pub static mut realmem: ::core::ffi::c_long;
    pub static mut rootdevnames: [*mut ::core::ffi::c_char; 2usize];
    pub static mut boothowto: ::core::ffi::c_int;
    pub static mut bootverbose: ::core::ffi::c_int;
    pub static mut maxusers: ::core::ffi::c_int;
    pub static mut ngroups_max: ::core::ffi::c_int;
    pub static mut vm_guest: ::core::ffi::c_int;
    pub static mut maxphys: u_long;
    pub static mut averunnable: loadavg;
    pub fn read_cpu_time(cp_time: *mut ::core::ffi::c_long);
    pub fn signal(arg1: ::core::ffi::c_int, arg2: __sighandler_t) -> __sighandler_t;
    pub fn convert_sigevent32(sig32: *mut sigevent32, sig: *mut sigevent) -> ::core::ffi::c_int;
    pub fn siginfo_to_siginfo32(src: *const siginfo_t, dst: *mut __siginfo32);
    pub fn get_mcontext(
        arg1: *mut thread,
        arg2: *mut mcontext_t,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn set_mcontext(arg1: *mut thread, arg2: *mut mcontext_t) -> ::core::ffi::c_int;
    #[link_name = "midr_check_var_part_range__extern"]
    pub fn midr_check_var_part_range(
        midr: u_int,
        impl_: u_int,
        part: u_int,
        var_low: u_int,
        part_low: u_int,
        var_high: u_int,
        part_high: u_int,
    ) -> bool_;
    pub static mut btext: [::core::ffi::c_char; 0usize];
    pub static mut etext: [::core::ffi::c_char; 0usize];
    pub static mut __cpu_affinity: [u64; 0usize];
    pub static mut elf64_addr_mask: arm64_addr_mask;
    pub static mut elf64_addr_mask_14: arm64_addr_mask;
    pub static mut cpu_reset_hook: cpu_reset_hook_t;
    pub fn cpu_halt() -> !;
    pub fn cpu_reset() -> !;
    pub fn fork_trampoline();
    pub fn identify_cache(arg1: u64);
    pub fn identify_cpu(arg1: u_int);
    pub fn install_cpu_errata();
    pub fn ptrauth_init();
    pub fn ptrauth_fork(arg1: *mut thread, arg2: *mut thread);
    pub fn ptrauth_exec(arg1: *mut thread);
    pub fn ptrauth_copy_thread(arg1: *mut thread, arg2: *mut thread);
    pub fn ptrauth_thread_alloc(arg1: *mut thread);
    pub fn ptrauth_thread0(arg1: *mut thread);
    pub fn ptrauth_mp_start(arg1: u64);
    pub fn update_special_regs(arg1: u_int);
    pub fn update_special_reg_iss(arg1: u_int, arg2: u64, arg3: u64);
    pub fn get_kernel_reg_iss(arg1: u_int, arg2: *mut u64) -> bool_;
    pub fn get_kernel_reg_iss_masked(arg1: u_int, arg2: *mut u64, arg3: u64) -> bool_;
    pub fn get_user_reg_iss(arg1: u_int, arg2: *mut u64, arg3: bool_) -> bool_;
    pub fn cpu_desc_init();
    #[link_name = "get_cyclecount__extern"]
    pub fn get_cyclecount() -> u64;
    #[link_name = "arm64_address_translate_s1e0r__extern"]
    pub fn arm64_address_translate_s1e0r(addr: u64) -> u64;
    #[link_name = "arm64_address_translate_s1e0w__extern"]
    pub fn arm64_address_translate_s1e0w(addr: u64) -> u64;
    #[link_name = "arm64_address_translate_s1e1r__extern"]
    pub fn arm64_address_translate_s1e1r(addr: u64) -> u64;
    #[link_name = "arm64_address_translate_s1e1w__extern"]
    pub fn arm64_address_translate_s1e1w(addr: u64) -> u64;
    #[link_name = "\u{1}x18"]
    pub static mut pcpup: *mut pcpu;
    #[link_name = "get_pcpu__extern"]
    pub fn get_pcpu() -> *mut pcpu;
    #[link_name = "get_curthread__extern"]
    pub fn get_curthread() -> *mut thread;
    pub static mut __start_set_pcpu: *mut usize;
    pub static mut __stop_set_pcpu: *mut usize;
    pub static mut dpcpu_off: [usize; 0usize];
    pub static mut cpuhead: cpuhead;
    pub static mut cpuid_to_pcpu: [*mut pcpu; 0usize];
    pub static mut pcpu0: pcpu;
    pub fn cpu_pcpu_init(pcpu: *mut pcpu, cpuid: ::core::ffi::c_int, size: usize);
    pub fn db_show_mdpcpu(pcpu: *mut pcpu);
    pub fn dpcpu_alloc(size: ::core::ffi::c_int) -> *mut ::core::ffi::c_void;
    pub fn dpcpu_copy(s: *mut ::core::ffi::c_void, size: ::core::ffi::c_int);
    pub fn dpcpu_free(s: *mut ::core::ffi::c_void, size: ::core::ffi::c_int);
    pub fn dpcpu_init(dpcpu: *mut ::core::ffi::c_void, cpuid: ::core::ffi::c_int);
    pub fn pcpu_destroy(pcpu: *mut pcpu);
    pub fn pcpu_find(cpuid: u_int) -> *mut pcpu;
    pub fn pcpu_init(pcpu: *mut pcpu, cpuid: ::core::ffi::c_int, size: usize);
    #[link_name = "sched_pin_lite__extern"]
    pub fn sched_pin_lite(td: *mut thread_lite);
    #[link_name = "sched_unpin_lite__extern"]
    pub fn sched_unpin_lite(td: *mut thread_lite);
    pub static mut scheduler_stopped: bool_;
    pub static osreldate: ::core::ffi::c_int;
    pub static mut zero_region: *const ::core::ffi::c_void;
    pub static mut unmapped_buf_allowed: ::core::ffi::c_int;
    pub fn setjmp(arg1: *mut _jmp_buf) -> ::core::ffi::c_int;
    pub fn longjmp(arg1: *mut _jmp_buf, arg2: ::core::ffi::c_int) -> !;
    pub fn dumpstatus(addr: vm_offset_t, count: off_t) -> ::core::ffi::c_int;
    pub fn nullop() -> ::core::ffi::c_int;
    pub fn eopnotsupp() -> ::core::ffi::c_int;
    pub fn ureadc(arg1: ::core::ffi::c_int, arg2: *mut uio) -> ::core::ffi::c_int;
    pub fn hashdestroy(arg1: *mut ::core::ffi::c_void, arg2: *mut malloc_type, arg3: u_long);
    pub fn hashinit(
        count: ::core::ffi::c_int,
        type_: *mut malloc_type,
        hashmask: *mut u_long,
    ) -> *mut ::core::ffi::c_void;
    pub fn hashinit_flags(
        count: ::core::ffi::c_int,
        type_: *mut malloc_type,
        hashmask: *mut u_long,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn phashinit(
        count: ::core::ffi::c_int,
        type_: *mut malloc_type,
        nentries: *mut u_long,
    ) -> *mut ::core::ffi::c_void;
    pub fn phashinit_flags(
        count: ::core::ffi::c_int,
        type_: *mut malloc_type,
        nentries: *mut u_long,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn cpu_flush_dcache(arg1: *mut ::core::ffi::c_void, arg2: usize);
    pub fn cpu_rootconf();
    pub fn critical_enter_KBI();
    pub fn critical_exit_KBI();
    pub fn critical_exit_preempt();
    pub fn init_param1();
    pub fn init_param2(physpages: ::core::ffi::c_long);
    pub fn init_static_kenv(arg1: *mut ::core::ffi::c_char, arg2: usize);
    pub fn tablefull(arg1: *const ::core::ffi::c_char);
    pub static mut lkpi_alloc_current: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut thread, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int,
    >;
    pub fn linux_alloc_current_noop(
        arg1: *mut thread,
        arg2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[link_name = "critical_enter__extern"]
    pub fn critical_enter();
    #[link_name = "critical_exit__extern"]
    pub fn critical_exit();
    pub fn kvprintf(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: ::core::ffi::c_int, arg2: *mut ::core::ffi::c_void),
        >,
        arg3: *mut ::core::ffi::c_void,
        arg4: ::core::ffi::c_int,
        arg5: __va_list,
    ) -> ::core::ffi::c_int;
    pub fn log(arg1: ::core::ffi::c_int, arg2: *const ::core::ffi::c_char, ...);
    pub fn log_console(arg1: *mut uio);
    pub fn vlog(arg1: ::core::ffi::c_int, arg2: *const ::core::ffi::c_char, arg3: __va_list);
    pub fn asprintf(
        ret: *mut *mut ::core::ffi::c_char,
        mtp: *mut malloc_type,
        format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn printf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn snprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: usize,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn sprintf(
        buf: *mut ::core::ffi::c_char,
        arg1: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn uprintf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn vprintf(arg1: *const ::core::ffi::c_char, arg2: __va_list) -> ::core::ffi::c_int;
    pub fn vasprintf(
        ret: *mut *mut ::core::ffi::c_char,
        mtp: *mut malloc_type,
        format: *const ::core::ffi::c_char,
        ap: __va_list,
    ) -> ::core::ffi::c_int;
    pub fn vsnprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: usize,
        arg3: *const ::core::ffi::c_char,
        arg4: __va_list,
    ) -> ::core::ffi::c_int;
    pub fn vsnrprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: usize,
        arg3: ::core::ffi::c_int,
        arg4: *const ::core::ffi::c_char,
        arg5: __va_list,
    ) -> ::core::ffi::c_int;
    pub fn vsprintf(
        buf: *mut ::core::ffi::c_char,
        arg1: *const ::core::ffi::c_char,
        arg2: __va_list,
    ) -> ::core::ffi::c_int;
    pub fn sscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn vsscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: __va_list,
    ) -> ::core::ffi::c_int;
    pub fn strtol(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_long;
    pub fn strtoul(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> u_long;
    pub fn strtoq(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> quad_t;
    pub fn strtouq(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> u_quad_t;
    pub fn tprintf(p: *mut proc_, pri: ::core::ffi::c_int, arg1: *const ::core::ffi::c_char, ...);
    pub fn vtprintf(
        arg1: *mut proc_,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: __va_list,
    );
    pub fn hexdump(
        ptr: *const ::core::ffi::c_void,
        length: ::core::ffi::c_int,
        hdr: *const ::core::ffi::c_char,
        flags: ::core::ffi::c_int,
    );
    pub fn explicit_bzero(arg1: *mut ::core::ffi::c_void, arg2: usize);
    pub fn memset(
        buf: *mut ::core::ffi::c_void,
        c: ::core::ffi::c_int,
        len: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn memcpy(
        to: *mut ::core::ffi::c_void,
        from: *const ::core::ffi::c_void,
        len: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn memmove(
        dest: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        n: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn memcmp(
        b1: *const ::core::ffi::c_void,
        b2: *const ::core::ffi::c_void,
        len: usize,
    ) -> ::core::ffi::c_int;
    pub fn memset_early(
        buf: *mut ::core::ffi::c_void,
        c: ::core::ffi::c_int,
        len: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn memcpy_early(
        to: *mut ::core::ffi::c_void,
        from: *const ::core::ffi::c_void,
        len: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn memmove_early(
        dest: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        n: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn copyinstr(
        udaddr: *const ::core::ffi::c_void,
        kaddr: *mut ::core::ffi::c_void,
        len: usize,
        lencopied: *mut usize,
    ) -> ::core::ffi::c_int;
    pub fn copyin(
        udaddr: *const ::core::ffi::c_void,
        kaddr: *mut ::core::ffi::c_void,
        len: usize,
    ) -> ::core::ffi::c_int;
    pub fn copyin_nofault(
        udaddr: *const ::core::ffi::c_void,
        kaddr: *mut ::core::ffi::c_void,
        len: usize,
    ) -> ::core::ffi::c_int;
    pub fn copyout(
        kaddr: *const ::core::ffi::c_void,
        udaddr: *mut ::core::ffi::c_void,
        len: usize,
    ) -> ::core::ffi::c_int;
    pub fn copyout_nofault(
        kaddr: *const ::core::ffi::c_void,
        udaddr: *mut ::core::ffi::c_void,
        len: usize,
    ) -> ::core::ffi::c_int;
    pub fn fubyte(base: *const ::core::ffi::c_void) -> ::core::ffi::c_int;
    pub fn fuword(base: *const ::core::ffi::c_void) -> ::core::ffi::c_long;
    pub fn fuword16(base: *const ::core::ffi::c_void) -> ::core::ffi::c_int;
    pub fn fuword32(base: *const ::core::ffi::c_void) -> i32;
    pub fn fuword64(base: *const ::core::ffi::c_void) -> i64;
    pub fn fueword(
        base: *const ::core::ffi::c_void,
        val: *mut ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
    pub fn fueword32(base: *const ::core::ffi::c_void, val: *mut i32) -> ::core::ffi::c_int;
    pub fn fueword64(base: *const ::core::ffi::c_void, val: *mut i64) -> ::core::ffi::c_int;
    pub fn subyte(base: *mut ::core::ffi::c_void, byte: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn suword(base: *mut ::core::ffi::c_void, word: ::core::ffi::c_long) -> ::core::ffi::c_int;
    pub fn suword16(base: *mut ::core::ffi::c_void, word: ::core::ffi::c_int)
        -> ::core::ffi::c_int;
    pub fn suword32(base: *mut ::core::ffi::c_void, word: i32) -> ::core::ffi::c_int;
    pub fn suword64(base: *mut ::core::ffi::c_void, word: i64) -> ::core::ffi::c_int;
    pub fn casuword32(base: *mut u32, oldval: u32, newval: u32) -> u32;
    pub fn casuword(p: *mut u_long, oldval: u_long, newval: u_long) -> u_long;
    pub fn casueword32(
        base: *mut u32,
        oldval: u32,
        oldvalp: *mut u32,
        newval: u32,
    ) -> ::core::ffi::c_int;
    pub fn casueword(
        p: *mut u_long,
        oldval: u_long,
        oldvalp: *mut u_long,
        newval: u_long,
    ) -> ::core::ffi::c_int;
    pub fn sysbeep(hertz: ::core::ffi::c_int, duration: sbintime_t) -> ::core::ffi::c_int;
    pub fn hardclock(cnt: ::core::ffi::c_int, usermode: ::core::ffi::c_int);
    pub fn hardclock_sync(cpu: ::core::ffi::c_int);
    pub fn statclock(cnt: ::core::ffi::c_int, usermode: ::core::ffi::c_int);
    pub fn profclock(cnt: ::core::ffi::c_int, usermode: ::core::ffi::c_int, pc: uintfptr_t);
    pub fn hardclockintr() -> ::core::ffi::c_int;
    pub fn startprofclock(arg1: *mut proc_);
    pub fn stopprofclock(arg1: *mut proc_);
    pub fn cpu_startprofclock();
    pub fn cpu_stopprofclock();
    pub fn suspendclock();
    pub fn resumeclock();
    pub fn cpu_idleclock() -> sbintime_t;
    pub fn cpu_activeclock();
    pub fn cpu_new_callout(cpu: ::core::ffi::c_int, bt: sbintime_t, bt_opt: sbintime_t);
    pub fn cpu_et_frequency(et: *mut eventtimer, newfreq: u64);
    pub static mut cpu_disable_c2_sleep: ::core::ffi::c_int;
    pub static mut cpu_disable_c3_sleep: ::core::ffi::c_int;
    pub static mut tcp_hpts_softclock: ::core::option::Option<unsafe extern "C" fn()>;
    pub static mut hpts_that_need_softclock: u32;
    pub fn kern_getenv(name: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn freeenv(env: *mut ::core::ffi::c_char);
    pub fn getenv_int(
        name: *const ::core::ffi::c_char,
        data: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn getenv_uint(
        name: *const ::core::ffi::c_char,
        data: *mut ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
    pub fn getenv_long(
        name: *const ::core::ffi::c_char,
        data: *mut ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
    pub fn getenv_ulong(
        name: *const ::core::ffi::c_char,
        data: *mut ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
    pub fn getenv_string(
        name: *const ::core::ffi::c_char,
        data: *mut ::core::ffi::c_char,
        size: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn getenv_int64(name: *const ::core::ffi::c_char, data: *mut i64) -> ::core::ffi::c_int;
    pub fn getenv_uint64(name: *const ::core::ffi::c_char, data: *mut u64) -> ::core::ffi::c_int;
    pub fn getenv_quad(name: *const ::core::ffi::c_char, data: *mut quad_t) -> ::core::ffi::c_int;
    pub fn getenv_bool(name: *const ::core::ffi::c_char, data: *mut bool_) -> ::core::ffi::c_int;
    pub fn getenv_is_true(name: *const ::core::ffi::c_char) -> bool_;
    pub fn getenv_is_false(name: *const ::core::ffi::c_char) -> bool_;
    pub fn kern_setenv(
        name: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn kern_unsetenv(name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn testenv(name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn getenv_array(
        name: *const ::core::ffi::c_char,
        data: *mut ::core::ffi::c_void,
        size: ::core::ffi::c_int,
        psize: *mut ::core::ffi::c_int,
        type_size: ::core::ffi::c_int,
        allow_signed: bool_,
    ) -> ::core::ffi::c_int;
    pub fn set_cputicker(func: cpu_tick_f, freq: u64, isvariable: bool_);
    pub static mut cpu_ticks: cpu_tick_f;
    pub fn cpu_tickrate() -> u64;
    pub fn cputick2usec(tick: u64) -> u64;
    pub static bcd2bin_data: [u_char; 0usize];
    pub static bin2bcd_data: [u_char; 0usize];
    pub static hex2ascii_data: [::core::ffi::c_char; 0usize];
    #[link_name = "bcd2bin__extern"]
    pub fn bcd2bin(bcd: ::core::ffi::c_int) -> u_char;
    #[link_name = "bin2bcd__extern"]
    pub fn bin2bcd(bin: ::core::ffi::c_int) -> u_char;
    #[link_name = "hex2ascii__extern"]
    pub fn hex2ascii(hex: ::core::ffi::c_int) -> ::core::ffi::c_char;
    #[link_name = "validbcd__extern"]
    pub fn validbcd(bcd: ::core::ffi::c_int) -> bool_;
    #[link_name = "imax__extern"]
    pub fn imax(a: ::core::ffi::c_int, b: ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[link_name = "imin__extern"]
    pub fn imin(a: ::core::ffi::c_int, b: ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[link_name = "lmax__extern"]
    pub fn lmax(a: ::core::ffi::c_long, b: ::core::ffi::c_long) -> ::core::ffi::c_long;
    #[link_name = "lmin__extern"]
    pub fn lmin(a: ::core::ffi::c_long, b: ::core::ffi::c_long) -> ::core::ffi::c_long;
    #[link_name = "max__extern"]
    pub fn max(a: u_int, b: u_int) -> u_int;
    #[link_name = "min__extern"]
    pub fn min(a: u_int, b: u_int) -> u_int;
    #[link_name = "qmax__extern"]
    pub fn qmax(a: quad_t, b: quad_t) -> quad_t;
    #[link_name = "qmin__extern"]
    pub fn qmin(a: quad_t, b: quad_t) -> quad_t;
    #[link_name = "uqmax__extern"]
    pub fn uqmax(a: u_quad_t, b: u_quad_t) -> u_quad_t;
    #[link_name = "uqmin__extern"]
    pub fn uqmin(a: u_quad_t, b: u_quad_t) -> u_quad_t;
    #[link_name = "ulmax__extern"]
    pub fn ulmax(a: u_long, b: u_long) -> u_long;
    #[link_name = "ulmin__extern"]
    pub fn ulmin(a: u_long, b: u_long) -> u_long;
    #[link_name = "ummax__extern"]
    pub fn ummax(a: __uintmax_t, b: __uintmax_t) -> __uintmax_t;
    #[link_name = "ummin__extern"]
    pub fn ummin(a: __uintmax_t, b: __uintmax_t) -> __uintmax_t;
    #[link_name = "omax__extern"]
    pub fn omax(a: off_t, b: off_t) -> off_t;
    #[link_name = "omin__extern"]
    pub fn omin(a: off_t, b: off_t) -> off_t;
    #[link_name = "abs__extern"]
    pub fn abs(a: ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[link_name = "labs__extern"]
    pub fn labs(a: ::core::ffi::c_long) -> ::core::ffi::c_long;
    #[link_name = "abs64__extern"]
    pub fn abs64(a: i64) -> i64;
    #[link_name = "qabs__extern"]
    pub fn qabs(a: quad_t) -> quad_t;
    pub static mut arc4rand_iniseed_state: ::core::ffi::c_int;
    pub fn arc4random() -> u32;
    pub fn arc4random_buf(arg1: *mut ::core::ffi::c_void, arg2: usize);
    pub fn arc4random_uniform(arg1: u32) -> u32;
    pub fn arc4rand(arg1: *mut ::core::ffi::c_void, arg2: u_int, arg3: ::core::ffi::c_int);
    pub fn timingsafe_bcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: usize,
    ) -> ::core::ffi::c_int;
    pub fn bsearch(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: usize,
        arg4: usize,
        arg5: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
    ) -> *mut ::core::ffi::c_void;
    #[link_name = "ffs__extern"]
    pub fn ffs(mask: ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[link_name = "ffsl__extern"]
    pub fn ffsl(mask: ::core::ffi::c_long) -> ::core::ffi::c_int;
    #[link_name = "ffsll__extern"]
    pub fn ffsll(mask: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
    #[link_name = "fls__extern"]
    pub fn fls(mask: ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[link_name = "flsl__extern"]
    pub fn flsl(mask: ::core::ffi::c_long) -> ::core::ffi::c_int;
    #[link_name = "flsll__extern"]
    pub fn flsll(mask: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
    #[link_name = "ilog2_int__extern"]
    pub fn ilog2_int(n: ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[link_name = "ilog2_long__extern"]
    pub fn ilog2_long(n: ::core::ffi::c_long) -> ::core::ffi::c_int;
    #[link_name = "ilog2_long_long__extern"]
    pub fn ilog2_long_long(n: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
    pub fn fnmatch(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn locc(
        arg1: ::core::ffi::c_int,
        arg2: *mut ::core::ffi::c_char,
        arg3: u_int,
    ) -> ::core::ffi::c_int;
    pub fn memchr(
        s: *const ::core::ffi::c_void,
        c: ::core::ffi::c_int,
        n: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn memcchr(
        s: *const ::core::ffi::c_void,
        c: ::core::ffi::c_int,
        n: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn memmem(
        l: *const ::core::ffi::c_void,
        l_len: usize,
        s: *const ::core::ffi::c_void,
        s_len: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn qsort(
        base: *mut ::core::ffi::c_void,
        nmemb: usize,
        size: usize,
        compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
    );
    pub fn qsort_r(
        base: *mut ::core::ffi::c_void,
        nmemb: usize,
        size: usize,
        compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
                arg3: *mut ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
        thunk: *mut ::core::ffi::c_void,
    );
    pub fn random() -> u_long;
    pub fn scanc(
        arg1: u_int,
        arg2: *const u_char,
        arg3: *const u_char,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn strcasecmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn strcasestr(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcat(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strchr(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn strchrnul(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn strcpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strdup_flags(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut malloc_type,
        arg3: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcspn(arg1: *const ::core::ffi::c_char, arg2: *const ::core::ffi::c_char) -> usize;
    pub fn strdup(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut malloc_type,
    ) -> *mut ::core::ffi::c_char;
    pub fn strncat(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> *mut ::core::ffi::c_char;
    pub fn strndup(
        arg1: *const ::core::ffi::c_char,
        arg2: usize,
        arg3: *mut malloc_type,
    ) -> *mut ::core::ffi::c_char;
    pub fn strlcat(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> usize;
    pub fn strlcpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> usize;
    pub fn strlen(arg1: *const ::core::ffi::c_char) -> usize;
    pub fn strncasecmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> ::core::ffi::c_int;
    pub fn strncmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> ::core::ffi::c_int;
    pub fn strncpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> *mut ::core::ffi::c_char;
    pub fn strnlen(arg1: *const ::core::ffi::c_char, arg2: usize) -> usize;
    pub fn strnstr(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> *mut ::core::ffi::c_char;
    pub fn strrchr(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn strsep(
        arg1: *mut *mut ::core::ffi::c_char,
        delim: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strspn(arg1: *const ::core::ffi::c_char, arg2: *const ::core::ffi::c_char) -> usize;
    pub fn strstr(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strvalid(arg1: *const ::core::ffi::c_char, arg2: usize) -> ::core::ffi::c_int;
    #[link_name = "index__extern"]
    pub fn index(p: *const ::core::ffi::c_char, ch: ::core::ffi::c_int)
        -> *mut ::core::ffi::c_char;
    #[link_name = "rindex__extern"]
    pub fn rindex(
        p: *const ::core::ffi::c_char,
        ch: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    #[link_name = "signed_extend64__extern"]
    pub fn signed_extend64(bitmap: u64, lsb: ::core::ffi::c_int, width: ::core::ffi::c_int) -> i64;
    #[link_name = "signed_extend32__extern"]
    pub fn signed_extend32(bitmap: u32, lsb: ::core::ffi::c_int, width: ::core::ffi::c_int) -> i32;
    pub fn consinit();
    pub fn cpu_initclocks();
    pub fn cpu_initclocks_bsp();
    pub fn cpu_initclocks_ap();
    pub fn usrinfoinit();
    pub fn kern_reboot(arg1: ::core::ffi::c_int) -> !;
    pub fn shutdown_nice(arg1: ::core::ffi::c_int);
    #[link_name = "splhigh__extern"]
    pub fn splhigh() -> intrmask_t;
    #[link_name = "splimp__extern"]
    pub fn splimp() -> intrmask_t;
    #[link_name = "splnet__extern"]
    pub fn splnet() -> intrmask_t;
    #[link_name = "spltty__extern"]
    pub fn spltty() -> intrmask_t;
    #[link_name = "splx__extern"]
    pub fn splx(ipl: intrmask_t);
    pub fn _sleep(
        chan: *const ::core::ffi::c_void,
        lock: *mut lock_object,
        pri: ::core::ffi::c_int,
        wmesg: *const ::core::ffi::c_char,
        sbt: sbintime_t,
        pr: sbintime_t,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn msleep_spin_sbt(
        chan: *const ::core::ffi::c_void,
        mtx: *mut mtx,
        wmesg: *const ::core::ffi::c_char,
        sbt: sbintime_t,
        pr: sbintime_t,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn pause_sbt(
        wmesg: *const ::core::ffi::c_char,
        sbt: sbintime_t,
        pr: sbintime_t,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[link_name = "pause__extern"]
    pub fn pause(wmesg: *const ::core::ffi::c_char, timo: ::core::ffi::c_int)
        -> ::core::ffi::c_int;
    pub fn wakeup(chan: *const ::core::ffi::c_void);
    pub fn wakeup_one(chan: *const ::core::ffi::c_void);
    pub fn wakeup_any(chan: *const ::core::ffi::c_void);
    pub fn dev2udev(x: *mut cdev) -> dev_t;
    pub fn devtoname(cdev: *mut cdev) -> *const ::core::ffi::c_char;
    pub fn devfs_iosize_max() -> usize;
    pub fn iosize_max() -> usize;
    pub fn poll_no_poll(events: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn DELAY(usec: ::core::ffi::c_int);
    pub fn kcmp_cmp(a: usize, b: usize) -> ::core::ffi::c_int;
    pub fn root_mount_hold(identifier: *const ::core::ffi::c_char) -> *mut root_hold_token;
    pub fn root_mount_hold_token(identifier: *const ::core::ffi::c_char, h: *mut root_hold_token);
    pub fn root_mount_rel(h: *mut root_hold_token);
    pub fn root_mounted() -> ::core::ffi::c_int;
    pub fn new_unrhdr(
        low: ::core::ffi::c_int,
        high: ::core::ffi::c_int,
        mutex: *mut mtx,
    ) -> *mut unrhdr;
    pub fn init_unrhdr(
        uh: *mut unrhdr,
        low: ::core::ffi::c_int,
        high: ::core::ffi::c_int,
        mutex: *mut mtx,
    );
    pub fn delete_unrhdr(uh: *mut unrhdr);
    pub fn clear_unrhdr(uh: *mut unrhdr);
    pub fn clean_unrhdr(uh: *mut unrhdr);
    pub fn clean_unrhdrl(uh: *mut unrhdr);
    pub fn alloc_unr(uh: *mut unrhdr) -> ::core::ffi::c_int;
    pub fn alloc_unr_specific(uh: *mut unrhdr, item: u_int) -> ::core::ffi::c_int;
    pub fn alloc_unrl(uh: *mut unrhdr) -> ::core::ffi::c_int;
    pub fn free_unr(uh: *mut unrhdr, item: u_int);
    pub fn create_iter_unr(uh: *mut unrhdr) -> *mut ::core::ffi::c_void;
    pub fn next_iter_unr(handle: *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
    pub fn free_iter_unr(handle: *mut ::core::ffi::c_void);
    #[link_name = "new_unrhdr64__extern"]
    pub fn new_unrhdr64(unr64: *mut unrhdr64, low: u64);
    #[link_name = "alloc_unr64__extern"]
    pub fn alloc_unr64(unr64: *mut unrhdr64) -> u64;
    pub fn intr_prof_stack_use(td: *mut thread, frame: *mut trapframe);
    pub fn counted_warning(counter: *mut ::core::ffi::c_uint, msg: *const ::core::ffi::c_char);
    pub fn _gone_in(major: ::core::ffi::c_int, msg: *const ::core::ffi::c_char, ...);
    pub fn _gone_in_dev(
        dev: device_t,
        major: ::core::ffi::c_int,
        msg: *const ::core::ffi::c_char,
        ...
    );
    #[doc = " devctl hooks.  Typically one should use the devctl_notify\n hook to send the message."]
    pub fn devctl_process_running() -> bool_;
    pub fn devctl_notify(
        __system: *const ::core::ffi::c_char,
        __subsystem: *const ::core::ffi::c_char,
        __type: *const ::core::ffi::c_char,
        __data: *const ::core::ffi::c_char,
    );
    pub fn devctl_safe_quote_sb(__sb: *mut sbuf, __src: *const ::core::ffi::c_char);
    pub fn devctl_set_notify_hook(hook: send_event_f);
    pub fn devctl_unset_notify_hook();
    pub fn resource_init_map_request_impl(_args: *mut resource_map_request, _sz: usize);
    pub fn resource_validate_map_request(
        r: *mut resource,
        in_: *mut resource_map_request,
        out: *mut resource_map_request,
        startp: *mut rman_res_t,
        lengthp: *mut rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn resource_list_init(rl: *mut resource_list);
    pub fn resource_list_free(rl: *mut resource_list);
    pub fn resource_list_add(
        rl: *mut resource_list,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
        start: rman_res_t,
        end: rman_res_t,
        count: rman_res_t,
    ) -> *mut resource_list_entry;
    pub fn resource_list_add_next(
        rl: *mut resource_list,
        type_: ::core::ffi::c_int,
        start: rman_res_t,
        end: rman_res_t,
        count: rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn resource_list_busy(
        rl: *mut resource_list,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn resource_list_reserved(
        rl: *mut resource_list,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn resource_list_find(
        rl: *mut resource_list,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
    ) -> *mut resource_list_entry;
    pub fn resource_list_delete(
        rl: *mut resource_list,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
    );
    pub fn resource_list_alloc(
        rl: *mut resource_list,
        bus: device_t,
        child: device_t,
        type_: ::core::ffi::c_int,
        rid: *mut ::core::ffi::c_int,
        start: rman_res_t,
        end: rman_res_t,
        count: rman_res_t,
        flags: u_int,
    ) -> *mut resource;
    pub fn resource_list_release(
        rl: *mut resource_list,
        bus: device_t,
        child: device_t,
        res: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn resource_list_release_active(
        rl: *mut resource_list,
        bus: device_t,
        child: device_t,
        type_: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn resource_list_reserve(
        rl: *mut resource_list,
        bus: device_t,
        child: device_t,
        type_: ::core::ffi::c_int,
        rid: *mut ::core::ffi::c_int,
        start: rman_res_t,
        end: rman_res_t,
        count: rman_res_t,
        flags: u_int,
    ) -> *mut resource;
    pub fn resource_list_unreserve(
        rl: *mut resource_list,
        bus: device_t,
        child: device_t,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn resource_list_purge(rl: *mut resource_list);
    pub fn resource_list_print_type(
        rl: *mut resource_list,
        name: *const ::core::ffi::c_char,
        type_: ::core::ffi::c_int,
        format: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub static mut root_bus: device_t;
    pub static mut root_devclass: devclass_t;
    pub fn root_bus_configure();
    pub fn bus_generic_activate_resource(
        dev: device_t,
        child: device_t,
        r: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_add_child(
        dev: device_t,
        order: u_int,
        name: *const ::core::ffi::c_char,
        unit: ::core::ffi::c_int,
    ) -> device_t;
    pub fn bus_generic_adjust_resource(
        bus: device_t,
        child: device_t,
        r: *mut resource,
        start: rman_res_t,
        end: rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_alloc_resource(
        bus: device_t,
        child: device_t,
        type_: ::core::ffi::c_int,
        rid: *mut ::core::ffi::c_int,
        start: rman_res_t,
        end: rman_res_t,
        count: rman_res_t,
        flags: u_int,
    ) -> *mut resource;
    pub fn bus_generic_translate_resource(
        dev: device_t,
        type_: ::core::ffi::c_int,
        start: rman_res_t,
        newstart: *mut rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_attach(dev: device_t) -> ::core::ffi::c_int;
    pub fn bus_generic_bind_intr(
        dev: device_t,
        child: device_t,
        irq: *mut resource,
        cpu: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_child_location(
        dev: device_t,
        child: device_t,
        sb: *mut sbuf,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_child_pnpinfo(
        dev: device_t,
        child: device_t,
        sb: *mut sbuf,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_child_present(dev: device_t, child: device_t) -> ::core::ffi::c_int;
    pub fn bus_generic_config_intr(
        arg1: device_t,
        arg2: ::core::ffi::c_int,
        arg3: intr_trigger,
        arg4: intr_polarity,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_describe_intr(
        dev: device_t,
        child: device_t,
        irq: *mut resource,
        cookie: *mut ::core::ffi::c_void,
        descr: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_deactivate_resource(
        dev: device_t,
        child: device_t,
        r: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_detach(dev: device_t) -> ::core::ffi::c_int;
    pub fn bus_generic_driver_added(dev: device_t, driver: *mut driver_t);
    pub fn bus_generic_get_cpus(
        dev: device_t,
        child: device_t,
        op: cpu_sets,
        setsize: usize,
        cpuset: *mut _cpuset,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_get_dma_tag(dev: device_t, child: device_t) -> bus_dma_tag_t;
    pub fn bus_generic_get_bus_tag(dev: device_t, child: device_t) -> bus_space_tag_t;
    pub fn bus_generic_get_domain(
        dev: device_t,
        child: device_t,
        domain: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_get_property(
        dev: device_t,
        child: device_t,
        propname: *const ::core::ffi::c_char,
        propvalue: *mut ::core::ffi::c_void,
        size: usize,
        type_: device_property_type_t,
    ) -> isize;
    pub fn bus_generic_map_resource(
        dev: device_t,
        child: device_t,
        r: *mut resource,
        args: *mut resource_map_request,
        map: *mut resource_map,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_new_pass(dev: device_t);
    pub fn bus_print_child_header(dev: device_t, child: device_t) -> ::core::ffi::c_int;
    pub fn bus_print_child_domain(dev: device_t, child: device_t) -> ::core::ffi::c_int;
    pub fn bus_print_child_footer(dev: device_t, child: device_t) -> ::core::ffi::c_int;
    pub fn bus_generic_print_child(dev: device_t, child: device_t) -> ::core::ffi::c_int;
    pub fn bus_generic_probe(dev: device_t) -> ::core::ffi::c_int;
    pub fn bus_generic_read_ivar(
        dev: device_t,
        child: device_t,
        which: ::core::ffi::c_int,
        result: *mut usize,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_release_resource(
        bus: device_t,
        child: device_t,
        r: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_resume(dev: device_t) -> ::core::ffi::c_int;
    pub fn bus_generic_resume_child(dev: device_t, child: device_t) -> ::core::ffi::c_int;
    pub fn bus_generic_setup_intr(
        dev: device_t,
        child: device_t,
        irq: *mut resource,
        flags: ::core::ffi::c_int,
        filter: driver_filter_t,
        intr: driver_intr_t,
        arg: *mut ::core::ffi::c_void,
        cookiep: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_rl_alloc_resource(
        arg1: device_t,
        arg2: device_t,
        arg3: ::core::ffi::c_int,
        arg4: *mut ::core::ffi::c_int,
        arg5: rman_res_t,
        arg6: rman_res_t,
        arg7: rman_res_t,
        arg8: u_int,
    ) -> *mut resource;
    pub fn bus_generic_rl_delete_resource(
        arg1: device_t,
        arg2: device_t,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
    );
    pub fn bus_generic_rl_get_resource(
        arg1: device_t,
        arg2: device_t,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
        arg5: *mut rman_res_t,
        arg6: *mut rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_rl_set_resource(
        arg1: device_t,
        arg2: device_t,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
        arg5: rman_res_t,
        arg6: rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_rl_release_resource(
        arg1: device_t,
        arg2: device_t,
        arg3: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_rman_alloc_resource(
        dev: device_t,
        child: device_t,
        type_: ::core::ffi::c_int,
        rid: *mut ::core::ffi::c_int,
        start: rman_res_t,
        end: rman_res_t,
        count: rman_res_t,
        flags: u_int,
    ) -> *mut resource;
    pub fn bus_generic_rman_adjust_resource(
        dev: device_t,
        child: device_t,
        r: *mut resource,
        start: rman_res_t,
        end: rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_rman_release_resource(
        dev: device_t,
        child: device_t,
        r: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_rman_activate_resource(
        dev: device_t,
        child: device_t,
        r: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_rman_deactivate_resource(
        dev: device_t,
        child: device_t,
        r: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_shutdown(dev: device_t) -> ::core::ffi::c_int;
    pub fn bus_generic_suspend(dev: device_t) -> ::core::ffi::c_int;
    pub fn bus_generic_suspend_child(dev: device_t, child: device_t) -> ::core::ffi::c_int;
    pub fn bus_generic_teardown_intr(
        dev: device_t,
        child: device_t,
        irq: *mut resource,
        cookie: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_suspend_intr(
        dev: device_t,
        child: device_t,
        irq: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_resume_intr(
        dev: device_t,
        child: device_t,
        irq: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_unmap_resource(
        dev: device_t,
        child: device_t,
        r: *mut resource,
        map: *mut resource_map,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_write_ivar(
        dev: device_t,
        child: device_t,
        which: ::core::ffi::c_int,
        value: usize,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_get_device_path(
        bus: device_t,
        child: device_t,
        locator: *const ::core::ffi::c_char,
        sb: *mut sbuf,
    ) -> ::core::ffi::c_int;
    pub fn bus_helper_reset_post(dev: device_t, flags: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn bus_helper_reset_prepare(dev: device_t, flags: ::core::ffi::c_int)
        -> ::core::ffi::c_int;
    pub fn bus_null_rescan(dev: device_t) -> ::core::ffi::c_int;
    pub fn bus_alloc_resources(
        dev: device_t,
        rs: *mut resource_spec,
        res: *mut *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_release_resources(dev: device_t, rs: *const resource_spec, res: *mut *mut resource);
    pub fn bus_adjust_resource(
        child: device_t,
        r: *mut resource,
        start: rman_res_t,
        end: rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn bus_translate_resource(
        child: device_t,
        type_: ::core::ffi::c_int,
        start: rman_res_t,
        newstart: *mut rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn bus_alloc_resource(
        dev: device_t,
        type_: ::core::ffi::c_int,
        rid: *mut ::core::ffi::c_int,
        start: rman_res_t,
        end: rman_res_t,
        count: rman_res_t,
        flags: u_int,
    ) -> *mut resource;
    pub fn bus_activate_resource(dev: device_t, r: *mut resource) -> ::core::ffi::c_int;
    pub fn bus_deactivate_resource(dev: device_t, r: *mut resource) -> ::core::ffi::c_int;
    pub fn bus_map_resource(
        dev: device_t,
        r: *mut resource,
        args: *mut resource_map_request,
        map: *mut resource_map,
    ) -> ::core::ffi::c_int;
    pub fn bus_unmap_resource(
        dev: device_t,
        r: *mut resource,
        map: *mut resource_map,
    ) -> ::core::ffi::c_int;
    pub fn bus_get_cpus(
        dev: device_t,
        op: cpu_sets,
        setsize: usize,
        cpuset: *mut _cpuset,
    ) -> ::core::ffi::c_int;
    pub fn bus_get_dma_tag(dev: device_t) -> bus_dma_tag_t;
    pub fn bus_get_bus_tag(dev: device_t) -> bus_space_tag_t;
    pub fn bus_get_domain(dev: device_t, domain: *mut ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn bus_release_resource(dev: device_t, r: *mut resource) -> ::core::ffi::c_int;
    pub fn bus_free_resource(
        dev: device_t,
        type_: ::core::ffi::c_int,
        r: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_setup_intr(
        dev: device_t,
        r: *mut resource,
        flags: ::core::ffi::c_int,
        filter: driver_filter_t,
        handler: driver_intr_t,
        arg: *mut ::core::ffi::c_void,
        cookiep: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn bus_teardown_intr(
        dev: device_t,
        r: *mut resource,
        cookie: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn bus_suspend_intr(dev: device_t, r: *mut resource) -> ::core::ffi::c_int;
    pub fn bus_resume_intr(dev: device_t, r: *mut resource) -> ::core::ffi::c_int;
    pub fn bus_bind_intr(
        dev: device_t,
        r: *mut resource,
        cpu: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_describe_intr(
        dev: device_t,
        irq: *mut resource,
        cookie: *mut ::core::ffi::c_void,
        fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn bus_set_resource(
        dev: device_t,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
        start: rman_res_t,
        count: rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn bus_get_resource(
        dev: device_t,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
        startp: *mut rman_res_t,
        countp: *mut rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn bus_get_resource_start(
        dev: device_t,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
    ) -> rman_res_t;
    pub fn bus_get_resource_count(
        dev: device_t,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
    ) -> rman_res_t;
    pub fn bus_delete_resource(dev: device_t, type_: ::core::ffi::c_int, rid: ::core::ffi::c_int);
    pub fn bus_child_present(child: device_t) -> ::core::ffi::c_int;
    pub fn bus_child_pnpinfo(child: device_t, sb: *mut sbuf) -> ::core::ffi::c_int;
    pub fn bus_child_location(child: device_t, sb: *mut sbuf) -> ::core::ffi::c_int;
    pub fn bus_attach_children(dev: device_t);
    pub fn bus_delayed_attach_children(bus: device_t);
    pub fn bus_detach_children(dev: device_t) -> ::core::ffi::c_int;
    pub fn bus_enumerate_hinted_children(bus: device_t);
    pub fn bus_identify_children(dev: device_t);
    #[link_name = "bus_alloc_resource_any__extern"]
    pub fn bus_alloc_resource_any(
        dev: device_t,
        type_: ::core::ffi::c_int,
        rid: *mut ::core::ffi::c_int,
        flags: u_int,
    ) -> *mut resource;
    #[link_name = "bus_alloc_resource_anywhere__extern"]
    pub fn bus_alloc_resource_anywhere(
        dev: device_t,
        type_: ::core::ffi::c_int,
        rid: *mut ::core::ffi::c_int,
        count: rman_res_t,
        flags: u_int,
    ) -> *mut resource;
    pub fn bus_adjust_resource_old(
        child: device_t,
        type_: ::core::ffi::c_int,
        r: *mut resource,
        start: rman_res_t,
        end: rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn bus_activate_resource_old(
        dev: device_t,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
        r: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_deactivate_resource_old(
        dev: device_t,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
        r: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_map_resource_old(
        dev: device_t,
        type_: ::core::ffi::c_int,
        r: *mut resource,
        args: *mut resource_map_request,
        map: *mut resource_map,
    ) -> ::core::ffi::c_int;
    pub fn bus_unmap_resource_old(
        dev: device_t,
        type_: ::core::ffi::c_int,
        r: *mut resource,
        map: *mut resource_map,
    ) -> ::core::ffi::c_int;
    pub fn bus_release_resource_old(
        dev: device_t,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
        r: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn device_add_child(
        dev: device_t,
        name: *const ::core::ffi::c_char,
        unit: ::core::ffi::c_int,
    ) -> device_t;
    pub fn device_add_child_ordered(
        dev: device_t,
        order: u_int,
        name: *const ::core::ffi::c_char,
        unit: ::core::ffi::c_int,
    ) -> device_t;
    pub fn device_busy(dev: device_t);
    pub fn device_delete_child(dev: device_t, child: device_t) -> ::core::ffi::c_int;
    pub fn device_delete_children(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_attach(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_detach(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_disable(dev: device_t);
    pub fn device_enable(dev: device_t);
    pub fn device_find_child(
        dev: device_t,
        classname: *const ::core::ffi::c_char,
        unit: ::core::ffi::c_int,
    ) -> device_t;
    pub fn device_get_desc(dev: device_t) -> *const ::core::ffi::c_char;
    pub fn device_get_devclass(dev: device_t) -> devclass_t;
    pub fn device_get_driver(dev: device_t) -> *mut driver_t;
    pub fn device_get_flags(dev: device_t) -> u_int32_t;
    pub fn device_get_parent(dev: device_t) -> device_t;
    pub fn device_get_children(
        dev: device_t,
        listp: *mut *mut device_t,
        countp: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn device_get_ivars(dev: device_t) -> *mut ::core::ffi::c_void;
    pub fn device_set_ivars(dev: device_t, ivars: *mut ::core::ffi::c_void);
    pub fn device_get_name(dev: device_t) -> *const ::core::ffi::c_char;
    pub fn device_get_nameunit(dev: device_t) -> *const ::core::ffi::c_char;
    pub fn device_get_softc(dev: device_t) -> *mut ::core::ffi::c_void;
    pub fn device_get_state(dev: device_t) -> device_state_t;
    pub fn device_get_unit(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_get_sysctl_ctx(dev: device_t) -> *mut sysctl_ctx_list;
    pub fn device_get_sysctl_tree(dev: device_t) -> *mut sysctl_oid;
    pub fn device_has_quiet_children(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_is_alive(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_is_attached(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_is_enabled(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_is_suspended(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_is_quiet(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_lookup_by_name(name: *const ::core::ffi::c_char) -> device_t;
    pub fn device_print_prettyname(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_printf(
        dev: device_t,
        arg1: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn device_log(
        dev: device_t,
        pri: ::core::ffi::c_int,
        arg1: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn device_probe(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_probe_and_attach(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_probe_child(bus: device_t, dev: device_t) -> ::core::ffi::c_int;
    pub fn device_quiesce(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_quiet(dev: device_t);
    pub fn device_quiet_children(dev: device_t);
    pub fn device_set_desc(dev: device_t, desc: *const ::core::ffi::c_char);
    pub fn device_set_descf(dev: device_t, fmt: *const ::core::ffi::c_char, ...);
    pub fn device_set_desc_copy(dev: device_t, desc: *const ::core::ffi::c_char);
    pub fn device_set_devclass(
        dev: device_t,
        classname: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn device_set_devclass_fixed(
        dev: device_t,
        classname: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn device_is_devclass_fixed(dev: device_t) -> bool_;
    pub fn device_set_driver(dev: device_t, driver: *mut driver_t) -> ::core::ffi::c_int;
    pub fn device_set_flags(dev: device_t, flags: u_int32_t);
    pub fn device_set_softc(dev: device_t, softc: *mut ::core::ffi::c_void);
    pub fn device_free_softc(softc: *mut ::core::ffi::c_void);
    pub fn device_claim_softc(dev: device_t);
    pub fn device_set_unit(dev: device_t, unit: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn device_shutdown(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_unbusy(dev: device_t);
    pub fn device_verbose(dev: device_t);
    pub fn device_get_property(
        dev: device_t,
        prop: *const ::core::ffi::c_char,
        val: *mut ::core::ffi::c_void,
        sz: usize,
        type_: device_property_type_t,
    ) -> isize;
    pub fn device_has_property(dev: device_t, prop: *const ::core::ffi::c_char) -> bool_;
    pub fn devclass_add_driver(
        dc: devclass_t,
        driver: *mut driver_t,
        pass: ::core::ffi::c_int,
        dcp: *mut devclass_t,
    ) -> ::core::ffi::c_int;
    pub fn devclass_create(classname: *const ::core::ffi::c_char) -> devclass_t;
    pub fn devclass_delete_driver(
        busclass: devclass_t,
        driver: *mut driver_t,
    ) -> ::core::ffi::c_int;
    pub fn devclass_find(classname: *const ::core::ffi::c_char) -> devclass_t;
    pub fn devclass_get_name(dc: devclass_t) -> *const ::core::ffi::c_char;
    pub fn devclass_get_device(dc: devclass_t, unit: ::core::ffi::c_int) -> device_t;
    pub fn devclass_get_softc(dc: devclass_t, unit: ::core::ffi::c_int)
        -> *mut ::core::ffi::c_void;
    pub fn devclass_get_devices(
        dc: devclass_t,
        listp: *mut *mut device_t,
        countp: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn devclass_get_drivers(
        dc: devclass_t,
        listp: *mut *mut *mut driver_t,
        countp: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn devclass_get_count(dc: devclass_t) -> ::core::ffi::c_int;
    pub fn devclass_get_maxunit(dc: devclass_t) -> ::core::ffi::c_int;
    pub fn devclass_find_free_unit(dc: devclass_t, unit: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn devclass_set_parent(dc: devclass_t, pdc: devclass_t);
    pub fn devclass_get_parent(dc: devclass_t) -> devclass_t;
    pub fn devclass_get_sysctl_ctx(dc: devclass_t) -> *mut sysctl_ctx_list;
    pub fn devclass_get_sysctl_tree(dc: devclass_t) -> *mut sysctl_oid;
    pub fn resource_int_value(
        name: *const ::core::ffi::c_char,
        unit: ::core::ffi::c_int,
        resname: *const ::core::ffi::c_char,
        result: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn resource_long_value(
        name: *const ::core::ffi::c_char,
        unit: ::core::ffi::c_int,
        resname: *const ::core::ffi::c_char,
        result: *mut ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
    pub fn resource_string_value(
        name: *const ::core::ffi::c_char,
        unit: ::core::ffi::c_int,
        resname: *const ::core::ffi::c_char,
        result: *mut *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn resource_disabled(
        name: *const ::core::ffi::c_char,
        unit: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn resource_find_match(
        anchor: *mut ::core::ffi::c_int,
        name: *mut *const ::core::ffi::c_char,
        unit: *mut ::core::ffi::c_int,
        resname: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn resource_find_dev(
        anchor: *mut ::core::ffi::c_int,
        name: *const ::core::ffi::c_char,
        unit: *mut ::core::ffi::c_int,
        resname: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn resource_unset_value(
        name: *const ::core::ffi::c_char,
        unit: ::core::ffi::c_int,
        resname: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn bus_data_generation_check(generation: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn bus_data_generation_update();
    pub fn bus_get_pass() -> ::core::ffi::c_int;
    #[doc = " Routines to lock / unlock the newbus lock.\n Must be taken out to interact with newbus."]
    pub fn bus_topo_lock();
    pub fn bus_topo_unlock();
    pub fn bus_topo_mtx() -> *mut mtx;
    pub fn bus_topo_assert();
    #[doc = " @brief Unique descriptor for the DEVICE_PROBE() method"]
    pub static mut device_probe_desc: kobjop_desc;
    #[doc = " @brief Probe to see if a device matches a driver.\n\n Users should not call this method directly. Normally, this\n is called via device_probe_and_attach() to select a driver\n calling the DEVICE_PROBE() of all candidate drivers and attach\n the winning driver (if any) to the device.\n\n This function is used to match devices to device drivers.\n Typically, the driver will examine the device to see if\n it is suitable for this driver. This might include checking\n the values of various device instance variables or reading\n hardware registers.\n\n In some cases, there may be more than one driver available\n which can be used for a device (for instance there might\n be a generic driver which works for a set of many types of\n device and a more specific driver which works for a subset\n of devices). Because of this, a driver should not assume\n that it will be the driver that attaches to the device even\n if it returns a success status from DEVICE_PROBE(). In particular,\n a driver must free any resources which it allocated during\n the probe before returning. The return value of DEVICE_PROBE()\n is used to elect which driver is used - the driver which returns\n the largest non-error value wins the election and attaches to\n the device. Common non-error values are described in the\n DEVICE_PROBE(9) manual page.\n\n If a driver matches the hardware, it should set the device\n description string using device_set_desc() or\n device_set_desc_copy(). This string is used to generate an\n informative message when DEVICE_ATTACH() is called.\n\n As a special case, if a driver returns zero, the driver election\n is cut short and that driver will attach to the device\n immediately. This should rarely be used.\n\n For example, a probe method for a PCI device driver might look\n like this:\n\n @code\n int\n foo_probe(device_t dev)\n {\n         if (pci_get_vendor(dev) == FOOVENDOR &&\n             pci_get_device(dev) == FOODEVICE) {\n                 device_set_desc(dev, \"Foo device\");\n                 return (BUS_PROBE_DEFAULT);\n         }\n         return (ENXIO);\n }\n @endcode\n\n To include this method in a device driver, use a line like this\n in the driver's method list:\n\n @code\n \tKOBJMETHOD(device_probe, foo_probe)\n @endcode\n\n @param dev\t\tthe device to probe\n\n @retval 0\t\tif this is the only possible driver for this\n\t\t\tdevice\n @retval negative\tif the driver can match this device - the\n\t\t\tleast negative value is used to select the\n\t\t\tdriver\n @retval ENXIO\tif the driver does not match the device\n @retval positive\tif some kind of error was detected during\n\t\t\tthe probe, a regular unix error code should\n\t\t\tbe returned to indicate the type of error\n @see DEVICE_ATTACH(), pci_get_vendor(), pci_get_device()"]
    #[link_name = "DEVICE_PROBE__extern"]
    pub fn DEVICE_PROBE(dev: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the DEVICE_IDENTIFY() method"]
    pub static mut device_identify_desc: kobjop_desc;
    #[doc = " @brief Allow a device driver to detect devices not otherwise enumerated.\n\n The DEVICE_IDENTIFY() method is used by some drivers (e.g. the ISA\n bus driver) to help populate the bus device with a useful set of\n child devices, normally by calling the BUS_ADD_CHILD() method of\n the parent device. For instance, the ISA bus driver uses several\n special drivers, including the isahint driver and the pnp driver to\n create child devices based on configuration hints and PnP bus\n probes respectively.\n\n Many bus drivers which support true plug-and-play do not need to\n use this method at all since child devices can be discovered\n automatically without help from child drivers.\n\n To include this method in a device driver, use a line like this\n in the driver's method list:\n\n @code\n \tKOBJMETHOD(device_identify, foo_identify)\n @endcode\n\n @param driver\tthe driver whose identify method is being called\n @param parent\tthe parent device to use when adding new children"]
    #[link_name = "DEVICE_IDENTIFY__extern"]
    pub fn DEVICE_IDENTIFY(driver: *mut driver_t, parent: device_t);
    #[doc = " @brief Unique descriptor for the DEVICE_ATTACH() method"]
    pub static mut device_attach_desc: kobjop_desc;
    #[doc = " @brief Attach a device to a device driver\n\n Normally only called via device_probe_and_attach(), this is called\n when a driver has succeeded in probing against a device.\n This method should initialise the hardware and allocate other\n system resources (e.g. devfs entries) as required.\n\n To include this method in a device driver, use a line like this\n in the driver's method list:\n\n @code\n \tKOBJMETHOD(device_attach, foo_attach)\n @endcode\n\n @param dev\t\tthe device to probe\n\n @retval 0\t\tsuccess\n @retval non-zero\tif some kind of error was detected during\n\t\t\tthe attach, a regular unix error code should\n\t\t\tbe returned to indicate the type of error\n @see DEVICE_PROBE()"]
    #[link_name = "DEVICE_ATTACH__extern"]
    pub fn DEVICE_ATTACH(dev: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the DEVICE_DETACH() method"]
    pub static mut device_detach_desc: kobjop_desc;
    #[doc = " @brief Detach a driver from a device.\n\n This can be called if the user is replacing the\n driver software or if a device is about to be physically removed\n from the system (e.g. for removable hardware such as USB or PCCARD).\n\n To include this method in a device driver, use a line like this\n in the driver's method list:\n\n @code\n \tKOBJMETHOD(device_detach, foo_detach)\n @endcode\n\n @param dev\t\tthe device to detach\n\n @retval 0\t\tsuccess\n @retval non-zero\tthe detach could not be performed, e.g. if the\n\t\t\tdriver does not support detaching.\n\n @see DEVICE_ATTACH()"]
    #[link_name = "DEVICE_DETACH__extern"]
    pub fn DEVICE_DETACH(dev: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the DEVICE_SHUTDOWN() method"]
    pub static mut device_shutdown_desc: kobjop_desc;
    #[doc = " @brief Called during system shutdown.\n\n This method allows drivers to detect when the system is being shut down.\n Some drivers need to use this to place their hardware in a consistent\n state before rebooting the computer.\n\n To include this method in a device driver, use a line like this\n in the driver's method list:\n\n @code\n \tKOBJMETHOD(device_shutdown, foo_shutdown)\n @endcode"]
    #[link_name = "DEVICE_SHUTDOWN__extern"]
    pub fn DEVICE_SHUTDOWN(dev: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the DEVICE_SUSPEND() method"]
    pub static mut device_suspend_desc: kobjop_desc;
    #[doc = " @brief This is called by the power-management subsystem when a\n suspend has been requested by the user or by some automatic\n mechanism.\n\n This gives drivers a chance to veto the suspend or save their\n configuration before power is removed.\n\n To include this method in a device driver, use a line like this in\n the driver's method list:\n\n @code\n \tKOBJMETHOD(device_suspend, foo_suspend)\n @endcode\n\n @param dev\t\tthe device being suspended\n\n @retval 0\t\tsuccess\n @retval non-zero\tan error occurred while attempting to prepare the\n                      device for suspension\n\n @see DEVICE_RESUME()"]
    #[link_name = "DEVICE_SUSPEND__extern"]
    pub fn DEVICE_SUSPEND(dev: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the DEVICE_RESUME() method"]
    pub static mut device_resume_desc: kobjop_desc;
    #[doc = " @brief This is called when the system resumes after a suspend.\n\n To include this method in a device driver, use a line like this\n in the driver's method list:\n\n @code\n \tKOBJMETHOD(device_resume, foo_resume)\n @endcode\n\n @param dev\t\tthe device being resumed\n\n @retval 0\t\tsuccess\n @retval non-zero\tan error occurred while attempting to restore the\n                      device from suspension\n\n @see DEVICE_SUSPEND()"]
    #[link_name = "DEVICE_RESUME__extern"]
    pub fn DEVICE_RESUME(dev: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the DEVICE_QUIESCE() method"]
    pub static mut device_quiesce_desc: kobjop_desc;
    #[doc = " @brief This is called when the driver is asked to quiesce itself.\n\n The driver should arrange for the orderly shutdown of this device.\n All further access to the device should be curtailed.  Soon there\n will be a request to detach, but there won't necessarily be one.\n\n To include this method in a device driver, use a line like this\n in the driver's method list:\n\n @code\n \tKOBJMETHOD(device_quiesce, foo_quiesce)\n @endcode\n\n @param dev\t\tthe device being quiesced\n\n @retval 0\t\tsuccess\n @retval non-zero\tan error occurred while attempting to quiesce the\n                      device\n\n @see DEVICE_DETACH()"]
    #[link_name = "DEVICE_QUIESCE__extern"]
    pub fn DEVICE_QUIESCE(dev: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the DEVICE_REGISTER() method"]
    pub static mut device_register_desc: kobjop_desc;
    #[doc = " @brief This is called when the driver is asked to register handlers.\n\n\n To include this method in a device driver, use a line like this\n in the driver's method list:\n\n @code\n \tKOBJMETHOD(device_register, foo_register)\n @endcode\n\n @param dev\t\tthe device for which handlers are being registered\n\n @retval NULL     method not implemented\n @retval non-NULL\ta pointer to implementation specific static driver state\n"]
    #[link_name = "DEVICE_REGISTER__extern"]
    pub fn DEVICE_REGISTER(dev: device_t) -> *mut ::core::ffi::c_void;
    #[doc = " @brief Unique descriptor for the BUS_PRINT_CHILD() method"]
    pub static mut bus_print_child_desc: kobjop_desc;
    #[doc = " @brief Print a description of a child device\n\n This is called from system code which prints out a description of a\n device. It should describe the attachment that the child has with\n the parent. For instance the TurboLaser bus prints which node the\n device is attached to. See bus_generic_print_child() for more\n information.\n\n @param _dev\t\tthe device whose child is being printed\n @param _child\tthe child device to describe\n\n @returns\t\tthe number of characters output."]
    #[link_name = "BUS_PRINT_CHILD__extern"]
    pub fn BUS_PRINT_CHILD(_dev: device_t, _child: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_PROBE_NOMATCH() method"]
    pub static mut bus_probe_nomatch_desc: kobjop_desc;
    #[doc = " @brief Print a notification about an unprobed child device.\n\n Called for each child device that did not succeed in probing for a\n driver.\n\n @param _dev\t\tthe device whose child was being probed\n @param _child\tthe child device which failed to probe"]
    #[link_name = "BUS_PROBE_NOMATCH__extern"]
    pub fn BUS_PROBE_NOMATCH(_dev: device_t, _child: device_t);
    #[doc = " @brief Unique descriptor for the BUS_READ_IVAR() method"]
    pub static mut bus_read_ivar_desc: kobjop_desc;
    #[doc = " @brief Read the value of a bus-specific attribute of a device\n\n This method, along with BUS_WRITE_IVAR() manages a bus-specific set\n of instance variables of a child device.  The intention is that\n each different type of bus defines a set of appropriate instance\n variables (such as ports and irqs for ISA bus etc.)\n\n This information could be given to the child device as a struct but\n that makes it hard for a bus to add or remove variables without\n forcing an edit and recompile for all drivers which may not be\n possible for vendor supplied binary drivers.\n\n This method copies the value of an instance variable to the\n location specified by @p *_result.\n\n @param _dev\t\tthe device whose child was being examined\n @param _child\tthe child device whose instance variable is\n\t\t\tbeing read\n @param _index\tthe instance variable to read\n @param _result\ta location to receive the instance variable\n\t\t\tvalue\n\n @retval 0\t\tsuccess\n @retval ENOENT\tno such instance variable is supported by @p\n\t\t\t_dev"]
    #[link_name = "BUS_READ_IVAR__extern"]
    pub fn BUS_READ_IVAR(
        _dev: device_t,
        _child: device_t,
        _index: ::core::ffi::c_int,
        _result: *mut usize,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_WRITE_IVAR() method"]
    pub static mut bus_write_ivar_desc: kobjop_desc;
    #[doc = " @brief Write the value of a bus-specific attribute of a device\n\n This method sets the value of an instance variable to @p _value.\n\n @param _dev\t\tthe device whose child was being updated\n @param _child\tthe child device whose instance variable is\n\t\t\tbeing written\n @param _index\tthe instance variable to write\n @param _value\tthe value to write to that instance variable\n\n @retval 0\t\tsuccess\n @retval ENOENT\tno such instance variable is supported by @p\n\t\t\t_dev\n @retval EINVAL\tthe instance variable was recognised but\n\t\t\tcontains a read-only value"]
    #[link_name = "BUS_WRITE_IVAR__extern"]
    pub fn BUS_WRITE_IVAR(
        _dev: device_t,
        _child: device_t,
        _indx: ::core::ffi::c_int,
        _value: usize,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_CHILD_DELETED() method"]
    pub static mut bus_child_deleted_desc: kobjop_desc;
    #[doc = " @brief Notify a bus that a child was deleted\n\n Called at the beginning of device_delete_child() to allow the parent\n to teardown any bus-specific state for the child.\n\n @param _dev\t\tthe device whose child is being deleted\n @param _child\tthe child device which is being deleted"]
    #[link_name = "BUS_CHILD_DELETED__extern"]
    pub fn BUS_CHILD_DELETED(_dev: device_t, _child: device_t);
    #[doc = " @brief Unique descriptor for the BUS_CHILD_DETACHED() method"]
    pub static mut bus_child_detached_desc: kobjop_desc;
    #[doc = " @brief Notify a bus that a child was detached\n\n Called after the child's DEVICE_DETACH() method to allow the parent\n to reclaim any resources allocated on behalf of the child.\n\n @param _dev\t\tthe device whose child changed state\n @param _child\tthe child device which changed state"]
    #[link_name = "BUS_CHILD_DETACHED__extern"]
    pub fn BUS_CHILD_DETACHED(_dev: device_t, _child: device_t);
    #[doc = " @brief Unique descriptor for the BUS_DRIVER_ADDED() method"]
    pub static mut bus_driver_added_desc: kobjop_desc;
    #[doc = " @brief Notify a bus that a new driver was added\n\n Called when a new driver is added to the devclass which owns this\n bus. The generic implementation of this method attempts to probe and\n attach any un-matched children of the bus.\n\n @param _dev\t\tthe device whose devclass had a new driver\n\t\t\tadded to it\n @param _driver\tthe new driver which was added"]
    #[link_name = "BUS_DRIVER_ADDED__extern"]
    pub fn BUS_DRIVER_ADDED(_dev: device_t, _driver: *mut driver_t);
    #[doc = " @brief Unique descriptor for the BUS_ADD_CHILD() method"]
    pub static mut bus_add_child_desc: kobjop_desc;
    #[doc = " @brief Create a new child device\n\n For buses which use use drivers supporting DEVICE_IDENTIFY() to\n enumerate their devices, this method is used to create new\n device instances. The new device will be added after the last\n existing child with the same order. Implementations of bus_add_child\n call device_add_child_ordered to add the child and often add\n a suitable ivar to the device specific to that bus.\n\n @param _dev\t\tthe bus device which will be the parent of the\n\t\t\tnew child device\n @param _order\ta value which is used to partially sort the\n\t\t\tchildren of @p _dev - devices created using\n\t\t\tlower values of @p _order appear first in @p\n\t\t\t_dev's list of children\n @param _name\t\tdevclass name for new device or @c NULL if not\n\t\t\tspecified\n @param _unit\t\tunit number for new device or @c -1 if not\n\t\t\tspecified"]
    #[link_name = "BUS_ADD_CHILD__extern"]
    pub fn BUS_ADD_CHILD(
        _dev: device_t,
        _order: u_int,
        _name: *const ::core::ffi::c_char,
        _unit: ::core::ffi::c_int,
    ) -> device_t;
    #[doc = " @brief Unique descriptor for the BUS_RESCAN() method"]
    pub static mut bus_rescan_desc: kobjop_desc;
    #[doc = " @brief Rescan the bus\n\n This method is called by a parent bridge or devctl to trigger a bus\n rescan.  The rescan should delete devices no longer present and\n enumerate devices that have newly arrived.\n\n @param _dev\t\tthe bus device"]
    #[link_name = "BUS_RESCAN__extern"]
    pub fn BUS_RESCAN(_dev: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_ALLOC_RESOURCE() method"]
    pub static mut bus_alloc_resource_desc: kobjop_desc;
    #[doc = " @brief Allocate a system resource\n\n This method is called by child devices of a bus to allocate resources.\n The types are defined in <machine/resource.h>; the meaning of the\n resource-ID field varies from bus to bus (but @p *rid == 0 is always\n valid if the resource type is). If a resource was allocated and the\n caller did not use the RF_ACTIVE to specify that it should be\n activated immediately, the caller is responsible for calling\n BUS_ACTIVATE_RESOURCE() when it actually uses the resource.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which is requesting an allocation\n @param _type\t\tthe type of resource to allocate\n @param _rid\t\ta pointer to the resource identifier\n @param _start\thint at the start of the resource range - pass\n\t\t\t@c 0 for any start address\n @param _end\t\thint at the end of the resource range - pass\n\t\t\t@c ~0 for any end address\n @param _count\thint at the size of range required - pass @c 1\n\t\t\tfor any size\n @param _flags\tany extra flags to control the resource\n\t\t\tallocation - see @c RF_XXX flags in\n\t\t\t<sys/rman.h> for details\n\n @returns\t\tthe resource which was allocated or @c NULL if no\n\t\t\tresource could be allocated"]
    #[link_name = "BUS_ALLOC_RESOURCE__extern"]
    pub fn BUS_ALLOC_RESOURCE(
        _dev: device_t,
        _child: device_t,
        _type: ::core::ffi::c_int,
        _rid: *mut ::core::ffi::c_int,
        _start: rman_res_t,
        _end: rman_res_t,
        _count: rman_res_t,
        _flags: u_int,
    ) -> *mut resource;
    #[doc = " @brief Unique descriptor for the BUS_ACTIVATE_RESOURCE() method"]
    pub static mut bus_activate_resource_desc: kobjop_desc;
    #[doc = " @brief Activate a resource\n\n Activate a resource previously allocated with\n BUS_ALLOC_RESOURCE().  This may enable decoding of this resource in a\n device for instance.  It will also establish a mapping for the resource\n unless RF_UNMAPPED was set when allocating the resource.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which allocated the resource\n @param _r\t\tthe resource to activate"]
    #[link_name = "BUS_ACTIVATE_RESOURCE__extern"]
    pub fn BUS_ACTIVATE_RESOURCE(
        _dev: device_t,
        _child: device_t,
        _r: *mut resource,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_MAP_RESOURCE() method"]
    pub static mut bus_map_resource_desc: kobjop_desc;
    #[doc = " @brief Map a resource\n\n Allocate a mapping for a range of an active resource.  The mapping\n is described by a struct resource_map object.  This may for instance\n map a memory region into the kernel's virtual address space.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which allocated the resource\n @param _r\t\tthe resource to map\n @param _args\t\toptional attributes of the mapping\n @param _map\t\tthe mapping"]
    #[link_name = "BUS_MAP_RESOURCE__extern"]
    pub fn BUS_MAP_RESOURCE(
        _dev: device_t,
        _child: device_t,
        _r: *mut resource,
        _args: *mut resource_map_request,
        _map: *mut resource_map,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_UNMAP_RESOURCE() method"]
    pub static mut bus_unmap_resource_desc: kobjop_desc;
    #[doc = " @brief Unmap a resource\n\n Release a mapping previously allocated with\n BUS_MAP_RESOURCE(). This may for instance unmap a memory region\n from the kernel's virtual address space.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which allocated the resource\n @param _r\t\tthe resource\n @param _map\t\tthe mapping to release"]
    #[link_name = "BUS_UNMAP_RESOURCE__extern"]
    pub fn BUS_UNMAP_RESOURCE(
        _dev: device_t,
        _child: device_t,
        _r: *mut resource,
        _map: *mut resource_map,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_DEACTIVATE_RESOURCE() method"]
    pub static mut bus_deactivate_resource_desc: kobjop_desc;
    #[doc = " @brief Deactivate a resource\n\n Deactivate a resource previously allocated with\n BUS_ALLOC_RESOURCE().\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which allocated the resource\n @param _r\t\tthe resource to deactivate"]
    #[link_name = "BUS_DEACTIVATE_RESOURCE__extern"]
    pub fn BUS_DEACTIVATE_RESOURCE(
        _dev: device_t,
        _child: device_t,
        _r: *mut resource,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_ADJUST_RESOURCE() method"]
    pub static mut bus_adjust_resource_desc: kobjop_desc;
    #[doc = " @brief Adjust a resource\n\n Adjust the start and/or end of a resource allocated by\n BUS_ALLOC_RESOURCE.  At least part of the new address range must overlap\n with the existing address range.  If the successful, the resource's range\n will be adjusted to [start, end] on return.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which allocated the resource\n @param _res\t\tthe resource to adjust\n @param _start\tthe new starting address of the resource range\n @param _end\t\tthe new ending address of the resource range"]
    #[link_name = "BUS_ADJUST_RESOURCE__extern"]
    pub fn BUS_ADJUST_RESOURCE(
        _dev: device_t,
        _child: device_t,
        _res: *mut resource,
        _start: rman_res_t,
        _end: rman_res_t,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_TRANSLATE_RESOURCE() method"]
    pub static mut bus_translate_resource_desc: kobjop_desc;
    #[doc = " @brief translate a resource value\n\n Give a bus driver the opportunity to translate resource ranges.  If\n successful, the host's view of the resource starting at @p _start is\n returned in @p _newstart, otherwise an error is returned.\n\n @param _dev\t\tthe device associated with the resource\n @param _type\t\tthe type of resource\n @param _start\tthe starting address of the resource range\n @param _newstart\tthe new starting address of the resource range"]
    #[link_name = "BUS_TRANSLATE_RESOURCE__extern"]
    pub fn BUS_TRANSLATE_RESOURCE(
        _dev: device_t,
        _type: ::core::ffi::c_int,
        _start: rman_res_t,
        _newstart: *mut rman_res_t,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_RELEASE_RESOURCE() method"]
    pub static mut bus_release_resource_desc: kobjop_desc;
    #[doc = " @brief Release a resource\n\n Free a resource allocated by the BUS_ALLOC_RESOURCE.  The @p _rid\n value must be the same as the one returned by BUS_ALLOC_RESOURCE()\n (which is not necessarily the same as the one the client passed).\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which allocated the resource\n @param _r\t\tthe resource to release"]
    #[link_name = "BUS_RELEASE_RESOURCE__extern"]
    pub fn BUS_RELEASE_RESOURCE(
        _dev: device_t,
        _child: device_t,
        _res: *mut resource,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_SETUP_INTR() method"]
    pub static mut bus_setup_intr_desc: kobjop_desc;
    #[doc = " @brief Install an interrupt handler\n\n This method is used to associate an interrupt handler function with\n an irq resource. When the interrupt triggers, the function @p _intr\n will be called with the value of @p _arg as its single\n argument. The value returned in @p *_cookiep is used to cancel the\n interrupt handler - the caller should save this value to use in a\n future call to BUS_TEARDOWN_INTR().\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which allocated the resource\n @param _irq\t\tthe resource representing the interrupt\n @param _flags\ta set of bits from enum intr_type specifying\n\t\t\tthe class of interrupt\n @param _intr\t\tthe function to call when the interrupt\n\t\t\ttriggers\n @param _arg\t\ta value to use as the single argument in calls\n\t\t\tto @p _intr\n @param _cookiep\ta pointer to a location to receive a cookie\n\t\t\tvalue that may be used to remove the interrupt\n\t\t\thandler"]
    #[link_name = "BUS_SETUP_INTR__extern"]
    pub fn BUS_SETUP_INTR(
        _dev: device_t,
        _child: device_t,
        _irq: *mut resource,
        _flags: ::core::ffi::c_int,
        _filter: driver_filter_t,
        _intr: driver_intr_t,
        _arg: *mut ::core::ffi::c_void,
        _cookiep: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_TEARDOWN_INTR() method"]
    pub static mut bus_teardown_intr_desc: kobjop_desc;
    #[doc = " @brief Uninstall an interrupt handler\n\n This method is used to disassociate an interrupt handler function\n with an irq resource. The value of @p _cookie must be the value\n returned from a previous call to BUS_SETUP_INTR().\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which allocated the resource\n @param _irq\t\tthe resource representing the interrupt\n @param _cookie\tthe cookie value returned when the interrupt\n\t\t\twas originally registered"]
    #[link_name = "BUS_TEARDOWN_INTR__extern"]
    pub fn BUS_TEARDOWN_INTR(
        _dev: device_t,
        _child: device_t,
        _irq: *mut resource,
        _cookie: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_SUSPEND_INTR() method"]
    pub static mut bus_suspend_intr_desc: kobjop_desc;
    #[doc = " @brief Suspend an interrupt handler\n\n This method is used to mark a handler as suspended in the case\n that the associated device is powered down and cannot be a source\n for the, typically shared, interrupt.\n The value of @p _irq must be the interrupt resource passed\n to a previous call to BUS_SETUP_INTR().\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which allocated the resource\n @param _irq\t\tthe resource representing the interrupt"]
    #[link_name = "BUS_SUSPEND_INTR__extern"]
    pub fn BUS_SUSPEND_INTR(
        _dev: device_t,
        _child: device_t,
        _irq: *mut resource,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_RESUME_INTR() method"]
    pub static mut bus_resume_intr_desc: kobjop_desc;
    #[doc = " @brief Resume an interrupt handler\n\n This method is used to clear suspended state of a handler when\n the associated device is powered up and can be an interrupt source\n again.\n The value of @p _irq must be the interrupt resource passed\n to a previous call to BUS_SETUP_INTR().\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which allocated the resource\n @param _irq\t\tthe resource representing the interrupt"]
    #[link_name = "BUS_RESUME_INTR__extern"]
    pub fn BUS_RESUME_INTR(
        _dev: device_t,
        _child: device_t,
        _irq: *mut resource,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_SET_RESOURCE() method"]
    pub static mut bus_set_resource_desc: kobjop_desc;
    #[doc = " @brief Define a resource which can be allocated with\n BUS_ALLOC_RESOURCE().\n\n This method is used by some buses (typically ISA) to allow a\n driver to describe a resource range that it would like to\n allocate. The resource defined by @p _type and @p _rid is defined\n to start at @p _start and to include @p _count indices in its\n range.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which owns the resource\n @param _type\t\tthe type of resource\n @param _rid\t\tthe resource identifier\n @param _start\tthe start of the resource range\n @param _count\tthe size of the resource range"]
    #[link_name = "BUS_SET_RESOURCE__extern"]
    pub fn BUS_SET_RESOURCE(
        _dev: device_t,
        _child: device_t,
        _type: ::core::ffi::c_int,
        _rid: ::core::ffi::c_int,
        _start: rman_res_t,
        _count: rman_res_t,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_GET_RESOURCE() method"]
    pub static mut bus_get_resource_desc: kobjop_desc;
    #[doc = " @brief Describe a resource\n\n This method allows a driver to examine the range used for a given\n resource without actually allocating it.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which owns the resource\n @param _type\t\tthe type of resource\n @param _rid\t\tthe resource identifier\n @param _start\tthe address of a location to receive the start\n\t\t\tindex of the resource range\n @param _count\tthe address of a location to receive the size\n\t\t\tof the resource range"]
    #[link_name = "BUS_GET_RESOURCE__extern"]
    pub fn BUS_GET_RESOURCE(
        _dev: device_t,
        _child: device_t,
        _type: ::core::ffi::c_int,
        _rid: ::core::ffi::c_int,
        _startp: *mut rman_res_t,
        _countp: *mut rman_res_t,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_DELETE_RESOURCE() method"]
    pub static mut bus_delete_resource_desc: kobjop_desc;
    #[doc = " @brief Delete a resource.\n\n Use this to delete a resource (possibly one previously added with\n BUS_SET_RESOURCE()).\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which owns the resource\n @param _type\t\tthe type of resource\n @param _rid\t\tthe resource identifier"]
    #[link_name = "BUS_DELETE_RESOURCE__extern"]
    pub fn BUS_DELETE_RESOURCE(
        _dev: device_t,
        _child: device_t,
        _type: ::core::ffi::c_int,
        _rid: ::core::ffi::c_int,
    );
    #[doc = " @brief Unique descriptor for the BUS_GET_RESOURCE_LIST() method"]
    pub static mut bus_get_resource_list_desc: kobjop_desc;
    #[doc = " @brief Return a struct resource_list.\n\n Used by drivers which use bus_generic_rl_alloc_resource() etc. to\n implement their resource handling. It should return the resource\n list of the given child device.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which owns the resource list"]
    #[link_name = "BUS_GET_RESOURCE_LIST__extern"]
    pub fn BUS_GET_RESOURCE_LIST(_dev: device_t, _child: device_t) -> *mut resource_list;
    #[doc = " @brief Unique descriptor for the BUS_GET_RMAN() method"]
    pub static mut bus_get_rman_desc: kobjop_desc;
    #[doc = " @brief Return a struct rman.\n\n Used by drivers which use bus_generic_rman_alloc_resource() etc. to\n implement their resource handling. It should return the resource\n manager used for the given resource type.\n\n @param _dev\t\tthe bus device\n @param _type\t\tthe resource type\n @param _flags\tresource flags (@c RF_XXX flags in\n\t\t\t<sys/rman.h>)"]
    #[link_name = "BUS_GET_RMAN__extern"]
    pub fn BUS_GET_RMAN(_dev: device_t, _type: ::core::ffi::c_int, _flags: u_int) -> *mut rman;
    #[doc = " @brief Unique descriptor for the BUS_CHILD_PRESENT() method"]
    pub static mut bus_child_present_desc: kobjop_desc;
    #[doc = " @brief Is the hardware described by @p _child still attached to the\n system?\n\n This method should return 0 if the device is not present.  It\n should return -1 if it is present.  Any errors in determining\n should be returned as a normal errno value.  Client drivers are to\n assume that the device is present, even if there is an error\n determining if it is there.  Buses are to try to avoid returning\n errors, but newcard will return an error if the device fails to\n implement this method.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which is being examined"]
    #[link_name = "BUS_CHILD_PRESENT__extern"]
    pub fn BUS_CHILD_PRESENT(_dev: device_t, _child: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_CHILD_PNPINFO() method"]
    pub static mut bus_child_pnpinfo_desc: kobjop_desc;
    #[doc = " @brief Returns the pnp info for this device.\n\n Return it as a string, appended to @p _sb\n\n The string must be formatted as a space-separated list of\n name=value pairs.  Names may only contain alphanumeric characters,\n underscores ('_') and hyphens ('-').  Values can contain any\n non-whitespace characters.  Values containing whitespace can be\n quoted with double quotes ('\"').  Double quotes and backslashes in\n quoted values can be escaped with backslashes ('\\').\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which is being examined\n @param _sb\t\tsbuf for results string"]
    #[link_name = "BUS_CHILD_PNPINFO__extern"]
    pub fn BUS_CHILD_PNPINFO(
        _dev: device_t,
        _child: device_t,
        _sb: *mut sbuf,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_CHILD_LOCATION() method"]
    pub static mut bus_child_location_desc: kobjop_desc;
    #[doc = " @brief Returns the location for this device.\n\n Return it as a string, appended to @p _sb\n\n The string must be formatted as a space-separated list of\n name=value pairs.  Names may only contain alphanumeric characters,\n underscores ('_') and hyphens ('-').  Values can contain any\n non-whitespace characters.  Values containing whitespace can be\n quoted with double quotes ('\"').  Double quotes and backslashes in\n quoted values can be escaped with backslashes ('\\').\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which is being examined\n @param _sb\t\tsbuf for results string"]
    #[link_name = "BUS_CHILD_LOCATION__extern"]
    pub fn BUS_CHILD_LOCATION(
        _dev: device_t,
        _child: device_t,
        _sb: *mut sbuf,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_BIND_INTR() method"]
    pub static mut bus_bind_intr_desc: kobjop_desc;
    #[doc = " @brief Allow drivers to request that an interrupt be bound to a specific\n CPU.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which allocated the resource\n @param _irq\t\tthe resource representing the interrupt\n @param _cpu\t\tthe CPU to bind the interrupt to"]
    #[link_name = "BUS_BIND_INTR__extern"]
    pub fn BUS_BIND_INTR(
        _dev: device_t,
        _child: device_t,
        _irq: *mut resource,
        _cpu: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_CONFIG_INTR() method"]
    pub static mut bus_config_intr_desc: kobjop_desc;
    #[doc = " @brief Allow (bus) drivers to specify the trigger mode and polarity\n of the specified interrupt.\n\n @param _dev\t\tthe bus device\n @param _irq\t\tthe interrupt number to modify\n @param _trig\t\tthe trigger mode required\n @param _pol\t\tthe interrupt polarity required"]
    #[link_name = "BUS_CONFIG_INTR__extern"]
    pub fn BUS_CONFIG_INTR(
        _dev: device_t,
        _irq: ::core::ffi::c_int,
        _trig: intr_trigger,
        _pol: intr_polarity,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_DESCRIBE_INTR() method"]
    pub static mut bus_describe_intr_desc: kobjop_desc;
    #[doc = " @brief Allow drivers to associate a description with an active\n interrupt handler.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which allocated the resource\n @param _irq\t\tthe resource representing the interrupt\n @param _cookie\tthe cookie value returned when the interrupt\n\t\t\twas originally registered\n @param _descr\tthe description to associate with the interrupt"]
    #[link_name = "BUS_DESCRIBE_INTR__extern"]
    pub fn BUS_DESCRIBE_INTR(
        _dev: device_t,
        _child: device_t,
        _irq: *mut resource,
        _cookie: *mut ::core::ffi::c_void,
        _descr: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_HINTED_CHILD() method"]
    pub static mut bus_hinted_child_desc: kobjop_desc;
    #[doc = " @brief Notify a (bus) driver about a child that the hints mechanism\n believes it has discovered.\n\n The bus is responsible for then adding the child in the right order\n and discovering other things about the child.  The bus driver is\n free to ignore this hint, to do special things, etc.  It is all up\n to the bus driver to interpret.\n\n This method is only called in response to the parent bus asking for\n hinted devices to be enumerated.\n\n @param _dev\t\tthe bus device\n @param _dname\tthe name of the device w/o unit numbers\n @param _dunit\tthe unit number of the device"]
    #[link_name = "BUS_HINTED_CHILD__extern"]
    pub fn BUS_HINTED_CHILD(
        _dev: device_t,
        _dname: *const ::core::ffi::c_char,
        _dunit: ::core::ffi::c_int,
    );
    #[doc = " @brief Unique descriptor for the BUS_GET_DMA_TAG() method"]
    pub static mut bus_get_dma_tag_desc: kobjop_desc;
    #[doc = " @brief Returns bus_dma_tag_t for use w/ devices on the bus.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device to which the tag will belong"]
    #[link_name = "BUS_GET_DMA_TAG__extern"]
    pub fn BUS_GET_DMA_TAG(_dev: device_t, _child: device_t) -> bus_dma_tag_t;
    #[doc = " @brief Unique descriptor for the BUS_GET_BUS_TAG() method"]
    pub static mut bus_get_bus_tag_desc: kobjop_desc;
    #[doc = " @brief Returns bus_space_tag_t for use w/ devices on the bus.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device to which the tag will belong"]
    #[link_name = "BUS_GET_BUS_TAG__extern"]
    pub fn BUS_GET_BUS_TAG(_dev: device_t, _child: device_t) -> bus_space_tag_t;
    #[doc = " @brief Unique descriptor for the BUS_HINT_DEVICE_UNIT() method"]
    pub static mut bus_hint_device_unit_desc: kobjop_desc;
    #[doc = " @brief Allow the bus to determine the unit number of a device.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device whose unit is to be wired\n @param _name\t\tthe name of the device's new devclass\n @param _unitp\ta pointer to the device's new unit value"]
    #[link_name = "BUS_HINT_DEVICE_UNIT__extern"]
    pub fn BUS_HINT_DEVICE_UNIT(
        _dev: device_t,
        _child: device_t,
        _name: *const ::core::ffi::c_char,
        _unitp: *mut ::core::ffi::c_int,
    );
    #[doc = " @brief Unique descriptor for the BUS_NEW_PASS() method"]
    pub static mut bus_new_pass_desc: kobjop_desc;
    #[doc = " @brief Notify a bus that the bus pass level has been changed\n\n @param _dev\t\tthe bus device"]
    #[link_name = "BUS_NEW_PASS__extern"]
    pub fn BUS_NEW_PASS(_dev: device_t);
    #[doc = " @brief Unique descriptor for the BUS_REMAP_INTR() method"]
    pub static mut bus_remap_intr_desc: kobjop_desc;
    #[doc = " @brief Notify a bus that specified child's IRQ should be remapped.\n\n @param _dev\t\tthe bus device\n @param _child\tthe child device\n @param _irq\t\tthe irq number"]
    #[link_name = "BUS_REMAP_INTR__extern"]
    pub fn BUS_REMAP_INTR(_dev: device_t, _child: device_t, _irq: u_int) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_SUSPEND_CHILD() method"]
    pub static mut bus_suspend_child_desc: kobjop_desc;
    #[doc = " @brief Suspend a given child\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device to suspend"]
    #[link_name = "BUS_SUSPEND_CHILD__extern"]
    pub fn BUS_SUSPEND_CHILD(_dev: device_t, _child: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_RESUME_CHILD() method"]
    pub static mut bus_resume_child_desc: kobjop_desc;
    #[doc = " @brief Resume a given child\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device to resume"]
    #[link_name = "BUS_RESUME_CHILD__extern"]
    pub fn BUS_RESUME_CHILD(_dev: device_t, _child: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_GET_DOMAIN() method"]
    pub static mut bus_get_domain_desc: kobjop_desc;
    #[doc = " @brief Get the VM domain handle for the given bus and child.\n\n @param _dev\t\tthe bus device\n @param _child\tthe child device\n @param _domain\ta pointer to the bus's domain handle identifier"]
    #[link_name = "BUS_GET_DOMAIN__extern"]
    pub fn BUS_GET_DOMAIN(
        _dev: device_t,
        _child: device_t,
        _domain: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_GET_CPUS() method"]
    pub static mut bus_get_cpus_desc: kobjop_desc;
    #[doc = " @brief Request a set of CPUs\n\n @param _dev\t\tthe bus device\n @param _child\tthe child device\n @param _op\t\ttype of CPUs to request\n @param _setsize\tthe size of the set passed in _cpuset\n @param _cpuset\ta pointer to a cpuset to receive the requested\n\t\t\tset of CPUs"]
    #[link_name = "BUS_GET_CPUS__extern"]
    pub fn BUS_GET_CPUS(
        _dev: device_t,
        _child: device_t,
        _op: cpu_sets,
        _setsize: usize,
        _cpuset: *mut _cpuset,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_RESET_PREPARE() method"]
    pub static mut bus_reset_prepare_desc: kobjop_desc;
    #[doc = " @brief Prepares the given child of the bus for reset\n\n Typically bus detaches or suspends children' drivers, and then\n calls this method to save bus-specific information, for instance,\n PCI config space, which is damaged by reset.\n\n The bus_helper_reset_prepare() helper is provided to ease\n implementing bus reset methods.\n\n @param _dev\t\tthe bus device\n @param _child\tthe child device"]
    #[link_name = "BUS_RESET_PREPARE__extern"]
    pub fn BUS_RESET_PREPARE(_dev: device_t, _child: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_RESET_POST() method"]
    pub static mut bus_reset_post_desc: kobjop_desc;
    #[doc = " @brief Restores the child operations after the reset\n\n The bus_helper_reset_post() helper is provided to ease\n implementing bus reset methods.\n\n @param _dev\t\tthe bus device\n @param _child\tthe child device"]
    #[link_name = "BUS_RESET_POST__extern"]
    pub fn BUS_RESET_POST(_dev: device_t, _child: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_RESET_CHILD() method"]
    pub static mut bus_reset_child_desc: kobjop_desc;
    #[doc = " @brief Performs reset of the child\n\n @param _dev\t\tthe bus device\n @param _child\tthe child device\n @param _flags\tDEVF_RESET_ flags"]
    #[link_name = "BUS_RESET_CHILD__extern"]
    pub fn BUS_RESET_CHILD(
        _dev: device_t,
        _child: device_t,
        _flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_GET_PROPERTY() method"]
    pub static mut bus_get_property_desc: kobjop_desc;
    #[doc = " @brief Gets child's specific property\n\n The bus_get_property can be used to access device\n specific properties stored on the bus. If _propvalue\n is NULL or _size is 0, then method only returns size\n of the property.\n\n @param _dev\t\t\tthe bus device\n @param _child\t\tthe child device\n @param _propname\t\tproperty name\n @param _propvalue\tproperty value destination\n @param _size\t\t\tproperty value size\n\n @returns size of property if successful otherwise -1"]
    #[link_name = "BUS_GET_PROPERTY__extern"]
    pub fn BUS_GET_PROPERTY(
        _dev: device_t,
        _child: device_t,
        _propname: *const ::core::ffi::c_char,
        _propvalue: *mut ::core::ffi::c_void,
        _size: usize,
        type_: device_property_type_t,
    ) -> isize;
    #[doc = " @brief Unique descriptor for the BUS_GET_DEVICE_PATH() method"]
    pub static mut bus_get_device_path_desc: kobjop_desc;
    #[doc = " @brief Gets a child's full path to the device\n\n The get_device_path method retrieves a device's\n full path to the device using one of several\n locators present in the system.\n\n @param _bus\t\t\tthe bus device\n @param _child\t\tthe child device\n @param _locator\t\tlocator name\n @param _sb\t\t\tbuffer loaction string"]
    #[link_name = "BUS_GET_DEVICE_PATH__extern"]
    pub fn BUS_GET_DEVICE_PATH(
        _bus: device_t,
        _child: device_t,
        _locator: *const ::core::ffi::c_char,
        _sb: *mut sbuf,
    ) -> ::core::ffi::c_int;
    pub fn driver_module_handler(
        arg1: *mut module,
        arg2: ::core::ffi::c_int,
        arg3: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn dev_wired_cache_init() -> *mut device_location_cache_t;
    pub fn dev_wired_cache_fini(dcp: *mut device_location_cache_t);
    pub fn dev_wired_cache_match(
        dcp: *mut device_location_cache_t,
        dev: device_t,
        at: *const ::core::ffi::c_char,
    ) -> bool_;
    pub fn device_set_prop(
        dev: device_t,
        name: *const ::core::ffi::c_char,
        val: *mut ::core::ffi::c_void,
        dtr: device_prop_dtr_t,
        dtr_ctx: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn device_get_prop(
        dev: device_t,
        name: *const ::core::ffi::c_char,
        valp: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn device_clear_prop(dev: device_t, name: *const ::core::ffi::c_char)
        -> ::core::ffi::c_int;
    pub fn device_clear_prop_alldev(name: *const ::core::ffi::c_char);
    pub static mut cpusetsizemin: u_int;
    pub static mut cpuset_root: *mut cpuset_t;
    pub fn cpuset_thread0() -> *mut cpuset;
    pub fn cpuset_ref(arg1: *mut cpuset) -> *mut cpuset;
    pub fn cpuset_rel(arg1: *mut cpuset);
    pub fn cpuset_setthread(id: lwpid_t, arg1: *mut cpuset_t) -> ::core::ffi::c_int;
    pub fn cpuset_setithread(id: lwpid_t, cpu: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn cpuset_create_root(arg1: *mut prison, arg2: *mut *mut cpuset) -> ::core::ffi::c_int;
    pub fn cpuset_setproc_update_set(arg1: *mut proc_, arg2: *mut cpuset) -> ::core::ffi::c_int;
    pub fn cpuset_which(
        arg1: cpuwhich_t,
        arg2: id_t,
        arg3: *mut *mut proc_,
        arg4: *mut *mut thread,
        arg5: *mut *mut cpuset,
    ) -> ::core::ffi::c_int;
    pub fn cpuset_kernthread(arg1: *mut thread);
    pub fn cpusetobj_strprint(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const cpuset_t,
    ) -> *mut ::core::ffi::c_char;
    pub fn cpusetobj_strscan(
        arg1: *mut cpuset_t,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub static mut M_CACHE: [malloc_type; 1usize];
    pub static mut M_DEVBUF: [malloc_type; 1usize];
    pub static mut M_PARGS: [malloc_type; 1usize];
    pub static mut M_SESSION: [malloc_type; 1usize];
    pub static mut M_SUBPROC: [malloc_type; 1usize];
    pub static mut M_TEMP: [malloc_type; 1usize];
    pub static mut M_IOV: [malloc_type; 1usize];
    pub static mut malloc_mtx: mtx;
    pub fn contigfree(
        addr: *mut ::core::ffi::c_void,
        arg1: ::core::ffi::c_ulong,
        type_: *mut malloc_type,
    );
    pub fn contigmalloc(
        size: ::core::ffi::c_ulong,
        type_: *mut malloc_type,
        flags: ::core::ffi::c_int,
        low: vm_paddr_t,
        high: vm_paddr_t,
        alignment: ::core::ffi::c_ulong,
        boundary: vm_paddr_t,
    ) -> *mut ::core::ffi::c_void;
    pub fn contigmalloc_domainset(
        size: ::core::ffi::c_ulong,
        type_: *mut malloc_type,
        ds: *mut domainset,
        flags: ::core::ffi::c_int,
        low: vm_paddr_t,
        high: vm_paddr_t,
        alignment: ::core::ffi::c_ulong,
        boundary: vm_paddr_t,
    ) -> *mut ::core::ffi::c_void;
    pub fn free(addr: *mut ::core::ffi::c_void, type_: *mut malloc_type);
    pub fn zfree(addr: *mut ::core::ffi::c_void, type_: *mut malloc_type);
    pub fn malloc(
        size: usize,
        type_: *mut malloc_type,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn malloc_domainset(
        size: usize,
        type_: *mut malloc_type,
        ds: *mut domainset,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn mallocarray(
        nmemb: usize,
        size: usize,
        type_: *mut malloc_type,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn mallocarray_domainset(
        nmemb: usize,
        size: usize,
        type_: *mut malloc_type,
        ds: *mut domainset,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn malloc_exec(
        size: usize,
        type_: *mut malloc_type,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn malloc_domainset_exec(
        size: usize,
        type_: *mut malloc_type,
        ds: *mut domainset,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn malloc_init(arg1: *mut ::core::ffi::c_void);
    pub fn malloc_type_allocated(type_: *mut malloc_type, size: ::core::ffi::c_ulong);
    pub fn malloc_type_freed(type_: *mut malloc_type, size: ::core::ffi::c_ulong);
    pub fn malloc_type_list(arg1: malloc_type_list_func_t, arg2: *mut ::core::ffi::c_void);
    pub fn malloc_uninit(arg1: *mut ::core::ffi::c_void);
    pub fn malloc_size(arg1: usize) -> usize;
    pub fn malloc_usable_size(arg1: *const ::core::ffi::c_void) -> usize;
    pub fn realloc(
        addr: *mut ::core::ffi::c_void,
        size: usize,
        type_: *mut malloc_type,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn reallocf(
        addr: *mut ::core::ffi::c_void,
        size: usize,
        type_: *mut malloc_type,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn malloc_aligned(
        size: usize,
        align: usize,
        type_: *mut malloc_type,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn malloc_domainset_aligned(
        size: usize,
        align: usize,
        mtp: *mut malloc_type,
        ds: *mut domainset,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn malloc_desc2type(desc: *const ::core::ffi::c_char) -> *mut malloc_type;
    #[link_name = "WOULD_OVERFLOW__extern"]
    pub fn WOULD_OVERFLOW(nmemb: usize, size: usize) -> bool_;
    pub fn vm_ksubmap_init(arg1: *mut kva_md_info);
    pub fn swap_reserve(incr: vm_ooffset_t) -> bool_;
    pub fn swap_reserve_by_cred(incr: vm_ooffset_t, cred: *mut ucred) -> bool_;
    pub fn swap_reserve_force(incr: vm_ooffset_t);
    pub fn swap_release(decr: vm_ooffset_t);
    pub fn swap_release_by_cred(decr: vm_ooffset_t, cred: *mut ucred);
    pub static mut kmi: kva_md_info;
    pub static mut old_mlock: ::core::ffi::c_int;
    pub static mut vm_ndomains: ::core::ffi::c_int;
    pub static mut vm_overcommit: ::core::ffi::c_int;
    pub static mut M_OFWPROP: [malloc_type; 1usize];
    pub fn OF_install(name: *mut ::core::ffi::c_char, prio: ::core::ffi::c_int) -> bool_;
    pub fn OF_init(cookie: *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
    pub fn OF_test(name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn OF_printf(fmt: *const ::core::ffi::c_char, ...);
    pub fn OF_peer(node: phandle_t) -> phandle_t;
    pub fn OF_child(node: phandle_t) -> phandle_t;
    pub fn OF_parent(node: phandle_t) -> phandle_t;
    pub fn OF_getproplen(node: phandle_t, propname: *const ::core::ffi::c_char) -> isize;
    pub fn OF_getprop(
        node: phandle_t,
        propname: *const ::core::ffi::c_char,
        buf: *mut ::core::ffi::c_void,
        len: usize,
    ) -> isize;
    pub fn OF_getencprop(
        node: phandle_t,
        prop: *const ::core::ffi::c_char,
        buf: *mut pcell_t,
        len: usize,
    ) -> isize;
    pub fn OF_hasprop(node: phandle_t, propname: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn OF_searchprop(
        node: phandle_t,
        propname: *const ::core::ffi::c_char,
        buf: *mut ::core::ffi::c_void,
        len: usize,
    ) -> isize;
    pub fn OF_searchencprop(
        node: phandle_t,
        propname: *const ::core::ffi::c_char,
        buf: *mut pcell_t,
        len: usize,
    ) -> isize;
    pub fn OF_getprop_alloc(
        node: phandle_t,
        propname: *const ::core::ffi::c_char,
        buf: *mut *mut ::core::ffi::c_void,
    ) -> isize;
    pub fn OF_getprop_alloc_multi(
        node: phandle_t,
        propname: *const ::core::ffi::c_char,
        elsz: ::core::ffi::c_int,
        buf: *mut *mut ::core::ffi::c_void,
    ) -> isize;
    pub fn OF_getencprop_alloc(
        node: phandle_t,
        propname: *const ::core::ffi::c_char,
        buf: *mut *mut ::core::ffi::c_void,
    ) -> isize;
    pub fn OF_getencprop_alloc_multi(
        node: phandle_t,
        propname: *const ::core::ffi::c_char,
        elsz: ::core::ffi::c_int,
        buf: *mut *mut ::core::ffi::c_void,
    ) -> isize;
    pub fn OF_prop_free(buf: *mut ::core::ffi::c_void);
    pub fn OF_nextprop(
        node: phandle_t,
        propname: *const ::core::ffi::c_char,
        buf: *mut ::core::ffi::c_char,
        len: usize,
    ) -> ::core::ffi::c_int;
    pub fn OF_setprop(
        node: phandle_t,
        name: *const ::core::ffi::c_char,
        buf: *const ::core::ffi::c_void,
        len: usize,
    ) -> ::core::ffi::c_int;
    pub fn OF_canon(
        path: *const ::core::ffi::c_char,
        buf: *mut ::core::ffi::c_char,
        len: usize,
    ) -> isize;
    pub fn OF_finddevice(path: *const ::core::ffi::c_char) -> phandle_t;
    pub fn OF_package_to_path(node: phandle_t, buf: *mut ::core::ffi::c_char, len: usize) -> isize;
    pub fn OF_node_from_xref(xref: phandle_t) -> phandle_t;
    pub fn OF_xref_from_node(node: phandle_t) -> phandle_t;
    pub fn OF_device_from_xref(xref: phandle_t) -> device_t;
    pub fn OF_xref_from_device(dev: device_t) -> phandle_t;
    pub fn OF_device_register_xref(xref: phandle_t, dev: device_t) -> ::core::ffi::c_int;
    pub fn OF_device_unregister_xref(xref: phandle_t, dev: device_t);
    pub fn OF_open(path: *const ::core::ffi::c_char) -> ihandle_t;
    pub fn OF_close(instance: ihandle_t);
    pub fn OF_read(instance: ihandle_t, buf: *mut ::core::ffi::c_void, len: usize) -> isize;
    pub fn OF_write(instance: ihandle_t, buf: *const ::core::ffi::c_void, len: usize) -> isize;
    pub fn OF_seek(instance: ihandle_t, where_: u64) -> ::core::ffi::c_int;
    pub fn OF_instance_to_package(instance: ihandle_t) -> phandle_t;
    pub fn OF_instance_to_path(
        instance: ihandle_t,
        buf: *mut ::core::ffi::c_char,
        len: usize,
    ) -> isize;
    pub fn OF_call_method(
        method: *const ::core::ffi::c_char,
        instance: ihandle_t,
        nargs: ::core::ffi::c_int,
        nreturns: ::core::ffi::c_int,
        ...
    ) -> ::core::ffi::c_int;
    pub fn OF_claim(
        virtrequest: *mut ::core::ffi::c_void,
        size: usize,
        align: u_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn OF_release(virt: *mut ::core::ffi::c_void, size: usize);
    pub fn OF_enter();
    pub fn OF_exit() -> !;
    pub fn OF_interpret(
        cmd: *const ::core::ffi::c_char,
        nreturns: ::core::ffi::c_int,
        ...
    ) -> ::core::ffi::c_int;
    pub fn OF_decode_addr(
        dev: phandle_t,
        regno: ::core::ffi::c_int,
        ptag: *mut bus_space_tag_t,
        phandle: *mut bus_space_handle_t,
        sz: *mut bus_size_t,
    ) -> ::core::ffi::c_int;
    #[link_name = "arm_irq_memory_barrier__extern"]
    pub fn arm_irq_memory_barrier(irq: usize);
    pub fn intr_isrc_deregister(arg1: *mut intr_irqsrc) -> ::core::ffi::c_int;
    pub fn intr_isrc_register(
        arg1: *mut intr_irqsrc,
        arg2: device_t,
        arg3: u_int,
        arg4: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn intr_isrc_init_on_cpu(isrc: *mut intr_irqsrc, cpu: u_int) -> bool_;
    pub fn intr_isrc_dispatch(arg1: *mut intr_irqsrc, arg2: *mut trapframe) -> ::core::ffi::c_int;
    pub fn intr_irq_next_cpu(current_cpu: u_int, cpumask: *mut cpuset_t) -> u_int;
    pub fn intr_pic_register(arg1: device_t, arg2: isize) -> *mut intr_pic;
    pub fn intr_pic_deregister(arg1: device_t, arg2: isize) -> ::core::ffi::c_int;
    pub fn intr_pic_claim_root(
        arg1: device_t,
        arg2: isize,
        arg3: intr_irq_filter_t,
        arg4: *mut ::core::ffi::c_void,
        arg5: u32,
    ) -> ::core::ffi::c_int;
    pub fn intr_pic_add_handler(
        arg1: device_t,
        arg2: *mut intr_pic,
        arg3: intr_child_irq_filter_t,
        arg4: *mut ::core::ffi::c_void,
        arg5: usize,
        arg6: usize,
    ) -> ::core::ffi::c_int;
    pub fn intr_is_per_cpu(arg1: *mut resource) -> bool_;
    pub fn intr_irq_root_device(arg1: u32) -> device_t;
    pub fn intr_activate_irq(arg1: device_t, arg2: *mut resource) -> ::core::ffi::c_int;
    pub fn intr_deactivate_irq(arg1: device_t, arg2: *mut resource) -> ::core::ffi::c_int;
    pub fn intr_setup_irq(
        arg1: device_t,
        arg2: *mut resource,
        arg3: driver_filter_t,
        arg4: driver_intr_t,
        arg5: *mut ::core::ffi::c_void,
        arg6: ::core::ffi::c_int,
        arg7: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn intr_teardown_irq(
        arg1: device_t,
        arg2: *mut resource,
        arg3: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn intr_describe_irq(
        arg1: device_t,
        arg2: *mut resource,
        arg3: *mut ::core::ffi::c_void,
        arg4: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn intr_child_irq_handler(arg1: *mut intr_pic, arg2: usize) -> ::core::ffi::c_int;
    pub fn intr_alloc_map_data(
        arg1: intr_map_data_type,
        arg2: usize,
        arg3: ::core::ffi::c_int,
    ) -> *mut intr_map_data;
    pub fn intr_free_intr_map_data(arg1: *mut intr_map_data);
    pub fn intr_map_irq(arg1: device_t, arg2: isize, arg3: *mut intr_map_data) -> u_int;
    pub fn intr_unmap_irq(arg1: u_int);
    pub fn intr_map_clone_irq(arg1: u_int) -> u_int;
    pub fn intr_msi_register(arg1: device_t, arg2: isize) -> ::core::ffi::c_int;
    pub fn intr_alloc_msi(
        arg1: device_t,
        arg2: device_t,
        arg3: isize,
        arg4: ::core::ffi::c_int,
        arg5: ::core::ffi::c_int,
        arg6: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn intr_release_msi(
        arg1: device_t,
        arg2: device_t,
        arg3: isize,
        arg4: ::core::ffi::c_int,
        arg5: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn intr_map_msi(
        arg1: device_t,
        arg2: device_t,
        arg3: isize,
        arg4: ::core::ffi::c_int,
        arg5: *mut u64,
        arg6: *mut u32,
    ) -> ::core::ffi::c_int;
    pub fn intr_alloc_msix(
        arg1: device_t,
        arg2: device_t,
        arg3: isize,
        arg4: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn intr_release_msix(
        arg1: device_t,
        arg2: device_t,
        arg3: isize,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn intr_bind_irq(
        arg1: device_t,
        arg2: *mut resource,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn intr_pic_init_secondary();
    pub static mut intr_nirq: u_int;
    pub fn intr_ipi_pic_register(dev: device_t, priority: u_int) -> ::core::ffi::c_int;
    pub fn intr_ipi_setup(
        ipi: u_int,
        name: *const ::core::ffi::c_char,
        hand: intr_ipi_handler_t,
        arg: *mut ::core::ffi::c_void,
    );
    pub fn intr_ipi_send(cpus: cpuset_t, ipi: u_int);
    pub fn intr_ipi_dispatch(ipi: u_int);
    pub fn intr_irq_handler(tf: *mut trapframe, rootnum: u32);
    pub static mut kernelname: [::core::ffi::c_char; 1024usize];
    pub static mut tick: ::core::ffi::c_int;
    pub static mut hz: ::core::ffi::c_int;
    pub static mut psratio: ::core::ffi::c_int;
    pub static mut stathz: ::core::ffi::c_int;
    pub static mut profhz: ::core::ffi::c_int;
    pub static mut profprocs: ::core::ffi::c_int;
    pub static mut ticks: ::core::ffi::c_int;
    pub static mut ticksl: ::core::ffi::c_long;
    pub fn sysinit_add(set: *mut *mut sysinit, set_end: *mut *mut sysinit);
    pub fn tunable_int_init(arg1: *const ::core::ffi::c_void);
    pub fn tunable_long_init(arg1: *const ::core::ffi::c_void);
    pub fn tunable_ulong_init(arg1: *const ::core::ffi::c_void);
    pub fn tunable_int64_init(arg1: *const ::core::ffi::c_void);
    pub fn tunable_uint64_init(arg1: *const ::core::ffi::c_void);
    pub fn tunable_quad_init(arg1: *const ::core::ffi::c_void);
    pub fn tunable_bool_init(arg1: *const ::core::ffi::c_void);
    pub fn tunable_str_init(arg1: *const ::core::ffi::c_void);
    pub fn config_intrhook_establish(hook: *mut intr_config_hook) -> ::core::ffi::c_int;
    pub fn config_intrhook_disestablish(hook: *mut intr_config_hook);
    pub fn config_intrhook_drain(hook: *mut intr_config_hook) -> ::core::ffi::c_int;
    pub fn config_intrhook_oneshot(_func: ich_func_t, _arg: *mut ::core::ffi::c_void);
    pub static mut lock_class_mtx_sleep: lock_class;
    pub static mut lock_class_mtx_spin: lock_class;
    pub static mut lock_class_sx: lock_class;
    pub static mut lock_class_rw: lock_class;
    pub static mut lock_class_rm: lock_class;
    pub static mut lock_class_rm_sleepable: lock_class;
    pub static mut lock_class_lockmgr: lock_class;
    pub static mut lock_classes: [*mut lock_class; 0usize];
    pub static mut locks_delay: lock_delay_config;
    pub static mut locks_delay_retries: u_short;
    pub static mut locks_delay_loops: u_short;
    #[link_name = "lock_delay_arg_init__extern"]
    pub fn lock_delay_arg_init(la: *mut lock_delay_arg, lc: *mut lock_delay_config);
    #[link_name = "lock_delay_arg_init_noadapt__extern"]
    pub fn lock_delay_arg_init_noadapt(la: *mut lock_delay_arg);
    pub fn lock_init(
        arg1: *mut lock_object,
        arg2: *mut lock_class,
        arg3: *const ::core::ffi::c_char,
        arg4: *const ::core::ffi::c_char,
        arg5: ::core::ffi::c_int,
    );
    pub fn lock_destroy(arg1: *mut lock_object);
    pub fn lock_delay(arg1: *mut lock_delay_arg);
    pub fn lock_delay_default_init(arg1: *mut lock_delay_config);
    pub fn spinlock_enter();
    pub fn spinlock_exit();
    pub fn witness_init(arg1: *mut lock_object, arg2: *const ::core::ffi::c_char);
    pub fn witness_destroy(arg1: *mut lock_object);
    pub fn witness_defineorder(
        arg1: *mut lock_object,
        arg2: *mut lock_object,
    ) -> ::core::ffi::c_int;
    pub fn witness_checkorder(
        arg1: *mut lock_object,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: ::core::ffi::c_int,
        arg5: *mut lock_object,
    );
    pub fn witness_lock(
        arg1: *mut lock_object,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: ::core::ffi::c_int,
    );
    pub fn witness_upgrade(
        arg1: *mut lock_object,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: ::core::ffi::c_int,
    );
    pub fn witness_downgrade(
        arg1: *mut lock_object,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: ::core::ffi::c_int,
    );
    pub fn witness_unlock(
        arg1: *mut lock_object,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: ::core::ffi::c_int,
    );
    pub fn witness_save(
        arg1: *mut lock_object,
        arg2: *mut *const ::core::ffi::c_char,
        arg3: *mut ::core::ffi::c_int,
    );
    pub fn witness_restore(
        arg1: *mut lock_object,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    );
    pub fn witness_list_locks(
        arg1: *mut *mut lock_list_entry,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int,
        >,
    ) -> ::core::ffi::c_int;
    pub fn witness_warn(
        arg1: ::core::ffi::c_int,
        arg2: *mut lock_object,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn witness_assert(
        arg1: *const lock_object,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: ::core::ffi::c_int,
    );
    pub fn witness_is_owned(lock: *const lock_object) -> ::core::ffi::c_int;
    pub fn witness_display_spinlock(
        arg1: *mut lock_object,
        arg2: *mut thread,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int,
        >,
    );
    pub fn witness_line(arg1: *mut lock_object) -> ::core::ffi::c_int;
    pub fn witness_norelease(arg1: *mut lock_object);
    pub fn witness_releaseok(arg1: *mut lock_object);
    pub fn witness_file(arg1: *mut lock_object) -> *const ::core::ffi::c_char;
    pub fn witness_thread_exit(arg1: *mut thread);
    pub fn witness_startup_count() -> ::core::ffi::c_int;
    pub fn witness_startup(arg1: *mut ::core::ffi::c_void);
    #[doc = " descr is a string that describes each entry in the table. The general\n form is the grammar (TYPE:pnp_name[/pnp_name];)*\n where TYPE is one of the following:\n\tU8\tuint8_t element\n\tV8\tlike U8 and 0xff means match any\n\tG16\tuint16_t element, any value >= matches\n\tL16\tuint16_t element, any value <= matches\n\tM16\tuint16_t element, mask of which of the following fields to use.\n\tU16\tuint16_t element\n\tV16\tlike U16 and 0xffff means match any\n\tU32\tuint32_t element\n\tV32\tlike U32 and 0xffffffff means match any\n\tW32\tTwo 16-bit values with first pnp_name in LSW and second in MSW.\n\tZ\tpointer to a string to match exactly\n\tD\tpointer to a string to human readable description for device\n\tP\tA pointer that should be ignored\n\tE\tEISA PNP Identifier (in binary, but bus publishes string)\n\tT\tKey for whole table. pnp_name=value. must be last, if present.\n\n The pnp_name \"#\" is reserved for other fields that should be ignored.\n Otherwise pnp_name must match the name from the parent device's pnpinfo\n output. The second pnp_name is used for the W32 type."]
    pub static mut modules_sx: sx;
    pub fn module_register_init(arg1: *const ::core::ffi::c_void);
    pub fn module_register(arg1: *const moduledata, arg2: *mut linker_file) -> ::core::ffi::c_int;
    pub fn module_lookupbyname(arg1: *const ::core::ffi::c_char) -> module_t;
    pub fn module_lookupbyid(arg1: ::core::ffi::c_int) -> module_t;
    pub fn module_quiesce(arg1: module_t) -> ::core::ffi::c_int;
    pub fn module_reference(arg1: module_t);
    pub fn module_release(arg1: module_t);
    pub fn module_unload(arg1: module_t) -> ::core::ffi::c_int;
    pub fn module_getid(arg1: module_t) -> ::core::ffi::c_int;
    pub fn module_getfnext(arg1: module_t) -> module_t;
    pub fn module_getname(arg1: module_t) -> *const ::core::ffi::c_char;
    pub fn module_setspecific(arg1: module_t, arg2: *mut modspecific_t);
    pub fn module_file(arg1: module_t) -> *mut linker_file;
    pub static mut sdt_probes_enabled: bool_;
    pub fn sdt_probe(arg1: u32, arg2: usize, arg3: usize, arg4: usize, arg5: usize, arg6: usize);
    pub fn sdt_probe6(
        arg1: u32,
        arg2: usize,
        arg3: usize,
        arg4: usize,
        arg5: usize,
        arg6: usize,
        arg7: usize,
    );
    pub fn sdt_tracepoint_valid(patchpoint: usize, target: usize) -> bool_;
    pub fn sdt_tracepoint_patch(patchpoint: usize, target: usize);
    pub fn sdt_tracepoint_restore(patchpoint: usize);
    pub static mut __start_set_sdt_providers_set: *mut sdt_provider;
    pub static mut __stop_set_sdt_providers_set: *mut sdt_provider;
    pub static mut __start_set_sdt_probes_set: *mut sdt_probe;
    pub static mut __stop_set_sdt_probes_set: *mut sdt_probe;
    pub static mut __start_set_sdt_argtypes_set: *mut sdt_argtype;
    pub static mut __stop_set_sdt_argtypes_set: *mut sdt_argtype;
    pub static mut sdt_probe_func: sdt_probe_func_t;
    pub fn sdt_probe_stub(
        arg1: u32,
        arg2: usize,
        arg3: usize,
        arg4: usize,
        arg5: usize,
        arg6: usize,
        arg7: usize,
    );
    pub static mut sdt_provider_sdt: sdt_provider;
    pub static mut sdt_provider_lockstat: sdt_provider;
    pub static mut sdt_lockstat___adaptive__acquire: sdt_probe;
    pub static mut sdt_lockstat___adaptive__release: sdt_probe;
    pub static mut sdt_lockstat___adaptive__spin: sdt_probe;
    pub static mut sdt_lockstat___adaptive__block: sdt_probe;
    pub static mut sdt_lockstat___spin__acquire: sdt_probe;
    pub static mut sdt_lockstat___spin__release: sdt_probe;
    pub static mut sdt_lockstat___spin__spin: sdt_probe;
    pub static mut sdt_lockstat___rw__acquire: sdt_probe;
    pub static mut sdt_lockstat___rw__release: sdt_probe;
    pub static mut sdt_lockstat___rw__block: sdt_probe;
    pub static mut sdt_lockstat___rw__spin: sdt_probe;
    pub static mut sdt_lockstat___rw__upgrade: sdt_probe;
    pub static mut sdt_lockstat___rw__downgrade: sdt_probe;
    pub static mut sdt_lockstat___sx__acquire: sdt_probe;
    pub static mut sdt_lockstat___sx__release: sdt_probe;
    pub static mut sdt_lockstat___sx__block: sdt_probe;
    pub static mut sdt_lockstat___sx__spin: sdt_probe;
    pub static mut sdt_lockstat___sx__upgrade: sdt_probe;
    pub static mut sdt_lockstat___sx__downgrade: sdt_probe;
    pub static mut sdt_lockstat___lockmgr__acquire: sdt_probe;
    pub static mut sdt_lockstat___lockmgr__release: sdt_probe;
    pub static mut sdt_lockstat___lockmgr__disown: sdt_probe;
    pub static mut sdt_lockstat___lockmgr__block: sdt_probe;
    pub static mut sdt_lockstat___lockmgr__upgrade: sdt_probe;
    pub static mut sdt_lockstat___lockmgr__downgrade: sdt_probe;
    pub static mut sdt_lockstat___thread__spin: sdt_probe;
    pub static mut lockstat_enabled: bool_;
    pub fn lockstat_nsecs(arg1: *mut lock_object) -> u64;
    pub fn _mtx_init(
        c: *mut usize,
        name: *const ::core::ffi::c_char,
        type_: *const ::core::ffi::c_char,
        opts: ::core::ffi::c_int,
    );
    pub fn _mtx_destroy(c: *mut usize);
    pub fn mtx_sysinit(arg: *const ::core::ffi::c_void);
    pub fn _mtx_trylock_flags_int(
        m: *mut mtx,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn _mtx_trylock_flags_(
        c: *mut usize,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn mutex_init();
    pub fn __mtx_lock_sleep(
        c: *mut usize,
        v: usize,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn __mtx_unlock_sleep(
        c: *mut usize,
        v: usize,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn mtx_wait_unlocked(m: *mut mtx);
    pub fn _mtx_lock_spin_cookie(
        c: *mut usize,
        v: usize,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn __mtx_lock_flags(
        c: *mut usize,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn __mtx_unlock_flags(
        c: *mut usize,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn __mtx_lock_spin_flags(
        c: *mut usize,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn __mtx_trylock_spin_flags(
        c: *mut usize,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn __mtx_unlock_spin_flags(
        c: *mut usize,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn mtx_spin_wait_unlocked(m: *mut mtx);
    pub fn __mtx_assert(
        c: *const usize,
        what: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn thread_lock_flags_(
        arg1: *mut thread,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: ::core::ffi::c_int,
    );
    pub fn _thread_lock(
        td: *mut thread,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn mtx_pool_create(
        mtx_name: *const ::core::ffi::c_char,
        pool_size: ::core::ffi::c_int,
        opts: ::core::ffi::c_int,
    ) -> *mut mtx_pool;
    pub fn mtx_pool_destroy(poolp: *mut *mut mtx_pool);
    pub fn mtx_pool_find(pool: *mut mtx_pool, ptr: *mut ::core::ffi::c_void) -> *mut mtx;
    pub fn mtx_pool_alloc(pool: *mut mtx_pool) -> *mut mtx;
    pub static mut mtxpool_sleep: *mut mtx_pool;
    pub static mut Giant: mtx;
    pub static mut blocked_lock: mtx;
    pub fn knote(list: *mut knlist, hint: ::core::ffi::c_long, lockflags: ::core::ffi::c_int);
    pub fn knote_fork(list: *mut knlist, pid: ::core::ffi::c_int);
    pub fn knote_triv_copy(kn: *mut knote, p1: *mut proc_) -> ::core::ffi::c_int;
    pub fn knlist_alloc(lock: *mut mtx) -> *mut knlist;
    pub fn knlist_detach(knl: *mut knlist);
    pub fn knlist_add(knl: *mut knlist, kn: *mut knote, islocked: ::core::ffi::c_int);
    pub fn knlist_remove(knl: *mut knlist, kn: *mut knote, islocked: ::core::ffi::c_int);
    pub fn knlist_empty(knl: *mut knlist) -> ::core::ffi::c_int;
    pub fn knlist_init(
        knl: *mut knlist,
        lock: *mut ::core::ffi::c_void,
        kl_lock: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        kl_unlock: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        kl_assert_lock: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: ::core::ffi::c_int),
        >,
    );
    pub fn knlist_init_mtx(knl: *mut knlist, lock: *mut mtx);
    pub fn knlist_destroy(knl: *mut knlist);
    pub fn knlist_cleardel(
        knl: *mut knlist,
        td: *mut thread,
        islocked: ::core::ffi::c_int,
        killkn: ::core::ffi::c_int,
    );
    pub fn knote_fdclose(p: *mut thread, fd: ::core::ffi::c_int);
    pub fn kqfd_register(
        fd: ::core::ffi::c_int,
        kev: *mut kevent,
        p: *mut thread,
        mflag: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn kqueue_add_filteropts(
        filt: ::core::ffi::c_int,
        filtops: *const filterops,
    ) -> ::core::ffi::c_int;
    pub fn kqueue_del_filteropts(filt: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn kqueue_drain_schedtask();
    pub fn cv_init(cvp: *mut cv, desc: *const ::core::ffi::c_char);
    pub fn cv_destroy(cvp: *mut cv);
    pub fn _cv_wait(cvp: *mut cv, lock: *mut lock_object);
    pub fn _cv_wait_unlock(cvp: *mut cv, lock: *mut lock_object);
    pub fn _cv_wait_sig(cvp: *mut cv, lock: *mut lock_object) -> ::core::ffi::c_int;
    pub fn _cv_timedwait_sbt(
        cvp: *mut cv,
        lock: *mut lock_object,
        sbt: sbintime_t,
        pr: sbintime_t,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn _cv_timedwait_sig_sbt(
        cvp: *mut cv,
        lock: *mut lock_object,
        sbt: sbintime_t,
        pr: sbintime_t,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn cv_signal(cvp: *mut cv);
    pub fn cv_broadcastpri(cvp: *mut cv, pri: ::core::ffi::c_int);
    pub fn osd_register(
        type_: u_int,
        destructor: osd_destructor_t,
        methods: *const osd_method_t,
    ) -> ::core::ffi::c_int;
    pub fn osd_deregister(type_: u_int, slot: u_int);
    pub fn osd_set(
        type_: u_int,
        osd: *mut osd,
        slot: u_int,
        value: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn osd_reserve(slot: u_int) -> *mut *mut ::core::ffi::c_void;
    pub fn osd_set_reserved(
        type_: u_int,
        osd: *mut osd,
        slot: u_int,
        rsv: *mut *mut ::core::ffi::c_void,
        value: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn osd_free_reserved(rsv: *mut *mut ::core::ffi::c_void);
    pub fn osd_get(type_: u_int, osd: *mut osd, slot: u_int) -> *mut ::core::ffi::c_void;
    pub fn osd_get_unlocked(type_: u_int, osd: *mut osd, slot: u_int) -> *mut ::core::ffi::c_void;
    pub fn osd_del(type_: u_int, osd: *mut osd, slot: u_int);
    pub fn osd_call(
        type_: u_int,
        method: u_int,
        obj: *mut ::core::ffi::c_void,
        data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn osd_exit(type_: u_int, osd: *mut osd);
    pub fn rtp_to_pri(arg1: *mut rtprio, arg2: *mut thread) -> ::core::ffi::c_int;
    pub fn pri_to_rtp(arg1: *mut thread, arg2: *mut rtprio);
    pub fn fgetown(sigiop: *mut *mut sigio) -> pid_t;
    pub fn fsetown(pgid: pid_t, sigiop: *mut *mut sigio) -> ::core::ffi::c_int;
    pub fn funsetown(sigiop: *mut *mut sigio);
    pub fn funsetownlst(sigiolst: *mut sigiolst);
    #[link_name = "__sigisempty__extern"]
    pub fn __sigisempty(set: *mut sigset_t) -> ::core::ffi::c_int;
    #[link_name = "__sigseteq__extern"]
    pub fn __sigseteq(set1: *mut sigset_t, set2: *mut sigset_t) -> ::core::ffi::c_int;
    pub static mut sigfastblock_fetch_always: bool_;
    pub static mut pt_attach_transparent: bool_;
    #[link_name = "sigsetmasked__extern"]
    pub fn sigsetmasked(set: *mut sigset_t, mask: *mut sigset_t) -> bool_;
    #[link_name = "ksiginfo_copy__extern"]
    pub fn ksiginfo_copy(src: *mut ksiginfo_t, dst: *mut ksiginfo_t);
    #[link_name = "ksiginfo_set_sigev__extern"]
    pub fn ksiginfo_set_sigev(dst: *mut ksiginfo_t, sigev: *mut sigevent);
    pub static mut sigio_lock: mtx;
    pub fn sigdeferstop_impl(mode: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn sigallowstop_impl(prev: ::core::ffi::c_int);
    #[link_name = "sigdeferstop__extern"]
    pub fn sigdeferstop(mode: ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[link_name = "sigallowstop__extern"]
    pub fn sigallowstop(prev: ::core::ffi::c_int);
    pub fn cursig(td: *mut thread) -> ::core::ffi::c_int;
    pub fn execsigs(p: *mut proc_);
    pub fn killproc(p: *mut proc_, why: *const ::core::ffi::c_char);
    pub fn ksiginfo_alloc(mwait: ::core::ffi::c_int) -> *mut ksiginfo_t;
    pub fn ksiginfo_free(ksi: *mut ksiginfo_t);
    pub fn pksignal(
        p: *mut proc_,
        sig: ::core::ffi::c_int,
        ksi: *mut ksiginfo_t,
    ) -> ::core::ffi::c_int;
    pub fn pgsigio(sigiop: *mut *mut sigio, sig: ::core::ffi::c_int, checkctty: ::core::ffi::c_int);
    pub fn pgsignal(
        pgrp: *mut pgrp,
        sig: ::core::ffi::c_int,
        checkctty: ::core::ffi::c_int,
        ksi: *mut ksiginfo_t,
    );
    pub fn postsig(sig: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn kern_psignal(p: *mut proc_, sig: ::core::ffi::c_int);
    pub fn ptracestop(
        td: *mut thread,
        sig: ::core::ffi::c_int,
        si: *mut ksiginfo_t,
    ) -> ::core::ffi::c_int;
    pub fn sendsig(catcher: sig_t, ksi: *mut ksiginfo_t, retmask: *mut sigset_t);
    pub fn sigacts_alloc() -> *mut sigacts;
    pub fn sigacts_copy(dest: *mut sigacts, src: *mut sigacts);
    pub fn sigacts_free(ps: *mut sigacts);
    pub fn sigacts_hold(ps: *mut sigacts) -> *mut sigacts;
    pub fn sigacts_shared(ps: *mut sigacts) -> ::core::ffi::c_int;
    pub fn sig_ast_checksusp(td: *mut thread) -> ::core::ffi::c_int;
    pub fn sig_ast_needsigchk(td: *mut thread) -> ::core::ffi::c_int;
    pub fn sig_drop_caught(p: *mut proc_);
    pub fn sigexit(td: *mut thread, sig: ::core::ffi::c_int) -> !;
    pub fn sigev_findtd(
        p: *mut proc_,
        sigev: *mut sigevent,
        arg1: *mut *mut thread,
    ) -> ::core::ffi::c_int;
    pub fn sigfastblock_clear(td: *mut thread);
    pub fn sigfastblock_fetch(td: *mut thread);
    pub fn sig_intr() -> ::core::ffi::c_int;
    pub fn sig_do_core(arg1: ::core::ffi::c_int) -> bool_;
    pub fn siginit(p: *mut proc_);
    pub fn signotify(td: *mut thread);
    pub fn sigqueue_delete(queue: *mut sigqueue, sig: ::core::ffi::c_int);
    pub fn sigqueue_delete_proc(p: *mut proc_, sig: ::core::ffi::c_int);
    pub fn sigqueue_flush(queue: *mut sigqueue);
    pub fn sigqueue_init(queue: *mut sigqueue, p: *mut proc_);
    pub fn sigqueue_take(ksi: *mut ksiginfo_t);
    pub fn tdksignal(td: *mut thread, sig: ::core::ffi::c_int, ksi: *mut ksiginfo_t);
    pub fn tdsendsignal(
        p: *mut proc_,
        td: *mut thread,
        sig: ::core::ffi::c_int,
        ksi: *mut ksiginfo_t,
    ) -> ::core::ffi::c_int;
    pub fn tdsigcleanup(td: *mut thread);
    pub fn tdsignal(td: *mut thread, sig: ::core::ffi::c_int);
    pub fn trapsignal(td: *mut thread, ksi: *mut ksiginfo_t);
    pub fn user_setcred(
        td: *mut thread,
        flags: u_int,
        uwcred: *const ::core::ffi::c_void,
        size: usize,
        is_32bit: bool_,
    ) -> ::core::ffi::c_int;
    #[link_name = "credbatch_prep__extern"]
    pub fn credbatch_prep(crb: *mut credbatch);
    pub fn credbatch_add(crb: *mut credbatch, td: *mut thread);
    #[link_name = "credbatch_process__extern"]
    pub fn credbatch_process(crb: *mut credbatch);
    pub fn credbatch_final(crb: *mut credbatch);
    pub fn change_egid(newcred: *mut ucred, egid: gid_t);
    pub fn change_euid(newcred: *mut ucred, euip: *mut uidinfo);
    pub fn change_rgid(newcred: *mut ucred, rgid: gid_t);
    pub fn change_ruid(newcred: *mut ucred, ruip: *mut uidinfo);
    pub fn change_svgid(newcred: *mut ucred, svgid: gid_t);
    pub fn change_svuid(newcred: *mut ucred, svuid: uid_t);
    pub fn crcopy(dest: *mut ucred, src: *mut ucred);
    pub fn crcopysafe(p: *mut proc_, cr: *mut ucred) -> *mut ucred;
    pub fn crdup(cr: *mut ucred) -> *mut ucred;
    pub fn crextend(cr: *mut ucred, n: ::core::ffi::c_int);
    pub fn proc_set_cred(p: *mut proc_, newcred: *mut ucred);
    pub fn proc_set_cred_enforce_proc_lim(p: *mut proc_, newcred: *mut ucred) -> bool_;
    pub fn proc_unset_cred(p: *mut proc_, decrement_proc_count: bool_);
    pub fn crfree(cr: *mut ucred);
    pub fn crcowsync() -> *mut ucred;
    pub fn crget() -> *mut ucred;
    pub fn crhold(cr: *mut ucred) -> *mut ucred;
    pub fn crcowget(cr: *mut ucred) -> *mut ucred;
    pub fn crcowfree(td: *mut thread);
    pub fn cru2x(cr: *mut ucred, xcr: *mut xucred);
    pub fn cru2xt(td: *mut thread, xcr: *mut xucred);
    pub fn crsetgroups(cr: *mut ucred, ngrp: ::core::ffi::c_int, groups: *const gid_t);
    pub fn crsetgroups_and_egid(
        cr: *mut ucred,
        ngrp: ::core::ffi::c_int,
        groups: *const gid_t,
        default_egid: gid_t,
    );
    pub fn cr_xids_subset(active_cred: *mut ucred, obj_cred: *mut ucred) -> bool_;
    #[link_name = "group_is_primary__extern"]
    pub fn group_is_primary(gid: gid_t, cred: *const ucred) -> bool_;
    pub fn group_is_supplementary(gid: gid_t, cred: *const ucred) -> bool_;
    pub fn groupmember(gid: gid_t, cred: *const ucred) -> bool_;
    pub fn realgroupmember(gid: gid_t, cred: *const ucred) -> bool_;
    pub fn thread_lock_block(arg1: *mut thread) -> *mut mtx;
    pub fn thread_lock_block_wait(arg1: *mut thread);
    pub fn thread_lock_set(arg1: *mut thread, arg2: *mut mtx);
    pub fn thread_lock_unblock(arg1: *mut thread, arg2: *mut mtx);
    pub static mut pid_max: pid_t;
    pub static mut pidhashtbl: *mut pidhashhead;
    pub static mut pidhashtbl_lock: *mut sx;
    pub static mut pidhash: u_long;
    pub static mut pidhashlock: u_long;
    pub static mut pgrphashtbl: *mut pgrphashhead;
    pub static mut pgrphash: u_long;
    pub static mut allproc_lock: sx;
    pub static mut allproc_gen: ::core::ffi::c_int;
    pub static mut proctree_lock: sx;
    pub static mut ppeers_lock: mtx;
    pub static mut procid_lock: mtx;
    pub static mut proc0: proc_;
    pub static mut thread0_st: thread0_storage;
    pub static mut vmspace0: vmspace;
    pub static mut hogticks: ::core::ffi::c_int;
    pub static mut lastpid: ::core::ffi::c_int;
    pub static mut nprocs: ::core::ffi::c_int;
    pub static mut maxproc: ::core::ffi::c_int;
    pub static mut maxprocperuid: ::core::ffi::c_int;
    pub static mut ps_arg_cache_limit: u_long;
    pub static mut allproc: proclist;
    pub static mut initproc: *mut proc_;
    pub static mut pageproc: *mut proc_;
    pub static mut proc_zone: *mut uma_zone;
    pub static mut pgrp_zone: *mut uma_zone;
    pub fn pfind(arg1: pid_t) -> *mut proc_;
    pub fn pfind_any(arg1: pid_t) -> *mut proc_;
    pub fn pfind_any_locked(pid: pid_t) -> *mut proc_;
    pub fn pgfind(arg1: pid_t) -> *mut pgrp;
    pub fn pidhash_slockall();
    pub fn pidhash_sunlockall();
    pub fn pget(pid: pid_t, flags: ::core::ffi::c_int, pp: *mut *mut proc_) -> ::core::ffi::c_int;
    pub fn ast(framep: *mut trapframe);
    pub fn ast_kclear(td: *mut thread);
    pub fn ast_register(
        ast: ::core::ffi::c_int,
        ast_flags: ::core::ffi::c_int,
        tdp: ::core::ffi::c_int,
        f: ::core::option::Option<unsafe extern "C" fn(td: *mut thread, asts: ::core::ffi::c_int)>,
    );
    pub fn ast_deregister(tda: ::core::ffi::c_int);
    pub fn ast_sched_locked(td: *mut thread, tda: ::core::ffi::c_int);
    pub fn ast_sched_mask(td: *mut thread, ast: ::core::ffi::c_int);
    pub fn ast_sched(td: *mut thread, tda: ::core::ffi::c_int);
    pub fn ast_unsched_locked(td: *mut thread, tda: ::core::ffi::c_int);
    pub fn choosethread() -> *mut thread;
    pub fn cr_bsd_visible(u1: *mut ucred, u2: *mut ucred) -> ::core::ffi::c_int;
    pub fn cr_cansee(u1: *mut ucred, u2: *mut ucred) -> ::core::ffi::c_int;
    pub fn cr_canseesocket(cred: *mut ucred, so: *mut socket) -> ::core::ffi::c_int;
    pub fn cr_cansignal(
        cred: *mut ucred,
        proc_: *mut proc_,
        signum: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn enterpgrp(
        p: *mut proc_,
        pgid: pid_t,
        pgrp: *mut pgrp,
        sess: *mut session,
    ) -> ::core::ffi::c_int;
    pub fn enterthispgrp(p: *mut proc_, pgrp: *mut pgrp) -> ::core::ffi::c_int;
    pub fn fork1(arg1: *mut thread, arg2: *mut fork_req) -> ::core::ffi::c_int;
    pub fn fork_exit(
        arg1: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *mut trapframe),
        >,
        arg2: *mut ::core::ffi::c_void,
        arg3: *mut trapframe,
    );
    pub fn fork_return(arg1: *mut thread, arg2: *mut trapframe);
    pub fn inferior(p: *mut proc_) -> ::core::ffi::c_int;
    pub fn itimer_proc_continue(p: *mut proc_);
    pub fn kqtimer_proc_continue(p: *mut proc_);
    pub fn kern_proc_vmmap_resident(
        map: *mut vm_map,
        entry: *mut vm_map_entry,
        resident_count: *mut ::core::ffi::c_int,
        super_: *mut bool_,
    );
    pub fn kern_yield(arg1: ::core::ffi::c_int);
    pub fn killjobc();
    pub fn leavepgrp(p: *mut proc_) -> ::core::ffi::c_int;
    pub fn maybe_preempt(td: *mut thread) -> ::core::ffi::c_int;
    pub fn maybe_yield();
    pub fn mi_switch(flags: ::core::ffi::c_int);
    pub fn p_candebug(td: *mut thread, p: *mut proc_) -> ::core::ffi::c_int;
    pub fn p_cansee(td: *mut thread, p: *mut proc_) -> ::core::ffi::c_int;
    pub fn p_cansched(td: *mut thread, p: *mut proc_) -> ::core::ffi::c_int;
    pub fn p_cansignal(
        td: *mut thread,
        p: *mut proc_,
        signum: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn p_canwait(td: *mut thread, p: *mut proc_) -> ::core::ffi::c_int;
    pub fn pargs_alloc(len: ::core::ffi::c_int) -> *mut pargs;
    pub fn pargs_drop(pa: *mut pargs);
    pub fn pargs_hold(pa: *mut pargs);
    pub fn pgrp_calc_jobc(pgrp: *mut pgrp) -> ::core::ffi::c_int;
    pub fn proc_add_orphan(child: *mut proc_, parent: *mut proc_);
    pub fn proc_get_binpath(
        p: *mut proc_,
        binname: *mut ::core::ffi::c_char,
        fullpath: *mut *mut ::core::ffi::c_char,
        freepath: *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn proc_getargv(td: *mut thread, p: *mut proc_, sb: *mut sbuf) -> ::core::ffi::c_int;
    pub fn proc_getauxv(td: *mut thread, p: *mut proc_, sb: *mut sbuf) -> ::core::ffi::c_int;
    pub fn proc_getenvv(td: *mut thread, p: *mut proc_, sb: *mut sbuf) -> ::core::ffi::c_int;
    pub fn procinit();
    pub fn proc_iterate(
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut proc_,
                arg2: *mut ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
        cbarg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn proc_linkup0(p: *mut proc_, td: *mut thread);
    pub fn proc_linkup(p: *mut proc_, td: *mut thread);
    pub fn proc_realparent(child: *mut proc_) -> *mut proc_;
    pub fn proc_reap(
        td: *mut thread,
        p: *mut proc_,
        status: *mut ::core::ffi::c_int,
        options: ::core::ffi::c_int,
    );
    pub fn proc_reparent(child: *mut proc_, newparent: *mut proc_, set_oppid: bool_);
    pub fn proc_set_p2_wexit(p: *mut proc_);
    pub fn proc_set_traced(p: *mut proc_, stop: bool_);
    pub fn proc_wkilled(p: *mut proc_);
    pub fn pstats_alloc() -> *mut pstats;
    pub fn pstats_fork(src: *mut pstats, dst: *mut pstats);
    pub fn pstats_free(ps: *mut pstats);
    pub fn proc_clear_orphan(p: *mut proc_);
    pub fn reaper_abandon_children(p: *mut proc_, exiting: bool_);
    pub fn securelevel_ge(cr: *mut ucred, level: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn securelevel_gt(cr: *mut ucred, level: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn sess_hold(arg1: *mut session);
    pub fn sess_release(arg1: *mut session);
    pub fn setrunnable(arg1: *mut thread, arg2: ::core::ffi::c_int);
    pub fn setsugid(p: *mut proc_);
    pub fn should_yield() -> bool_;
    pub fn sigonstack(sp: usize) -> ::core::ffi::c_int;
    pub fn stopevent(arg1: *mut proc_, arg2: u_int, arg3: u_int);
    pub fn tdfind(arg1: lwpid_t, arg2: pid_t) -> *mut thread;
    pub fn threadinit();
    pub fn tidhash_add(arg1: *mut thread);
    pub fn tidhash_remove(arg1: *mut thread);
    pub fn cpu_idle(arg1: ::core::ffi::c_int);
    pub fn cpu_idle_wakeup(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub static mut cpu_idle_hook: ::core::option::Option<unsafe extern "C" fn(arg1: sbintime_t)>;
    pub fn cpu_switch(arg1: *mut thread, arg2: *mut thread, arg3: *mut mtx);
    pub fn cpu_sync_core();
    pub fn cpu_throw(arg1: *mut thread, arg2: *mut thread) -> !;
    pub fn cpu_update_pcb(arg1: *mut thread);
    pub fn curproc_sigkilled() -> bool_;
    pub fn userret(arg1: *mut thread, arg2: *mut trapframe);
    pub fn cpu_exit(arg1: *mut thread);
    pub fn exit1(arg1: *mut thread, arg2: ::core::ffi::c_int, arg3: ::core::ffi::c_int) -> !;
    pub fn cpu_copy_thread(td: *mut thread, td0: *mut thread);
    pub fn cpu_exec_vmspace_reuse(p: *mut proc_, map: *mut vm_map) -> bool_;
    pub fn cpu_fetch_syscall_args(td: *mut thread) -> ::core::ffi::c_int;
    pub fn cpu_fork(
        arg1: *mut thread,
        arg2: *mut proc_,
        arg3: *mut thread,
        arg4: ::core::ffi::c_int,
    );
    pub fn cpu_fork_kthread_handler(
        arg1: *mut thread,
        arg2: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg3: *mut ::core::ffi::c_void,
    );
    pub fn cpu_procctl(
        td: *mut thread,
        idtype: ::core::ffi::c_int,
        id: id_t,
        com: ::core::ffi::c_int,
        data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn cpu_set_syscall_retval(arg1: *mut thread, arg2: ::core::ffi::c_int);
    pub fn cpu_set_upcall(
        arg1: *mut thread,
        arg2: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg3: *mut ::core::ffi::c_void,
        arg4: *mut stack_t,
    ) -> ::core::ffi::c_int;
    pub fn cpu_set_user_tls(
        arg1: *mut thread,
        tls_base: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn cpu_thread_alloc(arg1: *mut thread);
    pub fn cpu_thread_clean(arg1: *mut thread);
    pub fn cpu_thread_exit(arg1: *mut thread);
    pub fn cpu_thread_free(arg1: *mut thread);
    pub fn thread_alloc(pages: ::core::ffi::c_int) -> *mut thread;
    pub fn thread_check_susp(td: *mut thread, sleep: bool_) -> ::core::ffi::c_int;
    pub fn thread_cow_get_proc(newtd: *mut thread, p: *mut proc_);
    pub fn thread_cow_get(newtd: *mut thread, td: *mut thread);
    pub fn thread_cow_free(td: *mut thread);
    pub fn thread_cow_update(td: *mut thread);
    pub fn thread_cow_synced(td: *mut thread);
    pub fn thread_create(
        td: *mut thread,
        rtp: *mut rtprio,
        initialize_thread: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut thread,
                arg2: *mut ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
        thunk: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn thread_exit() -> !;
    pub fn thread_free(td: *mut thread);
    pub fn thread_link(td: *mut thread, p: *mut proc_);
    pub fn thread_reap_barrier();
    pub fn thread_recycle(arg1: *mut thread, pages: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn thread_single(p: *mut proc_, how: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn thread_single_end(p: *mut proc_, how: ::core::ffi::c_int);
    pub fn thread_stash(td: *mut thread);
    pub fn thread_stopped(p: *mut proc_);
    pub fn childproc_stopped(child: *mut proc_, reason: ::core::ffi::c_int);
    pub fn childproc_continued(child: *mut proc_);
    pub fn childproc_exited(child: *mut proc_);
    pub fn thread_run_flash(td: *mut thread);
    pub fn thread_suspend_check(how: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn thread_suspend_check_needed() -> bool_;
    pub fn thread_suspend_switch(arg1: *mut thread, p: *mut proc_);
    pub fn thread_suspend_one(td: *mut thread);
    pub fn thread_unlink(td: *mut thread);
    pub fn thread_unsuspend(p: *mut proc_);
    pub fn thread_wait(p: *mut proc_);
    pub fn stop_all_proc_block() -> bool_;
    pub fn stop_all_proc_unblock();
    pub fn stop_all_proc();
    pub fn resume_all_proc();
    #[link_name = "curthread_pflags_set__extern"]
    pub fn curthread_pflags_set(flags: ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[link_name = "curthread_pflags_restore__extern"]
    pub fn curthread_pflags_restore(save: ::core::ffi::c_int);
    #[link_name = "curthread_pflags2_set__extern"]
    pub fn curthread_pflags2_set(flags: ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[link_name = "curthread_pflags2_restore__extern"]
    pub fn curthread_pflags2_restore(save: ::core::ffi::c_int);
    #[link_name = "td_get_sched__extern"]
    pub fn td_get_sched(td: *mut thread) -> *mut td_sched;
    pub fn proc_id_set(type_: ::core::ffi::c_int, id: pid_t);
    pub fn proc_id_set_cond(type_: ::core::ffi::c_int, id: pid_t);
    pub fn proc_id_clear(type_: ::core::ffi::c_int, id: pid_t);
    pub static mut _eventhandler_list_process_ctor: *mut eventhandler_list;
    pub static mut _eventhandler_list_process_dtor: *mut eventhandler_list;
    pub static mut _eventhandler_list_process_init: *mut eventhandler_list;
    pub static mut _eventhandler_list_process_fini: *mut eventhandler_list;
    pub static mut _eventhandler_list_process_exit: *mut eventhandler_list;
    pub static mut _eventhandler_list_process_fork: *mut eventhandler_list;
    pub static mut _eventhandler_list_process_exec: *mut eventhandler_list;
    pub static mut _eventhandler_list_thread_ctor: *mut eventhandler_list;
    pub static mut _eventhandler_list_thread_dtor: *mut eventhandler_list;
    pub static mut _eventhandler_list_thread_init: *mut eventhandler_list;
    #[link_name = "_refcount_update_saturated__extern"]
    pub fn _refcount_update_saturated(count: *mut u_int);
    #[link_name = "refcount_init__extern"]
    pub fn refcount_init(count: *mut u_int, value: u_int);
    #[link_name = "refcount_load__extern"]
    pub fn refcount_load(count: *const u_int) -> u_int;
    #[link_name = "refcount_acquire__extern"]
    pub fn refcount_acquire(count: *mut u_int) -> u_int;
    #[link_name = "refcount_acquiren__extern"]
    pub fn refcount_acquiren(count: *mut u_int, n: u_int) -> u_int;
    #[link_name = "refcount_acquire_checked__extern"]
    pub fn refcount_acquire_checked(count: *mut u_int) -> bool_;
    #[link_name = "refcount_acquire_if_gt__extern"]
    pub fn refcount_acquire_if_gt(count: *mut u_int, n: u_int) -> bool_;
    #[link_name = "refcount_acquire_if_not_zero__extern"]
    pub fn refcount_acquire_if_not_zero(count: *mut u_int) -> bool_;
    #[link_name = "refcount_releasen__extern"]
    pub fn refcount_releasen(count: *mut u_int, n: u_int) -> bool_;
    #[link_name = "refcount_release__extern"]
    pub fn refcount_release(count: *mut u_int) -> bool_;
    #[link_name = "_refcount_release_if_gt__extern"]
    pub fn _refcount_release_if_gt(count: *mut u_int, n: u_int) -> bool_;
    #[link_name = "_refcount_release_if_eq__extern"]
    pub fn _refcount_release_if_eq(count: *mut u_int, n: u_int) -> bool_;
    #[link_name = "refcount_release_if_gt__extern"]
    pub fn refcount_release_if_gt(count: *mut u_int, n: u_int) -> bool_;
    #[link_name = "refcount_release_if_last__extern"]
    pub fn refcount_release_if_last(count: *mut u_int) -> bool_;
    #[link_name = "refcount_release_if_not_last__extern"]
    pub fn refcount_release_if_not_last(count: *mut u_int) -> bool_;
    pub fn rman_activate_resource(r: *mut resource) -> ::core::ffi::c_int;
    pub fn rman_adjust_resource(
        r: *mut resource,
        start: rman_res_t,
        end: rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn rman_first_free_region(
        rm: *mut rman,
        start: *mut rman_res_t,
        end: *mut rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn rman_get_bushandle(arg1: *const resource) -> bus_space_handle_t;
    pub fn rman_get_bustag(arg1: *const resource) -> bus_space_tag_t;
    pub fn rman_get_end(arg1: *const resource) -> rman_res_t;
    pub fn rman_get_device(arg1: *const resource) -> device_t;
    pub fn rman_get_flags(arg1: *const resource) -> u_int;
    pub fn rman_get_irq_cookie(arg1: *const resource) -> *mut ::core::ffi::c_void;
    pub fn rman_get_mapping(arg1: *const resource, arg2: *mut resource_map);
    pub fn rman_get_rid(arg1: *const resource) -> ::core::ffi::c_int;
    pub fn rman_get_size(arg1: *const resource) -> rman_res_t;
    pub fn rman_get_start(arg1: *const resource) -> rman_res_t;
    pub fn rman_get_type(arg1: *const resource) -> ::core::ffi::c_int;
    pub fn rman_get_virtual(arg1: *const resource) -> *mut ::core::ffi::c_void;
    pub fn rman_deactivate_resource(r: *mut resource) -> ::core::ffi::c_int;
    pub fn rman_fini(rm: *mut rman) -> ::core::ffi::c_int;
    pub fn rman_init(rm: *mut rman) -> ::core::ffi::c_int;
    pub fn rman_init_from_resource(rm: *mut rman, r: *mut resource) -> ::core::ffi::c_int;
    pub fn rman_last_free_region(
        rm: *mut rman,
        start: *mut rman_res_t,
        end: *mut rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn rman_make_alignment_flags(size: u32) -> u32;
    pub fn rman_manage_region(
        rm: *mut rman,
        start: rman_res_t,
        end: rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn rman_is_region_manager(r: *const resource, rm: *const rman) -> ::core::ffi::c_int;
    pub fn rman_release_resource(r: *mut resource) -> ::core::ffi::c_int;
    pub fn rman_reserve_resource(
        rm: *mut rman,
        start: rman_res_t,
        end: rman_res_t,
        count: rman_res_t,
        flags: u_int,
        dev: device_t,
    ) -> *mut resource;
    pub fn rman_set_bushandle(_r: *mut resource, _h: bus_space_handle_t);
    pub fn rman_set_bustag(_r: *mut resource, _t: bus_space_tag_t);
    pub fn rman_set_device(_r: *mut resource, _dev: device_t);
    pub fn rman_set_irq_cookie(_r: *mut resource, _c: *mut ::core::ffi::c_void);
    pub fn rman_set_mapping(arg1: *mut resource, arg2: *mut resource_map);
    pub fn rman_set_rid(_r: *mut resource, _rid: ::core::ffi::c_int);
    pub fn rman_set_type(_r: *mut resource, _type: ::core::ffi::c_int);
    pub fn rman_set_virtual(_r: *mut resource, _v: *mut ::core::ffi::c_void);
    pub static mut rman_head: rman_head;
    pub fn topo_init_node(node: *mut topo_node);
    pub fn topo_init_root(root: *mut topo_node);
    pub fn topo_add_node_by_hwid(
        parent: *mut topo_node,
        hwid: ::core::ffi::c_int,
        type_: topo_node_type,
        subtype: usize,
    ) -> *mut topo_node;
    pub fn topo_find_node_by_hwid(
        parent: *mut topo_node,
        hwid: ::core::ffi::c_int,
        type_: topo_node_type,
        subtype: usize,
    ) -> *mut topo_node;
    pub fn topo_promote_child(child: *mut topo_node);
    pub fn topo_next_node(top: *mut topo_node, node: *mut topo_node) -> *mut topo_node;
    pub fn topo_next_nonchild_node(top: *mut topo_node, node: *mut topo_node) -> *mut topo_node;
    pub fn topo_set_pu_id(node: *mut topo_node, id: cpuid_t);
    pub fn topo_analyze(
        topo_root: *mut topo_node,
        all: ::core::ffi::c_int,
        results: *mut topo_analysis,
    ) -> ::core::ffi::c_int;
    pub fn smp_topo() -> *mut cpu_group;
    pub fn smp_topo_alloc(count: u_int) -> *mut cpu_group;
    pub fn smp_topo_none() -> *mut cpu_group;
    pub fn smp_topo_1level(
        l1share: ::core::ffi::c_int,
        l1count: ::core::ffi::c_int,
        l1flags: ::core::ffi::c_int,
    ) -> *mut cpu_group;
    pub fn smp_topo_2level(
        l2share: ::core::ffi::c_int,
        l2count: ::core::ffi::c_int,
        l1share: ::core::ffi::c_int,
        l1count: ::core::ffi::c_int,
        l1flags: ::core::ffi::c_int,
    ) -> *mut cpu_group;
    pub fn smp_topo_find(top: *mut cpu_group, cpu: ::core::ffi::c_int) -> *mut cpu_group;
    pub static mut cpustop_restartfunc: ::core::option::Option<unsafe extern "C" fn()>;
    pub static mut resuming_cpus: cpuset_t;
    pub static mut started_cpus: cpuset_t;
    pub static mut stopped_cpus: cpuset_t;
    pub static mut suspended_cpus: cpuset_t;
    pub static mut toresume_cpus: cpuset_t;
    pub static mut hlt_cpus_mask: cpuset_t;
    pub static mut logical_cpus_mask: cpuset_t;
    pub static mut mp_maxid: u_int;
    pub static mut mp_maxcpus: ::core::ffi::c_int;
    pub static mut mp_ncores: ::core::ffi::c_int;
    pub static mut mp_ncpus: ::core::ffi::c_int;
    pub static mut smp_cpus: ::core::ffi::c_int;
    pub static mut smp_started: ::core::ffi::c_int;
    pub static mut smp_threads_per_core: ::core::ffi::c_int;
    pub static mut all_cpus: cpuset_t;
    pub static mut cpuset_domain: [cpuset_t; 8usize];
    pub static mut stoppcbs: *mut pcb;
    #[link_name = "cpu_first__extern"]
    pub fn cpu_first() -> ::core::ffi::c_int;
    #[link_name = "cpu_next__extern"]
    pub fn cpu_next(i: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn cpu_topo() -> *mut cpu_group;
    pub fn cpu_mp_announce();
    pub fn cpu_mp_probe() -> ::core::ffi::c_int;
    pub fn cpu_mp_setmaxid();
    pub fn cpu_mp_start();
    pub fn forward_signal(arg1: *mut thread);
    pub fn restart_cpus(arg1: cpuset_t) -> ::core::ffi::c_int;
    pub fn stop_cpus(arg1: cpuset_t) -> ::core::ffi::c_int;
    pub fn stop_cpus_hard(arg1: cpuset_t) -> ::core::ffi::c_int;
    pub fn smp_rendezvous_action();
    pub static mut smp_ipi_mtx: mtx;
    pub fn quiesce_all_cpus(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn quiesce_cpus(
        arg1: cpuset_t,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn quiesce_all_critical();
    pub fn cpus_fence_seq_cst();
    pub fn smp_no_rendezvous_barrier(arg1: *mut ::core::ffi::c_void);
    pub fn smp_rendezvous(
        arg1: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg2: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg3: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg: *mut ::core::ffi::c_void,
    );
    pub fn smp_rendezvous_cpus(
        arg1: cpuset_t,
        arg2: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg3: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg4: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg: *mut ::core::ffi::c_void,
    );
    pub fn smp_rendezvous_cpus_retry(
        arg1: cpuset_t,
        arg2: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg3: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg4: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg5: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: ::core::ffi::c_int),
        >,
        arg6: *mut smp_rendezvous_cpus_retry_arg,
    );
    pub fn smp_rendezvous_cpus_done(arg1: *mut smp_rendezvous_cpus_retry_arg);
    pub fn taskqueue_create(
        name: *const ::core::ffi::c_char,
        mflags: ::core::ffi::c_int,
        enqueue: taskqueue_enqueue_fn,
        context: *mut ::core::ffi::c_void,
    ) -> *mut taskqueue;
    pub fn taskqueue_start_threads(
        tqp: *mut *mut taskqueue,
        count: ::core::ffi::c_int,
        pri: ::core::ffi::c_int,
        name: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn taskqueue_start_threads_in_proc(
        tqp: *mut *mut taskqueue,
        count: ::core::ffi::c_int,
        pri: ::core::ffi::c_int,
        p: *mut proc_,
        name: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn taskqueue_start_threads_cpuset(
        tqp: *mut *mut taskqueue,
        count: ::core::ffi::c_int,
        pri: ::core::ffi::c_int,
        mask: *mut cpuset_t,
        name: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn taskqueue_enqueue(queue: *mut taskqueue, task: *mut task) -> ::core::ffi::c_int;
    pub fn taskqueue_enqueue_flags(
        queue: *mut taskqueue,
        task: *mut task,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn taskqueue_enqueue_timeout(
        queue: *mut taskqueue,
        timeout_task: *mut timeout_task,
        ticks: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn taskqueue_enqueue_timeout_sbt(
        queue: *mut taskqueue,
        timeout_task: *mut timeout_task,
        sbt: sbintime_t,
        pr: sbintime_t,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn taskqueue_poll_is_busy(queue: *mut taskqueue, task: *mut task) -> ::core::ffi::c_int;
    pub fn taskqueue_cancel(
        queue: *mut taskqueue,
        task: *mut task,
        pendp: *mut u_int,
    ) -> ::core::ffi::c_int;
    pub fn taskqueue_cancel_timeout(
        queue: *mut taskqueue,
        timeout_task: *mut timeout_task,
        pendp: *mut u_int,
    ) -> ::core::ffi::c_int;
    pub fn taskqueue_drain(queue: *mut taskqueue, task: *mut task);
    pub fn taskqueue_drain_timeout(queue: *mut taskqueue, timeout_task: *mut timeout_task);
    pub fn taskqueue_drain_all(queue: *mut taskqueue);
    pub fn taskqueue_quiesce(queue: *mut taskqueue);
    pub fn taskqueue_free(queue: *mut taskqueue);
    pub fn taskqueue_run(queue: *mut taskqueue);
    pub fn taskqueue_block(queue: *mut taskqueue);
    pub fn taskqueue_unblock(queue: *mut taskqueue);
    pub fn taskqueue_member(queue: *mut taskqueue, td: *mut thread) -> ::core::ffi::c_int;
    pub fn taskqueue_set_callback(
        queue: *mut taskqueue,
        cb_type: taskqueue_callback_type,
        callback: taskqueue_callback_fn,
        context: *mut ::core::ffi::c_void,
    );
    pub fn taskqueue_thread_loop(arg: *mut ::core::ffi::c_void);
    pub fn taskqueue_thread_enqueue(context: *mut ::core::ffi::c_void);
    pub fn _timeout_task_init(
        queue: *mut taskqueue,
        timeout_task: *mut timeout_task,
        priority: ::core::ffi::c_int,
        func: task_fn_t,
        context: *mut ::core::ffi::c_void,
    );
    pub static mut taskqueue_swi_giant: *mut taskqueue;
    pub static mut taskqueue_swi: *mut taskqueue;
    pub static mut taskqueue_thread: *mut taskqueue;
    pub static mut taskqueue_fast: *mut taskqueue;
    pub fn taskqueue_create_fast(
        name: *const ::core::ffi::c_char,
        mflags: ::core::ffi::c_int,
        enqueue: taskqueue_enqueue_fn,
        context: *mut ::core::ffi::c_void,
    ) -> *mut taskqueue;
    pub static mut taskqueue_bus: *mut taskqueue;
    pub fn busdma_lock_mutex(arg: *mut ::core::ffi::c_void, op: bus_dma_lock_op_t);
    pub fn _busdma_dflt_lock(arg: *mut ::core::ffi::c_void, op: bus_dma_lock_op_t);
    pub fn bus_dma_tag_create(
        parent: bus_dma_tag_t,
        alignment: bus_size_t,
        boundary: bus_addr_t,
        lowaddr: bus_addr_t,
        highaddr: bus_addr_t,
        filtfunc: bus_dma_filter_t,
        filtfuncarg: *mut ::core::ffi::c_void,
        maxsize: bus_size_t,
        nsegments: ::core::ffi::c_int,
        maxsegsz: bus_size_t,
        flags: ::core::ffi::c_int,
        lockfunc: bus_dma_lock_t,
        lockfuncarg: *mut ::core::ffi::c_void,
        dmat: *mut bus_dma_tag_t,
    ) -> ::core::ffi::c_int;
    pub fn bus_dma_template_init(t: *mut bus_dma_template_t, parent: bus_dma_tag_t);
    pub fn bus_dma_template_tag(
        t: *mut bus_dma_template_t,
        dmat: *mut bus_dma_tag_t,
    ) -> ::core::ffi::c_int;
    pub fn bus_dma_template_clone(t: *mut bus_dma_template_t, dmat: bus_dma_tag_t);
    pub fn bus_dma_template_fill(
        t: *mut bus_dma_template_t,
        kv: *mut bus_dma_param_t,
        count: u_int,
    );
    pub fn bus_dma_tag_set_domain(
        dmat: bus_dma_tag_t,
        domain: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_dma_tag_destroy(dmat: bus_dma_tag_t) -> ::core::ffi::c_int;
    pub fn bus_dmamap_load(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        buf: *mut ::core::ffi::c_void,
        buflen: bus_size_t,
        callback: bus_dmamap_callback_t,
        callback_arg: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_dmamap_load_mbuf(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        mbuf: *mut mbuf,
        callback: bus_dmamap_callback2_t,
        callback_arg: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_dmamap_load_mbuf_sg(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        mbuf: *mut mbuf,
        segs: *mut bus_dma_segment_t,
        nsegs: *mut ::core::ffi::c_int,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_dmamap_load_uio(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        ui: *mut uio,
        callback: bus_dmamap_callback2_t,
        callback_arg: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_dmamap_load_ccb(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        ccb: *mut ccb,
        callback: bus_dmamap_callback_t,
        callback_arg: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_dmamap_load_bio(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        bio: *mut bio,
        callback: bus_dmamap_callback_t,
        callback_arg: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_dmamap_load_crp(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        crp: *mut cryptop,
        callback: bus_dmamap_callback_t,
        callback_arg: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_dmamap_load_crp_buffer(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        cb: *mut crypto_buffer,
        callback: bus_dmamap_callback_t,
        callback_arg: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_dmamap_load_mem(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        mem: *mut memdesc,
        callback: bus_dmamap_callback_t,
        callback_arg: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_dmamap_load_ma_triv(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        ma: *mut *mut vm_page,
        tlen: bus_size_t,
        ma_offs: ::core::ffi::c_int,
        flags: ::core::ffi::c_int,
        segs: *mut bus_dma_segment_t,
        segp: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[link_name = "bus_dmamap_create__extern"]
    pub fn bus_dmamap_create(
        dmat: bus_dma_tag_t,
        flags: ::core::ffi::c_int,
        mapp: *mut bus_dmamap_t,
    ) -> ::core::ffi::c_int;
    #[link_name = "bus_dmamap_destroy__extern"]
    pub fn bus_dmamap_destroy(dmat: bus_dma_tag_t, map: bus_dmamap_t) -> ::core::ffi::c_int;
    #[link_name = "bus_dmamem_alloc__extern"]
    pub fn bus_dmamem_alloc(
        dmat: bus_dma_tag_t,
        vaddr: *mut *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
        mapp: *mut bus_dmamap_t,
    ) -> ::core::ffi::c_int;
    #[link_name = "bus_dmamem_free__extern"]
    pub fn bus_dmamem_free(dmat: bus_dma_tag_t, vaddr: *mut ::core::ffi::c_void, map: bus_dmamap_t);
    #[link_name = "bus_dmamap_sync__extern"]
    pub fn bus_dmamap_sync(dmat: bus_dma_tag_t, dmamap: bus_dmamap_t, op: bus_dmasync_op_t);
    #[link_name = "bus_dmamap_unload__extern"]
    pub fn bus_dmamap_unload(dmat: bus_dma_tag_t, dmamap: bus_dmamap_t);
    pub fn common_bus_dma_tag_create(
        parent: *mut bus_dma_tag_common,
        alignment: bus_size_t,
        boundary: bus_addr_t,
        lowaddr: bus_addr_t,
        highaddr: bus_addr_t,
        maxsize: bus_size_t,
        nsegments: ::core::ffi::c_int,
        maxsegsz: bus_size_t,
        flags: ::core::ffi::c_int,
        lockfunc: bus_dma_lock_t,
        lockfuncarg: *mut ::core::ffi::c_void,
        sz: usize,
        dmat: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub static mut bus_dma_bounce_impl: bus_dma_impl;
    #[link_name = "bus_dma_id_mapped__extern"]
    pub fn bus_dma_id_mapped(dmat: bus_dma_tag_t, buf: vm_paddr_t, buflen: bus_size_t) -> bool_;
    #[link_name = "_bus_dmamap_load_phys__extern"]
    pub fn _bus_dmamap_load_phys(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        buf: vm_paddr_t,
        buflen: bus_size_t,
        flags: ::core::ffi::c_int,
        segs: *mut bus_dma_segment_t,
        segp: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[link_name = "_bus_dmamap_load_ma__extern"]
    pub fn _bus_dmamap_load_ma(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        ma: *mut *mut vm_page,
        tlen: bus_size_t,
        ma_offs: ::core::ffi::c_int,
        flags: ::core::ffi::c_int,
        segs: *mut bus_dma_segment_t,
        segp: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[link_name = "_bus_dmamap_load_buffer__extern"]
    pub fn _bus_dmamap_load_buffer(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        buf: *mut ::core::ffi::c_void,
        buflen: bus_size_t,
        pmap: *mut pmap,
        flags: ::core::ffi::c_int,
        segs: *mut bus_dma_segment_t,
        segp: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[link_name = "_bus_dmamap_waitok__extern"]
    pub fn _bus_dmamap_waitok(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        mem: *mut memdesc,
        callback: bus_dmamap_callback_t,
        callback_arg: *mut ::core::ffi::c_void,
    );
    #[link_name = "_bus_dmamap_complete__extern"]
    pub fn _bus_dmamap_complete(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        segs: *mut bus_dma_segment_t,
        nsegs: ::core::ffi::c_int,
        error: ::core::ffi::c_int,
    ) -> *mut bus_dma_segment_t;
    pub static mut arm64_bus_method: arm64_bus;
    pub fn dbg_init();
    pub fn has_hyp() -> bool_;
    pub fn in_vhe() -> bool_;
    pub fn initarm(arg1: *mut arm64_bootparams);
    pub fn parse_boot_param(abp: *mut arm64_bootparams) -> vm_offset_t;
    pub fn parse_fdt_bootargs();
    pub fn memory_mapping_mode(pa: vm_paddr_t) -> ::core::ffi::c_int;
    pub static mut pagezero:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
    pub fn dbg_monitor_init();
    pub fn dbg_register_sync(arg1: *mut debug_monitor_state);
    pub fn vfp_init_secondary();
    pub fn vfp_enable();
    pub fn vfp_disable();
    pub fn vfp_discard(arg1: *mut thread);
    pub fn vfp_store(arg1: *mut vfpstate);
    pub fn vfp_restore(arg1: *mut vfpstate);
    pub fn vfp_new_thread(arg1: *mut thread, arg2: *mut thread, arg3: bool_);
    pub fn vfp_reset_state(arg1: *mut thread, arg2: *mut pcb);
    pub fn vfp_restore_state();
    pub fn vfp_save_state(arg1: *mut thread, arg2: *mut pcb);
    pub fn vfp_save_state_savectx(arg1: *mut pcb);
    pub fn vfp_save_state_switch(arg1: *mut thread);
    pub fn vfp_to_sve_sync(arg1: *mut thread);
    pub fn sve_to_vfp_sync(arg1: *mut thread);
    pub fn sve_max_buf_size() -> usize;
    pub fn sve_buf_size(arg1: *mut thread) -> usize;
    pub fn sve_restore_state(arg1: *mut thread) -> bool_;
    pub fn fpu_kern_alloc_ctx(arg1: u_int) -> *mut fpu_kern_ctx;
    pub fn fpu_kern_free_ctx(arg1: *mut fpu_kern_ctx);
    pub fn fpu_kern_enter(arg1: *mut thread, arg2: *mut fpu_kern_ctx, arg3: u_int);
    pub fn fpu_kern_leave(arg1: *mut thread, arg2: *mut fpu_kern_ctx) -> ::core::ffi::c_int;
    pub fn fpu_kern_thread(arg1: u_int) -> ::core::ffi::c_int;
    pub fn is_fpu_kern_thread(arg1: u_int) -> ::core::ffi::c_int;
    pub fn fpu_save_area_alloc() -> *mut vfpstate;
    pub fn fpu_save_area_free(fsa: *mut vfpstate);
    pub fn fpu_save_area_reset(fsa: *mut vfpstate);
    pub fn get_fpcontext32(td: *mut thread, mcp: *mut mcontext32_vfp_t);
    pub fn set_fpcontext32(td: *mut thread, mcp: *mut mcontext32_vfp_t);
    pub fn makectx(tf: *mut trapframe, pcb: *mut pcb);
    pub fn savectx(pcb: *mut pcb);
    pub fn ipi_all_but_self(ipi: u_int);
    pub fn ipi_cpu(cpu: ::core::ffi::c_int, ipi: u_int);
    pub fn ipi_selected(cpus: cpuset_t, ipi: u_int);
    #[doc = " @brief Unique descriptor for the OFW_BUS_GET_DEVINFO() method"]
    pub static mut ofw_bus_get_devinfo_desc: kobjop_desc;
    #[link_name = "OFW_BUS_GET_DEVINFO__extern"]
    pub fn OFW_BUS_GET_DEVINFO(bus: device_t, dev: device_t) -> *const ofw_bus_devinfo;
    #[doc = " @brief Unique descriptor for the OFW_BUS_GET_COMPAT() method"]
    pub static mut ofw_bus_get_compat_desc: kobjop_desc;
    #[link_name = "OFW_BUS_GET_COMPAT__extern"]
    pub fn OFW_BUS_GET_COMPAT(bus: device_t, dev: device_t) -> *const ::core::ffi::c_char;
    #[doc = " @brief Unique descriptor for the OFW_BUS_GET_MODEL() method"]
    pub static mut ofw_bus_get_model_desc: kobjop_desc;
    #[link_name = "OFW_BUS_GET_MODEL__extern"]
    pub fn OFW_BUS_GET_MODEL(bus: device_t, dev: device_t) -> *const ::core::ffi::c_char;
    #[doc = " @brief Unique descriptor for the OFW_BUS_GET_NAME() method"]
    pub static mut ofw_bus_get_name_desc: kobjop_desc;
    #[link_name = "OFW_BUS_GET_NAME__extern"]
    pub fn OFW_BUS_GET_NAME(bus: device_t, dev: device_t) -> *const ::core::ffi::c_char;
    #[doc = " @brief Unique descriptor for the OFW_BUS_GET_NODE() method"]
    pub static mut ofw_bus_get_node_desc: kobjop_desc;
    #[link_name = "OFW_BUS_GET_NODE__extern"]
    pub fn OFW_BUS_GET_NODE(bus: device_t, dev: device_t) -> phandle_t;
    #[doc = " @brief Unique descriptor for the OFW_BUS_GET_TYPE() method"]
    pub static mut ofw_bus_get_type_desc: kobjop_desc;
    #[link_name = "OFW_BUS_GET_TYPE__extern"]
    pub fn OFW_BUS_GET_TYPE(bus: device_t, dev: device_t) -> *const ::core::ffi::c_char;
    #[doc = " @brief Unique descriptor for the OFW_BUS_MAP_INTR() method"]
    pub static mut ofw_bus_map_intr_desc: kobjop_desc;
    #[link_name = "OFW_BUS_MAP_INTR__extern"]
    pub fn OFW_BUS_MAP_INTR(
        bus: device_t,
        dev: device_t,
        iparent: phandle_t,
        icells: ::core::ffi::c_int,
        interrupt: *mut pcell_t,
    ) -> ::core::ffi::c_int;
    #[link_name = "ofw_bus_get_compat__extern"]
    pub fn ofw_bus_get_compat(dev: device_t) -> *const ::core::ffi::c_char;
    #[link_name = "ofw_bus_get_model__extern"]
    pub fn ofw_bus_get_model(dev: device_t) -> *const ::core::ffi::c_char;
    #[link_name = "ofw_bus_get_name__extern"]
    pub fn ofw_bus_get_name(dev: device_t) -> *const ::core::ffi::c_char;
    #[link_name = "ofw_bus_get_node__extern"]
    pub fn ofw_bus_get_node(dev: device_t) -> phandle_t;
    #[link_name = "ofw_bus_get_type__extern"]
    pub fn ofw_bus_get_type(dev: device_t) -> *const ::core::ffi::c_char;
    #[link_name = "ofw_bus_map_intr__extern"]
    pub fn ofw_bus_map_intr(
        dev: device_t,
        iparent: phandle_t,
        icells: ::core::ffi::c_int,
        intr: *mut pcell_t,
    ) -> ::core::ffi::c_int;
    pub static mut simplebus_driver: kobj_class;
    pub fn simplebus_init(dev: device_t, node: phandle_t);
    pub fn simplebus_add_device(
        dev: device_t,
        node: phandle_t,
        order: u_int,
        name: *const ::core::ffi::c_char,
        unit: ::core::ffi::c_int,
        di: *mut simplebus_devinfo,
    ) -> device_t;
    pub fn simplebus_setup_dinfo(
        dev: device_t,
        node: phandle_t,
        di: *mut simplebus_devinfo,
    ) -> *mut simplebus_devinfo;
    pub fn simplebus_fill_ranges(node: phandle_t, sc: *mut simplebus_softc) -> ::core::ffi::c_int;
    pub fn simplebus_attach(dev: device_t) -> ::core::ffi::c_int;
    pub fn simplebus_attach_impl(dev: device_t) -> ::core::ffi::c_int;
    pub fn simplebus_detach(dev: device_t) -> ::core::ffi::c_int;
    pub fn ofw_bus_gen_setup_devinfo(
        arg1: *mut ofw_bus_devinfo,
        arg2: phandle_t,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_gen_destroy_devinfo(arg1: *mut ofw_bus_devinfo);
    pub fn ofw_bus_gen_get_compat(bus: device_t, dev: device_t) -> *const ::core::ffi::c_char;
    pub fn ofw_bus_gen_get_model(bus: device_t, dev: device_t) -> *const ::core::ffi::c_char;
    pub fn ofw_bus_gen_get_name(bus: device_t, dev: device_t) -> *const ::core::ffi::c_char;
    pub fn ofw_bus_gen_get_node(bus: device_t, dev: device_t) -> phandle_t;
    pub fn ofw_bus_gen_get_type(bus: device_t, dev: device_t) -> *const ::core::ffi::c_char;
    pub fn ofw_bus_gen_child_pnpinfo(
        _dev: device_t,
        _child: device_t,
        _sb: *mut sbuf,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_gen_get_device_path(
        _bus: device_t,
        _child: device_t,
        _locator: *const ::core::ffi::c_char,
        _sb: *mut sbuf,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_setup_iinfo(arg1: phandle_t, arg2: *mut ofw_bus_iinfo, arg3: ::core::ffi::c_int);
    pub fn ofw_bus_lookup_imap(
        arg1: phandle_t,
        arg2: *mut ofw_bus_iinfo,
        arg3: *mut ::core::ffi::c_void,
        arg4: ::core::ffi::c_int,
        arg5: *mut ::core::ffi::c_void,
        arg6: ::core::ffi::c_int,
        arg7: *mut ::core::ffi::c_void,
        arg8: ::core::ffi::c_int,
        arg9: *mut phandle_t,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_search_intrmap(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::core::ffi::c_int,
        arg3: *mut ::core::ffi::c_void,
        arg4: ::core::ffi::c_int,
        arg5: *mut ::core::ffi::c_void,
        arg6: ::core::ffi::c_int,
        arg7: *mut ::core::ffi::c_void,
        arg8: *mut ::core::ffi::c_void,
        arg9: *mut ::core::ffi::c_void,
        arg10: ::core::ffi::c_int,
        arg11: *mut phandle_t,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_msimap(
        arg1: phandle_t,
        arg2: u16,
        arg3: *mut phandle_t,
        arg4: *mut u32,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_iommu_map(
        arg1: phandle_t,
        arg2: u16,
        arg3: *mut phandle_t,
        arg4: *mut u32,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_reg_to_rl(
        arg1: device_t,
        arg2: phandle_t,
        arg3: pcell_t,
        arg4: pcell_t,
        arg5: *mut resource_list,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_assigned_addresses_to_rl(
        arg1: device_t,
        arg2: phandle_t,
        arg3: pcell_t,
        arg4: pcell_t,
        arg5: *mut resource_list,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_intr_to_rl(
        arg1: device_t,
        arg2: phandle_t,
        arg3: *mut resource_list,
        arg4: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_intr_by_rid(
        arg1: device_t,
        arg2: phandle_t,
        arg3: ::core::ffi::c_int,
        arg4: *mut phandle_t,
        arg5: *mut ::core::ffi::c_int,
        arg6: *mut *mut pcell_t,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_get_status(dev: device_t) -> *const ::core::ffi::c_char;
    pub fn ofw_bus_status_okay(dev: device_t) -> ::core::ffi::c_int;
    pub fn ofw_bus_node_status_okay(node: phandle_t) -> ::core::ffi::c_int;
    pub fn ofw_bus_find_iparent(arg1: phandle_t) -> phandle_t;
    pub fn ofw_bus_is_compatible(
        arg1: device_t,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_is_compatible_strict(
        arg1: device_t,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_node_is_compatible(
        arg1: phandle_t,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_search_compatible(
        arg1: device_t,
        arg2: *const ofw_compat_data,
    ) -> *const ofw_compat_data;
    pub fn ofw_bus_has_prop(arg1: device_t, arg2: *const ::core::ffi::c_char)
        -> ::core::ffi::c_int;
    pub fn ofw_bus_find_compatible(arg1: phandle_t, arg2: *const ::core::ffi::c_char) -> phandle_t;
    pub fn ofw_bus_find_child(arg1: phandle_t, arg2: *const ::core::ffi::c_char) -> phandle_t;
    pub fn ofw_bus_find_child_device_by_phandle(bus: device_t, node: phandle_t) -> device_t;
    pub fn ofw_bus_parse_xref_list_alloc(
        node: phandle_t,
        list_name: *const ::core::ffi::c_char,
        cells_name: *const ::core::ffi::c_char,
        idx: ::core::ffi::c_int,
        producer: *mut phandle_t,
        ncells: *mut ::core::ffi::c_int,
        cells: *mut *mut pcell_t,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_parse_xref_list_get_length(
        node: phandle_t,
        list_name: *const ::core::ffi::c_char,
        cells_name: *const ::core::ffi::c_char,
        count: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_find_string_index(
        node: phandle_t,
        list_name: *const ::core::ffi::c_char,
        name: *const ::core::ffi::c_char,
        idx: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_string_list_to_array(
        node: phandle_t,
        list_name: *const ::core::ffi::c_char,
        array: *mut *mut *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the GPIO_GET_BUS() method"]
    pub static mut gpio_get_bus_desc: kobjop_desc;
    #[link_name = "GPIO_GET_BUS__extern"]
    pub fn GPIO_GET_BUS(dev: device_t) -> device_t;
    #[doc = " @brief Unique descriptor for the GPIO_PIN_MAX() method"]
    pub static mut gpio_pin_max_desc: kobjop_desc;
    #[link_name = "GPIO_PIN_MAX__extern"]
    pub fn GPIO_PIN_MAX(dev: device_t, maxpin: *mut ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the GPIO_PIN_SET() method"]
    pub static mut gpio_pin_set_desc: kobjop_desc;
    #[link_name = "GPIO_PIN_SET__extern"]
    pub fn GPIO_PIN_SET(dev: device_t, pin_num: u32, pin_value: u32) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the GPIO_PIN_GET() method"]
    pub static mut gpio_pin_get_desc: kobjop_desc;
    #[link_name = "GPIO_PIN_GET__extern"]
    pub fn GPIO_PIN_GET(dev: device_t, pin_num: u32, pin_value: *mut u32) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the GPIO_PIN_TOGGLE() method"]
    pub static mut gpio_pin_toggle_desc: kobjop_desc;
    #[link_name = "GPIO_PIN_TOGGLE__extern"]
    pub fn GPIO_PIN_TOGGLE(dev: device_t, pin_num: u32) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the GPIO_PIN_GETCAPS() method"]
    pub static mut gpio_pin_getcaps_desc: kobjop_desc;
    #[link_name = "GPIO_PIN_GETCAPS__extern"]
    pub fn GPIO_PIN_GETCAPS(dev: device_t, pin_num: u32, caps: *mut u32) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the GPIO_PIN_GETFLAGS() method"]
    pub static mut gpio_pin_getflags_desc: kobjop_desc;
    #[link_name = "GPIO_PIN_GETFLAGS__extern"]
    pub fn GPIO_PIN_GETFLAGS(dev: device_t, pin_num: u32, flags: *mut u32) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the GPIO_PIN_GETNAME() method"]
    pub static mut gpio_pin_getname_desc: kobjop_desc;
    #[link_name = "GPIO_PIN_GETNAME__extern"]
    pub fn GPIO_PIN_GETNAME(
        dev: device_t,
        pin_num: u32,
        name: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the GPIO_PIN_SETFLAGS() method"]
    pub static mut gpio_pin_setflags_desc: kobjop_desc;
    #[link_name = "GPIO_PIN_SETFLAGS__extern"]
    pub fn GPIO_PIN_SETFLAGS(dev: device_t, pin_num: u32, flags: u32) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the GPIO_MAP_GPIOS() method"]
    pub static mut gpio_map_gpios_desc: kobjop_desc;
    #[link_name = "GPIO_MAP_GPIOS__extern"]
    pub fn GPIO_MAP_GPIOS(
        bus: device_t,
        dev: phandle_t,
        gparent: phandle_t,
        gcells: ::core::ffi::c_int,
        gpios: *mut pcell_t,
        pin: *mut u32,
        flags: *mut u32,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the GPIO_PIN_ACCESS_32() method"]
    pub static mut gpio_pin_access_32_desc: kobjop_desc;
    #[link_name = "GPIO_PIN_ACCESS_32__extern"]
    pub fn GPIO_PIN_ACCESS_32(
        dev: device_t,
        first_pin: u32,
        clear_pins: u32,
        change_pins: u32,
        orig_pins: *mut u32,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the GPIO_PIN_CONFIG_32() method"]
    pub static mut gpio_pin_config_32_desc: kobjop_desc;
    #[link_name = "GPIO_PIN_CONFIG_32__extern"]
    pub fn GPIO_PIN_CONFIG_32(
        dev: device_t,
        first_pin: u32,
        num_pins: u32,
        pin_flags: *mut u32,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the GPIO_GET_PIN_LIST() method"]
    pub static mut gpio_get_pin_list_desc: kobjop_desc;
    #[link_name = "GPIO_GET_PIN_LIST__extern"]
    pub fn GPIO_GET_PIN_LIST(dev: device_t, pin_list: *mut u32) -> ::core::ffi::c_int;
    #[link_name = "gpiobus_get_npins__extern"]
    pub fn gpiobus_get_npins(dev: device_t) -> u32;
    #[link_name = "gpiobus_set_npins__extern"]
    pub fn gpiobus_set_npins(dev: device_t, t: u32);
    #[link_name = "gpiobus_get_pins__extern"]
    pub fn gpiobus_get_pins(dev: device_t) -> *const u32;
    #[link_name = "gpiobus_set_pins__extern"]
    pub fn gpiobus_set_pins(dev: device_t, t: *const u32);
    #[link_name = "gpio_map_gpios__extern"]
    pub fn gpio_map_gpios(
        bus: device_t,
        dev: phandle_t,
        gparent: phandle_t,
        gcells: ::core::ffi::c_int,
        gpios: *mut pcell_t,
        pin: *mut u32,
        flags: *mut u32,
    ) -> ::core::ffi::c_int;
    pub fn ofw_gpiobus_add_fdt_child(
        arg1: device_t,
        arg2: *const ::core::ffi::c_char,
        arg3: phandle_t,
    ) -> device_t;
    pub fn ofw_gpiobus_parse_gpios(
        arg1: device_t,
        arg2: *mut ::core::ffi::c_char,
        arg3: *mut *mut gpiobus_pin,
    ) -> ::core::ffi::c_int;
    pub fn ofw_gpiobus_register_provider(arg1: device_t);
    pub fn ofw_gpiobus_unregister_provider(arg1: device_t);
    pub fn gpio_pin_get_by_ofw_name(
        consumer: device_t,
        node: phandle_t,
        name: *mut ::core::ffi::c_char,
        gpio: *mut gpio_pin_t,
    ) -> ::core::ffi::c_int;
    pub fn gpio_pin_get_by_ofw_idx(
        consumer: device_t,
        node: phandle_t,
        idx: ::core::ffi::c_int,
        gpio: *mut gpio_pin_t,
    ) -> ::core::ffi::c_int;
    pub fn gpio_pin_get_by_ofw_property(
        consumer: device_t,
        node: phandle_t,
        name: *mut ::core::ffi::c_char,
        gpio: *mut gpio_pin_t,
    ) -> ::core::ffi::c_int;
    pub fn gpio_pin_get_by_ofw_propidx(
        consumer: device_t,
        node: phandle_t,
        name: *mut ::core::ffi::c_char,
        idx: ::core::ffi::c_int,
        gpio: *mut gpio_pin_t,
    ) -> ::core::ffi::c_int;
    pub fn gpio_pin_get_by_bus_pinnum(
        _bus: device_t,
        _pinnum: u32,
        _gp: *mut gpio_pin_t,
    ) -> ::core::ffi::c_int;
    pub fn gpio_pin_get_by_child_index(
        _child: device_t,
        _idx: u32,
        _gp: *mut gpio_pin_t,
    ) -> ::core::ffi::c_int;
    pub fn gpio_pin_acquire(gpio: gpio_pin_t) -> ::core::ffi::c_int;
    pub fn gpio_pin_release(gpio: gpio_pin_t);
    pub fn gpio_pin_getcaps(pin: gpio_pin_t, caps: *mut u32) -> ::core::ffi::c_int;
    pub fn gpio_pin_is_active(pin: gpio_pin_t, active: *mut bool_) -> ::core::ffi::c_int;
    pub fn gpio_pin_set_active(pin: gpio_pin_t, active: bool_) -> ::core::ffi::c_int;
    pub fn gpio_pin_setflags(pin: gpio_pin_t, flags: u32) -> ::core::ffi::c_int;
    pub fn gpio_alloc_intr_resource(
        consumer_dev: device_t,
        rid: *mut ::core::ffi::c_int,
        alloc_flags: u_int,
        pin: gpio_pin_t,
        intr_mode: u32,
    ) -> *mut resource;
    pub fn gpio_check_flags(arg1: u32, arg2: u32) -> ::core::ffi::c_int;
    pub fn gpiobus_add_bus(arg1: device_t) -> device_t;
    pub fn gpiobus_detach_bus(arg1: device_t) -> ::core::ffi::c_int;
    pub static mut bio_transient_maxcnt: ::core::ffi::c_int;
    pub fn biodone(bp: *mut bio);
    pub fn biofinish(bp: *mut bio, stat: *mut devstat, error: ::core::ffi::c_int);
    pub fn biowait(bp: *mut bio, wmesg: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn biotrack_buf(bp: *mut bio, location: *const ::core::ffi::c_char);
    #[link_name = "biotrack__extern"]
    pub fn biotrack(bp: *mut bio, location: *const ::core::ffi::c_char);
    pub fn bioq_disksort(ap: *mut bio_queue_head, bp: *mut bio);
    pub fn bioq_first(head: *mut bio_queue_head) -> *mut bio;
    pub fn bioq_takefirst(head: *mut bio_queue_head) -> *mut bio;
    pub fn bioq_flush(head: *mut bio_queue_head, stp: *mut devstat, error: ::core::ffi::c_int);
    pub fn bioq_init(head: *mut bio_queue_head);
    pub fn bioq_insert_head(head: *mut bio_queue_head, bp: *mut bio);
    pub fn bioq_insert_tail(head: *mut bio_queue_head, bp: *mut bio);
    pub fn bioq_remove(head: *mut bio_queue_head, bp: *mut bio);
    pub fn physio(dev: *mut cdev, uio: *mut uio, ioflag: ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[link_name = "counter_u64_add__extern"]
    pub fn counter_u64_add(c: counter_u64_t, inc: i64);
    pub fn counter_u64_alloc(arg1: ::core::ffi::c_int) -> counter_u64_t;
    pub fn counter_u64_free(arg1: counter_u64_t);
    pub fn counter_u64_zero(arg1: counter_u64_t);
    pub fn counter_u64_fetch(arg1: counter_u64_t) -> u64;
    pub fn counter_rate_alloc(
        flags: ::core::ffi::c_int,
        period: ::core::ffi::c_int,
    ) -> *mut counter_rate;
    pub fn counter_rate_free(arg1: *mut counter_rate);
    pub fn counter_ratecheck(arg1: *mut counter_rate, arg2: i64) -> i64;
    pub fn counter_rate_get(arg1: *mut counter_rate) -> u64;
    pub fn counter_u64_sysinit(arg1: *mut ::core::ffi::c_void);
    pub fn counter_u64_sysuninit(arg1: *mut ::core::ffi::c_void);
    #[link_name = "memdesc_vaddr__extern"]
    pub fn memdesc_vaddr(vaddr: *mut ::core::ffi::c_void, len: usize) -> memdesc;
    #[link_name = "memdesc_paddr__extern"]
    pub fn memdesc_paddr(paddr: vm_paddr_t, len: usize) -> memdesc;
    #[link_name = "memdesc_vlist__extern"]
    pub fn memdesc_vlist(vlist: *mut bus_dma_segment, sglist_cnt: ::core::ffi::c_int) -> memdesc;
    #[link_name = "memdesc_plist__extern"]
    pub fn memdesc_plist(plist: *mut bus_dma_segment, sglist_cnt: ::core::ffi::c_int) -> memdesc;
    #[link_name = "memdesc_uio__extern"]
    pub fn memdesc_uio(uio: *mut uio) -> memdesc;
    #[link_name = "memdesc_mbuf__extern"]
    pub fn memdesc_mbuf(mbuf: *mut mbuf) -> memdesc;
    #[link_name = "memdesc_vmpages__extern"]
    pub fn memdesc_vmpages(ma: *mut *mut vm_page, len: usize, ma_offset: u_int) -> memdesc;
    pub fn memdesc_bio(bio: *mut bio) -> memdesc;
    pub fn memdesc_ccb(ccb: *mut ccb) -> memdesc;
    pub fn memdesc_copyback(
        mem: *mut memdesc,
        off: ::core::ffi::c_int,
        size: ::core::ffi::c_int,
        src: *const ::core::ffi::c_void,
    );
    pub fn memdesc_copydata(
        mem: *mut memdesc,
        off: ::core::ffi::c_int,
        size: ::core::ffi::c_int,
        dst: *mut ::core::ffi::c_void,
    );
    pub fn memdesc_alloc_ext_mbufs(
        mem: *mut memdesc,
        ext_alloc: memdesc_alloc_ext_mbuf_t,
        extpg_alloc: memdesc_alloc_extpg_mbuf_t,
        cb_arg: *mut ::core::ffi::c_void,
        how: ::core::ffi::c_int,
        offset: usize,
        len: usize,
        actual_len: *mut usize,
        can_truncate: bool_,
    ) -> *mut mbuf;
    pub fn uma_zcreate(
        name: *const ::core::ffi::c_char,
        size: usize,
        ctor: uma_ctor,
        dtor: uma_dtor,
        uminit: uma_init,
        fini: uma_fini,
        align: ::core::ffi::c_int,
        flags: u32,
    ) -> uma_zone_t;
    pub fn uma_zsecond_create(
        name: *const ::core::ffi::c_char,
        ctor: uma_ctor,
        dtor: uma_dtor,
        zinit: uma_init,
        zfini: uma_fini,
        primary: uma_zone_t,
    ) -> uma_zone_t;
    pub fn uma_zcache_create(
        name: *const ::core::ffi::c_char,
        size: ::core::ffi::c_int,
        ctor: uma_ctor,
        dtor: uma_dtor,
        zinit: uma_init,
        zfini: uma_fini,
        zimport: uma_import,
        zrelease: uma_release,
        arg: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> uma_zone_t;
    pub fn uma_zdestroy(zone: uma_zone_t);
    pub fn uma_zalloc_arg(
        zone: uma_zone_t,
        arg: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn uma_zalloc_pcpu_arg(
        zone: uma_zone_t,
        arg: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn uma_zalloc_smr(zone: uma_zone_t, flags: ::core::ffi::c_int) -> *mut ::core::ffi::c_void;
    pub fn uma_zalloc_domain(
        zone: uma_zone_t,
        arg: *mut ::core::ffi::c_void,
        domain: ::core::ffi::c_int,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    #[link_name = "uma_zalloc__extern"]
    pub fn uma_zalloc(zone: uma_zone_t, flags: ::core::ffi::c_int) -> *mut ::core::ffi::c_void;
    #[link_name = "uma_zalloc_pcpu__extern"]
    pub fn uma_zalloc_pcpu(zone: uma_zone_t, flags: ::core::ffi::c_int)
        -> *mut ::core::ffi::c_void;
    pub fn uma_zfree_arg(
        zone: uma_zone_t,
        item: *mut ::core::ffi::c_void,
        arg: *mut ::core::ffi::c_void,
    );
    pub fn uma_zfree_pcpu_arg(
        zone: uma_zone_t,
        item: *mut ::core::ffi::c_void,
        arg: *mut ::core::ffi::c_void,
    );
    pub fn uma_zfree_smr(zone: uma_zone_t, item: *mut ::core::ffi::c_void);
    #[link_name = "uma_zfree__extern"]
    pub fn uma_zfree(zone: uma_zone_t, item: *mut ::core::ffi::c_void);
    #[link_name = "uma_zfree_pcpu__extern"]
    pub fn uma_zfree_pcpu(zone: uma_zone_t, item: *mut ::core::ffi::c_void);
    pub fn uma_zwait(zone: uma_zone_t);
    pub fn uma_reclaim(req: ::core::ffi::c_int);
    pub fn uma_reclaim_domain(req: ::core::ffi::c_int, domain: ::core::ffi::c_int);
    pub fn uma_zone_reclaim(arg1: uma_zone_t, req: ::core::ffi::c_int);
    pub fn uma_zone_reclaim_domain(
        arg1: uma_zone_t,
        req: ::core::ffi::c_int,
        domain: ::core::ffi::c_int,
    );
    pub fn uma_set_cache_align_mask(mask: ::core::ffi::c_uint);
    pub fn uma_get_cache_align_mask() -> ::core::ffi::c_uint;
    pub fn uma_zone_reserve(zone: uma_zone_t, nitems: ::core::ffi::c_int);
    pub fn uma_zone_reserve_kva(zone: uma_zone_t, nitems: ::core::ffi::c_int)
        -> ::core::ffi::c_int;
    pub fn uma_zone_set_max(zone: uma_zone_t, nitems: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn uma_zone_set_maxcache(zone: uma_zone_t, nitems: ::core::ffi::c_int);
    pub fn uma_zone_get_max(zone: uma_zone_t) -> ::core::ffi::c_int;
    pub fn uma_zone_set_warning(zone: uma_zone_t, warning: *const ::core::ffi::c_char);
    pub fn uma_zone_set_maxaction(zone: uma_zone_t, arg1: uma_maxaction_t);
    pub fn uma_zone_get_cur(zone: uma_zone_t) -> ::core::ffi::c_int;
    pub fn uma_zone_set_init(zone: uma_zone_t, uminit: uma_init);
    pub fn uma_zone_set_fini(zone: uma_zone_t, fini: uma_fini);
    pub fn uma_zone_set_zinit(zone: uma_zone_t, zinit: uma_init);
    pub fn uma_zone_set_zfini(zone: uma_zone_t, zfini: uma_fini);
    pub fn uma_zone_set_allocf(zone: uma_zone_t, allocf: uma_alloc);
    pub fn uma_zone_set_freef(zone: uma_zone_t, freef: uma_free);
    pub fn uma_zone_set_smr(zone: uma_zone_t, smr: smr_t);
    pub fn uma_zone_get_smr(zone: uma_zone_t) -> smr_t;
    pub fn uma_prealloc(zone: uma_zone_t, itemcnt: ::core::ffi::c_int);
    pub fn uma_zone_exhausted(zone: uma_zone_t) -> ::core::ffi::c_int;
    pub fn uma_zone_memory(zone: uma_zone_t) -> usize;
    pub static mut pcpu_zone_4: uma_zone_t;
    pub static mut pcpu_zone_8: uma_zone_t;
    pub static mut pcpu_zone_16: uma_zone_t;
    pub static mut pcpu_zone_32: uma_zone_t;
    pub static mut pcpu_zone_64: uma_zone_t;
    pub fn uma_reclaim_wakeup();
    pub fn uma_reclaim_worker(arg1: *mut ::core::ffi::c_void);
    pub fn uma_limit() -> ::core::ffi::c_ulong;
    pub fn uma_size() -> ::core::ffi::c_ulong;
    pub fn uma_avail() -> ::core::ffi::c_long;
    #[link_name = "be16dec__extern"]
    pub fn be16dec(pp: *const ::core::ffi::c_void) -> u16;
    #[link_name = "be32dec__extern"]
    pub fn be32dec(pp: *const ::core::ffi::c_void) -> u32;
    #[link_name = "be64dec__extern"]
    pub fn be64dec(pp: *const ::core::ffi::c_void) -> u64;
    #[link_name = "le16dec__extern"]
    pub fn le16dec(pp: *const ::core::ffi::c_void) -> u16;
    #[link_name = "le32dec__extern"]
    pub fn le32dec(pp: *const ::core::ffi::c_void) -> u32;
    #[link_name = "le64dec__extern"]
    pub fn le64dec(pp: *const ::core::ffi::c_void) -> u64;
    #[link_name = "be16enc__extern"]
    pub fn be16enc(pp: *mut ::core::ffi::c_void, u: u16);
    #[link_name = "be32enc__extern"]
    pub fn be32enc(pp: *mut ::core::ffi::c_void, u: u32);
    #[link_name = "be64enc__extern"]
    pub fn be64enc(pp: *mut ::core::ffi::c_void, u: u64);
    #[link_name = "le16enc__extern"]
    pub fn le16enc(pp: *mut ::core::ffi::c_void, u: u16);
    #[link_name = "le32enc__extern"]
    pub fn le32enc(pp: *mut ::core::ffi::c_void, u: u32);
    #[link_name = "le64enc__extern"]
    pub fn le64enc(pp: *mut ::core::ffi::c_void, u: u64);
    pub fn nvme_cpl_sbuf(cpl: *const nvme_completion, sbuf: *mut sbuf);
    pub fn nvme_opcode_sbuf(admin: bool_, opc: u8, sb: *mut sbuf);
    pub fn nvme_sc_sbuf(cpl: *const nvme_completion, sbuf: *mut sbuf);
    pub fn nvme_strvis(
        dst: *mut u8,
        src: *const u8,
        dstlen: ::core::ffi::c_int,
        srclen: ::core::ffi::c_int,
    );
    pub fn nvme_ctrlr_passthrough_cmd(
        ctrlr: *mut nvme_controller,
        pt: *mut nvme_pt_command,
        nsid: u32,
        is_user_buffer: ::core::ffi::c_int,
        is_admin_cmd: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn nvme_ctrlr_linux_passthru_cmd(
        ctrlr: *mut nvme_controller,
        npc: *mut nvme_passthru_cmd,
        nsid: u32,
        is_user: bool_,
        is_admin: bool_,
    ) -> ::core::ffi::c_int;
    pub fn nvme_ctrlr_cmd_set_feature(
        ctrlr: *mut nvme_controller,
        feature: u8,
        cdw11: u32,
        cdw12: u32,
        cdw13: u32,
        cdw14: u32,
        cdw15: u32,
        payload: *mut ::core::ffi::c_void,
        payload_size: u32,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_get_feature(
        ctrlr: *mut nvme_controller,
        feature: u8,
        cdw11: u32,
        payload: *mut ::core::ffi::c_void,
        payload_size: u32,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_get_log_page(
        ctrlr: *mut nvme_controller,
        log_page: u8,
        nsid: u32,
        payload: *mut ::core::ffi::c_void,
        payload_size: u32,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ns_cmd_write(
        ns: *mut nvme_namespace,
        payload: *mut ::core::ffi::c_void,
        lba: u64,
        lba_count: u32,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn nvme_ns_cmd_write_bio(
        ns: *mut nvme_namespace,
        bp: *mut bio,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn nvme_ns_cmd_read(
        ns: *mut nvme_namespace,
        payload: *mut ::core::ffi::c_void,
        lba: u64,
        lba_count: u32,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn nvme_ns_cmd_read_bio(
        ns: *mut nvme_namespace,
        bp: *mut bio,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn nvme_ns_cmd_deallocate(
        ns: *mut nvme_namespace,
        payload: *mut ::core::ffi::c_void,
        num_ranges: u8,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn nvme_ns_cmd_flush(
        ns: *mut nvme_namespace,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn nvme_ns_dump(
        ns: *mut nvme_namespace,
        virt: *mut ::core::ffi::c_void,
        offset: off_t,
        len: usize,
    ) -> ::core::ffi::c_int;
    pub fn nvme_register_consumer(
        ns_fn: nvme_cons_ns_fn_t,
        ctrlr_fn: nvme_cons_ctrlr_fn_t,
        async_fn: nvme_cons_async_fn_t,
        fail_fn: nvme_cons_fail_fn_t,
    ) -> *mut nvme_consumer;
    pub fn nvme_unregister_consumer(consumer: *mut nvme_consumer);
    pub fn nvme_ctrlr_get_device(ctrlr: *mut nvme_controller) -> device_t;
    pub fn nvme_ctrlr_get_data(ctrlr: *mut nvme_controller) -> *const nvme_controller_data;
    #[link_name = "nvme_ctrlr_has_dataset_mgmt__extern"]
    pub fn nvme_ctrlr_has_dataset_mgmt(cd: *const nvme_controller_data) -> bool_;
    pub fn nvme_ns_get_max_io_xfer_size(ns: *mut nvme_namespace) -> u32;
    pub fn nvme_ns_get_sector_size(ns: *mut nvme_namespace) -> u32;
    pub fn nvme_ns_get_num_sectors(ns: *mut nvme_namespace) -> u64;
    pub fn nvme_ns_get_size(ns: *mut nvme_namespace) -> u64;
    pub fn nvme_ns_get_flags(ns: *mut nvme_namespace) -> u32;
    pub fn nvme_ns_get_serial_number(ns: *mut nvme_namespace) -> *const ::core::ffi::c_char;
    pub fn nvme_ns_get_model_number(ns: *mut nvme_namespace) -> *const ::core::ffi::c_char;
    pub fn nvme_ns_get_data(ns: *mut nvme_namespace) -> *const nvme_namespace_data;
    pub fn nvme_ns_get_stripesize(ns: *mut nvme_namespace) -> u32;
    pub fn nvme_ns_bio_process(
        ns: *mut nvme_namespace,
        bp: *mut bio,
        cb_fn: nvme_cb_fn_t,
    ) -> ::core::ffi::c_int;
    pub fn nvme_ns_ioctl_process(
        ns: *mut nvme_namespace,
        cmd: u_long,
        arg: caddr_t,
        flag: ::core::ffi::c_int,
        td: *mut thread,
    ) -> ::core::ffi::c_int;
    #[link_name = "nvme_ns_flush_cmd__extern"]
    pub fn nvme_ns_flush_cmd(cmd: *mut nvme_command, nsid: u32);
    #[link_name = "nvme_ns_rw_cmd__extern"]
    pub fn nvme_ns_rw_cmd(cmd: *mut nvme_command, rwcmd: u32, nsid: u32, lba: u64, count: u32);
    #[link_name = "nvme_ns_write_cmd__extern"]
    pub fn nvme_ns_write_cmd(cmd: *mut nvme_command, nsid: u32, lba: u64, count: u32);
    #[link_name = "nvme_ns_read_cmd__extern"]
    pub fn nvme_ns_read_cmd(cmd: *mut nvme_command, nsid: u32, lba: u64, count: u32);
    #[link_name = "nvme_ns_trim_cmd__extern"]
    pub fn nvme_ns_trim_cmd(cmd: *mut nvme_command, nsid: u32, num_ranges: u32);
    pub static mut nvme_use_nvd: ::core::ffi::c_int;
    #[link_name = "nvme_completion_swapbytes__extern"]
    pub fn nvme_completion_swapbytes(s: *mut nvme_completion);
    #[link_name = "nvme_power_state_swapbytes__extern"]
    pub fn nvme_power_state_swapbytes(s: *mut nvme_power_state);
    #[link_name = "nvme_controller_data_swapbytes__extern"]
    pub fn nvme_controller_data_swapbytes(s: *mut nvme_controller_data);
    #[link_name = "nvme_namespace_data_swapbytes__extern"]
    pub fn nvme_namespace_data_swapbytes(s: *mut nvme_namespace_data);
    #[link_name = "nvme_error_information_entry_swapbytes__extern"]
    pub fn nvme_error_information_entry_swapbytes(s: *mut nvme_error_information_entry);
    #[link_name = "nvme_le128toh__extern"]
    pub fn nvme_le128toh(p: *mut ::core::ffi::c_void);
    #[link_name = "nvme_health_information_page_swapbytes__extern"]
    pub fn nvme_health_information_page_swapbytes(s: *mut nvme_health_information_page);
    #[link_name = "nvme_ns_list_swapbytes__extern"]
    pub fn nvme_ns_list_swapbytes(s: *mut nvme_ns_list);
    #[link_name = "nvme_command_effects_page_swapbytes__extern"]
    pub fn nvme_command_effects_page_swapbytes(s: *mut nvme_command_effects_page);
    #[link_name = "nvme_res_notification_page_swapbytes__extern"]
    pub fn nvme_res_notification_page_swapbytes(s: *mut nvme_res_notification_page);
    #[link_name = "nvme_sanitize_status_page_swapbytes__extern"]
    pub fn nvme_sanitize_status_page_swapbytes(s: *mut nvme_sanitize_status_page);
    #[link_name = "nvme_resv_status_swapbytes__extern"]
    pub fn nvme_resv_status_swapbytes(s: *mut nvme_resv_status, size: usize);
    #[link_name = "nvme_resv_status_ext_swapbytes__extern"]
    pub fn nvme_resv_status_ext_swapbytes(s: *mut nvme_resv_status_ext, size: usize);
    #[link_name = "nvme_device_self_test_swapbytes__extern"]
    pub fn nvme_device_self_test_swapbytes(s: *mut nvme_device_self_test_page);
    #[link_name = "nvme_discovery_log_entry_swapbytes__extern"]
    pub fn nvme_discovery_log_entry_swapbytes(s: *mut nvme_discovery_log_entry);
    #[link_name = "nvme_discovery_log_swapbytes__extern"]
    pub fn nvme_discovery_log_swapbytes(s: *mut nvme_discovery_log);
    pub static mut M_NVME: [malloc_type; 1usize];
    pub static mut nvme_retry_count: i32;
    pub static mut nvme_verbose_cmd_dump: bool_;
    pub fn nvme_qpair_sq_enter(qpair: *mut nvme_qpair, tr: *mut nvme_tracker) -> u32;
    pub fn nvme_qpair_sq_leave(qpair: *mut nvme_qpair, tr: *mut nvme_tracker);
    pub fn nvme_qpair_cq_done(qpair: *mut nvme_qpair, tr: *mut nvme_tracker);
    pub fn nvme_ns_test(ns: *mut nvme_namespace, cmd: u_long, arg: caddr_t);
    pub fn nvme_ctrlr_cmd_identify_controller(
        ctrlr: *mut nvme_controller,
        payload: *mut ::core::ffi::c_void,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_identify_namespace(
        ctrlr: *mut nvme_controller,
        nsid: u32,
        payload: *mut ::core::ffi::c_void,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_set_interrupt_coalescing(
        ctrlr: *mut nvme_controller,
        microseconds: u32,
        threshold: u32,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_get_error_page(
        ctrlr: *mut nvme_controller,
        payload: *mut nvme_error_information_entry,
        num_entries: u32,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_get_health_information_page(
        ctrlr: *mut nvme_controller,
        nsid: u32,
        payload: *mut nvme_health_information_page,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_get_firmware_page(
        ctrlr: *mut nvme_controller,
        payload: *mut nvme_firmware_page,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_create_io_cq(
        ctrlr: *mut nvme_controller,
        io_que: *mut nvme_qpair,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_create_io_sq(
        ctrlr: *mut nvme_controller,
        io_que: *mut nvme_qpair,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_delete_io_cq(
        ctrlr: *mut nvme_controller,
        io_que: *mut nvme_qpair,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_delete_io_sq(
        ctrlr: *mut nvme_controller,
        io_que: *mut nvme_qpair,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_set_num_queues(
        ctrlr: *mut nvme_controller,
        num_queues: u32,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_set_async_event_config(
        ctrlr: *mut nvme_controller,
        state: u32,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_abort(
        ctrlr: *mut nvme_controller,
        cid: u16,
        sqid: u16,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_completion_poll_cb(arg: *mut ::core::ffi::c_void, cpl: *const nvme_completion);
    pub fn nvme_ctrlr_construct(ctrlr: *mut nvme_controller, dev: device_t) -> ::core::ffi::c_int;
    pub fn nvme_ctrlr_destruct(ctrlr: *mut nvme_controller, dev: device_t);
    pub fn nvme_ctrlr_shutdown(ctrlr: *mut nvme_controller);
    pub fn nvme_ctrlr_reset(ctrlr: *mut nvme_controller);
    pub fn nvme_ctrlr_start_config_hook(ctrlr_arg: *mut ::core::ffi::c_void);
    pub fn nvme_ctrlr_submit_admin_request(ctrlr: *mut nvme_controller, req: *mut nvme_request);
    pub fn nvme_ctrlr_submit_io_request(ctrlr: *mut nvme_controller, req: *mut nvme_request);
    pub fn nvme_qpair_construct(
        dev: device_t,
        qpair: *mut nvme_qpair,
        num_entries: u32,
        num_trackers: u32,
        ctrlr: *mut nvme_controller,
    ) -> ::core::ffi::c_int;
    pub fn nvme_qpair_submit_tracker(qpair: *mut nvme_qpair, tr: *mut nvme_tracker);
    pub fn nvme_qpair_process_completions(qpair: *mut nvme_qpair) -> bool_;
    pub fn nvme_qpair_submit_request(qpair: *mut nvme_qpair, req: *mut nvme_request);
    pub fn nvme_qpair_reset(qpair: *mut nvme_qpair);
    pub fn nvme_qpair_fail(qpair: *mut nvme_qpair);
    pub fn nvme_admin_qpair_enable(qpair: *mut nvme_qpair);
    pub fn nvme_admin_qpair_disable(qpair: *mut nvme_qpair);
    pub fn nvme_admin_qpair_destroy(qpair: *mut nvme_qpair);
    pub fn nvme_io_qpair_enable(qpair: *mut nvme_qpair);
    pub fn nvme_io_qpair_disable(qpair: *mut nvme_qpair);
    pub fn nvme_io_qpair_destroy(qpair: *mut nvme_qpair);
    pub fn nvme_ns_construct(
        ns: *mut nvme_namespace,
        id: u32,
        ctrlr: *mut nvme_controller,
    ) -> ::core::ffi::c_int;
    pub fn nvme_ns_destruct(ns: *mut nvme_namespace);
    pub fn nvme_sysctl_initialize_ctrlr(ctrlr: *mut nvme_controller);
    pub fn nvme_qpair_print_command(qpair: *mut nvme_qpair, cmd: *mut nvme_command);
    pub fn nvme_qpair_print_completion(qpair: *mut nvme_qpair, cpl: *mut nvme_completion);
    pub fn nvme_attach(dev: device_t) -> ::core::ffi::c_int;
    pub fn nvme_shutdown(dev: device_t) -> ::core::ffi::c_int;
    pub fn nvme_detach(dev: device_t) -> ::core::ffi::c_int;
    #[link_name = "nvme_completion_poll__extern"]
    pub fn nvme_completion_poll(status: *mut nvme_completion_poll_status);
    #[link_name = "nvme_single_map__extern"]
    pub fn nvme_single_map(
        arg: *mut ::core::ffi::c_void,
        seg: *mut bus_dma_segment_t,
        nseg: ::core::ffi::c_int,
        error: ::core::ffi::c_int,
    );
    #[link_name = "_nvme_allocate_request__extern"]
    pub fn _nvme_allocate_request(
        how: ::core::ffi::c_int,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> *mut nvme_request;
    #[link_name = "nvme_allocate_request_vaddr__extern"]
    pub fn nvme_allocate_request_vaddr(
        payload: *mut ::core::ffi::c_void,
        payload_size: u32,
        how: ::core::ffi::c_int,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> *mut nvme_request;
    #[link_name = "nvme_allocate_request_null__extern"]
    pub fn nvme_allocate_request_null(
        how: ::core::ffi::c_int,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> *mut nvme_request;
    #[link_name = "nvme_allocate_request_bio__extern"]
    pub fn nvme_allocate_request_bio(
        bio: *mut bio,
        how: ::core::ffi::c_int,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> *mut nvme_request;
    #[link_name = "nvme_allocate_request_ccb__extern"]
    pub fn nvme_allocate_request_ccb(
        ccb: *mut ccb,
        how: ::core::ffi::c_int,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> *mut nvme_request;
    pub fn nvme_notify_async_consumers(
        ctrlr: *mut nvme_controller,
        async_cpl: *const nvme_completion,
        log_page_id: u32,
        log_page_buffer: *mut ::core::ffi::c_void,
        log_page_size: u32,
    );
    pub fn nvme_notify_fail_consumers(ctrlr: *mut nvme_controller);
    pub fn nvme_notify_new_controller(ctrlr: *mut nvme_controller);
    pub fn nvme_notify_ns(ctrlr: *mut nvme_controller, nsid: ::core::ffi::c_int);
    pub fn nvme_ctrlr_shared_handler(arg: *mut ::core::ffi::c_void);
    pub fn nvme_ctrlr_get_ident(ctrlr: *const nvme_controller, sn: *mut u8);
    pub fn nvme_ctrlr_poll(ctrlr: *mut nvme_controller);
    pub fn nvme_ctrlr_suspend(ctrlr: *mut nvme_controller) -> ::core::ffi::c_int;
    pub fn nvme_ctrlr_resume(ctrlr: *mut nvme_controller) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the NVME_DELAYED_ATTACH() method"]
    pub static mut nvme_delayed_attach_desc: kobjop_desc;
    #[link_name = "NVME_DELAYED_ATTACH__extern"]
    pub fn NVME_DELAYED_ATTACH(dev: device_t, ctrlr: *mut nvme_controller) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the NVME_ENABLE() method"]
    pub static mut nvme_enable_desc: kobjop_desc;
    #[link_name = "NVME_ENABLE__extern"]
    pub fn NVME_ENABLE(dev: device_t);
    #[doc = " @brief Unique descriptor for the NVME_SQ_ENTER() method"]
    pub static mut nvme_sq_enter_desc: kobjop_desc;
    #[link_name = "NVME_SQ_ENTER__extern"]
    pub fn NVME_SQ_ENTER(dev: device_t, qpair: *mut nvme_qpair, tr: *mut nvme_tracker) -> u32;
    #[doc = " @brief Unique descriptor for the NVME_SQ_LEAVE() method"]
    pub static mut nvme_sq_leave_desc: kobjop_desc;
    #[link_name = "NVME_SQ_LEAVE__extern"]
    pub fn NVME_SQ_LEAVE(dev: device_t, qpair: *mut nvme_qpair, tr: *mut nvme_tracker);
    #[doc = " @brief Unique descriptor for the NVME_CQ_DONE() method"]
    pub static mut nvme_cq_done_desc: kobjop_desc;
    #[link_name = "NVME_CQ_DONE__extern"]
    pub fn NVME_CQ_DONE(dev: device_t, qpair: *mut nvme_qpair, tr: *mut nvme_tracker);
    #[doc = " @brief Unique descriptor for the NVME_QPAIR_CONSTRUCT() method"]
    pub static mut nvme_qpair_construct_desc: kobjop_desc;
    #[link_name = "NVME_QPAIR_CONSTRUCT__extern"]
    pub fn NVME_QPAIR_CONSTRUCT(
        dev: device_t,
        qpair: *mut nvme_qpair,
        num_entries: u32,
        num_trackers: u32,
        ctrlr: *mut nvme_controller,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the PIC_ACTIVATE_INTR() method"]
    pub static mut pic_activate_intr_desc: kobjop_desc;
    #[link_name = "PIC_ACTIVATE_INTR__extern"]
    pub fn PIC_ACTIVATE_INTR(
        dev: device_t,
        isrc: *mut intr_irqsrc,
        res: *mut resource,
        data: *mut intr_map_data,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the PIC_BIND_INTR() method"]
    pub static mut pic_bind_intr_desc: kobjop_desc;
    #[link_name = "PIC_BIND_INTR__extern"]
    pub fn PIC_BIND_INTR(dev: device_t, isrc: *mut intr_irqsrc) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the PIC_DISABLE_INTR() method"]
    pub static mut pic_disable_intr_desc: kobjop_desc;
    #[link_name = "PIC_DISABLE_INTR__extern"]
    pub fn PIC_DISABLE_INTR(dev: device_t, isrc: *mut intr_irqsrc);
    #[doc = " @brief Unique descriptor for the PIC_ENABLE_INTR() method"]
    pub static mut pic_enable_intr_desc: kobjop_desc;
    #[link_name = "PIC_ENABLE_INTR__extern"]
    pub fn PIC_ENABLE_INTR(dev: device_t, isrc: *mut intr_irqsrc);
    #[doc = " @brief Unique descriptor for the PIC_MAP_INTR() method"]
    pub static mut pic_map_intr_desc: kobjop_desc;
    #[link_name = "PIC_MAP_INTR__extern"]
    pub fn PIC_MAP_INTR(
        dev: device_t,
        data: *mut intr_map_data,
        isrcp: *mut *mut intr_irqsrc,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the PIC_DEACTIVATE_INTR() method"]
    pub static mut pic_deactivate_intr_desc: kobjop_desc;
    #[link_name = "PIC_DEACTIVATE_INTR__extern"]
    pub fn PIC_DEACTIVATE_INTR(
        dev: device_t,
        isrc: *mut intr_irqsrc,
        res: *mut resource,
        data: *mut intr_map_data,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the PIC_SETUP_INTR() method"]
    pub static mut pic_setup_intr_desc: kobjop_desc;
    #[link_name = "PIC_SETUP_INTR__extern"]
    pub fn PIC_SETUP_INTR(
        dev: device_t,
        isrc: *mut intr_irqsrc,
        res: *mut resource,
        data: *mut intr_map_data,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the PIC_TEARDOWN_INTR() method"]
    pub static mut pic_teardown_intr_desc: kobjop_desc;
    #[link_name = "PIC_TEARDOWN_INTR__extern"]
    pub fn PIC_TEARDOWN_INTR(
        dev: device_t,
        isrc: *mut intr_irqsrc,
        res: *mut resource,
        data: *mut intr_map_data,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the PIC_POST_FILTER() method"]
    pub static mut pic_post_filter_desc: kobjop_desc;
    #[link_name = "PIC_POST_FILTER__extern"]
    pub fn PIC_POST_FILTER(dev: device_t, isrc: *mut intr_irqsrc);
    #[doc = " @brief Unique descriptor for the PIC_POST_ITHREAD() method"]
    pub static mut pic_post_ithread_desc: kobjop_desc;
    #[link_name = "PIC_POST_ITHREAD__extern"]
    pub fn PIC_POST_ITHREAD(dev: device_t, isrc: *mut intr_irqsrc);
    #[doc = " @brief Unique descriptor for the PIC_PRE_ITHREAD() method"]
    pub static mut pic_pre_ithread_desc: kobjop_desc;
    #[link_name = "PIC_PRE_ITHREAD__extern"]
    pub fn PIC_PRE_ITHREAD(dev: device_t, isrc: *mut intr_irqsrc);
    #[doc = " @brief Unique descriptor for the PIC_INIT_SECONDARY() method"]
    pub static mut pic_init_secondary_desc: kobjop_desc;
    #[link_name = "PIC_INIT_SECONDARY__extern"]
    pub fn PIC_INIT_SECONDARY(dev: device_t, rootnum: u32);
    #[doc = " @brief Unique descriptor for the PIC_IPI_SEND() method"]
    pub static mut pic_ipi_send_desc: kobjop_desc;
    #[link_name = "PIC_IPI_SEND__extern"]
    pub fn PIC_IPI_SEND(dev: device_t, isrc: *mut intr_irqsrc, cpus: cpuset_t, ipi: u_int);
    #[doc = " @brief Unique descriptor for the PIC_IPI_SETUP() method"]
    pub static mut pic_ipi_setup_desc: kobjop_desc;
    #[link_name = "PIC_IPI_SETUP__extern"]
    pub fn PIC_IPI_SETUP(
        dev: device_t,
        ipi: u_int,
        isrcp: *mut *mut intr_irqsrc,
    ) -> ::core::ffi::c_int;
    pub static mut memmap_bus: bus_space;
    pub fn rust_bindings_CPU_SET(cpu: u_int, set: *mut cpuset_t);
    pub fn rust_bindings_CPU_ISSET(cpu: u_int, set: *mut cpuset_t) -> bool_;
    pub fn rust_bindings_CPU_AFFINITY(cpu: u_int) -> u64;
    pub fn rust_bindings_CPU_AFF0(mpidr: u64) -> u64;
    pub fn rust_bindings_CPU_AFF1(mpidr: u64) -> u64;
    pub fn rust_bindings_bus_space_barrier(
        s: bus_space_tag_t,
        h: bus_space_handle_t,
        o: bus_size_t,
        len: bus_size_t,
        flags: ::core::ffi::c_int,
    );
    pub fn rust_bindings_bus_barrier(
        r: *mut resource,
        o: bus_size_t,
        len: bus_size_t,
        flags: ::core::ffi::c_int,
    );
    pub fn rust_bindings_bus_space_map(
        s: bus_space_tag_t,
        a: bus_addr_t,
        sz: bus_size_t,
        f: ::core::ffi::c_int,
        hp: *mut bus_space_handle_t,
    ) -> ::core::ffi::c_int;
    pub fn rust_bindings_mtx_initialized(mutex: *const mtx) -> usize;
    pub fn rust_bindings_bus_read_1(res: *mut resource, offset: bus_size_t) -> u8;
    pub fn rust_bindings_bus_write_region_1(
        res: *mut resource,
        o: bus_size_t,
        p: *mut u8,
        count: bus_size_t,
    );
    pub fn rust_bindings_bus_write_1(res: *mut resource, offset: bus_size_t, value: u8);
    pub fn rust_bindings_bus_read_2(res: *mut resource, offset: bus_size_t) -> u16;
    pub fn rust_bindings_bus_write_region_2(
        res: *mut resource,
        o: bus_size_t,
        p: *mut u16,
        count: bus_size_t,
    );
    pub fn rust_bindings_bus_write_2(res: *mut resource, offset: bus_size_t, value: u16);
    pub fn rust_bindings_bus_read_4(res: *mut resource, offset: bus_size_t) -> u32;
    pub fn rust_bindings_bus_write_region_4(
        res: *mut resource,
        o: bus_size_t,
        p: *mut u32,
        count: bus_size_t,
    );
    pub fn rust_bindings_bus_write_4(res: *mut resource, offset: bus_size_t, value: u32);
    pub fn rust_bindings_bus_read_8(res: *mut resource, offset: bus_size_t) -> u64;
    pub fn rust_bindings_bus_write_region_8(
        res: *mut resource,
        o: bus_size_t,
        p: *mut u64,
        count: bus_size_t,
    );
    pub fn rust_bindings_bus_write_8(res: *mut resource, offset: bus_size_t, value: u64);
}
