/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const __llvm__: i32 = 1;
pub const __clang__: i32 = 1;
pub const __clang_major__: i32 = 21;
pub const __clang_minor__: i32 = 1;
pub const __clang_patchlevel__: i32 = 6;
pub const __clang_version__: &[u8; 8] = b"21.1.6 \0";
pub const __GNUC__: i32 = 4;
pub const __GNUC_MINOR__: i32 = 2;
pub const __GNUC_PATCHLEVEL__: i32 = 1;
pub const __GXX_ABI_VERSION: i32 = 1002;
pub const __ATOMIC_RELAXED: i32 = 0;
pub const __ATOMIC_CONSUME: i32 = 1;
pub const __ATOMIC_ACQUIRE: i32 = 2;
pub const __ATOMIC_RELEASE: i32 = 3;
pub const __ATOMIC_ACQ_REL: i32 = 4;
pub const __ATOMIC_SEQ_CST: i32 = 5;
pub const __MEMORY_SCOPE_SYSTEM: i32 = 0;
pub const __MEMORY_SCOPE_DEVICE: i32 = 1;
pub const __MEMORY_SCOPE_WRKGRP: i32 = 2;
pub const __MEMORY_SCOPE_WVFRNT: i32 = 3;
pub const __MEMORY_SCOPE_SINGLE: i32 = 4;
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM: i32 = 0;
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP: i32 = 1;
pub const __OPENCL_MEMORY_SCOPE_DEVICE: i32 = 2;
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES: i32 = 3;
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP: i32 = 4;
pub const __FPCLASS_SNAN: i32 = 1;
pub const __FPCLASS_QNAN: i32 = 2;
pub const __FPCLASS_NEGINF: i32 = 4;
pub const __FPCLASS_NEGNORMAL: i32 = 8;
pub const __FPCLASS_NEGSUBNORMAL: i32 = 16;
pub const __FPCLASS_NEGZERO: i32 = 32;
pub const __FPCLASS_POSZERO: i32 = 64;
pub const __FPCLASS_POSSUBNORMAL: i32 = 128;
pub const __FPCLASS_POSNORMAL: i32 = 256;
pub const __FPCLASS_POSINF: i32 = 512;
pub const __PRAGMA_REDEFINE_EXTNAME: i32 = 1;
pub const __VERSION__: &[u8; 13] = b"Clang 21.1.6\0";
pub const __OBJC_BOOL_IS_BOOL: i32 = 0;
pub const __CONSTANT_CFSTRINGS__: i32 = 1;
pub const __clang_literal_encoding__: &[u8; 6] = b"UTF-8\0";
pub const __clang_wide_literal_encoding__: &[u8; 7] = b"UTF-32\0";
pub const __OPTIMIZE__: i32 = 1;
pub const __ORDER_LITTLE_ENDIAN__: i32 = 1234;
pub const __ORDER_BIG_ENDIAN__: i32 = 4321;
pub const __ORDER_PDP_ENDIAN__: i32 = 3412;
pub const __BYTE_ORDER__: i32 = 1234;
pub const __LITTLE_ENDIAN__: i32 = 1;
pub const _LP64: i32 = 1;
pub const __LP64__: i32 = 1;
pub const __CHAR_BIT__: i32 = 8;
pub const __BOOL_WIDTH__: i32 = 1;
pub const __SHRT_WIDTH__: i32 = 16;
pub const __INT_WIDTH__: i32 = 32;
pub const __LONG_WIDTH__: i32 = 64;
pub const __LLONG_WIDTH__: i32 = 64;
pub const __BITINT_MAXWIDTH__: i32 = 128;
pub const __SCHAR_MAX__: i32 = 127;
pub const __SHRT_MAX__: i32 = 32767;
pub const __INT_MAX__: i32 = 2147483647;
pub const __LONG_MAX__: i64 = 9223372036854775807;
pub const __LONG_LONG_MAX__: i64 = 9223372036854775807;
pub const __WCHAR_MAX__: i64 = 4294967295;
pub const __WCHAR_WIDTH__: i32 = 32;
pub const __WINT_MAX__: i32 = 2147483647;
pub const __WINT_WIDTH__: i32 = 32;
pub const __INTMAX_MAX__: i64 = 9223372036854775807;
pub const __INTMAX_WIDTH__: i32 = 64;
pub const __SIZE_MAX__: i32 = -1;
pub const __SIZE_WIDTH__: i32 = 64;
pub const __UINTMAX_MAX__: i32 = -1;
pub const __UINTMAX_WIDTH__: i32 = 64;
pub const __PTRDIFF_MAX__: i64 = 9223372036854775807;
pub const __PTRDIFF_WIDTH__: i32 = 64;
pub const __INTPTR_MAX__: i64 = 9223372036854775807;
pub const __INTPTR_WIDTH__: i32 = 64;
pub const __UINTPTR_MAX__: i32 = -1;
pub const __UINTPTR_WIDTH__: i32 = 64;
pub const __SIZEOF_DOUBLE__: i32 = 8;
pub const __SIZEOF_FLOAT__: i32 = 4;
pub const __SIZEOF_INT__: i32 = 4;
pub const __SIZEOF_LONG__: i32 = 8;
pub const __SIZEOF_LONG_DOUBLE__: i32 = 16;
pub const __SIZEOF_LONG_LONG__: i32 = 8;
pub const __SIZEOF_POINTER__: i32 = 8;
pub const __SIZEOF_SHORT__: i32 = 2;
pub const __SIZEOF_PTRDIFF_T__: i32 = 8;
pub const __SIZEOF_SIZE_T__: i32 = 8;
pub const __SIZEOF_WCHAR_T__: i32 = 4;
pub const __SIZEOF_WINT_T__: i32 = 4;
pub const __SIZEOF_INT128__: i32 = 16;
pub const __INTMAX_FMTd__: &[u8; 3] = b"ld\0";
pub const __INTMAX_FMTi__: &[u8; 3] = b"li\0";
pub const __UINTMAX_FMTo__: &[u8; 3] = b"lo\0";
pub const __UINTMAX_FMTu__: &[u8; 3] = b"lu\0";
pub const __UINTMAX_FMTx__: &[u8; 3] = b"lx\0";
pub const __UINTMAX_FMTX__: &[u8; 3] = b"lX\0";
pub const __PTRDIFF_FMTd__: &[u8; 3] = b"ld\0";
pub const __PTRDIFF_FMTi__: &[u8; 3] = b"li\0";
pub const __INTPTR_FMTd__: &[u8; 3] = b"ld\0";
pub const __INTPTR_FMTi__: &[u8; 3] = b"li\0";
pub const __SIZE_FMTo__: &[u8; 3] = b"lo\0";
pub const __SIZE_FMTu__: &[u8; 3] = b"lu\0";
pub const __SIZE_FMTx__: &[u8; 3] = b"lx\0";
pub const __SIZE_FMTX__: &[u8; 3] = b"lX\0";
pub const __SIG_ATOMIC_MAX__: i32 = 2147483647;
pub const __SIG_ATOMIC_WIDTH__: i32 = 32;
pub const __UINTPTR_FMTo__: &[u8; 3] = b"lo\0";
pub const __UINTPTR_FMTu__: &[u8; 3] = b"lu\0";
pub const __UINTPTR_FMTx__: &[u8; 3] = b"lx\0";
pub const __UINTPTR_FMTX__: &[u8; 3] = b"lX\0";
pub const __FLT16_HAS_DENORM__: i32 = 1;
pub const __FLT16_DIG__: i32 = 3;
pub const __FLT16_DECIMAL_DIG__: i32 = 5;
pub const __FLT16_HAS_INFINITY__: i32 = 1;
pub const __FLT16_HAS_QUIET_NAN__: i32 = 1;
pub const __FLT16_MANT_DIG__: i32 = 11;
pub const __FLT16_MAX_10_EXP__: i32 = 4;
pub const __FLT16_MAX_EXP__: i32 = 16;
pub const __FLT16_MIN_10_EXP__: i32 = -4;
pub const __FLT16_MIN_EXP__: i32 = -13;
pub const __FLT_HAS_DENORM__: i32 = 1;
pub const __FLT_DIG__: i32 = 6;
pub const __FLT_DECIMAL_DIG__: i32 = 9;
pub const __FLT_HAS_INFINITY__: i32 = 1;
pub const __FLT_HAS_QUIET_NAN__: i32 = 1;
pub const __FLT_MANT_DIG__: i32 = 24;
pub const __FLT_MAX_10_EXP__: i32 = 38;
pub const __FLT_MAX_EXP__: i32 = 128;
pub const __FLT_MIN_10_EXP__: i32 = -37;
pub const __FLT_MIN_EXP__: i32 = -125;
pub const __DBL_HAS_DENORM__: i32 = 1;
pub const __DBL_DIG__: i32 = 15;
pub const __DBL_DECIMAL_DIG__: i32 = 17;
pub const __DBL_HAS_INFINITY__: i32 = 1;
pub const __DBL_HAS_QUIET_NAN__: i32 = 1;
pub const __DBL_MANT_DIG__: i32 = 53;
pub const __DBL_MAX_10_EXP__: i32 = 308;
pub const __DBL_MAX_EXP__: i32 = 1024;
pub const __DBL_MIN_10_EXP__: i32 = -307;
pub const __DBL_MIN_EXP__: i32 = -1021;
pub const __LDBL_HAS_DENORM__: i32 = 1;
pub const __LDBL_DIG__: i32 = 33;
pub const __LDBL_DECIMAL_DIG__: i32 = 36;
pub const __LDBL_HAS_INFINITY__: i32 = 1;
pub const __LDBL_HAS_QUIET_NAN__: i32 = 1;
pub const __LDBL_MANT_DIG__: i32 = 113;
pub const __LDBL_MAX_10_EXP__: i32 = 4932;
pub const __LDBL_MAX_EXP__: i32 = 16384;
pub const __LDBL_MIN_10_EXP__: i32 = -4931;
pub const __LDBL_MIN_EXP__: i32 = -16381;
pub const __POINTER_WIDTH__: i32 = 64;
pub const __BIGGEST_ALIGNMENT__: i32 = 16;
pub const __CHAR_UNSIGNED__: i32 = 1;
pub const __WCHAR_UNSIGNED__: i32 = 1;
pub const __INT8_FMTd__: &[u8; 4] = b"hhd\0";
pub const __INT8_FMTi__: &[u8; 4] = b"hhi\0";
pub const __INT16_FMTd__: &[u8; 3] = b"hd\0";
pub const __INT16_FMTi__: &[u8; 3] = b"hi\0";
pub const __INT32_FMTd__: &[u8; 2] = b"d\0";
pub const __INT32_FMTi__: &[u8; 2] = b"i\0";
pub const __INT64_FMTd__: &[u8; 3] = b"ld\0";
pub const __INT64_FMTi__: &[u8; 3] = b"li\0";
pub const __UINT8_FMTo__: &[u8; 4] = b"hho\0";
pub const __UINT8_FMTu__: &[u8; 4] = b"hhu\0";
pub const __UINT8_FMTx__: &[u8; 4] = b"hhx\0";
pub const __UINT8_FMTX__: &[u8; 4] = b"hhX\0";
pub const __UINT8_MAX__: i32 = 255;
pub const __INT8_MAX__: i32 = 127;
pub const __UINT16_FMTo__: &[u8; 3] = b"ho\0";
pub const __UINT16_FMTu__: &[u8; 3] = b"hu\0";
pub const __UINT16_FMTx__: &[u8; 3] = b"hx\0";
pub const __UINT16_FMTX__: &[u8; 3] = b"hX\0";
pub const __UINT16_MAX__: i32 = 65535;
pub const __INT16_MAX__: i32 = 32767;
pub const __UINT32_FMTo__: &[u8; 2] = b"o\0";
pub const __UINT32_FMTu__: &[u8; 2] = b"u\0";
pub const __UINT32_FMTx__: &[u8; 2] = b"x\0";
pub const __UINT32_FMTX__: &[u8; 2] = b"X\0";
pub const __UINT32_MAX__: i64 = 4294967295;
pub const __INT32_MAX__: i32 = 2147483647;
pub const __UINT64_FMTo__: &[u8; 3] = b"lo\0";
pub const __UINT64_FMTu__: &[u8; 3] = b"lu\0";
pub const __UINT64_FMTx__: &[u8; 3] = b"lx\0";
pub const __UINT64_FMTX__: &[u8; 3] = b"lX\0";
pub const __UINT64_MAX__: i32 = -1;
pub const __INT64_MAX__: i64 = 9223372036854775807;
pub const __INT_LEAST8_MAX__: i32 = 127;
pub const __INT_LEAST8_WIDTH__: i32 = 8;
pub const __INT_LEAST8_FMTd__: &[u8; 4] = b"hhd\0";
pub const __INT_LEAST8_FMTi__: &[u8; 4] = b"hhi\0";
pub const __UINT_LEAST8_MAX__: i32 = 255;
pub const __UINT_LEAST8_FMTo__: &[u8; 4] = b"hho\0";
pub const __UINT_LEAST8_FMTu__: &[u8; 4] = b"hhu\0";
pub const __UINT_LEAST8_FMTx__: &[u8; 4] = b"hhx\0";
pub const __UINT_LEAST8_FMTX__: &[u8; 4] = b"hhX\0";
pub const __INT_LEAST16_MAX__: i32 = 32767;
pub const __INT_LEAST16_WIDTH__: i32 = 16;
pub const __INT_LEAST16_FMTd__: &[u8; 3] = b"hd\0";
pub const __INT_LEAST16_FMTi__: &[u8; 3] = b"hi\0";
pub const __UINT_LEAST16_MAX__: i32 = 65535;
pub const __UINT_LEAST16_FMTo__: &[u8; 3] = b"ho\0";
pub const __UINT_LEAST16_FMTu__: &[u8; 3] = b"hu\0";
pub const __UINT_LEAST16_FMTx__: &[u8; 3] = b"hx\0";
pub const __UINT_LEAST16_FMTX__: &[u8; 3] = b"hX\0";
pub const __INT_LEAST32_MAX__: i32 = 2147483647;
pub const __INT_LEAST32_WIDTH__: i32 = 32;
pub const __INT_LEAST32_FMTd__: &[u8; 2] = b"d\0";
pub const __INT_LEAST32_FMTi__: &[u8; 2] = b"i\0";
pub const __UINT_LEAST32_MAX__: i64 = 4294967295;
pub const __UINT_LEAST32_FMTo__: &[u8; 2] = b"o\0";
pub const __UINT_LEAST32_FMTu__: &[u8; 2] = b"u\0";
pub const __UINT_LEAST32_FMTx__: &[u8; 2] = b"x\0";
pub const __UINT_LEAST32_FMTX__: &[u8; 2] = b"X\0";
pub const __INT_LEAST64_MAX__: i64 = 9223372036854775807;
pub const __INT_LEAST64_WIDTH__: i32 = 64;
pub const __INT_LEAST64_FMTd__: &[u8; 3] = b"ld\0";
pub const __INT_LEAST64_FMTi__: &[u8; 3] = b"li\0";
pub const __UINT_LEAST64_MAX__: i32 = -1;
pub const __UINT_LEAST64_FMTo__: &[u8; 3] = b"lo\0";
pub const __UINT_LEAST64_FMTu__: &[u8; 3] = b"lu\0";
pub const __UINT_LEAST64_FMTx__: &[u8; 3] = b"lx\0";
pub const __UINT_LEAST64_FMTX__: &[u8; 3] = b"lX\0";
pub const __INT_FAST8_MAX__: i32 = 127;
pub const __INT_FAST8_WIDTH__: i32 = 8;
pub const __INT_FAST8_FMTd__: &[u8; 4] = b"hhd\0";
pub const __INT_FAST8_FMTi__: &[u8; 4] = b"hhi\0";
pub const __UINT_FAST8_MAX__: i32 = 255;
pub const __UINT_FAST8_FMTo__: &[u8; 4] = b"hho\0";
pub const __UINT_FAST8_FMTu__: &[u8; 4] = b"hhu\0";
pub const __UINT_FAST8_FMTx__: &[u8; 4] = b"hhx\0";
pub const __UINT_FAST8_FMTX__: &[u8; 4] = b"hhX\0";
pub const __INT_FAST16_MAX__: i32 = 32767;
pub const __INT_FAST16_WIDTH__: i32 = 16;
pub const __INT_FAST16_FMTd__: &[u8; 3] = b"hd\0";
pub const __INT_FAST16_FMTi__: &[u8; 3] = b"hi\0";
pub const __UINT_FAST16_MAX__: i32 = 65535;
pub const __UINT_FAST16_FMTo__: &[u8; 3] = b"ho\0";
pub const __UINT_FAST16_FMTu__: &[u8; 3] = b"hu\0";
pub const __UINT_FAST16_FMTx__: &[u8; 3] = b"hx\0";
pub const __UINT_FAST16_FMTX__: &[u8; 3] = b"hX\0";
pub const __INT_FAST32_MAX__: i32 = 2147483647;
pub const __INT_FAST32_WIDTH__: i32 = 32;
pub const __INT_FAST32_FMTd__: &[u8; 2] = b"d\0";
pub const __INT_FAST32_FMTi__: &[u8; 2] = b"i\0";
pub const __UINT_FAST32_MAX__: i64 = 4294967295;
pub const __UINT_FAST32_FMTo__: &[u8; 2] = b"o\0";
pub const __UINT_FAST32_FMTu__: &[u8; 2] = b"u\0";
pub const __UINT_FAST32_FMTx__: &[u8; 2] = b"x\0";
pub const __UINT_FAST32_FMTX__: &[u8; 2] = b"X\0";
pub const __INT_FAST64_MAX__: i64 = 9223372036854775807;
pub const __INT_FAST64_WIDTH__: i32 = 64;
pub const __INT_FAST64_FMTd__: &[u8; 3] = b"ld\0";
pub const __INT_FAST64_FMTi__: &[u8; 3] = b"li\0";
pub const __UINT_FAST64_MAX__: i32 = -1;
pub const __UINT_FAST64_FMTo__: &[u8; 3] = b"lo\0";
pub const __UINT_FAST64_FMTu__: &[u8; 3] = b"lu\0";
pub const __UINT_FAST64_FMTx__: &[u8; 3] = b"lx\0";
pub const __UINT_FAST64_FMTX__: &[u8; 3] = b"lX\0";
pub const __FINITE_MATH_ONLY__: i32 = 0;
pub const __GNUC_STDC_INLINE__: i32 = 1;
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL: i32 = 1;
pub const __GCC_DESTRUCTIVE_SIZE: i32 = 256;
pub const __GCC_CONSTRUCTIVE_SIZE: i32 = 64;
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE: i32 = 2;
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE: i32 = 2;
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE: i32 = 2;
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE: i32 = 2;
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE: i32 = 2;
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE: i32 = 2;
pub const __CLANG_ATOMIC_INT_LOCK_FREE: i32 = 2;
pub const __CLANG_ATOMIC_LONG_LOCK_FREE: i32 = 2;
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE: i32 = 2;
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE: i32 = 2;
pub const __GCC_ATOMIC_BOOL_LOCK_FREE: i32 = 2;
pub const __GCC_ATOMIC_CHAR_LOCK_FREE: i32 = 2;
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE: i32 = 2;
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE: i32 = 2;
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE: i32 = 2;
pub const __GCC_ATOMIC_SHORT_LOCK_FREE: i32 = 2;
pub const __GCC_ATOMIC_INT_LOCK_FREE: i32 = 2;
pub const __GCC_ATOMIC_LONG_LOCK_FREE: i32 = 2;
pub const __GCC_ATOMIC_LLONG_LOCK_FREE: i32 = 2;
pub const __GCC_ATOMIC_POINTER_LOCK_FREE: i32 = 2;
pub const __FLT_RADIX__: i32 = 2;
pub const __DECIMAL_DIG__: i32 = 36;
pub const __SSP__: i32 = 1;
pub const __ELF__: i32 = 1;
pub const __AARCH64EL__: i32 = 1;
pub const __aarch64__: i32 = 1;
pub const __GCC_ASM_FLAG_OUTPUTS__: i32 = 1;
pub const __AARCH64_CMODEL_SMALL__: i32 = 1;
pub const __ARM_ACLE: i32 = 202420;
pub const __FUNCTION_MULTI_VERSIONING_SUPPORT_LEVEL: i32 = 202430;
pub const __ARM_ARCH: i32 = 8;
pub const __ARM_ARCH_PROFILE: u8 = 65u8;
pub const __ARM_64BIT_STATE: i32 = 1;
pub const __ARM_PCS_AAPCS64: i32 = 1;
pub const __ARM_ARCH_ISA_A64: i32 = 1;
pub const __ARM_FEATURE_CLZ: i32 = 1;
pub const __ARM_FEATURE_FMA: i32 = 1;
pub const __ARM_FEATURE_LDREX: i32 = 15;
pub const __ARM_FEATURE_IDIV: i32 = 1;
pub const __ARM_FEATURE_DIV: i32 = 1;
pub const __ARM_FEATURE_NUMERIC_MAXMIN: i32 = 1;
pub const __ARM_FEATURE_DIRECTED_ROUNDING: i32 = 1;
pub const __ARM_ALIGN_MAX_STACK_PWR: i32 = 4;
pub const __ARM_STATE_ZA: i32 = 1;
pub const __ARM_STATE_ZT0: i32 = 1;
pub const __ARM_FP16_FORMAT_IEEE: i32 = 1;
pub const __ARM_FP16_ARGS: i32 = 1;
pub const __ARM_NEON_SVE_BRIDGE: i32 = 1;
pub const __ARM_SIZEOF_WCHAR_T: i32 = 4;
pub const __ARM_SIZEOF_MINIMAL_ENUM: i32 = 4;
pub const __ARM_FEATURE_UNALIGNED: i32 = 1;
pub const __ARM_FEATURE_PAC_DEFAULT: i32 = 1;
pub const __ARM_FEATURE_BTI_DEFAULT: i32 = 1;
pub const __ARM_FEATURE_GCS_DEFAULT: i32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1: i32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2: i32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4: i32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8: i32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16: i32 = 1;
pub const __FP_FAST_FMA: i32 = 1;
pub const __FP_FAST_FMAF: i32 = 1;
pub const __STDC__: i32 = 1;
pub const __STDC_HOSTED__: i32 = 0;
pub const __STDC_VERSION__: i32 = 201710;
pub const __STDC_UTF_16__: i32 = 1;
pub const __STDC_UTF_32__: i32 = 1;
pub const __STDC_EMBED_NOT_FOUND__: i32 = 0;
pub const __STDC_EMBED_FOUND__: i32 = 1;
pub const __STDC_EMBED_EMPTY__: i32 = 2;
pub const _KERNEL: i32 = 1;
pub const HAVE_KERNEL_OPTION_HEADERS: i32 = 1;
pub const LINUX_DTS_VERSION: &[u8; 5] = b"6.12\0";
pub const BINDGEN: i32 = 1;
pub const __GCC_HAVE_DWARF2_CFI_ASM: i32 = 1;
pub const RANDOM_ENABLE_KBD: i32 = 1;
pub const RANDOM_ENABLE_TPM: i32 = 1;
pub const EXTERR_STRINGS: i32 = 1;
pub const KDB: i32 = 1;
pub const AUDIT: i32 = 1;
pub const COMPAT_FREEBSD11: i32 = 1;
pub const COMPAT_FREEBSD13: i32 = 1;
pub const KDTRACE_HOOKS: i32 = 1;
pub const MAC: i32 = 1;
pub const DEBUGNET: i32 = 1;
pub const NETLINK: i32 = 1;
pub const TCP_HHOOK: i32 = 1;
pub const INVARIANTS: i32 = 1;
pub const NUMA: i32 = 1;
pub const DEV_NETMAP: i32 = 1;
pub const RACCT: i32 = 1;
pub const RCTL: i32 = 1;
pub const INTRNG: i32 = 1;
pub const LINUX_BOOT_ABI: i32 = 1;
pub const COMPAT_FREEBSD32: i32 = 1;
pub const PERTHREAD_SSP: i32 = 1;
pub const VFP: i32 = 1;
pub const ARM64: i32 = 1;
pub const RACCT_DEFAULT_TO_DISABLED: i32 = 1;
pub const VIMAGE: i32 = 1;
pub const WITNESS: i32 = 1;
pub const SMP: i32 = 1;
pub const INVARIANT_SUPPORT: i32 = 1;
pub const TCP_BLACKBOX: i32 = 1;
pub const NETDUMP: i32 = 1;
pub const PCI_IOV: i32 = 1;
pub const KDTRACE_MIB_SDT: i32 = 1;
pub const COMPAT_FREEBSD14: i32 = 1;
pub const COMPAT_FREEBSD12: i32 = 1;
pub const CC_CUBIC: i32 = 1;
pub const QUEUE_MACRO_DEBUG_TRASH: i32 = 1;
pub const FULL_BUF_TRACKING: i32 = 1;
pub const BUF_TRACKING: i32 = 1;
pub const RANDOM_ENABLE_MOUSE: i32 = 1;
pub const FDT: i32 = 1;
pub const __CC_SUPPORTS___INLINE: i32 = 1;
pub const __CC_SUPPORTS_SYMVER: i32 = 1;
pub const __POSIX_VISIBLE: i32 = 202405;
pub const __XSI_VISIBLE: i32 = 800;
pub const __BSD_VISIBLE: i32 = 1;
pub const __ISO_C_VISIBLE: i32 = 2023;
pub const __EXT1_VISIBLE: i32 = 1;
pub const NBBY: i32 = 8;
pub const BSD: i32 = 199506;
pub const BSD4_3: i32 = 1;
pub const BSD4_4: i32 = 1;
pub const __FreeBSD_version: i32 = 1600004;
pub const P_OSREL_SIGWAIT: i32 = 700000;
pub const P_OSREL_SIGSEGV: i32 = 700004;
pub const P_OSREL_MAP_ANON: i32 = 800104;
pub const P_OSREL_MAP_FSTRICT: i32 = 1100036;
pub const P_OSREL_SHUTDOWN_ENOTCONN: i32 = 1100077;
pub const P_OSREL_MAP_GUARD: i32 = 1200035;
pub const P_OSREL_WRFSBASE: i32 = 1200041;
pub const P_OSREL_CK_CYLGRP: i32 = 1200046;
pub const P_OSREL_VMTOTAL64: i32 = 1200054;
pub const P_OSREL_CK_SUPERBLOCK: i32 = 1300000;
pub const P_OSREL_CK_INODE: i32 = 1300005;
pub const P_OSREL_POWERPC_NEW_AUX_ARGS: i32 = 1300070;
pub const P_OSREL_TIDPID: i32 = 1400079;
pub const P_OSREL_ARM64_SPSR: i32 = 1400084;
pub const P_OSREL_TLSBASE: i32 = 1500044;
pub const P_OSREL_EXTERRCTL: i32 = 1500045;
pub const __WCHAR_MIN: i32 = 0;
pub const _BYTE_ORDER: i32 = 1234;
pub const _LITTLE_ENDIAN: i32 = 1234;
pub const _BIG_ENDIAN: i32 = 4321;
pub const _PDP_ENDIAN: i32 = 3412;
pub const _QUAD_HIGHWORD: i32 = 1;
pub const _QUAD_LOWWORD: i32 = 0;
pub const LITTLE_ENDIAN: i32 = 1234;
pub const BIG_ENDIAN: i32 = 4321;
pub const PDP_ENDIAN: i32 = 3412;
pub const BYTE_ORDER: i32 = 1234;
pub const __bool_true_false_are_defined: i32 = 1;
pub const false_: i32 = 0;
pub const true_: i32 = 1;
pub const _SIG_WORDS: i32 = 4;
pub const _SIG_MAXSIG: i32 = 128;
pub const __SSP_FORTIFY_LEVEL: i32 = 0;
pub const FD_SETSIZE: i32 = 1024;
pub const ARG_MAX: i32 = 524288;
pub const CHILD_MAX: i32 = 40;
pub const MAX_CANON: i32 = 255;
pub const MAX_INPUT: i32 = 255;
pub const NAME_MAX: i32 = 255;
pub const NGROUPS_MAX: i32 = 1023;
pub const OPEN_MAX: i32 = 64;
pub const PATH_MAX: i32 = 1024;
pub const PIPE_BUF: i32 = 512;
pub const IOV_MAX: i32 = 1024;
pub const MAXCOMLEN: i32 = 19;
pub const MAXINTERP: i32 = 1024;
pub const MAXLOGNAME: i32 = 33;
pub const MAXUPRC: i32 = 40;
pub const NCARGS: i32 = 524288;
pub const NGROUPS: i32 = 1024;
pub const NOFILE: i32 = 64;
pub const NOGROUP: i32 = 65535;
pub const MAXHOSTNAMELEN: i32 = 256;
pub const SPECNAMELEN: i32 = 255;
pub const EPERM: i32 = 1;
pub const ENOENT: i32 = 2;
pub const ESRCH: i32 = 3;
pub const EINTR: i32 = 4;
pub const EIO: i32 = 5;
pub const ENXIO: i32 = 6;
pub const E2BIG: i32 = 7;
pub const ENOEXEC: i32 = 8;
pub const EBADF: i32 = 9;
pub const ECHILD: i32 = 10;
pub const EDEADLK: i32 = 11;
pub const ENOMEM: i32 = 12;
pub const EACCES: i32 = 13;
pub const EFAULT: i32 = 14;
pub const ENOTBLK: i32 = 15;
pub const EBUSY: i32 = 16;
pub const EEXIST: i32 = 17;
pub const EXDEV: i32 = 18;
pub const ENODEV: i32 = 19;
pub const ENOTDIR: i32 = 20;
pub const EISDIR: i32 = 21;
pub const EINVAL: i32 = 22;
pub const ENFILE: i32 = 23;
pub const EMFILE: i32 = 24;
pub const ENOTTY: i32 = 25;
pub const ETXTBSY: i32 = 26;
pub const EFBIG: i32 = 27;
pub const ENOSPC: i32 = 28;
pub const ESPIPE: i32 = 29;
pub const EROFS: i32 = 30;
pub const EMLINK: i32 = 31;
pub const EPIPE: i32 = 32;
pub const EDOM: i32 = 33;
pub const ERANGE: i32 = 34;
pub const EAGAIN: i32 = 35;
pub const EWOULDBLOCK: i32 = 35;
pub const EINPROGRESS: i32 = 36;
pub const EALREADY: i32 = 37;
pub const ENOTSOCK: i32 = 38;
pub const EDESTADDRREQ: i32 = 39;
pub const EMSGSIZE: i32 = 40;
pub const EPROTOTYPE: i32 = 41;
pub const ENOPROTOOPT: i32 = 42;
pub const EPROTONOSUPPORT: i32 = 43;
pub const ESOCKTNOSUPPORT: i32 = 44;
pub const EOPNOTSUPP: i32 = 45;
pub const ENOTSUP: i32 = 45;
pub const EPFNOSUPPORT: i32 = 46;
pub const EAFNOSUPPORT: i32 = 47;
pub const EADDRINUSE: i32 = 48;
pub const EADDRNOTAVAIL: i32 = 49;
pub const ENETDOWN: i32 = 50;
pub const ENETUNREACH: i32 = 51;
pub const ENETRESET: i32 = 52;
pub const ECONNABORTED: i32 = 53;
pub const ECONNRESET: i32 = 54;
pub const ENOBUFS: i32 = 55;
pub const EISCONN: i32 = 56;
pub const ENOTCONN: i32 = 57;
pub const ESHUTDOWN: i32 = 58;
pub const ETOOMANYREFS: i32 = 59;
pub const ETIMEDOUT: i32 = 60;
pub const ECONNREFUSED: i32 = 61;
pub const ELOOP: i32 = 62;
pub const ENAMETOOLONG: i32 = 63;
pub const EHOSTDOWN: i32 = 64;
pub const EHOSTUNREACH: i32 = 65;
pub const ENOTEMPTY: i32 = 66;
pub const EPROCLIM: i32 = 67;
pub const EUSERS: i32 = 68;
pub const EDQUOT: i32 = 69;
pub const ESTALE: i32 = 70;
pub const EREMOTE: i32 = 71;
pub const EBADRPC: i32 = 72;
pub const ERPCMISMATCH: i32 = 73;
pub const EPROGUNAVAIL: i32 = 74;
pub const EPROGMISMATCH: i32 = 75;
pub const EPROCUNAVAIL: i32 = 76;
pub const ENOLCK: i32 = 77;
pub const ENOSYS: i32 = 78;
pub const EFTYPE: i32 = 79;
pub const EAUTH: i32 = 80;
pub const ENEEDAUTH: i32 = 81;
pub const EIDRM: i32 = 82;
pub const ENOMSG: i32 = 83;
pub const EOVERFLOW: i32 = 84;
pub const ECANCELED: i32 = 85;
pub const EILSEQ: i32 = 86;
pub const ENOATTR: i32 = 87;
pub const EDOOFUS: i32 = 88;
pub const EBADMSG: i32 = 89;
pub const EMULTIHOP: i32 = 90;
pub const ENOLINK: i32 = 91;
pub const EPROTO: i32 = 92;
pub const ENOTCAPABLE: i32 = 93;
pub const ECAPMODE: i32 = 94;
pub const ENOTRECOVERABLE: i32 = 95;
pub const EOWNERDEAD: i32 = 96;
pub const EINTEGRITY: i32 = 97;
pub const ELAST: i32 = 97;
pub const ERESTART: i32 = -1;
pub const EJUSTRETURN: i32 = -2;
pub const ENOIOCTL: i32 = -3;
pub const EDIRIOCTL: i32 = -4;
pub const ERELOOKUP: i32 = -5;
pub const CLOCK_REALTIME: i32 = 0;
pub const CLOCK_VIRTUAL: i32 = 1;
pub const CLOCK_PROF: i32 = 2;
pub const CLOCK_MONOTONIC: i32 = 4;
pub const CLOCK_UPTIME_FAST: i32 = 8;
pub const CLOCK_UPTIME: i32 = 5;
pub const CLOCK_UPTIME_PRECISE: i32 = 7;
pub const CLOCK_REALTIME_PRECISE: i32 = 9;
pub const CLOCK_REALTIME_FAST: i32 = 10;
pub const CLOCK_MONOTONIC_PRECISE: i32 = 11;
pub const CLOCK_MONOTONIC_FAST: i32 = 12;
pub const CLOCK_SECOND: i32 = 13;
pub const CLOCK_THREAD_CPUTIME_ID: i32 = 14;
pub const CLOCK_PROCESS_CPUTIME_ID: i32 = 15;
pub const CLOCK_TAI: i32 = 16;
pub const CLOCK_BOOTTIME: i32 = 4;
pub const CLOCK_REALTIME_COARSE: i32 = 10;
pub const CLOCK_MONOTONIC_COARSE: i32 = 12;
pub const TIMER_RELTIME: i32 = 0;
pub const TIMER_ABSTIME: i32 = 1;
pub const DST_NONE: i32 = 0;
pub const DST_USA: i32 = 1;
pub const DST_AUST: i32 = 2;
pub const DST_WET: i32 = 3;
pub const DST_MET: i32 = 4;
pub const DST_EET: i32 = 5;
pub const DST_CAN: i32 = 6;
pub const SBT_MAX: i64 = 9223372036854775807;
pub const ITIMER_REAL: i32 = 0;
pub const ITIMER_VIRTUAL: i32 = 1;
pub const ITIMER_PROF: i32 = 2;
pub const CPUCLOCK_WHICH_PID: i32 = 0;
pub const CPUCLOCK_WHICH_TID: i32 = 1;
pub const HZ_MINIMUM: i32 = 8;
pub const TC_DEFAULTPERC: i32 = 5;
pub const PRI_ITHD: i32 = 1;
pub const PRI_REALTIME: i32 = 2;
pub const PRI_TIMESHARE: i32 = 3;
pub const PRI_IDLE: i32 = 4;
pub const PRI_FIFO_BIT: i32 = 8;
pub const PRI_FIFO: i32 = 10;
pub const PRI_MIN: i32 = 0;
pub const PRI_MAX: i32 = 255;
pub const PRI_MIN_ITHD: i32 = 0;
pub const PI_REALTIME: i32 = 0;
pub const PI_INTR: i32 = 1;
pub const PI_AV: i32 = 1;
pub const PI_NET: i32 = 1;
pub const PI_DISK: i32 = 1;
pub const PI_TTY: i32 = 1;
pub const PI_DULL: i32 = 1;
pub const PI_SOFT: i32 = 2;
pub const PI_SOFTCLOCK: i32 = 2;
pub const PRI_MIN_REALTIME: i32 = 8;
pub const PRI_MIN_KERN: i32 = 40;
pub const PSWP: i32 = 40;
pub const PVM: i32 = 41;
pub const PINOD: i32 = 42;
pub const PRIBIO: i32 = 43;
pub const PVFS: i32 = 44;
pub const PZERO: i32 = 45;
pub const PSOCK: i32 = 46;
pub const PWAIT: i32 = 47;
pub const PLOCK: i32 = 48;
pub const PPAUSE: i32 = 49;
pub const PRI_MIN_TIMESHARE: i32 = 56;
pub const PUSER: i32 = 56;
pub const PRI_MIN_IDLE: i32 = 224;
pub const PRI_MAX_IDLE: i32 = 255;
pub const PRI_USER: i32 = -2;
pub const PRI_UNCHANGED: i32 = -1;
pub const FALSE: i32 = 0;
pub const TRUE: i32 = 1;
pub const STACKALIGNBYTES: i32 = 15;
pub const MACHINE: &[u8; 6] = b"arm64\0";
pub const MACHINE_ARCH: &[u8; 8] = b"aarch64\0";
pub const MACHINE_ARCH32: &[u8; 6] = b"armv7\0";
pub const MAXCPU: i32 = 1024;
pub const MAXMEMDOM: i32 = 8;
pub const CACHE_LINE_SHIFT: i32 = 7;
pub const CACHE_LINE_SIZE: i32 = 128;
pub const PAGE_SHIFT_4K: i32 = 12;
pub const PAGE_SIZE_4K: i32 = 4096;
pub const PAGE_SHIFT_16K: i32 = 14;
pub const PAGE_SIZE_16K: i32 = 16384;
pub const PAGE_SHIFT_64K: i32 = 16;
pub const PAGE_SIZE_64K: i32 = 65536;
pub const PAGE_SHIFT: i32 = 12;
pub const PAGE_SIZE: i32 = 4096;
pub const PAGE_MASK: i32 = 4095;
pub const MAXPAGESIZES: i32 = 4;
pub const KSTACK_PAGES: i32 = 4;
pub const KSTACK_GUARD_PAGES: i32 = 1;
pub const PCPU_PAGES: i32 = 1;
pub const DEV_BSHIFT: i32 = 9;
pub const DEV_BSIZE: i32 = 512;
pub const BLKDEV_IOSIZE: i32 = 4096;
pub const DFLTPHYS: i32 = 65536;
pub const MAXDUMPPGS: i32 = 16;
pub const MSIZE: i32 = 256;
pub const MCLSHIFT: i32 = 11;
pub const MCLBYTES: i32 = 2048;
pub const MJUMPAGESIZE: i32 = 4096;
pub const MJUM9BYTES: i32 = 9216;
pub const MJUM16BYTES: i32 = 16384;
pub const PRIMASK: i32 = 255;
pub const PCATCH: i32 = 256;
pub const PDROP: i32 = 512;
pub const PNOLOCK: i32 = 1024;
pub const PRILASTFLAG: i32 = 1024;
pub const NZERO: i32 = 0;
pub const CMASK: i32 = 18;
pub const MAXBSIZE: i32 = 65536;
pub const MAXBCACHEBUF: i32 = 65536;
pub const BKVASIZE: i32 = 16384;
pub const BKVAMASK: i32 = 16383;
pub const MAXPATHLEN: i32 = 1024;
pub const MAXSYMLINKS: i32 = 32;
pub const FSHIFT: i32 = 11;
pub const FSCALE: i32 = 2048;
pub const __CHAR_BIT: i32 = 8;
pub const __SCHAR_MAX: i32 = 127;
pub const __SCHAR_MIN: i32 = -128;
pub const __UCHAR_MAX: i32 = 255;
pub const __USHRT_MAX: i32 = 65535;
pub const __SHRT_MAX: i32 = 32767;
pub const __SHRT_MIN: i32 = -32768;
pub const __UINT_MAX: i64 = 4294967295;
pub const __INT_MAX: i32 = 2147483647;
pub const __INT_MIN: i32 = -2147483648;
pub const __ULONG_MAX: i32 = -1;
pub const __LONG_MAX: i64 = 9223372036854775807;
pub const __LONG_MIN: i64 = -9223372036854775808;
pub const __ULLONG_MAX: i32 = -1;
pub const __LLONG_MAX: i64 = 9223372036854775807;
pub const __LLONG_MIN: i64 = -9223372036854775808;
pub const __SSIZE_MAX: i64 = 9223372036854775807;
pub const __SIZE_T_MAX: i32 = -1;
pub const __OFF_MAX: i64 = 9223372036854775807;
pub const __OFF_MIN: i64 = -9223372036854775808;
pub const __UQUAD_MAX: i32 = -1;
pub const __QUAD_MAX: i64 = 9223372036854775807;
pub const __QUAD_MIN: i64 = -9223372036854775808;
pub const __LONG_BIT: i32 = 64;
pub const __WORD_BIT: i32 = 32;
pub const __MINSIGSTKSZ: i32 = 4096;
pub const IOCPARM_SHIFT: i32 = 13;
pub const IOCPARM_MASK: i32 = 8191;
pub const IOCPARM_MAX: i32 = 8192;
pub const IOC_VOID: i32 = 536870912;
pub const IOC_OUT: i32 = 1073741824;
pub const IOC_IN: i64 = 2147483648;
pub const IOC_INOUT: i64 = 3221225472;
pub const IOC_DIRMASK: i64 = 3758096384;
pub const BUS_USER_VERSION: i32 = 2;
pub const BUS_USER_BUFFER: i32 = 3072;
pub const DF_ENABLED: i32 = 1;
pub const DF_FIXEDCLASS: i32 = 2;
pub const DF_WILDCARD: i32 = 4;
pub const DF_DESCMALLOCED: i32 = 8;
pub const DF_QUIET: i32 = 16;
pub const DF_DONENOMATCH: i32 = 32;
pub const DF_EXTERNALSOFTC: i32 = 64;
pub const DF_SUSPENDED: i32 = 256;
pub const DF_QUIET_CHILDREN: i32 = 512;
pub const DF_ATTACHED_ONCE: i32 = 1024;
pub const DF_NEEDNOMATCH: i32 = 2048;
pub const DEVF_FORCE_DETACH: i32 = 1;
pub const DEVF_SET_DRIVER_DETACH: i32 = 1;
pub const DEVF_CLEAR_DRIVER_DETACH: i32 = 1;
pub const DEVF_FORCE_DELETE: i32 = 1;
pub const DEVF_RESET_DETACH: i32 = 1;
pub const DEVICE_UNIT_ANY: i32 = -1;
pub const EHE_DEAD_PRIORITY: i32 = -1;
pub const KOBJ_CACHE_SIZE: i32 = 256;
pub const CALLOUT_TRYLOCK: i32 = 1;
pub const CALLOUT_ACTIVE: i32 = 2;
pub const CALLOUT_PENDING: i32 = 4;
pub const CALLOUT_MPSAFE: i32 = 8;
pub const CALLOUT_RETURNUNLOCKED: i32 = 16;
pub const CALLOUT_SHAREDLOCK: i32 = 32;
pub const CALLOUT_DFRMIGRATION: i32 = 64;
pub const CALLOUT_PROCESSED: i32 = 128;
pub const CALLOUT_DIRECT: i32 = 256;
pub const C_DIRECT_EXEC: i32 = 1;
pub const C_PRELBITS: i32 = 7;
pub const C_PRELRANGE: i32 = 127;
pub const C_HARDCLOCK: i32 = 256;
pub const C_ABSOLUTE: i32 = 512;
pub const C_PRECALC: i32 = 1024;
pub const C_CATCH: i32 = 2048;
pub const CS_DRAIN: i32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT8_MAX: i32 = 127;
pub const INT16_MAX: i32 = 32767;
pub const INT32_MAX: i32 = 2147483647;
pub const INT64_MAX: i64 = 9223372036854775807;
pub const UINT8_MAX: i32 = 255;
pub const UINT16_MAX: i32 = 65535;
pub const UINT32_MAX: i64 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: i32 = 127;
pub const INT_LEAST16_MAX: i32 = 32767;
pub const INT_LEAST32_MAX: i32 = 2147483647;
pub const INT_LEAST64_MAX: i64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: i32 = 255;
pub const UINT_LEAST16_MAX: i32 = 65535;
pub const UINT_LEAST32_MAX: i64 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -2147483648;
pub const INT_FAST16_MIN: i32 = -2147483648;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: i32 = 2147483647;
pub const INT_FAST16_MAX: i32 = 2147483647;
pub const INT_FAST32_MAX: i32 = 2147483647;
pub const INT_FAST64_MAX: i64 = 9223372036854775807;
pub const UINT_FAST8_MAX: i64 = 4294967295;
pub const UINT_FAST16_MAX: i64 = 4294967295;
pub const UINT_FAST32_MAX: i64 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: i64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: i64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: i64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i64 = -9223372036854775808;
pub const SIG_ATOMIC_MAX: i64 = 9223372036854775807;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: i32 = 2147483647;
pub const __WORDSIZE: i32 = 64;
pub const WCHAR_MIN: i32 = 0;
pub const RSIZE_MAX: i32 = -1;
pub const INSN_SIZE: i32 = 4;
pub const AFSR0_EL1_op0: i32 = 3;
pub const AFSR0_EL1_op1: i32 = 0;
pub const AFSR0_EL1_CRn: i32 = 5;
pub const AFSR0_EL1_CRm: i32 = 1;
pub const AFSR0_EL1_op2: i32 = 0;
pub const AFSR0_EL12_op0: i32 = 3;
pub const AFSR0_EL12_op1: i32 = 5;
pub const AFSR0_EL12_CRn: i32 = 5;
pub const AFSR0_EL12_CRm: i32 = 1;
pub const AFSR0_EL12_op2: i32 = 0;
pub const AFSR1_EL1_op0: i32 = 3;
pub const AFSR1_EL1_op1: i32 = 0;
pub const AFSR1_EL1_CRn: i32 = 5;
pub const AFSR1_EL1_CRm: i32 = 1;
pub const AFSR1_EL1_op2: i32 = 1;
pub const AFSR1_EL12_op0: i32 = 3;
pub const AFSR1_EL12_op1: i32 = 5;
pub const AFSR1_EL12_CRn: i32 = 5;
pub const AFSR1_EL12_CRm: i32 = 1;
pub const AFSR1_EL12_op2: i32 = 1;
pub const AMAIR_EL1_op0: i32 = 3;
pub const AMAIR_EL1_op1: i32 = 0;
pub const AMAIR_EL1_CRn: i32 = 10;
pub const AMAIR_EL1_CRm: i32 = 3;
pub const AMAIR_EL1_op2: i32 = 0;
pub const AMAIR_EL12_op0: i32 = 3;
pub const AMAIR_EL12_op1: i32 = 5;
pub const AMAIR_EL12_CRn: i32 = 10;
pub const AMAIR_EL12_CRm: i32 = 3;
pub const AMAIR_EL12_op2: i32 = 0;
pub const APDAKeyHi_EL1_op0: i32 = 3;
pub const APDAKeyHi_EL1_op1: i32 = 0;
pub const APDAKeyHi_EL1_CRn: i32 = 2;
pub const APDAKeyHi_EL1_CRm: i32 = 2;
pub const APDAKeyHi_EL1_op2: i32 = 1;
pub const APDAKeyLo_EL1_op0: i32 = 3;
pub const APDAKeyLo_EL1_op1: i32 = 0;
pub const APDAKeyLo_EL1_CRn: i32 = 2;
pub const APDAKeyLo_EL1_CRm: i32 = 2;
pub const APDAKeyLo_EL1_op2: i32 = 0;
pub const APDBKeyHi_EL1_op0: i32 = 3;
pub const APDBKeyHi_EL1_op1: i32 = 0;
pub const APDBKeyHi_EL1_CRn: i32 = 2;
pub const APDBKeyHi_EL1_CRm: i32 = 2;
pub const APDBKeyHi_EL1_op2: i32 = 3;
pub const APDBKeyLo_EL1_op0: i32 = 3;
pub const APDBKeyLo_EL1_op1: i32 = 0;
pub const APDBKeyLo_EL1_CRn: i32 = 2;
pub const APDBKeyLo_EL1_CRm: i32 = 2;
pub const APDBKeyLo_EL1_op2: i32 = 2;
pub const APGAKeyHi_EL1_op0: i32 = 3;
pub const APGAKeyHi_EL1_op1: i32 = 0;
pub const APGAKeyHi_EL1_CRn: i32 = 2;
pub const APGAKeyHi_EL1_CRm: i32 = 3;
pub const APGAKeyHi_EL1_op2: i32 = 1;
pub const APGAKeyLo_EL1_op0: i32 = 3;
pub const APGAKeyLo_EL1_op1: i32 = 0;
pub const APGAKeyLo_EL1_CRn: i32 = 2;
pub const APGAKeyLo_EL1_CRm: i32 = 3;
pub const APGAKeyLo_EL1_op2: i32 = 0;
pub const APIAKeyHi_EL1_op0: i32 = 3;
pub const APIAKeyHi_EL1_op1: i32 = 0;
pub const APIAKeyHi_EL1_CRn: i32 = 2;
pub const APIAKeyHi_EL1_CRm: i32 = 1;
pub const APIAKeyHi_EL1_op2: i32 = 1;
pub const APIAKeyLo_EL1_op0: i32 = 3;
pub const APIAKeyLo_EL1_op1: i32 = 0;
pub const APIAKeyLo_EL1_CRn: i32 = 2;
pub const APIAKeyLo_EL1_CRm: i32 = 1;
pub const APIAKeyLo_EL1_op2: i32 = 0;
pub const APIBKeyHi_EL1_op0: i32 = 3;
pub const APIBKeyHi_EL1_op1: i32 = 0;
pub const APIBKeyHi_EL1_CRn: i32 = 2;
pub const APIBKeyHi_EL1_CRm: i32 = 1;
pub const APIBKeyHi_EL1_op2: i32 = 3;
pub const APIBKeyLo_EL1_op0: i32 = 3;
pub const APIBKeyLo_EL1_op1: i32 = 0;
pub const APIBKeyLo_EL1_CRn: i32 = 2;
pub const APIBKeyLo_EL1_CRm: i32 = 1;
pub const APIBKeyLo_EL1_op2: i32 = 2;
pub const CCSIDR_NumSets_MASK: i32 = 268427264;
pub const CCSIDR_NumSets64_MASK: i64 = 72057589742960640;
pub const CCSIDR_NumSets_SHIFT: i32 = 13;
pub const CCSIDR_NumSets64_SHIFT: i32 = 32;
pub const CCSIDR_Assoc_MASK: i32 = 8184;
pub const CCSIDR_Assoc64_MASK: i32 = 16777208;
pub const CCSIDR_Assoc_SHIFT: i32 = 3;
pub const CCSIDR_Assoc64_SHIFT: i32 = 3;
pub const CCSIDR_LineSize_MASK: i32 = 7;
pub const CLIDR_CTYPE_MASK: i32 = 7;
pub const CLIDR_CTYPE_IO: i32 = 1;
pub const CLIDR_CTYPE_DO: i32 = 2;
pub const CLIDR_CTYPE_ID: i32 = 3;
pub const CLIDR_CTYPE_UNIFIED: i32 = 4;
pub const CNTKCTL_EL1_op0: i32 = 3;
pub const CNTKCTL_EL1_op1: i32 = 0;
pub const CNTKCTL_EL1_CRn: i32 = 14;
pub const CNTKCTL_EL1_CRm: i32 = 1;
pub const CNTKCTL_EL1_op2: i32 = 0;
pub const CNTKCTL_EL12_op0: i32 = 3;
pub const CNTKCTL_EL12_op1: i32 = 5;
pub const CNTKCTL_EL12_CRn: i32 = 14;
pub const CNTKCTL_EL12_CRm: i32 = 1;
pub const CNTKCTL_EL12_op2: i32 = 0;
pub const CNTP_CTL_EL0_op0: i32 = 3;
pub const CNTP_CTL_EL0_op1: i32 = 3;
pub const CNTP_CTL_EL0_CRn: i32 = 14;
pub const CNTP_CTL_EL0_CRm: i32 = 2;
pub const CNTP_CTL_EL0_op2: i32 = 1;
pub const CNTP_CTL_ENABLE: i32 = 1;
pub const CNTP_CTL_IMASK: i32 = 2;
pub const CNTP_CTL_ISTATUS: i32 = 4;
pub const CNTP_CTL_EL02_op0: i32 = 3;
pub const CNTP_CTL_EL02_op1: i32 = 5;
pub const CNTP_CTL_EL02_CRn: i32 = 14;
pub const CNTP_CTL_EL02_CRm: i32 = 2;
pub const CNTP_CTL_EL02_op2: i32 = 1;
pub const CNTP_CVAL_EL0_op0: i32 = 3;
pub const CNTP_CVAL_EL0_op1: i32 = 3;
pub const CNTP_CVAL_EL0_CRn: i32 = 14;
pub const CNTP_CVAL_EL0_CRm: i32 = 2;
pub const CNTP_CVAL_EL0_op2: i32 = 2;
pub const CNTP_CVAL_EL02_op0: i32 = 3;
pub const CNTP_CVAL_EL02_op1: i32 = 5;
pub const CNTP_CVAL_EL02_CRn: i32 = 14;
pub const CNTP_CVAL_EL02_CRm: i32 = 2;
pub const CNTP_CVAL_EL02_op2: i32 = 2;
pub const CNTP_TVAL_EL0_op0: i32 = 3;
pub const CNTP_TVAL_EL0_op1: i32 = 3;
pub const CNTP_TVAL_EL0_CRn: i32 = 14;
pub const CNTP_TVAL_EL0_CRm: i32 = 2;
pub const CNTP_TVAL_EL0_op2: i32 = 0;
pub const CNTPCT_EL0_op0: i32 = 3;
pub const CNTPCT_EL0_op1: i32 = 3;
pub const CNTPCT_EL0_CRn: i32 = 14;
pub const CNTPCT_EL0_CRm: i32 = 0;
pub const CNTPCT_EL0_op2: i32 = 1;
pub const CNTPCTSS_EL0_op0: i32 = 3;
pub const CNTPCTSS_EL0_op1: i32 = 3;
pub const CNTPCTSS_EL0_CRn: i32 = 14;
pub const CNTPCTSS_EL0_CRm: i32 = 0;
pub const CNTPCTSS_EL0_op2: i32 = 5;
pub const CNTV_CTL_EL0_op0: i32 = 3;
pub const CNTV_CTL_EL0_op1: i32 = 3;
pub const CNTV_CTL_EL0_CRn: i32 = 14;
pub const CNTV_CTL_EL0_CRm: i32 = 3;
pub const CNTV_CTL_EL0_op2: i32 = 1;
pub const CNTV_CTL_EL02_op0: i32 = 3;
pub const CNTV_CTL_EL02_op1: i32 = 5;
pub const CNTV_CTL_EL02_CRn: i32 = 14;
pub const CNTV_CTL_EL02_CRm: i32 = 3;
pub const CNTV_CTL_EL02_op2: i32 = 1;
pub const CNTV_CVAL_EL0_op0: i32 = 3;
pub const CNTV_CVAL_EL0_op1: i32 = 3;
pub const CNTV_CVAL_EL0_CRn: i32 = 14;
pub const CNTV_CVAL_EL0_CRm: i32 = 3;
pub const CNTV_CVAL_EL0_op2: i32 = 2;
pub const CNTV_CVAL_EL02_op0: i32 = 3;
pub const CNTV_CVAL_EL02_op1: i32 = 5;
pub const CNTV_CVAL_EL02_CRn: i32 = 14;
pub const CNTV_CVAL_EL02_CRm: i32 = 3;
pub const CNTV_CVAL_EL02_op2: i32 = 2;
pub const CNTVCTSS_EL0_op0: i32 = 3;
pub const CNTVCTSS_EL0_op1: i32 = 3;
pub const CNTVCTSS_EL0_CRn: i32 = 14;
pub const CNTVCTSS_EL0_CRm: i32 = 0;
pub const CNTVCTSS_EL0_op2: i32 = 6;
pub const CONTEXTIDR_EL1_op0: i32 = 3;
pub const CONTEXTIDR_EL1_op1: i32 = 0;
pub const CONTEXTIDR_EL1_CRn: i32 = 13;
pub const CONTEXTIDR_EL1_CRm: i32 = 0;
pub const CONTEXTIDR_EL1_op2: i32 = 1;
pub const CONTEXTIDR_EL12_op0: i32 = 3;
pub const CONTEXTIDR_EL12_op1: i32 = 5;
pub const CONTEXTIDR_EL12_CRn: i32 = 13;
pub const CONTEXTIDR_EL12_CRm: i32 = 0;
pub const CONTEXTIDR_EL12_op2: i32 = 1;
pub const CPACR_EL1_op0: i32 = 3;
pub const CPACR_EL1_op1: i32 = 0;
pub const CPACR_EL1_CRn: i32 = 1;
pub const CPACR_EL1_CRm: i32 = 0;
pub const CPACR_EL1_op2: i32 = 2;
pub const CPACR_ZEN_MASK: i32 = 196608;
pub const CPACR_ZEN_TRAP_ALL1: i32 = 0;
pub const CPACR_ZEN_TRAP_EL0: i32 = 65536;
pub const CPACR_ZEN_TRAP_ALL2: i32 = 131072;
pub const CPACR_ZEN_TRAP_NONE: i32 = 196608;
pub const CPACR_FPEN_MASK: i32 = 3145728;
pub const CPACR_FPEN_TRAP_ALL1: i32 = 0;
pub const CPACR_FPEN_TRAP_EL0: i32 = 1048576;
pub const CPACR_FPEN_TRAP_ALL2: i32 = 2097152;
pub const CPACR_FPEN_TRAP_NONE: i32 = 3145728;
pub const CPACR_TTA: i32 = 268435456;
pub const CPACR_EL12_op0: i32 = 3;
pub const CPACR_EL12_op1: i32 = 5;
pub const CPACR_EL12_CRn: i32 = 1;
pub const CPACR_EL12_CRm: i32 = 0;
pub const CPACR_EL12_op2: i32 = 2;
pub const CSSELR_InD: i32 = 1;
pub const CTR_EL0_op0: i32 = 3;
pub const CTR_EL0_op1: i32 = 3;
pub const CTR_EL0_CRn: i32 = 0;
pub const CTR_EL0_CRm: i32 = 0;
pub const CTR_EL0_op2: i32 = 1;
pub const CTR_RES1: i64 = 2147483648;
pub const CTR_TminLine_SHIFT: i32 = 32;
pub const CTR_DIC_SHIFT: i32 = 29;
pub const CTR_DIC_WIDTH: i32 = 1;
pub const CTR_DIC_MASK: i32 = 536870912;
pub const CTR_DIC_NONE: i32 = 0;
pub const CTR_DIC_IMPL: i32 = 536870912;
pub const CTR_IDC_SHIFT: i32 = 28;
pub const CTR_IDC_WIDTH: i32 = 1;
pub const CTR_IDC_MASK: i32 = 268435456;
pub const CTR_IDC_NONE: i32 = 0;
pub const CTR_IDC_IMPL: i32 = 268435456;
pub const CTR_CWG_SHIFT: i32 = 24;
pub const CTR_CWG_WIDTH: i32 = 4;
pub const CTR_CWG_MASK: i32 = 251658240;
pub const CTR_ERG_SHIFT: i32 = 20;
pub const CTR_ERG_WIDTH: i32 = 4;
pub const CTR_ERG_MASK: i32 = 15728640;
pub const CTR_DLINE_SHIFT: i32 = 16;
pub const CTR_DLINE_WIDTH: i32 = 4;
pub const CTR_DLINE_MASK: i32 = 983040;
pub const CTR_L1IP_SHIFT: i32 = 14;
pub const CTR_L1IP_WIDTH: i32 = 2;
pub const CTR_L1IP_MASK: i32 = 49152;
pub const CTR_L1IP_VIPT: i32 = 32768;
pub const CTR_L1IP_PIPT: i32 = 49152;
pub const CTR_ILINE_SHIFT: i32 = 0;
pub const CTR_ILINE_WIDTH: i32 = 4;
pub const CTR_ILINE_MASK: i32 = 15;
pub const CURRENTEL_EL_SHIFT: i32 = 2;
pub const CURRENTEL_EL_MASK: i32 = 12;
pub const CURRENTEL_EL_EL0: i32 = 0;
pub const CURRENTEL_EL_EL1: i32 = 4;
pub const CURRENTEL_EL_EL2: i32 = 8;
pub const CURRENTEL_EL_EL3: i32 = 12;
pub const DAIF_D: i32 = 8;
pub const DAIF_A: i32 = 4;
pub const DAIF_I: i32 = 2;
pub const DAIF_F: i32 = 1;
pub const DAIF_ALL: i32 = 15;
pub const DAIF_INTR: i32 = 3;
pub const DBGBCR_EL1_op0: i32 = 2;
pub const DBGBCR_EL1_op1: i32 = 0;
pub const DBGBCR_EL1_CRn: i32 = 0;
pub const DBGBCR_EL1_op2: i32 = 5;
pub const DBGBCR_EN: i32 = 1;
pub const DBGBCR_PMC_SHIFT: i32 = 1;
pub const DBGBCR_PMC: i32 = 6;
pub const DBGBCR_PMC_EL1: i32 = 2;
pub const DBGBCR_PMC_EL0: i32 = 4;
pub const DBGBCR_BAS_SHIFT: i32 = 5;
pub const DBGBCR_BAS: i32 = 480;
pub const DBGBCR_HMC_SHIFT: i32 = 13;
pub const DBGBCR_HMC: i32 = 8192;
pub const DBGBCR_SSC_SHIFT: i32 = 14;
pub const DBGBCR_SSC: i32 = 49152;
pub const DBGBCR_LBN_SHIFT: i32 = 16;
pub const DBGBCR_LBN: i32 = 983040;
pub const DBGBCR_BT_SHIFT: i32 = 20;
pub const DBGBCR_BT: i32 = 15728640;
pub const DBGBVR_EL1_op0: i32 = 2;
pub const DBGBVR_EL1_op1: i32 = 0;
pub const DBGBVR_EL1_CRn: i32 = 0;
pub const DBGBVR_EL1_op2: i32 = 4;
pub const DBGWCR_EL1_op0: i32 = 2;
pub const DBGWCR_EL1_op1: i32 = 0;
pub const DBGWCR_EL1_CRn: i32 = 0;
pub const DBGWCR_EL1_op2: i32 = 7;
pub const DBGWCR_EN: i32 = 1;
pub const DBGWCR_PAC_SHIFT: i32 = 1;
pub const DBGWCR_PAC: i32 = 6;
pub const DBGWCR_PAC_EL1: i32 = 2;
pub const DBGWCR_PAC_EL0: i32 = 4;
pub const DBGWCR_LSC_SHIFT: i32 = 3;
pub const DBGWCR_LSC: i32 = 24;
pub const DBGWCR_BAS_SHIFT: i32 = 5;
pub const DBGWCR_BAS: i32 = 8160;
pub const DBGWCR_HMC_SHIFT: i32 = 13;
pub const DBGWCR_HMC: i32 = 8192;
pub const DBGWCR_SSC_SHIFT: i32 = 14;
pub const DBGWCR_SSC: i32 = 49152;
pub const DBGWCR_LBN_SHIFT: i32 = 16;
pub const DBGWCR_LBN: i32 = 983040;
pub const DBGWCR_WT_SHIFT: i32 = 20;
pub const DBGWCR_WT: i32 = 1048576;
pub const DBGWCR_MASK_SHIFT: i32 = 24;
pub const DBGWCR_MASK: i32 = 520093696;
pub const DBGWVR_EL1_op0: i32 = 2;
pub const DBGWVR_EL1_op1: i32 = 0;
pub const DBGWVR_EL1_CRn: i32 = 0;
pub const DBGWVR_EL1_op2: i32 = 6;
pub const DCZID_DZP: i32 = 16;
pub const DCZID_BS_SHIFT: i32 = 0;
pub const DCZID_BS_MASK: i32 = 15;
pub const DBGAUTHSTATUS_EL1_op0: i32 = 2;
pub const DBGAUTHSTATUS_EL1_op1: i32 = 0;
pub const DBGAUTHSTATUS_EL1_CRn: i32 = 7;
pub const DBGAUTHSTATUS_EL1_CRm: i32 = 14;
pub const DBGAUTHSTATUS_EL1_op2: i32 = 6;
pub const DBGCLAIMCLR_EL1_op0: i32 = 2;
pub const DBGCLAIMCLR_EL1_op1: i32 = 0;
pub const DBGCLAIMCLR_EL1_CRn: i32 = 7;
pub const DBGCLAIMCLR_EL1_CRm: i32 = 9;
pub const DBGCLAIMCLR_EL1_op2: i32 = 6;
pub const DBGCLAIMSET_EL1_op0: i32 = 2;
pub const DBGCLAIMSET_EL1_op1: i32 = 0;
pub const DBGCLAIMSET_EL1_CRn: i32 = 7;
pub const DBGCLAIMSET_EL1_CRm: i32 = 8;
pub const DBGCLAIMSET_EL1_op2: i32 = 6;
pub const DBGPRCR_EL1_op0: i32 = 2;
pub const DBGPRCR_EL1_op1: i32 = 0;
pub const DBGPRCR_EL1_CRn: i32 = 1;
pub const DBGPRCR_EL1_CRm: i32 = 4;
pub const DBGPRCR_EL1_op2: i32 = 4;
pub const ELR_EL1_op0: i32 = 3;
pub const ELR_EL1_op1: i32 = 0;
pub const ELR_EL1_CRn: i32 = 4;
pub const ELR_EL1_CRm: i32 = 0;
pub const ELR_EL1_op2: i32 = 1;
pub const ELR_EL12_op0: i32 = 3;
pub const ELR_EL12_op1: i32 = 5;
pub const ELR_EL12_CRn: i32 = 4;
pub const ELR_EL12_CRm: i32 = 0;
pub const ELR_EL12_op2: i32 = 1;
pub const ESR_ELx_ISS_MASK: i32 = 33554431;
pub const ISS_FP_TFV_SHIFT: i32 = 23;
pub const ISS_FP_TFV: i32 = 8388608;
pub const ISS_FP_IOF: i32 = 1;
pub const ISS_FP_DZF: i32 = 2;
pub const ISS_FP_OFF: i32 = 4;
pub const ISS_FP_UFF: i32 = 8;
pub const ISS_FP_IXF: i32 = 16;
pub const ISS_FP_IDF: i32 = 128;
pub const ISS_INSN_FnV: i32 = 1024;
pub const ISS_INSN_EA: i32 = 512;
pub const ISS_INSN_S1PTW: i32 = 128;
pub const ISS_INSN_IFSC_MASK: i32 = 31;
pub const ISS_WFx_TI_SHIFT: i32 = 0;
pub const ISS_WFx_TI_MASK: i32 = 3;
pub const ISS_WFx_TI_WFI: i32 = 0;
pub const ISS_WFx_TI_WFE: i32 = 1;
pub const ISS_WFx_TI_WFIT: i32 = 2;
pub const ISS_WFx_TI_WFET: i32 = 3;
pub const ISS_WFx_RV_SHIFT: i32 = 2;
pub const ISS_WFx_RV_MASK: i32 = 4;
pub const ISS_WFx_RV_INVALID: i32 = 0;
pub const ISS_WFx_RV_VALID: i32 = 4;
pub const ISS_WFx_RN_SHIFT: i32 = 5;
pub const ISS_WFx_RN_MASK: i32 = 992;
pub const ISS_WFx_COND_SHIFT: i32 = 20;
pub const ISS_WFx_COND_MASK: i32 = 15728640;
pub const ISS_WFx_CV_SHIFT: i32 = 24;
pub const ISS_WFx_CV_MASK: i32 = 16777216;
pub const ISS_WFx_CV_INVALID: i32 = 0;
pub const ISS_WFx_CV_VALID: i32 = 16777216;
pub const ISS_MSR_DIR_SHIFT: i32 = 0;
pub const ISS_MSR_DIR: i32 = 1;
pub const ISS_MSR_Rt_SHIFT: i32 = 5;
pub const ISS_MSR_Rt_MASK: i32 = 992;
pub const ISS_MSR_CRm_SHIFT: i32 = 1;
pub const ISS_MSR_CRm_MASK: i32 = 30;
pub const ISS_MSR_CRn_SHIFT: i32 = 10;
pub const ISS_MSR_CRn_MASK: i32 = 15360;
pub const ISS_MSR_OP1_SHIFT: i32 = 14;
pub const ISS_MSR_OP1_MASK: i32 = 114688;
pub const ISS_MSR_OP2_SHIFT: i32 = 17;
pub const ISS_MSR_OP2_MASK: i32 = 917504;
pub const ISS_MSR_OP0_SHIFT: i32 = 20;
pub const ISS_MSR_OP0_MASK: i32 = 3145728;
pub const ISS_MSR_REG_MASK: i32 = 4193310;
pub const ISS_DATA_ISV_SHIFT: i32 = 24;
pub const ISS_DATA_ISV: i32 = 16777216;
pub const ISS_DATA_SAS_SHIFT: i32 = 22;
pub const ISS_DATA_SAS_MASK: i32 = 12582912;
pub const ISS_DATA_SSE_SHIFT: i32 = 21;
pub const ISS_DATA_SSE: i32 = 2097152;
pub const ISS_DATA_SRT_SHIFT: i32 = 16;
pub const ISS_DATA_SRT_MASK: i32 = 2031616;
pub const ISS_DATA_SF: i32 = 32768;
pub const ISS_DATA_AR: i32 = 16384;
pub const ISS_DATA_FnV: i32 = 1024;
pub const ISS_DATA_EA: i32 = 512;
pub const ISS_DATA_CM: i32 = 256;
pub const ISS_DATA_S1PTW: i32 = 128;
pub const ISS_DATA_WnR_SHIFT: i32 = 6;
pub const ISS_DATA_WnR: i32 = 64;
pub const ISS_DATA_DFSC_MASK: i32 = 63;
pub const ISS_DATA_DFSC_ASF_L0: i32 = 0;
pub const ISS_DATA_DFSC_ASF_L1: i32 = 1;
pub const ISS_DATA_DFSC_ASF_L2: i32 = 2;
pub const ISS_DATA_DFSC_ASF_L3: i32 = 3;
pub const ISS_DATA_DFSC_TF_L0: i32 = 4;
pub const ISS_DATA_DFSC_TF_L1: i32 = 5;
pub const ISS_DATA_DFSC_TF_L2: i32 = 6;
pub const ISS_DATA_DFSC_TF_L3: i32 = 7;
pub const ISS_DATA_DFSC_AFF_L1: i32 = 9;
pub const ISS_DATA_DFSC_AFF_L2: i32 = 10;
pub const ISS_DATA_DFSC_AFF_L3: i32 = 11;
pub const ISS_DATA_DFSC_PF_L1: i32 = 13;
pub const ISS_DATA_DFSC_PF_L2: i32 = 14;
pub const ISS_DATA_DFSC_PF_L3: i32 = 15;
pub const ISS_DATA_DFSC_EXT: i32 = 16;
pub const ISS_DATA_DFSC_EXT_L0: i32 = 20;
pub const ISS_DATA_DFSC_EXT_L1: i32 = 21;
pub const ISS_DATA_DFSC_EXT_L2: i32 = 22;
pub const ISS_DATA_DFSC_EXT_L3: i32 = 23;
pub const ISS_DATA_DFSC_ECC: i32 = 24;
pub const ISS_DATA_DFSC_ECC_L0: i32 = 28;
pub const ISS_DATA_DFSC_ECC_L1: i32 = 29;
pub const ISS_DATA_DFSC_ECC_L2: i32 = 30;
pub const ISS_DATA_DFSC_ECC_L3: i32 = 31;
pub const ISS_DATA_DFSC_ALIGN: i32 = 33;
pub const ISS_DATA_DFSC_TLB_CONFLICT: i32 = 48;
pub const ESR_ELx_IL: i32 = 33554432;
pub const ESR_ELx_EC_SHIFT: i32 = 26;
pub const ESR_ELx_EC_MASK: i64 = 4227858432;
pub const EXCP_UNKNOWN: i32 = 0;
pub const EXCP_TRAP_WFI_WFE: i32 = 1;
pub const EXCP_FP_SIMD: i32 = 7;
pub const EXCP_BTI: i32 = 13;
pub const EXCP_ILL_STATE: i32 = 14;
pub const EXCP_SVC32: i32 = 17;
pub const EXCP_SVC64: i32 = 21;
pub const EXCP_HVC: i32 = 22;
pub const EXCP_MSR: i32 = 24;
pub const EXCP_SVE: i32 = 25;
pub const EXCP_FPAC: i32 = 28;
pub const EXCP_INSN_ABORT_L: i32 = 32;
pub const EXCP_INSN_ABORT: i32 = 33;
pub const EXCP_PC_ALIGN: i32 = 34;
pub const EXCP_DATA_ABORT_L: i32 = 36;
pub const EXCP_DATA_ABORT: i32 = 37;
pub const EXCP_SP_ALIGN: i32 = 38;
pub const EXCP_TRAP_FP: i32 = 44;
pub const EXCP_SERROR: i32 = 47;
pub const EXCP_BRKPT_EL0: i32 = 48;
pub const EXCP_BRKPT_EL1: i32 = 49;
pub const EXCP_SOFTSTP_EL0: i32 = 50;
pub const EXCP_SOFTSTP_EL1: i32 = 51;
pub const EXCP_WATCHPT_EL0: i32 = 52;
pub const EXCP_WATCHPT_EL1: i32 = 53;
pub const EXCP_BRKPT_32: i32 = 56;
pub const EXCP_BRK: i32 = 60;
pub const ESR_EL1_op0: i32 = 3;
pub const ESR_EL1_op1: i32 = 0;
pub const ESR_EL1_CRn: i32 = 5;
pub const ESR_EL1_CRm: i32 = 2;
pub const ESR_EL1_op2: i32 = 0;
pub const ESR_EL12_op0: i32 = 3;
pub const ESR_EL12_op1: i32 = 5;
pub const ESR_EL12_CRn: i32 = 5;
pub const ESR_EL12_CRm: i32 = 2;
pub const ESR_EL12_op2: i32 = 0;
pub const FAR_EL1_op0: i32 = 3;
pub const FAR_EL1_op1: i32 = 0;
pub const FAR_EL1_CRn: i32 = 6;
pub const FAR_EL1_CRm: i32 = 0;
pub const FAR_EL1_op2: i32 = 0;
pub const FAR_EL12_op0: i32 = 3;
pub const FAR_EL12_op1: i32 = 5;
pub const FAR_EL12_CRn: i32 = 6;
pub const FAR_EL12_CRm: i32 = 0;
pub const FAR_EL12_op2: i32 = 0;
pub const ICC_CTLR_EL1_EOIMODE: i32 = 2;
pub const ICC_IAR1_EL1_SPUR: i32 = 1023;
pub const ICC_IGRPEN0_EL1_EN: i32 = 1;
pub const ICC_PMR_EL1_PRIO_MASK: i32 = 255;
pub const ICC_SGI1R_EL1_op0: i32 = 3;
pub const ICC_SGI1R_EL1_op1: i32 = 0;
pub const ICC_SGI1R_EL1_CRn: i32 = 12;
pub const ICC_SGI1R_EL1_CRm: i32 = 11;
pub const ICC_SGI1R_EL1_op2: i32 = 5;
pub const ICC_SGI1R_EL1_TL_SHIFT: i32 = 0;
pub const ICC_SGI1R_EL1_TL_MASK: i32 = 65535;
pub const ICC_SGI1R_EL1_AFF1_SHIFT: i32 = 16;
pub const ICC_SGI1R_EL1_AFF1_MASK: i32 = 16711680;
pub const ICC_SGI1R_EL1_SGIID_SHIFT: i32 = 24;
pub const ICC_SGI1R_EL1_SGIID_MASK: i32 = 251658240;
pub const ICC_SGI1R_EL1_AFF2_SHIFT: i32 = 32;
pub const ICC_SGI1R_EL1_AFF2_MASK: i64 = 1095216660480;
pub const ICC_SGI1R_EL1_RS_SHIFT: i32 = 44;
pub const ICC_SGI1R_EL1_RS_MASK: i64 = 263882790666240;
pub const ICC_SGI1R_EL1_AFF3_SHIFT: i32 = 48;
pub const ICC_SGI1R_EL1_AFF3_MASK: i64 = 71776119061217280;
pub const ICC_SGI1R_EL1_IRM: i64 = 1099511627776;
pub const ICC_SRE_EL1_SRE: i32 = 1;
pub const ID_AA64AFR0_EL1_op0: i32 = 3;
pub const ID_AA64AFR0_EL1_op1: i32 = 0;
pub const ID_AA64AFR0_EL1_CRn: i32 = 0;
pub const ID_AA64AFR0_EL1_CRm: i32 = 5;
pub const ID_AA64AFR0_EL1_op2: i32 = 4;
pub const ID_AA64AFR1_EL1_op0: i32 = 3;
pub const ID_AA64AFR1_EL1_op1: i32 = 0;
pub const ID_AA64AFR1_EL1_CRn: i32 = 0;
pub const ID_AA64AFR1_EL1_CRm: i32 = 5;
pub const ID_AA64AFR1_EL1_op2: i32 = 5;
pub const ID_AA64DFR0_EL1_op0: i32 = 3;
pub const ID_AA64DFR0_EL1_op1: i32 = 0;
pub const ID_AA64DFR0_EL1_CRn: i32 = 0;
pub const ID_AA64DFR0_EL1_CRm: i32 = 5;
pub const ID_AA64DFR0_EL1_op2: i32 = 0;
pub const ID_AA64DFR0_DebugVer_SHIFT: i32 = 0;
pub const ID_AA64DFR0_DebugVer_WIDTH: i32 = 4;
pub const ID_AA64DFR0_TraceVer_SHIFT: i32 = 4;
pub const ID_AA64DFR0_TraceVer_WIDTH: i32 = 4;
pub const ID_AA64DFR0_PMUVer_SHIFT: i32 = 8;
pub const ID_AA64DFR0_PMUVer_WIDTH: i32 = 4;
pub const ID_AA64DFR0_BRPs_SHIFT: i32 = 12;
pub const ID_AA64DFR0_BRPs_WIDTH: i32 = 4;
pub const ID_AA64DFR0_PMSS_SHIFT: i32 = 16;
pub const ID_AA64DFR0_PMSS_WIDTH: i32 = 4;
pub const ID_AA64DFR0_WRPs_SHIFT: i32 = 20;
pub const ID_AA64DFR0_WRPs_WIDTH: i32 = 4;
pub const ID_AA64DFR0_CTX_CMPs_SHIFT: i32 = 28;
pub const ID_AA64DFR0_CTX_CMPs_WIDTH: i32 = 4;
pub const ID_AA64DFR0_PMSVer_SHIFT: i32 = 32;
pub const ID_AA64DFR0_PMSVer_WIDTH: i32 = 4;
pub const ID_AA64DFR0_DoubleLock_SHIFT: i32 = 36;
pub const ID_AA64DFR0_DoubleLock_WIDTH: i32 = 4;
pub const ID_AA64DFR0_TraceFilt_SHIFT: i32 = 40;
pub const ID_AA64DFR0_TraceFilt_WIDTH: i32 = 4;
pub const ID_AA64DFR0_TraceBuffer_SHIFT: i32 = 44;
pub const ID_AA64DFR0_TraceBuffer_WIDTH: i32 = 4;
pub const ID_AA64DFR0_MTPMU_SHIFT: i32 = 48;
pub const ID_AA64DFR0_MTPMU_WIDTH: i32 = 4;
pub const ID_AA64DFR0_BRBE_SHIFT: i32 = 52;
pub const ID_AA64DFR0_BRBE_WIDTH: i32 = 4;
pub const ID_AA64DFR0_HPMN0_SHIFT: i32 = 60;
pub const ID_AA64DFR0_HPMN0_WIDTH: i32 = 4;
pub const ID_AA64DFR1_EL1_op0: i32 = 3;
pub const ID_AA64DFR1_EL1_op1: i32 = 0;
pub const ID_AA64DFR1_EL1_CRn: i32 = 0;
pub const ID_AA64DFR1_EL1_CRm: i32 = 5;
pub const ID_AA64DFR1_EL1_op2: i32 = 1;
pub const ID_AA64DFR1_SPMU_SHIFT: i32 = 32;
pub const ID_AA64DFR1_SPMU_WIDTH: i32 = 4;
pub const ID_AA64DFR1_PMICNTR_SHIFT: i32 = 36;
pub const ID_AA64DFR1_PMICNTR_WIDTH: i32 = 4;
pub const ID_AA64DFR1_DPFZS_SHIFT: i32 = 52;
pub const ID_AA64DFR1_DPFZS_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_EL1_op0: i32 = 3;
pub const ID_AA64ISAR0_EL1_op1: i32 = 0;
pub const ID_AA64ISAR0_EL1_CRn: i32 = 0;
pub const ID_AA64ISAR0_EL1_CRm: i32 = 6;
pub const ID_AA64ISAR0_EL1_op2: i32 = 0;
pub const ID_AA64ISAR0_AES_SHIFT: i32 = 4;
pub const ID_AA64ISAR0_AES_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_SHA1_SHIFT: i32 = 8;
pub const ID_AA64ISAR0_SHA1_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_SHA2_SHIFT: i32 = 12;
pub const ID_AA64ISAR0_SHA2_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_CRC32_SHIFT: i32 = 16;
pub const ID_AA64ISAR0_CRC32_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_Atomic_SHIFT: i32 = 20;
pub const ID_AA64ISAR0_Atomic_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_TME_SHIFT: i32 = 24;
pub const ID_AA64ISAR0_TME_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_RDM_SHIFT: i32 = 28;
pub const ID_AA64ISAR0_RDM_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_SHA3_SHIFT: i32 = 32;
pub const ID_AA64ISAR0_SHA3_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_SM3_SHIFT: i32 = 36;
pub const ID_AA64ISAR0_SM3_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_SM4_SHIFT: i32 = 40;
pub const ID_AA64ISAR0_SM4_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_DP_SHIFT: i32 = 44;
pub const ID_AA64ISAR0_DP_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_FHM_SHIFT: i32 = 48;
pub const ID_AA64ISAR0_FHM_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_TS_SHIFT: i32 = 52;
pub const ID_AA64ISAR0_TS_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_TLB_SHIFT: i32 = 56;
pub const ID_AA64ISAR0_TLB_WIDTH: i32 = 4;
pub const ID_AA64ISAR0_RNDR_SHIFT: i32 = 60;
pub const ID_AA64ISAR0_RNDR_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_EL1_op0: i32 = 3;
pub const ID_AA64ISAR1_EL1_op1: i32 = 0;
pub const ID_AA64ISAR1_EL1_CRn: i32 = 0;
pub const ID_AA64ISAR1_EL1_CRm: i32 = 6;
pub const ID_AA64ISAR1_EL1_op2: i32 = 1;
pub const ID_AA64ISAR1_DPB_SHIFT: i32 = 0;
pub const ID_AA64ISAR1_DPB_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_APA_SHIFT: i32 = 4;
pub const ID_AA64ISAR1_APA_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_API_SHIFT: i32 = 8;
pub const ID_AA64ISAR1_API_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_JSCVT_SHIFT: i32 = 12;
pub const ID_AA64ISAR1_JSCVT_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_FCMA_SHIFT: i32 = 16;
pub const ID_AA64ISAR1_FCMA_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_LRCPC_SHIFT: i32 = 20;
pub const ID_AA64ISAR1_LRCPC_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_GPA_SHIFT: i32 = 24;
pub const ID_AA64ISAR1_GPA_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_GPI_SHIFT: i32 = 28;
pub const ID_AA64ISAR1_GPI_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_FRINTTS_SHIFT: i32 = 32;
pub const ID_AA64ISAR1_FRINTTS_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_SB_SHIFT: i32 = 36;
pub const ID_AA64ISAR1_SB_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_SPECRES_SHIFT: i32 = 40;
pub const ID_AA64ISAR1_SPECRES_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_BF16_SHIFT: i32 = 44;
pub const ID_AA64ISAR1_BF16_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_DGH_SHIFT: i32 = 48;
pub const ID_AA64ISAR1_DGH_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_I8MM_SHIFT: i32 = 52;
pub const ID_AA64ISAR1_I8MM_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_XS_SHIFT: i32 = 56;
pub const ID_AA64ISAR1_XS_WIDTH: i32 = 4;
pub const ID_AA64ISAR1_LS64_SHIFT: i32 = 60;
pub const ID_AA64ISAR1_LS64_WIDTH: i32 = 4;
pub const ID_AA64ISAR2_EL1_op0: i32 = 3;
pub const ID_AA64ISAR2_EL1_op1: i32 = 0;
pub const ID_AA64ISAR2_EL1_CRn: i32 = 0;
pub const ID_AA64ISAR2_EL1_CRm: i32 = 6;
pub const ID_AA64ISAR2_EL1_op2: i32 = 2;
pub const ID_AA64ISAR2_WFxT_SHIFT: i32 = 0;
pub const ID_AA64ISAR2_WFxT_WIDTH: i32 = 4;
pub const ID_AA64ISAR2_RPRES_SHIFT: i32 = 4;
pub const ID_AA64ISAR2_RPRES_WIDTH: i32 = 4;
pub const ID_AA64ISAR2_GPA3_SHIFT: i32 = 8;
pub const ID_AA64ISAR2_GPA3_WIDTH: i32 = 4;
pub const ID_AA64ISAR2_APA3_SHIFT: i32 = 12;
pub const ID_AA64ISAR2_APA3_WIDTH: i32 = 4;
pub const ID_AA64ISAR2_MOPS_SHIFT: i32 = 16;
pub const ID_AA64ISAR2_MOPS_WIDTH: i32 = 4;
pub const ID_AA64ISAR2_BC_SHIFT: i32 = 20;
pub const ID_AA64ISAR2_BC_WIDTH: i32 = 4;
pub const ID_AA64ISAR2_PAC_frac_SHIFT: i32 = 24;
pub const ID_AA64ISAR2_PAC_frac_WIDTH: i32 = 4;
pub const ID_AA64ISAR2_CLRBHB_SHIFT: i32 = 28;
pub const ID_AA64ISAR2_CLRBHB_WIDTH: i32 = 4;
pub const ID_AA64ISAR2_PRFMSLC_SHIFT: i32 = 40;
pub const ID_AA64ISAR2_PRFMSLC_WIDTH: i32 = 4;
pub const ID_AA64ISAR2_RPRFM_SHIFT: i32 = 48;
pub const ID_AA64ISAR2_RPRFM_WIDTH: i32 = 4;
pub const ID_AA64ISAR2_CSSC_SHIFT: i32 = 52;
pub const ID_AA64ISAR2_CSSC_WIDTH: i32 = 4;
pub const ID_AA64ISAR2_ATS1A_SHIFT: i32 = 60;
pub const ID_AA64ISAR2_ATS1A_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_EL1_op0: i32 = 3;
pub const ID_AA64MMFR0_EL1_op1: i32 = 0;
pub const ID_AA64MMFR0_EL1_CRn: i32 = 0;
pub const ID_AA64MMFR0_EL1_CRm: i32 = 7;
pub const ID_AA64MMFR0_EL1_op2: i32 = 0;
pub const ID_AA64MMFR0_PARange_SHIFT: i32 = 0;
pub const ID_AA64MMFR0_PARange_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_ASIDBits_SHIFT: i32 = 4;
pub const ID_AA64MMFR0_ASIDBits_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_BigEnd_SHIFT: i32 = 8;
pub const ID_AA64MMFR0_BigEnd_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_SNSMem_SHIFT: i32 = 12;
pub const ID_AA64MMFR0_SNSMem_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_BigEndEL0_SHIFT: i32 = 16;
pub const ID_AA64MMFR0_BigEndEL0_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_TGran16_SHIFT: i32 = 20;
pub const ID_AA64MMFR0_TGran16_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_TGran64_SHIFT: i32 = 24;
pub const ID_AA64MMFR0_TGran64_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_TGran4_SHIFT: i32 = 28;
pub const ID_AA64MMFR0_TGran4_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_TGran16_2_SHIFT: i32 = 32;
pub const ID_AA64MMFR0_TGran16_2_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_TGran64_2_SHIFT: i32 = 36;
pub const ID_AA64MMFR0_TGran64_2_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_TGran4_2_SHIFT: i32 = 40;
pub const ID_AA64MMFR0_TGran4_2_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_ExS_SHIFT: i32 = 44;
pub const ID_AA64MMFR0_ExS_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_FGT_SHIFT: i32 = 56;
pub const ID_AA64MMFR0_FGT_WIDTH: i32 = 4;
pub const ID_AA64MMFR0_ECV_SHIFT: i32 = 60;
pub const ID_AA64MMFR0_ECV_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_EL1_op0: i32 = 3;
pub const ID_AA64MMFR1_EL1_op1: i32 = 0;
pub const ID_AA64MMFR1_EL1_CRn: i32 = 0;
pub const ID_AA64MMFR1_EL1_CRm: i32 = 7;
pub const ID_AA64MMFR1_EL1_op2: i32 = 1;
pub const ID_AA64MMFR1_HAFDBS_SHIFT: i32 = 0;
pub const ID_AA64MMFR1_HAFDBS_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_VMIDBits_SHIFT: i32 = 4;
pub const ID_AA64MMFR1_VMIDBits_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_VH_SHIFT: i32 = 8;
pub const ID_AA64MMFR1_VH_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_HPDS_SHIFT: i32 = 12;
pub const ID_AA64MMFR1_HPDS_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_LO_SHIFT: i32 = 16;
pub const ID_AA64MMFR1_LO_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_PAN_SHIFT: i32 = 20;
pub const ID_AA64MMFR1_PAN_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_SpecSEI_SHIFT: i32 = 24;
pub const ID_AA64MMFR1_SpecSEI_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_XNX_SHIFT: i32 = 28;
pub const ID_AA64MMFR1_XNX_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_TWED_SHIFT: i32 = 32;
pub const ID_AA64MMFR1_TWED_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_ETS_SHIFT: i32 = 36;
pub const ID_AA64MMFR1_ETS_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_HCX_SHIFT: i32 = 40;
pub const ID_AA64MMFR1_HCX_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_AFP_SHIFT: i32 = 44;
pub const ID_AA64MMFR1_AFP_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_nTLBPA_SHIFT: i32 = 48;
pub const ID_AA64MMFR1_nTLBPA_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_TIDCP1_SHIFT: i32 = 52;
pub const ID_AA64MMFR1_TIDCP1_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_CMOVW_SHIFT: i32 = 56;
pub const ID_AA64MMFR1_CMOVW_WIDTH: i32 = 4;
pub const ID_AA64MMFR1_ECBHB_SHIFT: i32 = 60;
pub const ID_AA64MMFR1_ECBHB_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_EL1_op0: i32 = 3;
pub const ID_AA64MMFR2_EL1_op1: i32 = 0;
pub const ID_AA64MMFR2_EL1_CRn: i32 = 0;
pub const ID_AA64MMFR2_EL1_CRm: i32 = 7;
pub const ID_AA64MMFR2_EL1_op2: i32 = 2;
pub const ID_AA64MMFR2_CnP_SHIFT: i32 = 0;
pub const ID_AA64MMFR2_CnP_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_UAO_SHIFT: i32 = 4;
pub const ID_AA64MMFR2_UAO_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_LSM_SHIFT: i32 = 8;
pub const ID_AA64MMFR2_LSM_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_IESB_SHIFT: i32 = 12;
pub const ID_AA64MMFR2_IESB_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_VARange_SHIFT: i32 = 16;
pub const ID_AA64MMFR2_VARange_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_CCIDX_SHIFT: i32 = 20;
pub const ID_AA64MMFR2_CCIDX_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_NV_SHIFT: i32 = 24;
pub const ID_AA64MMFR2_NV_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_ST_SHIFT: i32 = 28;
pub const ID_AA64MMFR2_ST_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_AT_SHIFT: i32 = 32;
pub const ID_AA64MMFR2_AT_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_IDS_SHIFT: i32 = 36;
pub const ID_AA64MMFR2_IDS_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_FWB_SHIFT: i32 = 40;
pub const ID_AA64MMFR2_FWB_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_TTL_SHIFT: i32 = 48;
pub const ID_AA64MMFR2_TTL_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_BBM_SHIFT: i32 = 52;
pub const ID_AA64MMFR2_BBM_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_EVT_SHIFT: i32 = 56;
pub const ID_AA64MMFR2_EVT_WIDTH: i32 = 4;
pub const ID_AA64MMFR2_E0PD_SHIFT: i32 = 60;
pub const ID_AA64MMFR2_E0PD_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_EL1_op0: i32 = 3;
pub const ID_AA64MMFR3_EL1_op1: i32 = 0;
pub const ID_AA64MMFR3_EL1_CRn: i32 = 0;
pub const ID_AA64MMFR3_EL1_CRm: i32 = 7;
pub const ID_AA64MMFR3_EL1_op2: i32 = 3;
pub const ID_AA64MMFR3_TCRX_SHIFT: i32 = 0;
pub const ID_AA64MMFR3_TCRX_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_SCTLRX_SHIFT: i32 = 4;
pub const ID_AA64MMFR3_SCTLRX_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_S1PIE_SHIFT: i32 = 8;
pub const ID_AA64MMFR3_S1PIE_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_S2PIE_SHIFT: i32 = 12;
pub const ID_AA64MMFR3_S2PIE_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_S1POE_SHIFT: i32 = 16;
pub const ID_AA64MMFR3_S1POE_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_S2POE_SHIFT: i32 = 20;
pub const ID_AA64MMFR3_S2POE_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_AIE_SHIFT: i32 = 24;
pub const ID_AA64MMFR3_AIE_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_MEC_SHIFT: i32 = 28;
pub const ID_AA64MMFR3_MEC_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_SNERR_SHIFT: i32 = 40;
pub const ID_AA64MMFR3_SNERR_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_ANERR_SHIFT: i32 = 44;
pub const ID_AA64MMFR3_ANERR_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_SDERR_SHIFT: i32 = 52;
pub const ID_AA64MMFR3_SDERR_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_ADERR_SHIFT: i32 = 56;
pub const ID_AA64MMFR3_ADERR_WIDTH: i32 = 4;
pub const ID_AA64MMFR3_Spec_FPACC_SHIFT: i32 = 60;
pub const ID_AA64MMFR3_Spec_FPACC_WIDTH: i32 = 4;
pub const ID_AA64MMFR4_EL1_op0: i32 = 3;
pub const ID_AA64MMFR4_EL1_op1: i32 = 0;
pub const ID_AA64MMFR4_EL1_CRn: i32 = 0;
pub const ID_AA64MMFR4_EL1_CRm: i32 = 7;
pub const ID_AA64MMFR4_EL1_op2: i32 = 4;
pub const ID_AA64PFR0_EL1_op0: i32 = 3;
pub const ID_AA64PFR0_EL1_op1: i32 = 0;
pub const ID_AA64PFR0_EL1_CRn: i32 = 0;
pub const ID_AA64PFR0_EL1_CRm: i32 = 4;
pub const ID_AA64PFR0_EL1_op2: i32 = 0;
pub const ID_AA64PFR0_EL0_SHIFT: i32 = 0;
pub const ID_AA64PFR0_EL0_WIDTH: i32 = 4;
pub const ID_AA64PFR0_EL1_SHIFT: i32 = 4;
pub const ID_AA64PFR0_EL1_WIDTH: i32 = 4;
pub const ID_AA64PFR0_EL2_SHIFT: i32 = 8;
pub const ID_AA64PFR0_EL2_WIDTH: i32 = 4;
pub const ID_AA64PFR0_EL3_SHIFT: i32 = 12;
pub const ID_AA64PFR0_EL3_WIDTH: i32 = 4;
pub const ID_AA64PFR0_FP_SHIFT: i32 = 16;
pub const ID_AA64PFR0_FP_WIDTH: i32 = 4;
pub const ID_AA64PFR0_AdvSIMD_SHIFT: i32 = 20;
pub const ID_AA64PFR0_AdvSIMD_WIDTH: i32 = 4;
pub const ID_AA64PFR0_GIC_BITS: i32 = 4;
pub const ID_AA64PFR0_GIC_SHIFT: i32 = 24;
pub const ID_AA64PFR0_GIC_WIDTH: i32 = 4;
pub const ID_AA64PFR0_RAS_SHIFT: i32 = 28;
pub const ID_AA64PFR0_RAS_WIDTH: i32 = 4;
pub const ID_AA64PFR0_SVE_SHIFT: i32 = 32;
pub const ID_AA64PFR0_SVE_WIDTH: i32 = 4;
pub const ID_AA64PFR0_SEL2_SHIFT: i32 = 36;
pub const ID_AA64PFR0_SEL2_WIDTH: i32 = 4;
pub const ID_AA64PFR0_MPAM_SHIFT: i32 = 40;
pub const ID_AA64PFR0_MPAM_WIDTH: i32 = 4;
pub const ID_AA64PFR0_AMU_SHIFT: i32 = 44;
pub const ID_AA64PFR0_AMU_WIDTH: i32 = 4;
pub const ID_AA64PFR0_DIT_SHIFT: i32 = 48;
pub const ID_AA64PFR0_DIT_WIDTH: i32 = 4;
pub const ID_AA64PFR0_RME_SHIFT: i32 = 52;
pub const ID_AA64PFR0_RME_WIDTH: i32 = 4;
pub const ID_AA64PFR0_CSV2_SHIFT: i32 = 56;
pub const ID_AA64PFR0_CSV2_WIDTH: i32 = 4;
pub const ID_AA64PFR0_CSV3_SHIFT: i32 = 60;
pub const ID_AA64PFR0_CSV3_WIDTH: i32 = 4;
pub const ID_AA64PFR1_EL1_op0: i32 = 3;
pub const ID_AA64PFR1_EL1_op1: i32 = 0;
pub const ID_AA64PFR1_EL1_CRn: i32 = 0;
pub const ID_AA64PFR1_EL1_CRm: i32 = 4;
pub const ID_AA64PFR1_EL1_op2: i32 = 1;
pub const ID_AA64PFR1_BT_SHIFT: i32 = 0;
pub const ID_AA64PFR1_BT_WIDTH: i32 = 4;
pub const ID_AA64PFR1_SSBS_SHIFT: i32 = 4;
pub const ID_AA64PFR1_SSBS_WIDTH: i32 = 4;
pub const ID_AA64PFR1_MTE_SHIFT: i32 = 8;
pub const ID_AA64PFR1_MTE_WIDTH: i32 = 4;
pub const ID_AA64PFR1_RAS_frac_SHIFT: i32 = 12;
pub const ID_AA64PFR1_RAS_frac_WIDTH: i32 = 4;
pub const ID_AA64PFR1_MPAM_frac_SHIFT: i32 = 16;
pub const ID_AA64PFR1_MPAM_frac_WIDTH: i32 = 4;
pub const ID_AA64PFR1_SME_SHIFT: i32 = 24;
pub const ID_AA64PFR1_SME_WIDTH: i32 = 4;
pub const ID_AA64PFR1_RNDR_trap_SHIFT: i32 = 28;
pub const ID_AA64PFR1_RNDR_trap_WIDTH: i32 = 4;
pub const ID_AA64PFR1_CSV2_frac_SHIFT: i32 = 32;
pub const ID_AA64PFR1_CSV2_frac_WIDTH: i32 = 4;
pub const ID_AA64PFR1_NMI_SHIFT: i32 = 36;
pub const ID_AA64PFR1_NMI_WIDTH: i32 = 4;
pub const ID_AA64PFR1_MTE_frac_SHIFT: i32 = 40;
pub const ID_AA64PFR1_MTE_frac_WIDTH: i32 = 4;
pub const ID_AA64PFR1_THE_SHIFT: i32 = 48;
pub const ID_AA64PFR1_THE_WIDTH: i32 = 4;
pub const ID_AA64PFR1_MTEX_SHIFT: i32 = 52;
pub const ID_AA64PFR1_MTEX_WIDTH: i32 = 4;
pub const ID_AA64PFR1_DF2_SHIFT: i32 = 56;
pub const ID_AA64PFR1_DF2_WIDTH: i32 = 4;
pub const ID_AA64PFR1_PFAR_SHIFT: i32 = 60;
pub const ID_AA64PFR1_PFAR_WIDTH: i32 = 4;
pub const ID_AA64PFR2_EL1_op0: i32 = 3;
pub const ID_AA64PFR2_EL1_op1: i32 = 0;
pub const ID_AA64PFR2_EL1_CRn: i32 = 0;
pub const ID_AA64PFR2_EL1_CRm: i32 = 4;
pub const ID_AA64PFR2_EL1_op2: i32 = 2;
pub const ID_AA64ZFR0_EL1_op0: i32 = 3;
pub const ID_AA64ZFR0_EL1_op1: i32 = 0;
pub const ID_AA64ZFR0_EL1_CRn: i32 = 0;
pub const ID_AA64ZFR0_EL1_CRm: i32 = 4;
pub const ID_AA64ZFR0_EL1_op2: i32 = 4;
pub const ID_AA64ZFR0_SVEver_SHIFT: i32 = 0;
pub const ID_AA64ZFR0_SVEver_WIDTH: i32 = 4;
pub const ID_AA64ZFR0_AES_SHIFT: i32 = 4;
pub const ID_AA64ZFR0_AES_WIDTH: i32 = 4;
pub const ID_AA64ZFR0_BitPerm_SHIFT: i32 = 16;
pub const ID_AA64ZFR0_BitPerm_WIDTH: i32 = 4;
pub const ID_AA64ZFR0_BF16_SHIFT: i32 = 20;
pub const ID_AA64ZFR0_BF16_WIDTH: i32 = 4;
pub const ID_AA64ZFR0_SHA3_SHIFT: i32 = 32;
pub const ID_AA64ZFR0_SHA3_WIDTH: i32 = 4;
pub const ID_AA64ZFR0_SM4_SHIFT: i32 = 40;
pub const ID_AA64ZFR0_SM4_WIDTH: i32 = 4;
pub const ID_AA64ZFR0_I8MM_SHIFT: i32 = 44;
pub const ID_AA64ZFR0_I8MM_WIDTH: i32 = 4;
pub const ID_AA64ZFR0_F32MM_SHIFT: i32 = 52;
pub const ID_AA64ZFR0_F32MM_WIDTH: i32 = 4;
pub const ID_AA64ZFR0_F64MM_SHIFT: i32 = 56;
pub const ID_AA64ZFR0_F64MM_WIDTH: i32 = 4;
pub const ID_ISAR5_EL1_op0: i32 = 3;
pub const ID_ISAR5_EL1_op1: i32 = 0;
pub const ID_ISAR5_EL1_CRn: i32 = 0;
pub const ID_ISAR5_EL1_CRm: i32 = 2;
pub const ID_ISAR5_EL1_op2: i32 = 5;
pub const ID_ISAR5_SEVL_SHIFT: i32 = 0;
pub const ID_ISAR5_SEVL_WIDTH: i32 = 4;
pub const ID_ISAR5_AES_SHIFT: i32 = 4;
pub const ID_ISAR5_AES_WIDTH: i32 = 4;
pub const ID_ISAR5_SHA1_SHIFT: i32 = 8;
pub const ID_ISAR5_SHA1_WIDTH: i32 = 4;
pub const ID_ISAR5_SHA2_SHIFT: i32 = 12;
pub const ID_ISAR5_SHA2_WIDTH: i32 = 4;
pub const ID_ISAR5_CRC32_SHIFT: i32 = 16;
pub const ID_ISAR5_CRC32_WIDTH: i32 = 4;
pub const ID_ISAR5_RDM_SHIFT: i32 = 24;
pub const ID_ISAR5_RDM_WIDTH: i32 = 4;
pub const ID_ISAR5_VCMA_SHIFT: i32 = 28;
pub const ID_ISAR5_VCMA_WIDTH: i32 = 4;
pub const MAIR_EL1_op0: i32 = 3;
pub const MAIR_EL1_op1: i32 = 0;
pub const MAIR_EL1_CRn: i32 = 10;
pub const MAIR_EL1_CRm: i32 = 2;
pub const MAIR_EL1_op2: i32 = 0;
pub const MAIR_EL12_op0: i32 = 3;
pub const MAIR_EL12_op1: i32 = 5;
pub const MAIR_EL12_CRn: i32 = 10;
pub const MAIR_EL12_CRm: i32 = 2;
pub const MAIR_EL12_op2: i32 = 0;
pub const MDCCINT_EL1_op0: i32 = 2;
pub const MDCCINT_EL1_op1: i32 = 0;
pub const MDCCINT_EL1_CRn: i32 = 0;
pub const MDCCINT_EL1_CRm: i32 = 2;
pub const MDCCINT_EL1_op2: i32 = 0;
pub const MDCCSR_EL0_op0: i32 = 2;
pub const MDCCSR_EL0_op1: i32 = 3;
pub const MDCCSR_EL0_CRn: i32 = 0;
pub const MDCCSR_EL0_CRm: i32 = 1;
pub const MDCCSR_EL0_op2: i32 = 0;
pub const MDSCR_EL1_op0: i32 = 2;
pub const MDSCR_EL1_op1: i32 = 0;
pub const MDSCR_EL1_CRn: i32 = 0;
pub const MDSCR_EL1_CRm: i32 = 2;
pub const MDSCR_EL1_op2: i32 = 2;
pub const MDSCR_SS_SHIFT: i32 = 0;
pub const MDSCR_KDE_SHIFT: i32 = 13;
pub const MDSCR_MDE_SHIFT: i32 = 15;
pub const MIDR_EL1_op0: i32 = 3;
pub const MIDR_EL1_op1: i32 = 0;
pub const MIDR_EL1_CRn: i32 = 0;
pub const MIDR_EL1_CRm: i32 = 0;
pub const MIDR_EL1_op2: i32 = 0;
pub const MPIDR_EL1_op0: i32 = 3;
pub const MPIDR_EL1_op1: i32 = 0;
pub const MPIDR_EL1_CRn: i32 = 0;
pub const MPIDR_EL1_CRm: i32 = 0;
pub const MPIDR_EL1_op2: i32 = 5;
pub const MPIDR_AFF0_SHIFT: i32 = 0;
pub const MPIDR_AFF1_SHIFT: i32 = 8;
pub const MPIDR_AFF2_SHIFT: i32 = 16;
pub const MPIDR_MT_SHIFT: i32 = 24;
pub const MPIDR_U_SHIFT: i32 = 30;
pub const MPIDR_AFF3_SHIFT: i32 = 32;
pub const MVFR0_EL1_op0: i32 = 3;
pub const MVFR0_EL1_op1: i32 = 0;
pub const MVFR0_EL1_CRn: i32 = 0;
pub const MVFR0_EL1_CRm: i32 = 3;
pub const MVFR0_EL1_op2: i32 = 0;
pub const MVFR0_SIMDReg_SHIFT: i32 = 0;
pub const MVFR0_SIMDReg_WIDTH: i32 = 4;
pub const MVFR0_FPSP_SHIFT: i32 = 4;
pub const MVFR0_FPSP_WIDTH: i32 = 4;
pub const MVFR0_FPDP_SHIFT: i32 = 8;
pub const MVFR0_FPDP_WIDTH: i32 = 4;
pub const MVFR0_FPTrap_SHIFT: i32 = 12;
pub const MVFR0_FPTrap_WIDTH: i32 = 4;
pub const MVFR0_FPDivide_SHIFT: i32 = 16;
pub const MVFR0_FPDivide_WIDTH: i32 = 4;
pub const MVFR0_FPSqrt_SHIFT: i32 = 20;
pub const MVFR0_FPSqrt_WIDTH: i32 = 4;
pub const MVFR0_FPShVec_SHIFT: i32 = 24;
pub const MVFR0_FPShVec_WIDTH: i32 = 4;
pub const MVFR0_FPRound_SHIFT: i32 = 28;
pub const MVFR0_FPRound_WIDTH: i32 = 4;
pub const MVFR1_EL1_op0: i32 = 3;
pub const MVFR1_EL1_op1: i32 = 0;
pub const MVFR1_EL1_CRn: i32 = 0;
pub const MVFR1_EL1_CRm: i32 = 3;
pub const MVFR1_EL1_op2: i32 = 1;
pub const MVFR1_FPFtZ_SHIFT: i32 = 0;
pub const MVFR1_FPFtZ_WIDTH: i32 = 4;
pub const MVFR1_FPDNaN_SHIFT: i32 = 4;
pub const MVFR1_FPDNaN_WIDTH: i32 = 4;
pub const MVFR1_SIMDLS_SHIFT: i32 = 8;
pub const MVFR1_SIMDLS_WIDTH: i32 = 4;
pub const MVFR1_SIMDInt_SHIFT: i32 = 12;
pub const MVFR1_SIMDInt_WIDTH: i32 = 4;
pub const MVFR1_SIMDSP_SHIFT: i32 = 16;
pub const MVFR1_SIMDSP_WIDTH: i32 = 4;
pub const MVFR1_SIMDHP_SHIFT: i32 = 20;
pub const MVFR1_SIMDHP_WIDTH: i32 = 4;
pub const MVFR1_FPHP_SHIFT: i32 = 24;
pub const MVFR1_FPHP_WIDTH: i32 = 4;
pub const MVFR1_SIMDFMAC_SHIFT: i32 = 28;
pub const MVFR1_SIMDFMAC_WIDTH: i32 = 4;
pub const OSDLR_EL1_op0: i32 = 2;
pub const OSDLR_EL1_op1: i32 = 0;
pub const OSDLR_EL1_CRn: i32 = 1;
pub const OSDLR_EL1_CRm: i32 = 3;
pub const OSDLR_EL1_op2: i32 = 4;
pub const OSLAR_EL1_op0: i32 = 2;
pub const OSLAR_EL1_op1: i32 = 0;
pub const OSLAR_EL1_CRn: i32 = 1;
pub const OSLAR_EL1_CRm: i32 = 0;
pub const OSLAR_EL1_op2: i32 = 4;
pub const OSLAR_OSLK: i32 = 1;
pub const OSLSR_EL1_op0: i32 = 2;
pub const OSLSR_EL1_op1: i32 = 0;
pub const OSLSR_EL1_CRn: i32 = 1;
pub const OSLSR_EL1_CRm: i32 = 1;
pub const OSLSR_EL1_op2: i32 = 4;
pub const OSLSR_OSLM_1: i32 = 8;
pub const OSLSR_nTT: i32 = 4;
pub const OSLSR_OSLK: i32 = 2;
pub const OSLSR_OSLM_0: i32 = 1;
pub const PAR_F_SHIFT: i32 = 0;
pub const PAR_F: i32 = 1;
pub const PAR_LOW_MASK: i32 = 4095;
pub const PAR_SH_SHIFT: i32 = 7;
pub const PAR_SH_MASK: i32 = 384;
pub const PAR_NS_SHIFT: i32 = 9;
pub const PAR_NS_MASK: i32 = 1536;
pub const PAR_PA_SHIFT: i32 = 12;
pub const PAR_PA_MASK: i64 = 4503599627366400;
pub const PAR_ATTR_SHIFT: i32 = 56;
pub const PAR_ATTR_MASK: i64 = -72057594037927936;
pub const PAR_FST_SHIFT: i32 = 1;
pub const PAR_FST_MASK: i32 = 126;
pub const PAR_PTW_SHIFT: i32 = 8;
pub const PAR_PTW_MASK: i32 = 256;
pub const PAR_S_SHIFT: i32 = 9;
pub const PAR_S_MASK: i32 = 512;
pub const PMBIDR_EL1_op0: i32 = 3;
pub const PMBIDR_EL1_op1: i32 = 0;
pub const PMBIDR_EL1_CRn: i32 = 9;
pub const PMBIDR_EL1_CRm: i32 = 10;
pub const PMBIDR_EL1_op2: i32 = 7;
pub const PMBIDR_Align_SHIFT: i32 = 0;
pub const PMBIDR_P_SHIFT: i32 = 4;
pub const PMBIDR_F_SHIFT: i32 = 5;
pub const PMBLIMITR_EL1_op0: i32 = 3;
pub const PMBLIMITR_EL1_op1: i32 = 0;
pub const PMBLIMITR_EL1_CRn: i32 = 9;
pub const PMBLIMITR_EL1_CRm: i32 = 10;
pub const PMBLIMITR_EL1_op2: i32 = 0;
pub const PMBLIMITR_E_SHIFT: i32 = 0;
pub const PMBLIMITR_FM_SHIFT: i32 = 1;
pub const PMBLIMITR_PMFZ_SHIFT: i32 = 5;
pub const PMBLIMITR_LIMIT_SHIFT: i32 = 12;
pub const PMBPTR_EL1_op0: i32 = 3;
pub const PMBPTR_EL1_op1: i32 = 0;
pub const PMBPTR_EL1_CRn: i32 = 9;
pub const PMBPTR_EL1_CRm: i32 = 10;
pub const PMBPTR_EL1_op2: i32 = 1;
pub const PMBPTR_PTR_SHIFT: i32 = 0;
pub const PMBSR_EL1_op0: i32 = 3;
pub const PMBSR_EL1_op1: i32 = 0;
pub const PMBSR_EL1_CRn: i32 = 9;
pub const PMBSR_EL1_CRm: i32 = 10;
pub const PMBSR_EL1_op2: i32 = 3;
pub const PMBSR_MSS_SHIFT: i32 = 0;
pub const PMBSR_COLL_SHIFT: i32 = 16;
pub const PMBSR_S_SHIFT: i32 = 17;
pub const PMBSR_EA_SHIFT: i32 = 18;
pub const PMBSR_DL_SHIFT: i32 = 19;
pub const PMBSR_EC_SHIFT: i32 = 26;
pub const PMBSR_EC_OTHER_BUF_MGMT: i32 = 0;
pub const PMBSR_EC_GRAN_PROT_CHK: i32 = 30;
pub const PMBSR_EC_STAGE1_DA: i32 = 36;
pub const PMBSR_EC_STAGE2_DA: i32 = 37;
pub const PMCCFILTR_EL0_op0: i32 = 3;
pub const PMCCFILTR_EL0_op1: i32 = 3;
pub const PMCCFILTR_EL0_CRn: i32 = 14;
pub const PMCCFILTR_EL0_CRm: i32 = 15;
pub const PMCCFILTR_EL0_op2: i32 = 7;
pub const PMCCNTR_EL0_op0: i32 = 3;
pub const PMCCNTR_EL0_op1: i32 = 3;
pub const PMCCNTR_EL0_CRn: i32 = 9;
pub const PMCCNTR_EL0_CRm: i32 = 13;
pub const PMCCNTR_EL0_op2: i32 = 0;
pub const PMCEID0_EL0_op0: i32 = 3;
pub const PMCEID0_EL0_op1: i32 = 3;
pub const PMCEID0_EL0_CRn: i32 = 9;
pub const PMCEID0_EL0_CRm: i32 = 12;
pub const PMCEID0_EL0_op2: i32 = 6;
pub const PMCEID1_EL0_op0: i32 = 3;
pub const PMCEID1_EL0_op1: i32 = 3;
pub const PMCEID1_EL0_CRn: i32 = 9;
pub const PMCEID1_EL0_CRm: i32 = 12;
pub const PMCEID1_EL0_op2: i32 = 7;
pub const PMCNTENCLR_EL0_op0: i32 = 3;
pub const PMCNTENCLR_EL0_op1: i32 = 3;
pub const PMCNTENCLR_EL0_CRn: i32 = 9;
pub const PMCNTENCLR_EL0_CRm: i32 = 12;
pub const PMCNTENCLR_EL0_op2: i32 = 2;
pub const PMCNTENSET_EL0_op0: i32 = 3;
pub const PMCNTENSET_EL0_op1: i32 = 3;
pub const PMCNTENSET_EL0_CRn: i32 = 9;
pub const PMCNTENSET_EL0_CRm: i32 = 12;
pub const PMCNTENSET_EL0_op2: i32 = 1;
pub const PMCR_EL0_op0: i32 = 3;
pub const PMCR_EL0_op1: i32 = 3;
pub const PMCR_EL0_CRn: i32 = 9;
pub const PMCR_EL0_CRm: i32 = 12;
pub const PMCR_EL0_op2: i32 = 0;
pub const PMCR_E: i32 = 1;
pub const PMCR_P: i32 = 2;
pub const PMCR_C: i32 = 4;
pub const PMCR_D: i32 = 8;
pub const PMCR_X: i32 = 16;
pub const PMCR_DP: i32 = 32;
pub const PMCR_LC: i32 = 64;
pub const PMCR_LP: i32 = 128;
pub const PMCR_FZO: i32 = 512;
pub const PMCR_N_SHIFT: i32 = 11;
pub const PMCR_N_MASK: i32 = 63488;
pub const PMCR_IDCODE_SHIFT: i32 = 16;
pub const PMCR_IDCODE_MASK: i32 = 16711680;
pub const PMCR_IDCODE_CORTEX_A57: i32 = 1;
pub const PMCR_IDCODE_CORTEX_A72: i32 = 2;
pub const PMCR_IDCODE_CORTEX_A53: i32 = 3;
pub const PMCR_IDCODE_CORTEX_A73: i32 = 4;
pub const PMCR_IDCODE_CORTEX_A35: i32 = 10;
pub const PMCR_IDCODE_CORTEX_A76: i32 = 11;
pub const PMCR_IDCODE_NEOVERSE_N1: i32 = 12;
pub const PMCR_IDCODE_CORTEX_A77: i32 = 16;
pub const PMCR_IDCODE_CORTEX_A55: i32 = 69;
pub const PMCR_IDCODE_NEOVERSE_E1: i32 = 70;
pub const PMCR_IDCODE_CORTEX_A75: i32 = 74;
pub const PMCR_IMP_SHIFT: i32 = 24;
pub const PMCR_IMP_MASK: i64 = 4278190080;
pub const PMCR_IMP_ARM: i32 = 65;
pub const PMCR_FZS: i64 = 4294967296;
pub const PMEVCNTR_EL0_op0: i32 = 3;
pub const PMEVCNTR_EL0_op1: i32 = 3;
pub const PMEVCNTR_EL0_CRn: i32 = 14;
pub const PMEVCNTR_EL0_CRm: i32 = 8;
pub const PMEVTYPER_EL0_op0: i32 = 3;
pub const PMEVTYPER_EL0_op1: i32 = 3;
pub const PMEVTYPER_EL0_CRn: i32 = 14;
pub const PMEVTYPER_EL0_CRm: i32 = 12;
pub const PMEVTYPER_EVTCOUNT_MASK: i32 = 1023;
pub const PMEVTYPER_EVTCOUNT_8_1_MASK: i32 = 65535;
pub const PMEVTYPER_MT: i32 = 33554432;
pub const PMEVTYPER_M: i32 = 67108864;
pub const PMEVTYPER_NSH: i32 = 134217728;
pub const PMEVTYPER_NSU: i32 = 268435456;
pub const PMEVTYPER_NSK: i32 = 536870912;
pub const PMEVTYPER_U: i32 = 1073741824;
pub const PMEVTYPER_P: i64 = 2147483648;
pub const PMINTENCLR_EL1_op0: i32 = 3;
pub const PMINTENCLR_EL1_op1: i32 = 0;
pub const PMINTENCLR_EL1_CRn: i32 = 9;
pub const PMINTENCLR_EL1_CRm: i32 = 14;
pub const PMINTENCLR_EL1_op2: i32 = 2;
pub const PMINTENSET_EL1_op0: i32 = 3;
pub const PMINTENSET_EL1_op1: i32 = 0;
pub const PMINTENSET_EL1_CRn: i32 = 9;
pub const PMINTENSET_EL1_CRm: i32 = 14;
pub const PMINTENSET_EL1_op2: i32 = 1;
pub const PMMIR_EL1_op0: i32 = 3;
pub const PMMIR_EL1_op1: i32 = 0;
pub const PMMIR_EL1_CRn: i32 = 9;
pub const PMMIR_EL1_CRm: i32 = 14;
pub const PMMIR_EL1_op2: i32 = 6;
pub const PMOVSCLR_EL0_op0: i32 = 3;
pub const PMOVSCLR_EL0_op1: i32 = 3;
pub const PMOVSCLR_EL0_CRn: i32 = 9;
pub const PMOVSCLR_EL0_CRm: i32 = 12;
pub const PMOVSCLR_EL0_op2: i32 = 3;
pub const PMOVSSET_EL0_op0: i32 = 3;
pub const PMOVSSET_EL0_op1: i32 = 3;
pub const PMOVSSET_EL0_CRn: i32 = 9;
pub const PMOVSSET_EL0_CRm: i32 = 14;
pub const PMOVSSET_EL0_op2: i32 = 3;
pub const PMSCR_EL1_op0: i32 = 3;
pub const PMSCR_EL1_op1: i32 = 0;
pub const PMSCR_EL1_CRn: i32 = 9;
pub const PMSCR_EL1_CRm: i32 = 9;
pub const PMSCR_EL1_op2: i32 = 0;
pub const PMSCR_E0SPE_SHIFT: i32 = 0;
pub const PMSCR_E1SPE_SHIFT: i32 = 1;
pub const PMSCR_CX_SHIFT: i32 = 3;
pub const PMSCR_PA_SHIFT: i32 = 4;
pub const PMSCR_TS_SHIFT: i32 = 5;
pub const PMSCR_PCT_SHIFT: i32 = 6;
pub const PMSELR_EL0_op0: i32 = 3;
pub const PMSELR_EL0_op1: i32 = 3;
pub const PMSELR_EL0_CRn: i32 = 9;
pub const PMSELR_EL0_CRm: i32 = 12;
pub const PMSELR_EL0_op2: i32 = 5;
pub const PMSELR_SEL_MASK: i32 = 31;
pub const PMSEVFR_EL1_op0: i32 = 3;
pub const PMSEVFR_EL1_op1: i32 = 0;
pub const PMSEVFR_EL1_CRn: i32 = 9;
pub const PMSEVFR_EL1_CRm: i32 = 9;
pub const PMSEVFR_EL1_op2: i32 = 5;
pub const PMSFCR_EL1_op0: i32 = 3;
pub const PMSFCR_EL1_op1: i32 = 0;
pub const PMSFCR_EL1_CRn: i32 = 9;
pub const PMSFCR_EL1_CRm: i32 = 9;
pub const PMSFCR_EL1_op2: i32 = 4;
pub const PMSFCR_FE_SHIFT: i32 = 0;
pub const PMSFCR_FT_SHIFT: i32 = 1;
pub const PMSFCR_FL_SHIFT: i32 = 2;
pub const PMSFCR_FnE_SHIFT: i32 = 3;
pub const PMSFCR_B_SHIFT: i32 = 16;
pub const PMSFCR_LD_SHIFT: i32 = 17;
pub const PMSFCR_ST_SHIFT: i32 = 18;
pub const PMSICR_EL1_op0: i32 = 3;
pub const PMSICR_EL1_op1: i32 = 0;
pub const PMSICR_EL1_CRn: i32 = 9;
pub const PMSICR_EL1_CRm: i32 = 9;
pub const PMSICR_EL1_op2: i32 = 2;
pub const PMSICR_COUNT_SHIFT: i32 = 0;
pub const PMSICR_ECOUNT_SHIFT: i32 = 56;
pub const PMSIDR_EL1_op0: i32 = 3;
pub const PMSIDR_EL1_op1: i32 = 0;
pub const PMSIDR_EL1_CRn: i32 = 9;
pub const PMSIDR_EL1_CRm: i32 = 9;
pub const PMSIDR_EL1_op2: i32 = 7;
pub const PMSIDR_FE_SHIFT: i32 = 0;
pub const PMSIDR_FT_SHIFT: i32 = 1;
pub const PMSIDR_FL_SHIFT: i32 = 2;
pub const PMSIDR_ArchInst_SHIFT: i32 = 3;
pub const PMSIDR_LDS_SHIFT: i32 = 4;
pub const PMSIDR_ERnd_SHIFT: i32 = 5;
pub const PMSIDR_FnE_SHIFT: i32 = 6;
pub const PMSIDR_Interval_SHIFT: i32 = 8;
pub const PMSIDR_Interval_256: i32 = 0;
pub const PMSIDR_Interval_512: i32 = 2;
pub const PMSIDR_Interval_768: i32 = 3;
pub const PMSIDR_Interval_1024: i32 = 4;
pub const PMSIDR_Interval_1536: i32 = 5;
pub const PMSIDR_Interval_2048: i32 = 6;
pub const PMSIDR_Interval_3072: i32 = 7;
pub const PMSIDR_Interval_4096: i32 = 8;
pub const PMSIDR_MaxSize_SHIFT: i32 = 12;
pub const PMSIDR_CountSize_SHIFT: i32 = 16;
pub const PMSIDR_Format_SHIFT: i32 = 20;
pub const PMSIDR_PBT_SHIFT: i32 = 24;
pub const PMSIRR_EL1_op0: i32 = 3;
pub const PMSIRR_EL1_op1: i32 = 0;
pub const PMSIRR_EL1_CRn: i32 = 9;
pub const PMSIRR_EL1_CRm: i32 = 9;
pub const PMSIRR_EL1_op2: i32 = 3;
pub const PMSIRR_RND_SHIFT: i32 = 0;
pub const PMSIRR_INTERVAL_SHIFT: i32 = 8;
pub const PMSLATFR_EL1_op0: i32 = 3;
pub const PMSLATFR_EL1_op1: i32 = 0;
pub const PMSLATFR_EL1_CRn: i32 = 9;
pub const PMSLATFR_EL1_CRm: i32 = 9;
pub const PMSLATFR_EL1_op2: i32 = 6;
pub const PMSLATFR_MINLAT_SHIFT: i32 = 0;
pub const PMSNEVFR_EL1_op0: i32 = 3;
pub const PMSNEVFR_EL1_op1: i32 = 0;
pub const PMSNEVFR_EL1_CRn: i32 = 9;
pub const PMSNEVFR_EL1_CRm: i32 = 9;
pub const PMSNEVFR_EL1_op2: i32 = 1;
pub const PMSWINC_EL0_op0: i32 = 3;
pub const PMSWINC_EL0_op1: i32 = 3;
pub const PMSWINC_EL0_CRn: i32 = 9;
pub const PMSWINC_EL0_CRm: i32 = 12;
pub const PMSWINC_EL0_op2: i32 = 4;
pub const PMUSERENR_EL0_op0: i32 = 3;
pub const PMUSERENR_EL0_op1: i32 = 3;
pub const PMUSERENR_EL0_CRn: i32 = 9;
pub const PMUSERENR_EL0_CRm: i32 = 14;
pub const PMUSERENR_EL0_op2: i32 = 0;
pub const PMXEVCNTR_EL0_op0: i32 = 3;
pub const PMXEVCNTR_EL0_op1: i32 = 3;
pub const PMXEVCNTR_EL0_CRn: i32 = 9;
pub const PMXEVCNTR_EL0_CRm: i32 = 13;
pub const PMXEVCNTR_EL0_op2: i32 = 2;
pub const PMXEVTYPER_EL0_op0: i32 = 3;
pub const PMXEVTYPER_EL0_op1: i32 = 3;
pub const PMXEVTYPER_EL0_CRn: i32 = 9;
pub const PMXEVTYPER_EL0_CRm: i32 = 13;
pub const PMXEVTYPER_EL0_op2: i32 = 1;
pub const RNDRRS_op0: i32 = 3;
pub const RNDRRS_op1: i32 = 3;
pub const RNDRRS_CRn: i32 = 2;
pub const RNDRRS_CRm: i32 = 4;
pub const RNDRRS_op2: i32 = 1;
pub const SCTLR_EL1_op0: i32 = 3;
pub const SCTLR_EL1_op1: i32 = 0;
pub const SCTLR_EL1_CRn: i32 = 1;
pub const SCTLR_EL1_CRm: i32 = 0;
pub const SCTLR_EL1_op2: i32 = 0;
pub const SCTLR_RES1: i32 = 818939904;
pub const SCTLR_EL12_op0: i32 = 3;
pub const SCTLR_EL12_op1: i32 = 5;
pub const SCTLR_EL12_CRn: i32 = 1;
pub const SCTLR_EL12_CRm: i32 = 0;
pub const SCTLR_EL12_op2: i32 = 0;
pub const SPSR_EL1_op0: i32 = 3;
pub const SPSR_EL1_op1: i32 = 0;
pub const SPSR_EL1_CRn: i32 = 4;
pub const SPSR_EL1_CRm: i32 = 0;
pub const SPSR_EL1_op2: i32 = 0;
pub const PSR_M_EL0t: i32 = 0;
pub const PSR_M_EL1t: i32 = 4;
pub const PSR_M_EL1h: i32 = 5;
pub const PSR_M_EL2t: i32 = 8;
pub const PSR_M_EL2h: i32 = 9;
pub const PSR_M_64: i32 = 0;
pub const PSR_M_32: i32 = 16;
pub const PSR_M_MASK: i32 = 15;
pub const PSR_T: i32 = 32;
pub const PSR_AARCH32: i32 = 16;
pub const PSR_F: i32 = 64;
pub const PSR_I: i32 = 128;
pub const PSR_A: i32 = 256;
pub const PSR_D: i32 = 512;
pub const PSR_DAIF: i32 = 960;
pub const PSR_DAIF_DEFAULT: i32 = 0;
pub const PSR_DAIF_INTR: i32 = 192;
pub const PSR_BTYPE: i32 = 3072;
pub const PSR_SSBS: i32 = 4096;
pub const PSR_ALLINT: i32 = 8192;
pub const PSR_IL: i32 = 1048576;
pub const PSR_SS: i32 = 2097152;
pub const PSR_PAN: i32 = 4194304;
pub const PSR_UAO: i32 = 8388608;
pub const PSR_DIT: i32 = 16777216;
pub const PSR_TCO: i32 = 33554432;
pub const PSR_V: i32 = 268435456;
pub const PSR_C: i32 = 536870912;
pub const PSR_Z: i32 = 1073741824;
pub const PSR_N: i64 = 2147483648;
pub const PSR_FLAGS: i64 = 4026531840;
pub const PSR_SETTABLE_32: i64 = 4026531840;
pub const PSR_SETTABLE_64: i64 = 4028628992;
pub const SPSR_EL12_op0: i32 = 3;
pub const SPSR_EL12_op1: i32 = 5;
pub const SPSR_EL12_CRn: i32 = 4;
pub const SPSR_EL12_CRm: i32 = 0;
pub const SPSR_EL12_op2: i32 = 0;
pub const REVIDR_EL1_op0: i32 = 3;
pub const REVIDR_EL1_op1: i32 = 0;
pub const REVIDR_EL1_CRn: i32 = 0;
pub const REVIDR_EL1_CRm: i32 = 0;
pub const REVIDR_EL1_op2: i32 = 6;
pub const TCR_EL1_op0: i32 = 3;
pub const TCR_EL1_op1: i32 = 0;
pub const TCR_EL1_CRn: i32 = 2;
pub const TCR_EL1_CRm: i32 = 0;
pub const TCR_EL1_op2: i32 = 2;
pub const TCR_DS_SHIFT: i32 = 59;
pub const TCR_TCMA1_SHIFT: i32 = 58;
pub const TCR_TCMA0_SHIFT: i32 = 57;
pub const TCR_E0PD1_SHIFT: i32 = 56;
pub const TCR_E0PD0_SHIFT: i32 = 55;
pub const TCR_NFD1_SHIFT: i32 = 54;
pub const TCR_NFD0_SHIFT: i32 = 53;
pub const TCR_TBID1_SHIFT: i32 = 52;
pub const TCR_TBID0_SHIFT: i32 = 51;
pub const TCR_HWU162_SHIFT: i32 = 50;
pub const TCR_HWU161_SHIFT: i32 = 49;
pub const TCR_HWU160_SHIFT: i32 = 48;
pub const TCR_HWU159_SHIFT: i32 = 47;
pub const TCR_HWU062_SHIFT: i32 = 46;
pub const TCR_HWU061_SHIFT: i32 = 45;
pub const TCR_HWU060_SHIFT: i32 = 44;
pub const TCR_HWU059_SHIFT: i32 = 43;
pub const TCR_HPD1_SHIFT: i32 = 42;
pub const TCR_HPD0_SHIFT: i32 = 41;
pub const TCR_HD_SHIFT: i32 = 40;
pub const TCR_HA_SHIFT: i32 = 39;
pub const TCR_TBI1_SHIFT: i32 = 38;
pub const TCR_TBI0_SHIFT: i32 = 37;
pub const TCR_ASID_SHIFT: i32 = 36;
pub const TCR_ASID_WIDTH: i32 = 1;
pub const TCR_IPS_SHIFT: i32 = 32;
pub const TCR_IPS_WIDTH: i32 = 3;
pub const TCR_TG1_SHIFT: i32 = 30;
pub const TCR_SH1_SHIFT: i32 = 28;
pub const TCR_ORGN1_SHIFT: i32 = 26;
pub const TCR_IRGN1_SHIFT: i32 = 24;
pub const TCR_EPD1_SHIFT: i32 = 23;
pub const TCR_A1_SHIFT: i32 = 22;
pub const TCR_T1SZ_SHIFT: i32 = 16;
pub const TCR_TG0_SHIFT: i32 = 14;
pub const TCR_SH0_SHIFT: i32 = 12;
pub const TCR_ORGN0_SHIFT: i32 = 10;
pub const TCR_IRGN0_SHIFT: i32 = 8;
pub const TCR_EPD0_SHIFT: i32 = 7;
pub const TCR_T0SZ_SHIFT: i32 = 0;
pub const TCR_EL12_op0: i32 = 3;
pub const TCR_EL12_op1: i32 = 5;
pub const TCR_EL12_CRn: i32 = 2;
pub const TCR_EL12_CRm: i32 = 0;
pub const TCR_EL12_op2: i32 = 2;
pub const TTBR_ASID_SHIFT: i32 = 48;
pub const TTBR_ASID_MASK: i64 = -281474976710656;
pub const TTBR_BADDR: i64 = 281474976710654;
pub const TTBR_CnP_SHIFT: i32 = 0;
pub const TTBR_CnP: i32 = 1;
pub const TTBR0_EL1_op0: i32 = 3;
pub const TTBR0_EL1_op1: i32 = 0;
pub const TTBR0_EL1_CRn: i32 = 2;
pub const TTBR0_EL1_CRm: i32 = 0;
pub const TTBR0_EL1_op2: i32 = 0;
pub const TTBR0_EL12_op0: i32 = 3;
pub const TTBR0_EL12_op1: i32 = 5;
pub const TTBR0_EL12_CRn: i32 = 2;
pub const TTBR0_EL12_CRm: i32 = 0;
pub const TTBR0_EL12_op2: i32 = 0;
pub const TTBR1_EL1_op0: i32 = 3;
pub const TTBR1_EL1_op1: i32 = 0;
pub const TTBR1_EL1_CRn: i32 = 2;
pub const TTBR1_EL1_CRm: i32 = 0;
pub const TTBR1_EL1_op2: i32 = 1;
pub const TTBR1_EL12_op0: i32 = 3;
pub const TTBR1_EL12_op1: i32 = 5;
pub const TTBR1_EL12_CRn: i32 = 2;
pub const TTBR1_EL12_CRm: i32 = 0;
pub const TTBR1_EL12_op2: i32 = 1;
pub const VBAR_EL1_op0: i32 = 3;
pub const VBAR_EL1_op1: i32 = 0;
pub const VBAR_EL1_CRn: i32 = 12;
pub const VBAR_EL1_CRm: i32 = 0;
pub const VBAR_EL1_op2: i32 = 0;
pub const VBAR_EL12_op0: i32 = 3;
pub const VBAR_EL12_op1: i32 = 5;
pub const VBAR_EL12_CRn: i32 = 12;
pub const VBAR_EL12_CRm: i32 = 0;
pub const VBAR_EL12_op2: i32 = 0;
pub const ZCR_EL1_op0: i32 = 3;
pub const ZCR_EL1_op1: i32 = 0;
pub const ZCR_EL1_CRn: i32 = 1;
pub const ZCR_EL1_CRm: i32 = 2;
pub const ZCR_EL1_op2: i32 = 0;
pub const ZCR_LEN_SHIFT: i32 = 0;
pub const ZCR_LEN_MASK: i32 = 15;
pub const CPU_SETSIZE: i32 = 1024;
pub const CPU_MAXSIZE: i32 = 1024;
pub const LOCK_DEBUG: i32 = 1;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: i32 = 20;
pub const PRIO_PROCESS: i32 = 0;
pub const PRIO_PGRP: i32 = 1;
pub const PRIO_USER: i32 = 2;
pub const RUSAGE_SELF: i32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_THREAD: i32 = 1;
pub const RLIMIT_CPU: i32 = 0;
pub const RLIMIT_FSIZE: i32 = 1;
pub const RLIMIT_DATA: i32 = 2;
pub const RLIMIT_STACK: i32 = 3;
pub const RLIMIT_CORE: i32 = 4;
pub const RLIMIT_RSS: i32 = 5;
pub const RLIMIT_MEMLOCK: i32 = 6;
pub const RLIMIT_NPROC: i32 = 7;
pub const RLIMIT_NOFILE: i32 = 8;
pub const RLIMIT_SBSIZE: i32 = 9;
pub const RLIMIT_VMEM: i32 = 10;
pub const RLIMIT_AS: i32 = 10;
pub const RLIMIT_NPTS: i32 = 11;
pub const RLIMIT_SWAP: i32 = 12;
pub const RLIMIT_KQUEUES: i32 = 13;
pub const RLIMIT_UMTXP: i32 = 14;
pub const RLIMIT_PIPEBUF: i32 = 15;
pub const RLIM_NLIMITS: i32 = 16;
pub const CP_USER: i32 = 0;
pub const CP_NICE: i32 = 1;
pub const CP_SYS: i32 = 2;
pub const CP_INTR: i32 = 3;
pub const CP_IDLE: i32 = 4;
pub const CPUSTATES: i32 = 5;
pub const GETRLIMITUSAGE_EUID: i32 = 1;
pub const SS_ONSTACK: i32 = 1;
pub const SS_DISABLE: i32 = 4;
pub const MINSIGSTKSZ: i32 = 4096;
pub const SIGSTKSZ: i32 = 36864;
pub const SIGHUP: i32 = 1;
pub const SIGINT: i32 = 2;
pub const SIGQUIT: i32 = 3;
pub const SIGILL: i32 = 4;
pub const SIGTRAP: i32 = 5;
pub const SIGABRT: i32 = 6;
pub const SIGIOT: i32 = 6;
pub const SIGEMT: i32 = 7;
pub const SIGFPE: i32 = 8;
pub const SIGKILL: i32 = 9;
pub const SIGBUS: i32 = 10;
pub const SIGSEGV: i32 = 11;
pub const SIGSYS: i32 = 12;
pub const SIGPIPE: i32 = 13;
pub const SIGALRM: i32 = 14;
pub const SIGTERM: i32 = 15;
pub const SIGURG: i32 = 16;
pub const SIGSTOP: i32 = 17;
pub const SIGTSTP: i32 = 18;
pub const SIGCONT: i32 = 19;
pub const SIGCHLD: i32 = 20;
pub const SIGTTIN: i32 = 21;
pub const SIGTTOU: i32 = 22;
pub const SIGIO: i32 = 23;
pub const SIGXCPU: i32 = 24;
pub const SIGXFSZ: i32 = 25;
pub const SIGVTALRM: i32 = 26;
pub const SIGPROF: i32 = 27;
pub const SIGWINCH: i32 = 28;
pub const SIGINFO: i32 = 29;
pub const SIGUSR1: i32 = 30;
pub const SIGUSR2: i32 = 31;
pub const SIGTHR: i32 = 32;
pub const SIGLWP: i32 = 32;
pub const SIGLIBRT: i32 = 33;
pub const SIGRTMIN: i32 = 65;
pub const SIGRTMAX: i32 = 126;
pub const SIGEV_NONE: i32 = 0;
pub const SIGEV_SIGNAL: i32 = 1;
pub const SIGEV_THREAD: i32 = 2;
pub const SIGEV_KEVENT: i32 = 3;
pub const SIGEV_THREAD_ID: i32 = 4;
pub const ILL_ILLOPC: i32 = 1;
pub const ILL_ILLOPN: i32 = 2;
pub const ILL_ILLADR: i32 = 3;
pub const ILL_ILLTRP: i32 = 4;
pub const ILL_PRVOPC: i32 = 5;
pub const ILL_PRVREG: i32 = 6;
pub const ILL_COPROC: i32 = 7;
pub const ILL_BADSTK: i32 = 8;
pub const BUS_ADRALN: i32 = 1;
pub const BUS_ADRERR: i32 = 2;
pub const BUS_OBJERR: i32 = 3;
pub const BUS_OOMERR: i32 = 100;
pub const SEGV_MAPERR: i32 = 1;
pub const SEGV_ACCERR: i32 = 2;
pub const SEGV_PKUERR: i32 = 100;
pub const FPE_INTOVF: i32 = 1;
pub const FPE_INTDIV: i32 = 2;
pub const FPE_FLTDIV: i32 = 3;
pub const FPE_FLTOVF: i32 = 4;
pub const FPE_FLTUND: i32 = 5;
pub const FPE_FLTRES: i32 = 6;
pub const FPE_FLTINV: i32 = 7;
pub const FPE_FLTSUB: i32 = 8;
pub const FPE_FLTIDO: i32 = 9;
pub const TRAP_BRKPT: i32 = 1;
pub const TRAP_TRACE: i32 = 2;
pub const TRAP_DTRACE: i32 = 3;
pub const TRAP_CAP: i32 = 4;
pub const CLD_EXITED: i32 = 1;
pub const CLD_KILLED: i32 = 2;
pub const CLD_DUMPED: i32 = 3;
pub const CLD_TRAPPED: i32 = 4;
pub const CLD_STOPPED: i32 = 5;
pub const CLD_CONTINUED: i32 = 6;
pub const POLL_IN: i32 = 1;
pub const POLL_OUT: i32 = 2;
pub const POLL_MSG: i32 = 3;
pub const POLL_ERR: i32 = 4;
pub const POLL_PRI: i32 = 5;
pub const POLL_HUP: i32 = 6;
pub const SA_NOCLDSTOP: i32 = 8;
pub const SA_ONSTACK: i32 = 1;
pub const SA_RESTART: i32 = 2;
pub const SA_RESETHAND: i32 = 4;
pub const SA_NODEFER: i32 = 16;
pub const SA_NOCLDWAIT: i32 = 32;
pub const SA_SIGINFO: i32 = 64;
pub const NSIG: i32 = 32;
pub const SI_NOINFO: i32 = 0;
pub const SI_USER: i32 = 65537;
pub const SI_QUEUE: i32 = 65538;
pub const SI_TIMER: i32 = 65539;
pub const SI_ASYNCIO: i32 = 65540;
pub const SI_MESGQ: i32 = 65541;
pub const SI_KERNEL: i32 = 65542;
pub const SI_LWP: i32 = 65543;
pub const SI_UNDEFINED: i32 = 0;
pub const SV_ONSTACK: i32 = 1;
pub const SV_INTERRUPT: i32 = 2;
pub const SV_RESETHAND: i32 = 4;
pub const SV_NODEFER: i32 = 16;
pub const SV_NOCLDSTOP: i32 = 8;
pub const SV_SIGINFO: i32 = 64;
pub const __SIGQUEUE_TID: i64 = 2147483648;
pub const __SIGQUEUE_RSRV: i32 = 1073741824;
pub const SIG_BLOCK: i32 = 1;
pub const SIG_UNBLOCK: i32 = 2;
pub const SIG_SETMASK: i32 = 3;
pub const ARM64_CTX_END: i64 = 2779096485;
pub const ARM64_CTX_SVE: i32 = 6649459;
pub const _MC_FP_VALID: i32 = 1;
pub const UCF_SWAPPED: i32 = 1;
pub const GET_MC_CLEAR_RET: i32 = 1;
pub const CPU_AFF0_MASK: i32 = 255;
pub const CPU_AFF1_MASK: i32 = 65280;
pub const CPU_AFF2_MASK: i32 = 16711680;
pub const CPU_AFF3_MASK: i64 = 1095216660480;
pub const CPU_AFF_MASK: i64 = 1095233437695;
pub const CPU_IMPL_ARM: i32 = 65;
pub const CPU_IMPL_BROADCOM: i32 = 66;
pub const CPU_IMPL_CAVIUM: i32 = 67;
pub const CPU_IMPL_DEC: i32 = 68;
pub const CPU_IMPL_FUJITSU: i32 = 70;
pub const CPU_IMPL_HISILICON: i32 = 72;
pub const CPU_IMPL_INFINEON: i32 = 73;
pub const CPU_IMPL_FREESCALE: i32 = 77;
pub const CPU_IMPL_NVIDIA: i32 = 78;
pub const CPU_IMPL_APM: i32 = 80;
pub const CPU_IMPL_QUALCOMM: i32 = 81;
pub const CPU_IMPL_MARVELL: i32 = 86;
pub const CPU_IMPL_APPLE: i32 = 97;
pub const CPU_IMPL_INTEL: i32 = 105;
pub const CPU_IMPL_AMPERE: i32 = 192;
pub const CPU_IMPL_MICROSOFT: i32 = 109;
pub const CPU_PART_FOUNDATION: i32 = 3328;
pub const CPU_PART_CORTEX_A34: i32 = 3330;
pub const CPU_PART_CORTEX_A53: i32 = 3331;
pub const CPU_PART_CORTEX_A35: i32 = 3332;
pub const CPU_PART_CORTEX_A55: i32 = 3333;
pub const CPU_PART_CORTEX_A65: i32 = 3334;
pub const CPU_PART_CORTEX_A57: i32 = 3335;
pub const CPU_PART_CORTEX_A72: i32 = 3336;
pub const CPU_PART_CORTEX_A73: i32 = 3337;
pub const CPU_PART_CORTEX_A75: i32 = 3338;
pub const CPU_PART_CORTEX_A76: i32 = 3339;
pub const CPU_PART_NEOVERSE_N1: i32 = 3340;
pub const CPU_PART_CORTEX_A77: i32 = 3341;
pub const CPU_PART_CORTEX_A76AE: i32 = 3342;
pub const CPU_PART_AEM_V8: i32 = 3343;
pub const CPU_PART_NEOVERSE_V1: i32 = 3392;
pub const CPU_PART_CORTEX_A78: i32 = 3393;
pub const CPU_PART_CORTEX_A78AE: i32 = 3394;
pub const CPU_PART_CORTEX_A65AE: i32 = 3395;
pub const CPU_PART_CORTEX_X1: i32 = 3396;
pub const CPU_PART_CORTEX_A510: i32 = 3398;
pub const CPU_PART_CORTEX_A710: i32 = 3399;
pub const CPU_PART_CORTEX_X2: i32 = 3400;
pub const CPU_PART_NEOVERSE_N2: i32 = 3401;
pub const CPU_PART_NEOVERSE_E1: i32 = 3402;
pub const CPU_PART_CORTEX_A78C: i32 = 3403;
pub const CPU_PART_CORTEX_X1C: i32 = 3404;
pub const CPU_PART_CORTEX_A715: i32 = 3405;
pub const CPU_PART_CORTEX_X3: i32 = 3406;
pub const CPU_PART_NEOVERSE_V2: i32 = 3407;
pub const CPU_PART_CORTEX_A520: i32 = 3456;
pub const CPU_PART_CORTEX_A720: i32 = 3457;
pub const CPU_PART_CORTEX_X4: i32 = 3458;
pub const CPU_PART_NEOVERSE_V3AE: i32 = 3459;
pub const CPU_PART_NEOVERSE_V3: i32 = 3460;
pub const CPU_PART_CORTEX_X925: i32 = 3461;
pub const CPU_PART_CORTEX_A725: i32 = 3463;
pub const CPU_PART_C1_NANO: i32 = 3466;
pub const CPU_PART_C1_PRO: i32 = 3467;
pub const CPU_PART_C1_ULTRA: i32 = 3468;
pub const CPU_PART_NEOVERSE_N3: i32 = 3470;
pub const CPU_PART_C1_PREMIUM: i32 = 3472;
pub const CPU_PART_THUNDERX: i32 = 161;
pub const CPU_PART_THUNDERX_81XX: i32 = 162;
pub const CPU_PART_THUNDERX_83XX: i32 = 163;
pub const CPU_PART_THUNDERX2: i32 = 175;
pub const CPU_REV_THUNDERX_1_0: i32 = 0;
pub const CPU_REV_THUNDERX_1_1: i32 = 1;
pub const CPU_REV_THUNDERX2_0: i32 = 0;
pub const CPU_PART_EMAG8180: i32 = 0;
pub const CPU_PART_AMPERE1: i32 = 2755;
pub const CPU_PART_AMPERE1A: i32 = 2756;
pub const CPU_PART_AZURE_COBALT_100: i32 = 3401;
pub const CPU_PART_KRYO400_GOLD: i32 = 2052;
pub const CPU_PART_KRYO400_SILVER: i32 = 2053;
pub const CPU_PART_M1_ICESTORM: i32 = 34;
pub const CPU_PART_M1_FIRESTORM: i32 = 35;
pub const CPU_PART_M1_ICESTORM_PRO: i32 = 36;
pub const CPU_PART_M1_FIRESTORM_PRO: i32 = 37;
pub const CPU_PART_M1_ICESTORM_MAX: i32 = 40;
pub const CPU_PART_M1_FIRESTORM_MAX: i32 = 41;
pub const CPU_PART_M2_BLIZZARD: i32 = 50;
pub const CPU_PART_M2_AVALANCHE: i32 = 51;
pub const CPU_PART_M2_BLIZZARD_PRO: i32 = 52;
pub const CPU_PART_M2_AVALANCHE_PRO: i32 = 53;
pub const CPU_PART_M2_BLIZZARD_MAX: i32 = 56;
pub const CPU_PART_M2_AVALANCHE_MAX: i32 = 57;
pub const CPU_IMPL_MASK: i64 = 4278190080;
pub const CPU_PART_MASK: i32 = 65520;
pub const CPU_VAR_MASK: i32 = 15728640;
pub const CPU_ARCH_MASK: i32 = 983040;
pub const CPU_REV_MASK: i32 = 15;
pub const CPU_MATCH_ERRATA_CAVIUM_THUNDERX_1_1: i32 = 0;
pub const DPCPU_SETNAME: &[u8; 9] = b"set_pcpu\0";
pub const DPCPU_SYMPREFIX: &[u8; 12] = b"pcpu_entry_\0";
pub const DPCPU_MODMIN: i32 = 2048;
pub const UMA_PCPU_ALLOC_SIZE: i32 = 4096;
pub const HASH_NOWAIT: i32 = 1;
pub const HASH_WAITOK: i32 = 2;
pub const HD_COLUMN_MASK: i32 = 255;
pub const HD_DELIM_MASK: i32 = 65280;
pub const HD_OMIT_COUNT: i32 = 65536;
pub const HD_OMIT_HEX: i32 = 131072;
pub const HD_OMIT_CHARS: i32 = 262144;
pub const GETENV_UNSIGNED: i32 = 0;
pub const GETENV_SIGNED: i32 = 1;
pub const LIBKERN_LEN_BCD2BIN: i32 = 154;
pub const LIBKERN_LEN_BIN2BCD: i32 = 100;
pub const LIBKERN_LEN_HEX2ASCII: i32 = 36;
pub const ARC4_ENTR_NONE: i32 = 0;
pub const ARC4_ENTR_HAVE: i32 = 1;
pub const ARC4_ENTR_SEED: i32 = 2;
pub const FNM_NOMATCH: i32 = 1;
pub const FNM_NOESCAPE: i32 = 1;
pub const FNM_PATHNAME: i32 = 2;
pub const FNM_PERIOD: i32 = 4;
pub const FNM_LEADING_DIR: i32 = 8;
pub const FNM_CASEFOLD: i32 = 16;
pub const FNM_IGNORECASE: i32 = 16;
pub const FNM_FILE_NAME: i32 = 2;
pub const FILTER_STRAY: i32 = 1;
pub const FILTER_HANDLED: i32 = 2;
pub const FILTER_SCHEDULE_THREAD: i32 = 4;
pub const RLE_RESERVED: i32 = 1;
pub const RLE_ALLOCATED: i32 = 2;
pub const RLE_PREFETCH: i32 = 4;
pub const BUS_PROBE_SPECIFIC: i32 = 0;
pub const BUS_PROBE_VENDOR: i32 = -10;
pub const BUS_PROBE_DEFAULT: i32 = -20;
pub const BUS_PROBE_LOW_PRIORITY: i32 = -40;
pub const BUS_PROBE_GENERIC: i32 = -100;
pub const BUS_PROBE_HOOVER: i32 = -1000000;
pub const BUS_PROBE_NOWILDCARD: i32 = -2000000000;
pub const BUS_PASS_ROOT: i32 = 0;
pub const BUS_PASS_BUS: i32 = 10;
pub const BUS_PASS_CPU: i32 = 20;
pub const BUS_PASS_RESOURCE: i32 = 30;
pub const BUS_PASS_INTERRUPT: i32 = 40;
pub const BUS_PASS_TIMER: i32 = 50;
pub const BUS_PASS_SCHEDULER: i32 = 60;
pub const BUS_PASS_SUPPORTDEV: i32 = 100000;
pub const BUS_PASS_DEFAULT: i32 = 2147483647;
pub const BUS_PASS_ORDER_FIRST: i32 = 0;
pub const BUS_PASS_ORDER_EARLY: i32 = 2;
pub const BUS_PASS_ORDER_MIDDLE: i32 = 5;
pub const BUS_PASS_ORDER_LATE: i32 = 7;
pub const BUS_PASS_ORDER_LAST: i32 = 9;
pub const BUS_LOCATOR_ACPI: &[u8; 5] = b"ACPI\0";
pub const BUS_LOCATOR_FREEBSD: &[u8; 8] = b"FreeBSD\0";
pub const BUS_LOCATOR_UEFI: &[u8; 5] = b"UEFI\0";
pub const BUS_LOCATOR_OFW: &[u8; 4] = b"OFW\0";
pub const TS_ENTER: i32 = 0;
pub const TS_EXIT: i32 = 1;
pub const TS_THREAD: i32 = 2;
pub const TS_EVENT: i32 = 3;
pub const DEV_PROP_NAME_IOMMU: &[u8; 11] = b"iommu-unit\0";
pub const CPU_LEVEL_ROOT: i32 = 1;
pub const CPU_LEVEL_CPUSET: i32 = 2;
pub const CPU_LEVEL_WHICH: i32 = 3;
pub const CPU_WHICH_TID: i32 = 1;
pub const CPU_WHICH_PID: i32 = 2;
pub const CPU_WHICH_CPUSET: i32 = 3;
pub const CPU_WHICH_IRQ: i32 = 4;
pub const CPU_WHICH_JAIL: i32 = 5;
pub const CPU_WHICH_DOMAIN: i32 = 6;
pub const CPU_WHICH_INTRHANDLER: i32 = 7;
pub const CPU_WHICH_ITHREAD: i32 = 8;
pub const CPU_WHICH_TIDPID: i32 = 9;
pub const CPUSET_INVALID: i32 = -1;
pub const CPUSET_DEFAULT: i32 = 0;
pub const CPU_SET_ROOT: i32 = 1;
pub const CPU_SET_RDONLY: i32 = 2;
pub const M_NOWAIT: i32 = 1;
pub const M_WAITOK: i32 = 2;
pub const M_NORECLAIM: i32 = 128;
pub const M_ZERO: i32 = 256;
pub const M_NOVM: i32 = 512;
pub const M_USE_RESERVE: i32 = 1024;
pub const M_NODUMP: i32 = 2048;
pub const M_FIRSTFIT: i32 = 4096;
pub const M_BESTFIT: i32 = 8192;
pub const M_EXEC: i32 = 16384;
pub const M_NEXTFIT: i32 = 32768;
pub const M_NEVERFREED: i32 = 65536;
pub const M_VERSION: i32 = 2024073001;
pub const DTMALLOC_PROBE_MALLOC: i32 = 0;
pub const DTMALLOC_PROBE_FREE: i32 = 1;
pub const DTMALLOC_PROBE_MAX: i32 = 2;
pub const MALLOC_TYPE_STREAM_VERSION: i32 = 1;
pub const MALLOC_MAX_NAME: i32 = 32;
pub const VM_MEMATTR_DEVICE_nGnRnE: i32 = 0;
pub const VM_MEMATTR_UNCACHEABLE: i32 = 1;
pub const VM_MEMATTR_WRITE_BACK: i32 = 2;
pub const VM_MEMATTR_WRITE_THROUGH: i32 = 3;
pub const VM_MEMATTR_DEVICE_nGnRE: i32 = 4;
pub const VM_MEMATTR_DEVICE: i32 = 4;
pub const VM_MEMATTR_DEVICE_NP: i32 = 0;
pub const VM_MEMATTR_WRITE_COMBINING: i32 = 3;
pub const VM_MEMATTR_DEFAULT: i32 = 2;
pub const SWAP_RESERVE_FORCE_ON: i32 = 1;
pub const SWAP_RESERVE_RLIMIT_ON: i32 = 2;
pub const SWAP_RESERVE_ALLOW_NONWIRED: i32 = 4;
pub const OFW_STD_DIRECT: &[u8; 8] = b"ofw_std\0";
pub const OFW_STD_REAL: &[u8; 9] = b"ofw_real\0";
pub const OFW_STD_32BIT: &[u8; 10] = b"ofw_32bit\0";
pub const OFW_FDT: &[u8; 8] = b"ofw_fdt\0";
pub const NIRQ: i32 = 16384;
pub const INTR_ROOT_IRQ: i32 = 0;
pub const INTR_ROOT_FIQ: i32 = 1;
pub const INTR_ROOT_COUNT: i32 = 2;
pub const INTR_IRQ_INVALID: i64 = 4294967295;
pub const INTR_ISRC_NAMELEN: i32 = 20;
pub const INTR_ISRCF_IPI: i32 = 1;
pub const INTR_ISRCF_PPI: i32 = 2;
pub const INTR_ISRCF_BOUND: i32 = 4;
pub const ICHS_QUEUED: i32 = 1;
pub const ICHS_RUNNING: i32 = 2;
pub const ICHS_DONE: i32 = 3;
pub const KTR_GEN: i32 = 1;
pub const KTR_NET: i32 = 2;
pub const KTR_DEV: i32 = 4;
pub const KTR_LOCK: i32 = 8;
pub const KTR_SMP: i32 = 16;
pub const KTR_SUBSYS: i32 = 32;
pub const KTR_PMAP: i32 = 64;
pub const KTR_MALLOC: i32 = 128;
pub const KTR_TRAP: i32 = 256;
pub const KTR_INTR: i32 = 512;
pub const KTR_SIG: i32 = 1024;
pub const KTR_SPARE2: i32 = 2048;
pub const KTR_PROC: i32 = 4096;
pub const KTR_SYSC: i32 = 8192;
pub const KTR_INIT: i32 = 16384;
pub const KTR_SPARE3: i32 = 32768;
pub const KTR_SPARE4: i32 = 65536;
pub const KTR_EVH: i32 = 131072;
pub const KTR_VFS: i32 = 262144;
pub const KTR_VOP: i32 = 524288;
pub const KTR_VM: i32 = 1048576;
pub const KTR_INET: i32 = 2097152;
pub const KTR_RUNQ: i32 = 4194304;
pub const KTR_SPARE5: i32 = 8388608;
pub const KTR_UMA: i32 = 16777216;
pub const KTR_CALLOUT: i32 = 33554432;
pub const KTR_GEOM: i32 = 67108864;
pub const KTR_BUSDMA: i32 = 134217728;
pub const KTR_INET6: i32 = 268435456;
pub const KTR_SCHED: i32 = 536870912;
pub const KTR_BUF: i32 = 1073741824;
pub const KTR_PTRACE: i64 = 2147483648;
pub const KTR_ALL: i64 = 4294967295;
pub const KTR_COMPILE: i32 = 0;
pub const LC_SLEEPLOCK: i32 = 1;
pub const LC_SPINLOCK: i32 = 2;
pub const LC_SLEEPABLE: i32 = 4;
pub const LC_RECURSABLE: i32 = 8;
pub const LC_UPGRADABLE: i32 = 16;
pub const LO_CLASSFLAGS: i32 = 65535;
pub const LO_INITIALIZED: i32 = 65536;
pub const LO_WITNESS: i32 = 131072;
pub const LO_QUIET: i32 = 262144;
pub const LO_RECURSABLE: i32 = 524288;
pub const LO_SLEEPABLE: i32 = 1048576;
pub const LO_UPGRADABLE: i32 = 2097152;
pub const LO_DUPOK: i32 = 4194304;
pub const LO_IS_VNODE: i32 = 8388608;
pub const LO_CLASSMASK: i32 = 251658240;
pub const LO_NOPROFILE: i32 = 268435456;
pub const LO_NEW: i32 = 536870912;
pub const LO_CLASSSHIFT: i32 = 24;
pub const LOCK_CLASS_MAX: i32 = 15;
pub const LOP_NEWORDER: i32 = 1;
pub const LOP_QUIET: i32 = 2;
pub const LOP_TRYLOCK: i32 = 4;
pub const LOP_EXCLUSIVE: i32 = 8;
pub const LOP_DUPOK: i32 = 16;
pub const LOP_NOSLEEP: i32 = 32;
pub const LA_MASKASSERT: i32 = 255;
pub const LA_UNLOCKED: i32 = 0;
pub const LA_LOCKED: i32 = 1;
pub const LA_SLOCKED: i32 = 2;
pub const LA_XLOCKED: i32 = 4;
pub const LA_RECURSED: i32 = 8;
pub const LA_NOTRECURSED: i32 = 16;
pub const WARN_GIANTOK: i32 = 1;
pub const WARN_PANIC: i32 = 2;
pub const WARN_SLEEPOK: i32 = 4;
pub const MDT_DEPEND: i32 = 1;
pub const MDT_MODULE: i32 = 2;
pub const MDT_VERSION: i32 = 3;
pub const MDT_PNP_INFO: i32 = 4;
pub const MDT_STRUCT_VERSION: i32 = 1;
pub const MDT_SETNAME: &[u8; 16] = b"modmetadata_set\0";
pub const MAXMODNAMEV1V2: i32 = 32;
pub const MAXMODNAMEV3: i32 = 1024;
pub const MAXMODNAME: i32 = 1024;
pub const _SDT_ASM_PATCH_INSTR: &[u8; 4] = b"nop\0";
pub const _SDT_TRACEPOINT_SECTION: &[u8; 23] = b"set_sdt_tracepoint_set\0";
pub const _SDT_ASM_WORD: &[u8; 6] = b".quad\0";
pub const _SDT_ASM_PROBE_CONSTRAINT: &[u8; 2] = b"i\0";
pub const _SDT_ASM_PROBE_OPERAND: &[u8; 2] = b"c\0";
pub const LOCKSTAT_WRITER: i32 = 0;
pub const LOCKSTAT_READER: i32 = 1;
pub const MTX_DEF: i32 = 0;
pub const MTX_SPIN: i32 = 1;
pub const MTX_RECURSE: i32 = 4;
pub const MTX_NOWITNESS: i32 = 8;
pub const MTX_NOPROFILE: i32 = 32;
pub const MTX_NEW: i32 = 64;
pub const MTX_QUIET: i32 = 2;
pub const MTX_DUPOK: i32 = 16;
pub const MTX_UNOWNED: i32 = 0;
pub const MTX_RECURSED: i32 = 1;
pub const MTX_WAITERS: i32 = 2;
pub const MTX_DESTROYED: i32 = 4;
pub const MTX_FLAGMASK: i32 = 7;
pub const MA_OWNED: i32 = 4;
pub const MA_NOTOWNED: i32 = 0;
pub const MA_RECURSED: i32 = 8;
pub const MA_NOTRECURSED: i32 = 16;
pub const MTX_NETWORK_LOCK: &[u8; 15] = b"network driver\0";
pub const EVFILT_READ: i32 = -1;
pub const EVFILT_WRITE: i32 = -2;
pub const EVFILT_AIO: i32 = -3;
pub const EVFILT_VNODE: i32 = -4;
pub const EVFILT_PROC: i32 = -5;
pub const EVFILT_SIGNAL: i32 = -6;
pub const EVFILT_TIMER: i32 = -7;
pub const EVFILT_PROCDESC: i32 = -8;
pub const EVFILT_FS: i32 = -9;
pub const EVFILT_LIO: i32 = -10;
pub const EVFILT_USER: i32 = -11;
pub const EVFILT_SENDFILE: i32 = -12;
pub const EVFILT_EMPTY: i32 = -13;
pub const EVFILT_JAIL: i32 = -14;
pub const EVFILT_JAILDESC: i32 = -15;
pub const EVFILT_SYSCOUNT: i32 = 15;
pub const EV_ADD: i32 = 1;
pub const EV_DELETE: i32 = 2;
pub const EV_ENABLE: i32 = 4;
pub const EV_DISABLE: i32 = 8;
pub const EV_FORCEONESHOT: i32 = 256;
pub const EV_KEEPUDATA: i32 = 512;
pub const EV_ONESHOT: i32 = 16;
pub const EV_CLEAR: i32 = 32;
pub const EV_RECEIPT: i32 = 64;
pub const EV_DISPATCH: i32 = 128;
pub const EV_SYSFLAGS: i32 = 61440;
pub const EV_DROP: i32 = 4096;
pub const EV_FLAG1: i32 = 8192;
pub const EV_FLAG2: i32 = 16384;
pub const EV_EOF: i32 = 32768;
pub const EV_ERROR: i32 = 16384;
pub const NOTE_FFNOP: i32 = 0;
pub const NOTE_FFAND: i32 = 1073741824;
pub const NOTE_FFOR: i64 = 2147483648;
pub const NOTE_FFCOPY: i64 = 3221225472;
pub const NOTE_FFCTRLMASK: i64 = 3221225472;
pub const NOTE_FFLAGSMASK: i32 = 16777215;
pub const NOTE_TRIGGER: i32 = 16777216;
pub const NOTE_LOWAT: i32 = 1;
pub const NOTE_FILE_POLL: i32 = 2;
pub const NOTE_DELETE: i32 = 1;
pub const NOTE_WRITE: i32 = 2;
pub const NOTE_EXTEND: i32 = 4;
pub const NOTE_ATTRIB: i32 = 8;
pub const NOTE_LINK: i32 = 16;
pub const NOTE_RENAME: i32 = 32;
pub const NOTE_REVOKE: i32 = 64;
pub const NOTE_OPEN: i32 = 128;
pub const NOTE_CLOSE: i32 = 256;
pub const NOTE_CLOSE_WRITE: i32 = 512;
pub const NOTE_READ: i32 = 1024;
pub const NOTE_EXIT: i64 = 2147483648;
pub const NOTE_FORK: i32 = 1073741824;
pub const NOTE_EXEC: i32 = 536870912;
pub const NOTE_PCTRLMASK: i64 = 4026531840;
pub const NOTE_PDATAMASK: i32 = 1048575;
pub const NOTE_TRACK: i32 = 1;
pub const NOTE_TRACKERR: i32 = 2;
pub const NOTE_CHILD: i32 = 4;
pub const NOTE_JAIL_CHILD: i64 = 2147483648;
pub const NOTE_JAIL_SET: i32 = 1073741824;
pub const NOTE_JAIL_ATTACH: i32 = 536870912;
pub const NOTE_JAIL_REMOVE: i32 = 268435456;
pub const NOTE_JAIL_MULTI: i32 = 134217728;
pub const NOTE_JAIL_CTRLMASK: i64 = 4026531840;
pub const NOTE_SECONDS: i32 = 1;
pub const NOTE_MSECONDS: i32 = 2;
pub const NOTE_USECONDS: i32 = 4;
pub const NOTE_NSECONDS: i32 = 8;
pub const NOTE_ABSTIME: i32 = 16;
pub const KQUEUE_CLOEXEC: i32 = 1;
pub const KQUEUE_CPONFORK: i32 = 2;
pub const KNF_LISTLOCKED: i32 = 1;
pub const KNF_NOKQLOCK: i32 = 2;
pub const NOTE_SIGNAL: i32 = 134217728;
pub const EVENT_REGISTER: i32 = 1;
pub const EVENT_PROCESS: i32 = 2;
pub const KN_ACTIVE: i32 = 1;
pub const KN_QUEUED: i32 = 2;
pub const KN_DISABLED: i32 = 4;
pub const KN_DETACHED: i32 = 8;
pub const KN_MARKER: i32 = 32;
pub const KN_KQUEUE: i32 = 64;
pub const KN_SCAN: i32 = 256;
pub const OSD_THREAD: i32 = 0;
pub const OSD_JAIL: i32 = 1;
pub const OSD_KHELP: i32 = 2;
pub const OSD_FIRST: i32 = 0;
pub const OSD_LAST: i32 = 2;
pub const RTP_PRIO_ITHD: i32 = 1;
pub const RTP_PRIO_REALTIME: i32 = 2;
pub const RTP_PRIO_NORMAL: i32 = 3;
pub const RTP_PRIO_IDLE: i32 = 4;
pub const RTP_PRIO_FIFO_BIT: i32 = 8;
pub const RTP_PRIO_FIFO: i32 = 10;
pub const RTP_PRIO_MIN: i32 = 0;
pub const RTP_PRIO_MAX: i32 = 31;
pub const RTP_LOOKUP: i32 = 0;
pub const RTP_SET: i32 = 1;
pub const PS_NOCLDWAIT: i32 = 1;
pub const PS_NOCLDSTOP: i32 = 2;
pub const PS_CLDSIGIGN: i32 = 4;
pub const KSI_TRAP: i32 = 1;
pub const KSI_EXT: i32 = 2;
pub const KSI_INS: i32 = 4;
pub const KSI_SIGQ: i32 = 8;
pub const KSI_HEAD: i32 = 16;
pub const KSI_PTRACE: i32 = 32;
pub const KSI_COPYMASK: i32 = 41;
pub const SQ_INIT: i32 = 1;
pub const SIGFASTBLOCK_SETPTR: i32 = 1;
pub const SIGFASTBLOCK_UNBLOCK: i32 = 2;
pub const SIGFASTBLOCK_UNSETPTR: i32 = 3;
pub const SIGFASTBLOCK_PEND: i32 = 1;
pub const SIGFASTBLOCK_FLAGS: i32 = 15;
pub const SIGFASTBLOCK_INC: i32 = 16;
pub const SIGPROCMASK_OLD: i32 = 1;
pub const SIGPROCMASK_PROC_LOCKED: i32 = 2;
pub const SIGPROCMASK_PS_LOCKED: i32 = 4;
pub const SIGPROCMASK_FASTBLK: i32 = 8;
pub const SIGDEFERSTOP_NOP: i32 = 0;
pub const SIGDEFERSTOP_OFF: i32 = 1;
pub const SIGDEFERSTOP_SILENT: i32 = 2;
pub const SIGDEFERSTOP_EINTR: i32 = 3;
pub const SIGDEFERSTOP_ERESTART: i32 = 4;
pub const SIGDEFERSTOP_VAL_NCHG: i32 = -1;
pub const AUDIT_RECORD_MAGIC: i64 = 2190085915;
pub const MAX_AUDIT_RECORDS: i32 = 20;
pub const MAXAUDITDATA: i32 = 32767;
pub const MAX_AUDIT_RECORD_SIZE: i32 = 32767;
pub const MIN_AUDIT_FILE_SIZE: i32 = 524288;
pub const AUDIT_HARD_LIMIT_FREE_BLOCKS: i32 = 4;
pub const AUDIT_TRIGGER_MIN: i32 = 1;
pub const AUDIT_TRIGGER_LOW_SPACE: i32 = 1;
pub const AUDIT_TRIGGER_ROTATE_KERNEL: i32 = 2;
pub const AUDIT_TRIGGER_READ_FILE: i32 = 3;
pub const AUDIT_TRIGGER_CLOSE_AND_DIE: i32 = 4;
pub const AUDIT_TRIGGER_NO_SPACE: i32 = 5;
pub const AUDIT_TRIGGER_ROTATE_USER: i32 = 6;
pub const AUDIT_TRIGGER_INITIALIZE: i32 = 7;
pub const AUDIT_TRIGGER_EXPIRE_TRAILS: i32 = 8;
pub const AUDIT_TRIGGER_MAX: i32 = 8;
pub const AUDITDEV_FILENAME: &[u8; 6] = b"audit\0";
pub const AUDIT_TRIGGER_FILE: &[u8; 11] = b"/dev/audit\0";
pub const AU_DEFAUDITSID: i32 = 0;
pub const AU_ASSIGN_ASID: i32 = -1;
pub const AUC_UNSET: i32 = 0;
pub const AUC_AUDITING: i32 = 1;
pub const AUC_NOAUDIT: i32 = 2;
pub const AUC_DISABLED: i32 = -1;
pub const A_OLDGETPOLICY: i32 = 2;
pub const A_OLDSETPOLICY: i32 = 3;
pub const A_GETKMASK: i32 = 4;
pub const A_SETKMASK: i32 = 5;
pub const A_OLDGETQCTRL: i32 = 6;
pub const A_OLDSETQCTRL: i32 = 7;
pub const A_GETCWD: i32 = 8;
pub const A_GETCAR: i32 = 9;
pub const A_GETSTAT: i32 = 12;
pub const A_SETSTAT: i32 = 13;
pub const A_SETUMASK: i32 = 14;
pub const A_SETSMASK: i32 = 15;
pub const A_OLDGETCOND: i32 = 20;
pub const A_OLDSETCOND: i32 = 21;
pub const A_GETCLASS: i32 = 22;
pub const A_SETCLASS: i32 = 23;
pub const A_GETPINFO: i32 = 24;
pub const A_SETPMASK: i32 = 25;
pub const A_SETFSIZE: i32 = 26;
pub const A_GETFSIZE: i32 = 27;
pub const A_GETPINFO_ADDR: i32 = 28;
pub const A_GETKAUDIT: i32 = 29;
pub const A_SETKAUDIT: i32 = 30;
pub const A_SENDTRIGGER: i32 = 31;
pub const A_GETSINFO_ADDR: i32 = 32;
pub const A_GETPOLICY: i32 = 33;
pub const A_SETPOLICY: i32 = 34;
pub const A_GETQCTRL: i32 = 35;
pub const A_SETQCTRL: i32 = 36;
pub const A_GETCOND: i32 = 37;
pub const A_SETCOND: i32 = 38;
pub const A_GETEVENT: i32 = 39;
pub const A_SETEVENT: i32 = 40;
pub const AUDIT_CNT: i32 = 1;
pub const AUDIT_AHLT: i32 = 2;
pub const AUDIT_ARGV: i32 = 4;
pub const AUDIT_ARGE: i32 = 8;
pub const AUDIT_SEQ: i32 = 16;
pub const AUDIT_WINDATA: i32 = 32;
pub const AUDIT_USER: i32 = 64;
pub const AUDIT_GROUP: i32 = 128;
pub const AUDIT_TRAIL: i32 = 256;
pub const AUDIT_PATH: i32 = 512;
pub const AUDIT_SCNT: i32 = 1024;
pub const AUDIT_PUBLIC: i32 = 2048;
pub const AUDIT_ZONENAME: i32 = 4096;
pub const AUDIT_PERZONE: i32 = 8192;
pub const AQ_HIWATER: i32 = 100;
pub const AQ_MAXHIGH: i32 = 10000;
pub const AQ_LOWATER: i32 = 10;
pub const AQ_BUFSZ: i32 = 32767;
pub const AQ_MAXBUFSZ: i32 = 1048576;
pub const AU_FS_MINFREE: i32 = 20;
pub const AU_IPv4: i32 = 4;
pub const AU_IPv6: i32 = 16;
pub const EVNAMEMAP_NAME_SIZE: i32 = 64;
pub const CRED_FLAG_CAPMODE: i32 = 1;
pub const CRED_FLAG_GROUPSET: i32 = 2;
pub const CRED_SMALLGROUPS_NB: i32 = 16;
pub const XU_NGROUPS: i32 = 16;
pub const XUCRED_VERSION: i32 = 0;
pub const SETCREDF_UID: i32 = 1;
pub const SETCREDF_RUID: i32 = 2;
pub const SETCREDF_SVUID: i32 = 4;
pub const SETCREDF_GID: i32 = 8;
pub const SETCREDF_RGID: i32 = 16;
pub const SETCREDF_SVGID: i32 = 32;
pub const SETCREDF_SUPP_GROUPS: i32 = 64;
pub const SETCREDF_MAC_LABEL: i32 = 128;
pub const SETCREDF_MASK: i32 = 255;
pub const DOMAINSET_SETSIZE: i32 = 8;
pub const DOMAINSET_MAXSIZE: i32 = 256;
pub const KINFO_PROC_SIZE: i32 = 1088;
pub const KINFO_PROC32_SIZE: i32 = 816;
pub const PGRP_ORPHANED: i32 = 1;
pub const TDF_BORROWING: i32 = 1;
pub const TDF_INPANIC: i32 = 2;
pub const TDF_INMEM: i32 = 4;
pub const TDF_SINTR: i32 = 8;
pub const TDF_TIMEOUT: i32 = 16;
pub const TDF_IDLETD: i32 = 32;
pub const TDF_UNUSED11: i32 = 64;
pub const TDF_SIGWAIT: i32 = 128;
pub const TDF_KTH_SUSP: i32 = 256;
pub const TDF_ALLPROCSUSP: i32 = 512;
pub const TDF_BOUNDARY: i32 = 1024;
pub const TDF_UNUSED1: i32 = 2048;
pub const TDF_UNUSED2: i32 = 4096;
pub const TDF_SBDRY: i32 = 8192;
pub const TDF_UPIBLOCKED: i32 = 16384;
pub const TDF_UNUSED3: i32 = 32768;
pub const TDF_UNUSED4: i32 = 65536;
pub const TDF_UNUSED5: i32 = 131072;
pub const TDF_NOLOAD: i32 = 262144;
pub const TDF_SERESTART: i32 = 524288;
pub const TDF_THRWAKEUP: i32 = 1048576;
pub const TDF_SEINTR: i32 = 2097152;
pub const TDF_UNUSED12: i32 = 4194304;
pub const TDF_UNUSED6: i32 = 8388608;
pub const TDF_SCHED0: i32 = 16777216;
pub const TDF_SCHED1: i32 = 33554432;
pub const TDF_SCHED2: i32 = 67108864;
pub const TDF_SCHED3: i32 = 134217728;
pub const TDF_UNUSED7: i32 = 268435456;
pub const TDF_UNUSED8: i32 = 536870912;
pub const TDF_UNUSED9: i32 = 1073741824;
pub const TDF_UNUSED10: i64 = 2147483648;
pub const TDB_SUSPEND: i32 = 1;
pub const TDB_XSIG: i32 = 2;
pub const TDB_USERWR: i32 = 4;
pub const TDB_SCE: i32 = 8;
pub const TDB_SCX: i32 = 16;
pub const TDB_EXEC: i32 = 32;
pub const TDB_FORK: i32 = 64;
pub const TDB_STOPATFORK: i32 = 128;
pub const TDB_CHILD: i32 = 256;
pub const TDB_BORN: i32 = 512;
pub const TDB_EXIT: i32 = 1024;
pub const TDB_VFORK: i32 = 2048;
pub const TDB_FSTP: i32 = 4096;
pub const TDB_STEP: i32 = 8192;
pub const TDB_SSWITCH: i32 = 16384;
pub const TDB_BOUNDARY: i32 = 32768;
pub const TDB_COREDUMPREQ: i32 = 65536;
pub const TDB_SCREMOTEREQ: i32 = 131072;
pub const TDP_OLDMASK: i32 = 1;
pub const TDP_INKTR: i32 = 2;
pub const TDP_INKTRACE: i32 = 4;
pub const TDP_BUFNEED: i32 = 8;
pub const TDP_COWINPROGRESS: i32 = 16;
pub const TDP_ALTSTACK: i32 = 32;
pub const TDP_DEADLKTREAT: i32 = 64;
pub const TDP_NOFAULTING: i32 = 128;
pub const TDP_SIGFASTBLOCK: i32 = 256;
pub const TDP_OWEUPC: i32 = 512;
pub const TDP_ITHREAD: i32 = 1024;
pub const TDP_SYNCIO: i32 = 2048;
pub const TDP_SCHED1: i32 = 4096;
pub const TDP_SCHED2: i32 = 8192;
pub const TDP_SCHED3: i32 = 16384;
pub const TDP_SCHED4: i32 = 32768;
pub const TDP_GEOM: i32 = 65536;
pub const TDP_SOFTDEP: i32 = 131072;
pub const TDP_NORUNNINGBUF: i32 = 262144;
pub const TDP_WAKEUP: i32 = 524288;
pub const TDP_INBDFLUSH: i32 = 1048576;
pub const TDP_KTHREAD: i32 = 2097152;
pub const TDP_CALLCHAIN: i32 = 4194304;
pub const TDP_IGNSUSP: i32 = 8388608;
pub const TDP_AUDITREC: i32 = 16777216;
pub const TDP_RFPPWAIT: i32 = 33554432;
pub const TDP_RESETSPUR: i32 = 67108864;
pub const TDP_NERRNO: i32 = 134217728;
pub const TDP_UIOHELD: i32 = 268435456;
pub const TDP_EFIRT: i32 = 536870912;
pub const TDP_EXECVMSPC: i32 = 1073741824;
pub const TDP_SIGFASTPENDING: i64 = 2147483648;
pub const TDP2_SBPAGES: i32 = 1;
pub const TDP2_COMPAT32RB: i32 = 2;
pub const TDP2_ACCT: i32 = 4;
pub const TDP2_SAN_QUIET: i32 = 8;
pub const TDP2_EXTERR: i32 = 16;
pub const TDP2_UEXTERR: i32 = 32;
pub const TDI_SUSPENDED: i32 = 1;
pub const TDI_SLEEPING: i32 = 2;
pub const TDI_LOCK: i32 = 8;
pub const TDI_IWAIT: i32 = 16;
pub const NOCPU: i32 = -1;
pub const NOCPU_OLD: i32 = 255;
pub const MAXCPU_OLD: i32 = 254;
pub const P_ADVLOCK: i32 = 1;
pub const P_CONTROLT: i32 = 2;
pub const P_KPROC: i32 = 4;
pub const P_IDLEPROC: i32 = 8;
pub const P_PPWAIT: i32 = 16;
pub const P_PROFIL: i32 = 32;
pub const P_STOPPROF: i32 = 64;
pub const P_HADTHREADS: i32 = 128;
pub const P_SUGID: i32 = 256;
pub const P_SYSTEM: i32 = 512;
pub const P_SINGLE_EXIT: i32 = 1024;
pub const P_TRACED: i32 = 2048;
pub const P_WAITED: i32 = 4096;
pub const P_WEXIT: i32 = 8192;
pub const P_EXEC: i32 = 16384;
pub const P_WKILLED: i32 = 32768;
pub const P_CONTINUED: i32 = 65536;
pub const P_STOPPED_SIG: i32 = 131072;
pub const P_STOPPED_TRACE: i32 = 262144;
pub const P_STOPPED_SINGLE: i32 = 524288;
pub const P_PROTECTED: i32 = 1048576;
pub const P_SIGEVENT: i32 = 2097152;
pub const P_SINGLE_BOUNDARY: i32 = 4194304;
pub const P_HWPMC: i32 = 8388608;
pub const P_JAILED: i32 = 16777216;
pub const P_TOTAL_STOP: i32 = 33554432;
pub const P_INEXEC: i32 = 67108864;
pub const P_STATCHILD: i32 = 134217728;
pub const P_INMEM: i32 = 268435456;
pub const P_UNUSED1: i32 = 536870912;
pub const P_UNUSED2: i32 = 1073741824;
pub const P_PPTRACE: i64 = 2147483648;
pub const P_STOPPED: i32 = 917504;
pub const P2_INHERIT_PROTECTED: i32 = 1;
pub const P2_NOTRACE: i32 = 2;
pub const P2_NOTRACE_EXEC: i32 = 4;
pub const P2_AST_SU: i32 = 8;
pub const P2_PTRACE_FSTP: i32 = 16;
pub const P2_TRAPCAP: i32 = 32;
pub const P2_ASLR_ENABLE: i32 = 64;
pub const P2_ASLR_DISABLE: i32 = 128;
pub const P2_ASLR_IGNSTART: i32 = 256;
pub const P2_PROTMAX_ENABLE: i32 = 512;
pub const P2_PROTMAX_DISABLE: i32 = 1024;
pub const P2_STKGAP_DISABLE: i32 = 2048;
pub const P2_STKGAP_DISABLE_EXEC: i32 = 4096;
pub const P2_ITSTOPPED: i32 = 8192;
pub const P2_PTRACEREQ: i32 = 16384;
pub const P2_NO_NEW_PRIVS: i32 = 32768;
pub const P2_WXORX_DISABLE: i32 = 65536;
pub const P2_WXORX_ENABLE_EXEC: i32 = 131072;
pub const P2_WEXIT: i32 = 262144;
pub const P2_REAPKILLED: i32 = 524288;
pub const P2_MEMBAR_PRIVE: i32 = 1048576;
pub const P2_MEMBAR_PRIVE_SYNCORE: i32 = 2097152;
pub const P2_MEMBAR_GLOBE: i32 = 4194304;
pub const P2_LOGSIGEXIT_ENABLE: i32 = 8388608;
pub const P2_LOGSIGEXIT_CTL: i32 = 16777216;
pub const P2_HWT: i32 = 33554432;
pub const P_TREE_ORPHANED: i32 = 1;
pub const P_TREE_FIRST_ORPHAN: i32 = 2;
pub const P_TREE_REAPER: i32 = 4;
pub const P_TREE_GRPEXITED: i32 = 8;
pub const SIDL: i32 = 1;
pub const SRUN: i32 = 2;
pub const SSLEEP: i32 = 3;
pub const SSTOP: i32 = 4;
pub const SZOMB: i32 = 5;
pub const SWAIT: i32 = 6;
pub const SLOCK: i32 = 7;
pub const P_MAGIC: i64 = 3203398350;
pub const SW_TYPE_MASK: i32 = 255;
pub const SWT_OWEPREEMPT: i32 = 1;
pub const SWT_TURNSTILE: i32 = 2;
pub const SWT_SLEEPQ: i32 = 3;
pub const SWT_RELINQUISH: i32 = 4;
pub const SWT_NEEDRESCHED: i32 = 5;
pub const SWT_IDLE: i32 = 6;
pub const SWT_IWAIT: i32 = 7;
pub const SWT_SUSPEND: i32 = 8;
pub const SWT_REMOTEPREEMPT: i32 = 9;
pub const SWT_REMOTEWAKEIDLE: i32 = 10;
pub const SWT_BIND: i32 = 11;
pub const SWT_COUNT: i32 = 12;
pub const SW_VOL: i32 = 256;
pub const SW_INVOL: i32 = 512;
pub const SW_PREEMPT: i32 = 1024;
pub const SINGLE_NO_EXIT: i32 = 0;
pub const SINGLE_EXIT: i32 = 1;
pub const SINGLE_BOUNDARY: i32 = 2;
pub const SINGLE_ALLPROC: i32 = 3;
pub const PID_MAX: i32 = 99999;
pub const NO_PID: i32 = 100000;
pub const THREAD0_TID: i32 = 100000;
pub const FR2_DROPSIG_CAUGHT: i32 = 1;
pub const FR2_SHARE_PATHS: i32 = 2;
pub const FR2_KPROC: i32 = 4;
pub const PGET_HOLD: i32 = 1;
pub const PGET_CANSEE: i32 = 2;
pub const PGET_CANDEBUG: i32 = 4;
pub const PGET_ISCURRENT: i32 = 8;
pub const PGET_NOTWEXIT: i32 = 16;
pub const PGET_NOTINEXEC: i32 = 32;
pub const PGET_NOTID: i32 = 64;
pub const PGET_WANTREAD: i32 = 21;
pub const ASTR_ASTF_REQUIRED: i32 = 1;
pub const ASTR_TDP: i32 = 2;
pub const ASTR_KCLEAR: i32 = 4;
pub const ASTR_UNCOND: i32 = 8;
pub const PROC_ID_PID: i32 = 0;
pub const PROC_ID_GROUP: i32 = 1;
pub const PROC_ID_SESSION: i32 = 2;
pub const PROC_ID_REAP: i32 = 3;
pub const REFCOUNT_SATURATION_VALUE: i64 = 3221225472;
pub const _SYS_RMAN_H_: i32 = 1;
pub const _MACHINE_RESOURCE_H_: i32 = 1;
pub const SYS_RES_IRQ: i32 = 1;
pub const SYS_RES_DRQ: i32 = 2;
pub const SYS_RES_MEMORY: i32 = 3;
pub const SYS_RES_IOPORT: i32 = 4;
pub const SYS_RES_GPIO: i32 = 5;
pub const PCI_RES_BUS: i32 = 6;
pub const RF_ALLOCATED: i32 = 1;
pub const RF_ACTIVE: i32 = 2;
pub const RF_SHAREABLE: i32 = 4;
pub const RF_SPARE1: i32 = 8;
pub const RF_SPARE2: i32 = 16;
pub const RF_FIRSTSHARE: i32 = 32;
pub const RF_PREFETCHABLE: i32 = 64;
pub const RF_OPTIONAL: i32 = 128;
pub const RF_UNMAPPED: i32 = 256;
pub const RF_ALIGNMENT_SHIFT: i32 = 10;
pub const RF_ALIGNMENT_MASK: i32 = 64512;
pub const RM_TEXTLEN: i32 = 32;
pub const CG_SHARE_NONE: i32 = 0;
pub const CG_SHARE_L1: i32 = 1;
pub const CG_SHARE_L2: i32 = 2;
pub const CG_SHARE_L3: i32 = 3;
pub const MAX_CACHE_LEVELS: i32 = 3;
pub const CG_FLAG_HTT: i32 = 1;
pub const CG_FLAG_SMT: i32 = 2;
pub const CG_FLAG_THREAD: i32 = 3;
pub const CG_FLAG_NODE: i32 = 4;
pub const TASK_ENQUEUED: i32 = 1;
pub const TASK_NOENQUEUE: i32 = 2;
pub const TASK_NETWORK: i32 = 4;
pub const TASKQUEUE_NAMELEN: i32 = 32;
pub const TASKQUEUE_FAIL_IF_PENDING: i32 = 1;
pub const TASKQUEUE_FAIL_IF_CANCELING: i32 = 2;
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 2] = b"d\0";
pub const PRIdFAST32: &[u8; 2] = b"d\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIdMAX: &[u8; 3] = b"jd\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 2] = b"i\0";
pub const PRIiFAST32: &[u8; 2] = b"i\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIiMAX: &[u8; 3] = b"ji\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 2] = b"o\0";
pub const PRIoFAST32: &[u8; 2] = b"o\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIoMAX: &[u8; 3] = b"jo\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 2] = b"u\0";
pub const PRIuFAST32: &[u8; 2] = b"u\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIuMAX: &[u8; 3] = b"ju\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 2] = b"x\0";
pub const PRIxFAST32: &[u8; 2] = b"x\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIxMAX: &[u8; 3] = b"jx\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 2] = b"X\0";
pub const PRIXFAST32: &[u8; 2] = b"X\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIXMAX: &[u8; 3] = b"jX\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 2] = b"d\0";
pub const SCNdFAST16: &[u8; 2] = b"d\0";
pub const SCNdFAST32: &[u8; 2] = b"d\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNdMAX: &[u8; 3] = b"jd\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 2] = b"i\0";
pub const SCNiFAST16: &[u8; 2] = b"i\0";
pub const SCNiFAST32: &[u8; 2] = b"i\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNiMAX: &[u8; 3] = b"ji\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 2] = b"o\0";
pub const SCNoFAST16: &[u8; 2] = b"o\0";
pub const SCNoFAST32: &[u8; 2] = b"o\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNoMAX: &[u8; 3] = b"jo\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 2] = b"u\0";
pub const SCNuFAST16: &[u8; 2] = b"u\0";
pub const SCNuFAST32: &[u8; 2] = b"u\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNuMAX: &[u8; 3] = b"ju\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 2] = b"x\0";
pub const SCNxFAST16: &[u8; 2] = b"x\0";
pub const SCNxFAST32: &[u8; 2] = b"x\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNxMAX: &[u8; 3] = b"jx\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const BUS_SPACE_MAXADDR_24BIT: i32 = 16777215;
pub const BUS_SPACE_MAXADDR_32BIT: i64 = 4294967295;
pub const BUS_SPACE_MAXADDR_36BIT: i64 = 68719476735;
pub const BUS_SPACE_MAXADDR_40BIT: i64 = 1099511627775;
pub const BUS_SPACE_MAXSIZE_24BIT: i32 = 16777215;
pub const BUS_SPACE_MAXSIZE_32BIT: i64 = 4294967295;
pub const BUS_SPACE_MAXSIZE_40BIT: i64 = 1099511627775;
pub const BUS_SPACE_MAXADDR: i32 = -1;
pub const BUS_SPACE_MAXSIZE: i32 = -1;
pub const BUS_SPACE_MAP_CACHEABLE: i32 = 1;
pub const BUS_SPACE_MAP_LINEAR: i32 = 2;
pub const BUS_SPACE_MAP_PREFETCHABLE: i32 = 4;
pub const BUS_SPACE_MAP_NONPOSTED: i32 = 8;
pub const BUS_SPACE_UNRESTRICTED: i32 = -1;
pub const BUS_SPACE_BARRIER_READ: i32 = 1;
pub const BUS_SPACE_BARRIER_WRITE: i32 = 2;
pub const BUS_DMA_WAITOK: i32 = 0;
pub const BUS_DMA_NOWAIT: i32 = 1;
pub const BUS_DMA_ALLOCNOW: i32 = 2;
pub const BUS_DMA_COHERENT: i32 = 4;
pub const BUS_DMA_ZERO: i32 = 8;
pub const BUS_DMA_BUS1: i32 = 16;
pub const BUS_DMA_BUS2: i32 = 32;
pub const BUS_DMA_BUS3: i32 = 64;
pub const BUS_DMA_BUS4: i32 = 128;
pub const BUS_DMA_NOWRITE: i32 = 256;
pub const BUS_DMA_NOCACHE: i32 = 512;
pub const BUS_DMA_KEEP_PG_OFFSET: i32 = 1024;
pub const BUS_DMA_LOAD_MBUF: i32 = 2048;
pub const BUS_DMASYNC_PREREAD: i32 = 1;
pub const BUS_DMASYNC_POSTREAD: i32 = 2;
pub const BUS_DMASYNC_PREWRITE: i32 = 4;
pub const BUS_DMASYNC_POSTWRITE: i32 = 8;
pub const DBG_BRP_MAX: i32 = 16;
pub const DBG_WRP_MAX: i32 = 16;
pub const DBGMON_ENABLED: i32 = 1;
pub const DBGMON_KERNEL: i32 = 2;
pub const VFPCR_AHP: i32 = 67108864;
pub const VFPCR_DN: i32 = 33554432;
pub const VFPCR_FZ: i32 = 16777216;
pub const VFPCR_INIT: i32 = 0;
pub const VFPCR_RMODE_OFF: i32 = 22;
pub const VFPCR_RMODE_MASK: i32 = 12582912;
pub const VFPCR_RMODE_RN: i32 = 0;
pub const VFPCR_RMODE_RPI: i32 = 4194304;
pub const VFPCR_RMODE_RNI: i32 = 8388608;
pub const VFPCR_RMODE_RM: i32 = 12582912;
pub const VFPCR_STRIDE_OFF: i32 = 20;
pub const VFPCR_STRIDE_MASK: i32 = 3145728;
pub const VFPCR_LEN_OFF: i32 = 16;
pub const VFPCR_LEN_MASK: i32 = 458752;
pub const VFPCR_IDE: i32 = 32768;
pub const VFPCR_IXE: i32 = 4096;
pub const VFPCR_UFE: i32 = 2048;
pub const VFPCR_OFE: i32 = 1024;
pub const VFPCR_DZE: i32 = 512;
pub const VFPCR_IOE: i32 = 256;
pub const FPU_KERN_NORMAL: i32 = 0;
pub const FPU_KERN_NOWAIT: i32 = 1;
pub const FPU_KERN_KTHR: i32 = 2;
pub const FPU_KERN_NOCTX: i32 = 4;
pub const PCB_X_START: i32 = 19;
pub const PCB_X19: i32 = 0;
pub const PCB_X20: i32 = 1;
pub const PCB_FP: i32 = 10;
pub const PCB_LR: i32 = 11;
pub const PCB_SINGLE_STEP_SHIFT: i32 = 0;
pub const PCB_SINGLE_STEP: i32 = 1;
pub const PCB_FP_STARTED: i32 = 1;
pub const PCB_FP_SVEVALID: i32 = 2;
pub const PCB_FP_KERN: i32 = 1073741824;
pub const PCB_FP_NOSAVE: i64 = 2147483648;
pub const PCB_FP_USERMASK: i32 = 3;
pub const FDT_INTR_EDGE_RISING: i32 = 1;
pub const FDT_INTR_EDGE_FALLING: i32 = 2;
pub const FDT_INTR_LEVEL_HIGH: i32 = 4;
pub const FDT_INTR_LEVEL_LOW: i32 = 8;
pub const FDT_INTR_LOW_MASK: i32 = 10;
pub const FDT_INTR_EDGE_MASK: i32 = 3;
pub const FDT_INTR_MASK: i32 = 15;
pub const SB_FLAG_NO_RANGES: i32 = 1;
pub const ORIP_NOINT: i32 = -1;
pub const ORIR_NOTFOUND: i64 = 4294967295;
pub const FDTCOMPAT_PNP_DESCR: &[u8; 14] = b"Z:compat;P:#;\0";
pub const KTR_VERSION: i32 = 2;
pub const KTR_PARMS: i32 = 6;
pub const KTR_ATTR_LINKED: &[u8; 14] = b"linkedto:\"%s\"\0";
pub const POWER_PM_TYPE_ACPI: i32 = 1;
pub const POWER_PM_TYPE_NONE: i32 = 255;
pub const POWER_CMD_SUSPEND: i32 = 0;
pub const POWER_SLEEP_STATE_STANDBY: i32 = 0;
pub const POWER_SLEEP_STATE_SUSPEND: i32 = 1;
pub const POWER_SLEEP_STATE_HIBERNATE: i32 = 2;
pub const POWER_PROFILE_PERFORMANCE: i32 = 0;
pub const POWER_PROFILE_ECONOMY: i32 = 1;
pub const EVENTHANDLER_PRI_FIRST: i32 = 0;
pub const EVENTHANDLER_PRI_ANY: i32 = 10000;
pub const EVENTHANDLER_PRI_LAST: i32 = 20000;
pub const SHUTDOWN_PRI_FIRST: i32 = 0;
pub const SHUTDOWN_PRI_DEFAULT: i32 = 10000;
pub const SHUTDOWN_PRI_LAST: i32 = 20000;
pub const LOWMEM_PRI_DEFAULT: i32 = 0;
pub const O_RDONLY: i32 = 0;
pub const O_WRONLY: i32 = 1;
pub const O_RDWR: i32 = 2;
pub const O_ACCMODE: i32 = 3;
pub const FREAD: i32 = 1;
pub const FWRITE: i32 = 2;
pub const O_NONBLOCK: i32 = 4;
pub const O_APPEND: i32 = 8;
pub const O_SHLOCK: i32 = 16;
pub const O_EXLOCK: i32 = 32;
pub const O_ASYNC: i32 = 64;
pub const O_FSYNC: i32 = 128;
pub const O_SYNC: i32 = 128;
pub const O_NOFOLLOW: i32 = 256;
pub const O_CREAT: i32 = 512;
pub const O_TRUNC: i32 = 1024;
pub const O_EXCL: i32 = 2048;
pub const FHASLOCK: i32 = 16384;
pub const O_NOCTTY: i32 = 32768;
pub const O_DIRECT: i32 = 65536;
pub const O_DIRECTORY: i32 = 131072;
pub const O_EXEC: i32 = 262144;
pub const O_SEARCH: i32 = 262144;
pub const FEXEC: i32 = 262144;
pub const FSEARCH: i32 = 262144;
pub const O_TTY_INIT: i32 = 524288;
pub const O_CLOEXEC: i32 = 1048576;
pub const O_VERIFY: i32 = 2097152;
pub const O_PATH: i32 = 4194304;
pub const O_RESOLVE_BENEATH: i32 = 8388608;
pub const O_DSYNC: i32 = 16777216;
pub const O_EMPTY_PATH: i32 = 33554432;
pub const O_NAMEDATTR: i32 = 67108864;
pub const O_XATTR: i32 = 67108864;
pub const O_CLOFORK: i32 = 134217728;
pub const FLASTCLOSE: i32 = 131072;
pub const FREVOKE: i32 = 2097152;
pub const FOPENFAILED: i32 = 524288;
pub const FKQALLOWED: i32 = 8388608;
pub const FAPPEND: i32 = 8;
pub const FASYNC: i32 = 64;
pub const FFSYNC: i32 = 128;
pub const FDSYNC: i32 = 16777216;
pub const FNONBLOCK: i32 = 4;
pub const FNDELAY: i32 = 4;
pub const O_NDELAY: i32 = 4;
pub const FRDAHEAD: i32 = 512;
pub const AT_FDCWD: i32 = -100;
pub const AT_EACCESS: i32 = 256;
pub const AT_SYMLINK_NOFOLLOW: i32 = 512;
pub const AT_SYMLINK_FOLLOW: i32 = 1024;
pub const AT_REMOVEDIR: i32 = 2048;
pub const AT_RESOLVE_BENEATH: i32 = 8192;
pub const AT_EMPTY_PATH: i32 = 16384;
pub const F_DUPFD: i32 = 0;
pub const F_GETFD: i32 = 1;
pub const F_SETFD: i32 = 2;
pub const F_GETFL: i32 = 3;
pub const F_SETFL: i32 = 4;
pub const F_GETOWN: i32 = 5;
pub const F_SETOWN: i32 = 6;
pub const F_OGETLK: i32 = 7;
pub const F_OSETLK: i32 = 8;
pub const F_OSETLKW: i32 = 9;
pub const F_DUP2FD: i32 = 10;
pub const F_GETLK: i32 = 11;
pub const F_SETLK: i32 = 12;
pub const F_SETLKW: i32 = 13;
pub const F_SETLK_REMOTE: i32 = 14;
pub const F_READAHEAD: i32 = 15;
pub const F_RDAHEAD: i32 = 16;
pub const F_DUPFD_CLOEXEC: i32 = 17;
pub const F_DUP2FD_CLOEXEC: i32 = 18;
pub const F_ADD_SEALS: i32 = 19;
pub const F_GET_SEALS: i32 = 20;
pub const F_ISUNIONSTACK: i32 = 21;
pub const F_KINFO: i32 = 22;
pub const F_DUPFD_CLOFORK: i32 = 23;
pub const F_DUP3FD: i32 = 24;
pub const F_DUP3FD_SHIFT: i32 = 16;
pub const F_SEAL_SEAL: i32 = 1;
pub const F_SEAL_SHRINK: i32 = 2;
pub const F_SEAL_GROW: i32 = 4;
pub const F_SEAL_WRITE: i32 = 8;
pub const FD_CLOEXEC: i32 = 1;
pub const FD_RESOLVE_BENEATH: i32 = 2;
pub const FD_CLOFORK: i32 = 4;
pub const F_RDLCK: i32 = 1;
pub const F_UNLCK: i32 = 2;
pub const F_WRLCK: i32 = 3;
pub const F_UNLCKSYS: i32 = 4;
pub const F_CANCEL: i32 = 5;
pub const F_WAIT: i32 = 16;
pub const F_FLOCK: i32 = 32;
pub const F_POSIX: i32 = 64;
pub const F_REMOTE: i32 = 128;
pub const F_NOINTR: i32 = 256;
pub const F_FIRSTOPEN: i32 = 512;
pub const LOCK_SH: i32 = 1;
pub const LOCK_EX: i32 = 2;
pub const LOCK_NB: i32 = 4;
pub const LOCK_UN: i32 = 8;
pub const POSIX_FADV_NORMAL: i32 = 0;
pub const POSIX_FADV_RANDOM: i32 = 1;
pub const POSIX_FADV_SEQUENTIAL: i32 = 2;
pub const POSIX_FADV_WILLNEED: i32 = 3;
pub const POSIX_FADV_DONTNEED: i32 = 4;
pub const POSIX_FADV_NOREUSE: i32 = 5;
pub const FD_NONE: i32 = -200;
pub const SPACECTL_DEALLOC: i32 = 1;
pub const SPACECTL_F_SUPPORTED: i32 = 0;
pub const SI_ETERNAL: i32 = 1;
pub const SI_ALIAS: i32 = 2;
pub const SI_NAMED: i32 = 4;
pub const SI_UNUSED1: i32 = 8;
pub const SI_CHILD: i32 = 16;
pub const SI_DUMPDEV: i32 = 128;
pub const SI_CLONELIST: i32 = 512;
pub const SI_UNMAPPED: i32 = 1024;
pub const SI_NOSPLIT: i32 = 2048;
pub const D_TAPE: i32 = 1;
pub const D_DISK: i32 = 2;
pub const D_TTY: i32 = 4;
pub const D_MEM: i32 = 8;
pub const UID_ROOT: i32 = 0;
pub const UID_BIN: i32 = 3;
pub const UID_UUCP: i32 = 66;
pub const UID_NOBODY: i32 = 65534;
pub const GID_WHEEL: i32 = 0;
pub const GID_KMEM: i32 = 2;
pub const GID_TTY: i32 = 4;
pub const GID_OPERATOR: i32 = 5;
pub const GID_BIN: i32 = 7;
pub const GID_GAMES: i32 = 13;
pub const GID_VIDEO: i32 = 44;
pub const GID_RT_PRIO: i32 = 47;
pub const GID_ID_PRIO: i32 = 48;
pub const GID_DIALER: i32 = 68;
pub const GID_U2F: i32 = 116;
pub const GID_NOGROUP: i32 = 65533;
pub const GID_NOBODY: i32 = 65534;
pub const D_TYPEMASK: i32 = 65535;
pub const D_TRACKCLOSE: i32 = 524288;
pub const D_MMAP_ANON: i32 = 1048576;
pub const D_GIANTOK: i32 = 2097152;
pub const D_NEEDGIANT: i32 = 4194304;
pub const D_NEEDMINOR: i32 = 8388608;
pub const D_VERSION_00: i32 = 536942950;
pub const D_VERSION_01: i32 = 386080773;
pub const D_VERSION_02: i32 = 671358985;
pub const D_VERSION_03: i32 = 387063817;
pub const D_VERSION_04: i32 = 1548272467;
pub const D_VERSION: i32 = 1548272467;
pub const D_INIT: i64 = 2147483648;
pub const CLONE_UNITMASK: i32 = 1048575;
pub const CLONE_FLAG0: i32 = 1048576;
pub const MAKEDEV_REF: i32 = 1;
pub const MAKEDEV_WHTOUT: i32 = 2;
pub const MAKEDEV_NOWAIT: i32 = 4;
pub const MAKEDEV_WAITOK: i32 = 8;
pub const MAKEDEV_ETERNAL: i32 = 16;
pub const MAKEDEV_CHECKNAME: i32 = 32;
pub const MAKEDEV_ETERNAL_KLD: i32 = 16;
pub const DTYPE_NONE: i32 = 0;
pub const DTYPE_VNODE: i32 = 1;
pub const DTYPE_SOCKET: i32 = 2;
pub const DTYPE_PIPE: i32 = 3;
pub const DTYPE_FIFO: i32 = 4;
pub const DTYPE_KQUEUE: i32 = 5;
pub const DTYPE_CRYPTO: i32 = 6;
pub const DTYPE_MQUEUE: i32 = 7;
pub const DTYPE_SHM: i32 = 8;
pub const DTYPE_SEM: i32 = 9;
pub const DTYPE_PTS: i32 = 10;
pub const DTYPE_DEV: i32 = 11;
pub const DTYPE_PROCDESC: i32 = 12;
pub const DTYPE_EVENTFD: i32 = 13;
pub const DTYPE_TIMERFD: i32 = 14;
pub const DTYPE_INOTIFY: i32 = 15;
pub const DTYPE_JAILDESC: i32 = 16;
pub const FOF_OFFSET: i32 = 1;
pub const FOF_NOLOCK: i32 = 2;
pub const FOF_NEXTOFF_R: i32 = 4;
pub const FOF_NEXTOFF_W: i32 = 8;
pub const FOF_NOUPDATE: i32 = 16;
pub const DFLAG_PASSABLE: i32 = 1;
pub const DFLAG_SEEKABLE: i32 = 2;
pub const DFLAG_FORK: i32 = 4;
pub const FILE_V_FOFFSET_LOCKED: i32 = 1;
pub const FILE_V_FOFFSET_LOCK_WAITING: i32 = 2;
pub const FILE_V_SETFL_LOCKED: i32 = 4;
pub const FILE_V_SETFL_LOCK_WAITING: i32 = 8;
pub const UIO_MAXIOV: i32 = 1024;
pub const _PATH_LOG: &[u8; 13] = b"/var/run/log\0";
pub const _PATH_LOG_PRIV: &[u8; 17] = b"/var/run/logpriv\0";
pub const LOG_EMERG: i32 = 0;
pub const LOG_ALERT: i32 = 1;
pub const LOG_CRIT: i32 = 2;
pub const LOG_ERR: i32 = 3;
pub const LOG_WARNING: i32 = 4;
pub const LOG_NOTICE: i32 = 5;
pub const LOG_INFO: i32 = 6;
pub const LOG_DEBUG: i32 = 7;
pub const LOG_PRIMASK: i32 = 7;
pub const LOG_KERN: i32 = 0;
pub const LOG_USER: i32 = 8;
pub const LOG_MAIL: i32 = 16;
pub const LOG_DAEMON: i32 = 24;
pub const LOG_AUTH: i32 = 32;
pub const LOG_SYSLOG: i32 = 40;
pub const LOG_LPR: i32 = 48;
pub const LOG_NEWS: i32 = 56;
pub const LOG_UUCP: i32 = 64;
pub const LOG_CRON: i32 = 72;
pub const LOG_AUTHPRIV: i32 = 80;
pub const LOG_FTP: i32 = 88;
pub const LOG_NTP: i32 = 96;
pub const LOG_SECURITY: i32 = 104;
pub const LOG_CONSOLE: i32 = 112;
pub const LOG_LOCAL0: i32 = 128;
pub const LOG_LOCAL1: i32 = 136;
pub const LOG_LOCAL2: i32 = 144;
pub const LOG_LOCAL3: i32 = 152;
pub const LOG_LOCAL4: i32 = 160;
pub const LOG_LOCAL5: i32 = 168;
pub const LOG_LOCAL6: i32 = 176;
pub const LOG_LOCAL7: i32 = 184;
pub const LOG_NFACILITIES: i32 = 24;
pub const LOG_FACMASK: i32 = 1016;
pub const LOG_PRINTF: i32 = -1;
pub const LOG_PID: i32 = 1;
pub const LOG_CONS: i32 = 2;
pub const LOG_ODELAY: i32 = 4;
pub const LOG_NDELAY: i32 = 8;
pub const LOG_NOWAIT: i32 = 16;
pub const LOG_PERROR: i32 = 32;
pub const CHAR_BIT: i32 = 8;
pub const SCHAR_MAX: i32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: i32 = 255;
pub const CHAR_MAX: i32 = 255;
pub const CHAR_MIN: i32 = 0;
pub const USHRT_MAX: i32 = 65535;
pub const SHRT_MAX: i32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: i64 = 4294967295;
pub const INT_MAX: i32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: i64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: i64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const SSIZE_MAX: i64 = 9223372036854775807;
pub const SIZE_T_MAX: i32 = -1;
pub const OFF_MAX: i64 = 9223372036854775807;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const GID_MAX: i64 = 4294967295;
pub const UID_MAX: i64 = 4294967295;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: i64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: i32 = 64;
pub const WORD_BIT: i32 = 32;
pub const MQ_PRIO_MAX: i32 = 64;
pub const INHERIT_SHARE: i32 = 0;
pub const INHERIT_COPY: i32 = 1;
pub const INHERIT_NONE: i32 = 2;
pub const INHERIT_ZERO: i32 = 3;
pub const PROT_NONE: i32 = 0;
pub const PROT_READ: i32 = 1;
pub const PROT_WRITE: i32 = 2;
pub const PROT_EXEC: i32 = 4;
pub const PROT_CHERI0: i32 = 8;
pub const PROT_CHERI1: i32 = 16;
pub const _PROT_ALL: i32 = 7;
pub const _PROT_MAX_SHIFT: i32 = 16;
pub const MAP_SHARED: i32 = 1;
pub const MAP_PRIVATE: i32 = 2;
pub const MAP_COPY: i32 = 2;
pub const MAP_FIXED: i32 = 16;
pub const MAP_RESERVED0020: i32 = 32;
pub const MAP_RESERVED0040: i32 = 64;
pub const MAP_RESERVED0080: i32 = 128;
pub const MAP_RESERVED0100: i32 = 256;
pub const MAP_HASSEMAPHORE: i32 = 512;
pub const MAP_STACK: i32 = 1024;
pub const MAP_NOSYNC: i32 = 2048;
pub const MAP_FILE: i32 = 0;
pub const MAP_ANON: i32 = 4096;
pub const MAP_GUARD: i32 = 8192;
pub const MAP_EXCL: i32 = 16384;
pub const MAP_NOCORE: i32 = 131072;
pub const MAP_PREFAULT_READ: i32 = 262144;
pub const MAP_32BIT: i32 = 524288;
pub const MAP_ALIGNMENT_SHIFT: i32 = 24;
pub const SHM_RENAME_NOREPLACE: i32 = 1;
pub const SHM_RENAME_EXCHANGE: i32 = 2;
pub const MCL_CURRENT: i32 = 1;
pub const MCL_FUTURE: i32 = 2;
pub const MS_SYNC: i32 = 0;
pub const MS_ASYNC: i32 = 1;
pub const MS_INVALIDATE: i32 = 2;
pub const _MADV_NORMAL: i32 = 0;
pub const _MADV_RANDOM: i32 = 1;
pub const _MADV_SEQUENTIAL: i32 = 2;
pub const _MADV_WILLNEED: i32 = 3;
pub const _MADV_DONTNEED: i32 = 4;
pub const MADV_NORMAL: i32 = 0;
pub const MADV_RANDOM: i32 = 1;
pub const MADV_SEQUENTIAL: i32 = 2;
pub const MADV_WILLNEED: i32 = 3;
pub const MADV_DONTNEED: i32 = 4;
pub const MADV_FREE: i32 = 5;
pub const MADV_NOSYNC: i32 = 6;
pub const MADV_AUTOSYNC: i32 = 7;
pub const MADV_NOCORE: i32 = 8;
pub const MADV_CORE: i32 = 9;
pub const MADV_PROTECT: i32 = 10;
pub const MINCORE_INCORE: i32 = 1;
pub const MINCORE_REFERENCED: i32 = 2;
pub const MINCORE_MODIFIED: i32 = 4;
pub const MINCORE_REFERENCED_OTHER: i32 = 8;
pub const MINCORE_MODIFIED_OTHER: i32 = 16;
pub const MINCORE_SUPER: i32 = 96;
pub const MINCORE_PSIND_SHIFT: i32 = 5;
pub const SHM_ALLOW_SEALING: i32 = 1;
pub const SHM_GROW_ON_WRITE: i32 = 2;
pub const SHM_LARGEPAGE: i32 = 4;
pub const SHM_LARGEPAGE_ALLOC_DEFAULT: i32 = 0;
pub const SHM_LARGEPAGE_ALLOC_NOWAIT: i32 = 1;
pub const SHM_LARGEPAGE_ALLOC_HARD: i32 = 2;
pub const MFD_CLOEXEC: i32 = 1;
pub const MFD_ALLOW_SEALING: i32 = 2;
pub const MFD_HUGETLB: i32 = 4;
pub const MFD_HUGE_MASK: i64 = 4227858432;
pub const MFD_HUGE_SHIFT: i32 = 26;
pub const MFD_HUGE_64KB: i32 = 1073741824;
pub const MFD_HUGE_512KB: i32 = 1275068416;
pub const MFD_HUGE_1MB: i32 = 1342177280;
pub const MFD_HUGE_2MB: i32 = 1409286144;
pub const MFD_HUGE_8MB: i32 = 1543503872;
pub const MFD_HUGE_16MB: i32 = 1610612736;
pub const MFD_HUGE_32MB: i32 = 1677721600;
pub const MFD_HUGE_256MB: i32 = 1879048192;
pub const MFD_HUGE_512MB: i32 = 1946157056;
pub const MFD_HUGE_1GB: i32 = 2013265920;
pub const MFD_HUGE_2GB: i32 = 2080374784;
pub const MFD_HUGE_16GB: i64 = 2281701376;
pub const POSIX_MADV_NORMAL: i32 = 0;
pub const POSIX_MADV_RANDOM: i32 = 1;
pub const POSIX_MADV_SEQUENTIAL: i32 = 2;
pub const POSIX_MADV_WILLNEED: i32 = 3;
pub const POSIX_MADV_DONTNEED: i32 = 4;
pub const RL_LOCK_READ: i32 = 1;
pub const RL_LOCK_WRITE: i32 = 2;
pub const RL_LOCK_TYPE_MASK: i32 = 3;
pub const RCA_LOCKED: i32 = 1;
pub const RCA_RLOCKED: i32 = 2;
pub const RCA_WLOCKED: i32 = 4;
pub const POLLIN: i32 = 1;
pub const POLLPRI: i32 = 2;
pub const POLLOUT: i32 = 4;
pub const POLLRDNORM: i32 = 64;
pub const POLLWRNORM: i32 = 4;
pub const POLLRDBAND: i32 = 128;
pub const POLLWRBAND: i32 = 256;
pub const POLLINIGNEOF: i32 = 8192;
pub const POLLRDHUP: i32 = 16384;
pub const POLLERR: i32 = 8;
pub const POLLHUP: i32 = 16;
pub const POLLNVAL: i32 = 32;
pub const POLLSTANDARD: i32 = 511;
pub const INFTIM: i32 = -1;
pub const SBUF_FIXEDLEN: i32 = 0;
pub const SBUF_AUTOEXTEND: i32 = 1;
pub const SBUF_INCLUDENUL: i32 = 2;
pub const SBUF_DRAINTOEOR: i32 = 4;
pub const SBUF_NOWAIT: i32 = 8;
pub const SBUF_USRFLAGMSK: i32 = 65535;
pub const SBUF_DYNAMIC: i32 = 65536;
pub const SBUF_FINISHED: i32 = 131072;
pub const SBUF_DYNSTRUCT: i32 = 524288;
pub const SBUF_INSECTION: i32 = 1048576;
pub const SBUF_DRAINATEOL: i32 = 2097152;
pub const SOUND_VERSION: i32 = 301;
pub const SNDCARD_ADLIB: i32 = 1;
pub const SNDCARD_SB: i32 = 2;
pub const SNDCARD_PAS: i32 = 3;
pub const SNDCARD_GUS: i32 = 4;
pub const SNDCARD_MPU401: i32 = 5;
pub const SNDCARD_SB16: i32 = 6;
pub const SNDCARD_SB16MIDI: i32 = 7;
pub const SNDCARD_UART6850: i32 = 8;
pub const SNDCARD_GUS16: i32 = 9;
pub const SNDCARD_MSS: i32 = 10;
pub const SNDCARD_PSS: i32 = 11;
pub const SNDCARD_SSCAPE: i32 = 12;
pub const SNDCARD_PSS_MPU: i32 = 13;
pub const SNDCARD_PSS_MSS: i32 = 14;
pub const SNDCARD_SSCAPE_MSS: i32 = 15;
pub const SNDCARD_TRXPRO: i32 = 16;
pub const SNDCARD_TRXPRO_SB: i32 = 17;
pub const SNDCARD_TRXPRO_MPU: i32 = 18;
pub const SNDCARD_MAD16: i32 = 19;
pub const SNDCARD_MAD16_MPU: i32 = 20;
pub const SNDCARD_CS4232: i32 = 21;
pub const SNDCARD_CS4232_MPU: i32 = 22;
pub const SNDCARD_MAUI: i32 = 23;
pub const SNDCARD_PSEUDO_MSS: i32 = 24;
pub const SNDCARD_AWE32: i32 = 25;
pub const SNDCARD_NSS: i32 = 26;
pub const SNDCARD_UART16550: i32 = 27;
pub const SNDCARD_OPL: i32 = 28;
pub const AFMT_QUERY: i32 = 0;
pub const AFMT_MU_LAW: i32 = 1;
pub const AFMT_A_LAW: i32 = 2;
pub const AFMT_IMA_ADPCM: i32 = 4;
pub const AFMT_U8: i32 = 8;
pub const AFMT_S16_LE: i32 = 16;
pub const AFMT_S16_BE: i32 = 32;
pub const AFMT_S8: i32 = 64;
pub const AFMT_U16_LE: i32 = 128;
pub const AFMT_U16_BE: i32 = 256;
pub const AFMT_MPEG: i32 = 512;
pub const AFMT_AC3: i32 = 1024;
pub const AFMT_S32_LE: i32 = 4096;
pub const AFMT_S32_BE: i32 = 8192;
pub const AFMT_U32_LE: i32 = 16384;
pub const AFMT_U32_BE: i32 = 32768;
pub const AFMT_S24_LE: i32 = 65536;
pub const AFMT_S24_BE: i32 = 131072;
pub const AFMT_U24_LE: i32 = 262144;
pub const AFMT_U24_BE: i32 = 524288;
pub const AFMT_F32_LE: i32 = 268435456;
pub const AFMT_F32_BE: i32 = 536870912;
pub const AFMT_S16_NE: i32 = 16;
pub const AFMT_S24_NE: i32 = 65536;
pub const AFMT_S32_NE: i32 = 4096;
pub const AFMT_U16_NE: i32 = 128;
pub const AFMT_U24_NE: i32 = 262144;
pub const AFMT_U32_NE: i32 = 16384;
pub const AFMT_S16_OE: i32 = 32;
pub const AFMT_S24_OE: i32 = 131072;
pub const AFMT_S32_OE: i32 = 8192;
pub const AFMT_U16_OE: i32 = 256;
pub const AFMT_U24_OE: i32 = 524288;
pub const AFMT_U32_OE: i32 = 32768;
pub const AFMT_F32_NE: i32 = 268435456;
pub const AFMT_F32_OE: i32 = 536870912;
pub const AFMT_FLOAT: i32 = 268435456;
pub const AFMT_STEREO: i32 = 268435456;
pub const AFMT_WEIRD: i32 = 536870912;
pub const AFMT_FULLDUPLEX: i64 = 2147483648;
pub const AIOSYNC_PLAY: i32 = 1;
pub const AIOSYNC_CAPTURE: i32 = 2;
pub const AIOSYNC_SIGNAL: i32 = 256;
pub const AIOSYNC_SELECT: i32 = 512;
pub const AIOSYNC_READY: i32 = 1024;
pub const AIOSYNC_FREE: i32 = 2048;
pub const TMR_INTERNAL: i32 = 1;
pub const TMR_EXTERNAL: i32 = 2;
pub const TMR_MODE_MIDI: i32 = 16;
pub const TMR_MODE_FSK: i32 = 32;
pub const TMR_MODE_CLS: i32 = 64;
pub const TMR_MODE_SMPTE: i32 = 128;
pub const WAVE_16_BITS: i32 = 1;
pub const WAVE_UNSIGNED: i32 = 2;
pub const WAVE_LOOPING: i32 = 4;
pub const WAVE_BIDIR_LOOP: i32 = 8;
pub const WAVE_LOOP_BACK: i32 = 16;
pub const WAVE_SUSTAIN_ON: i32 = 32;
pub const WAVE_ENVELOPES: i32 = 64;
pub const WAVE_VIBRATO: i32 = 65536;
pub const WAVE_TREMOLO: i32 = 131072;
pub const WAVE_SCALE: i32 = 262144;
pub const PS_NO_PATCHES: i32 = 0;
pub const PS_MGR_NOT_OK: i32 = 1;
pub const PS_MGR_OK: i32 = 2;
pub const PS_MANAGED: i32 = 3;
pub const PM_K_EVENT: i32 = 1;
pub const PM_K_COMMAND: i32 = 2;
pub const PM_K_RESPONSE: i32 = 3;
pub const PM_ERROR: i32 = 4;
pub const PM_GET_DEVTYPE: i32 = 1;
pub const PMTYPE_FM2: i32 = 1;
pub const PMTYPE_FM4: i32 = 2;
pub const PMTYPE_WAVE: i32 = 3;
pub const PM_GET_NRPGM: i32 = 2;
pub const PM_GET_PGMMAP: i32 = 3;
pub const PM_GET_PGM_PATCHES: i32 = 4;
pub const PM_GET_PATCH: i32 = 5;
pub const PM_SET_PATCH: i32 = 6;
pub const PM_READ_PATCH: i32 = 7;
pub const PM_WRITE_PATCH: i32 = 8;
pub const _PM_LOAD_PATCH: i32 = 256;
pub const PM_E_OPENED: i32 = 1;
pub const PM_E_CLOSED: i32 = 2;
pub const PM_E_PATCH_RESET: i32 = 3;
pub const PM_E_PATCH_LOADED: i32 = 4;
pub const SEQ_NOTEOFF: i32 = 0;
pub const SEQ_FMNOTEOFF: i32 = 0;
pub const SEQ_NOTEON: i32 = 1;
pub const SEQ_FMNOTEON: i32 = 1;
pub const SEQ_PGMCHANGE: i32 = 3;
pub const SEQ_FMPGMCHANGE: i32 = 3;
pub const SEQ_MIDIPUTC: i32 = 5;
pub const SEQ_DRUMON: i32 = 6;
pub const SEQ_DRUMOFF: i32 = 7;
pub const SEQ_AFTERTOUCH: i32 = 9;
pub const SEQ_CONTROLLER: i32 = 10;
pub const CTL_BANK_SELECT: i32 = 0;
pub const CTL_MODWHEEL: i32 = 1;
pub const CTL_BREATH: i32 = 2;
pub const CTL_FOOT: i32 = 4;
pub const CTL_PORTAMENTO_TIME: i32 = 5;
pub const CTL_DATA_ENTRY: i32 = 6;
pub const CTL_MAIN_VOLUME: i32 = 7;
pub const CTL_BALANCE: i32 = 8;
pub const CTL_PAN: i32 = 10;
pub const CTL_EXPRESSION: i32 = 11;
pub const CTL_GENERAL_PURPOSE1: i32 = 16;
pub const CTL_GENERAL_PURPOSE2: i32 = 17;
pub const CTL_GENERAL_PURPOSE3: i32 = 18;
pub const CTL_GENERAL_PURPOSE4: i32 = 19;
pub const CTL_DAMPER_PEDAL: i32 = 64;
pub const CTL_SUSTAIN: i32 = 64;
pub const CTL_HOLD: i32 = 64;
pub const CTL_PORTAMENTO: i32 = 65;
pub const CTL_SOSTENUTO: i32 = 66;
pub const CTL_SOFT_PEDAL: i32 = 67;
pub const CTL_HOLD2: i32 = 69;
pub const CTL_GENERAL_PURPOSE5: i32 = 80;
pub const CTL_GENERAL_PURPOSE6: i32 = 81;
pub const CTL_GENERAL_PURPOSE7: i32 = 82;
pub const CTL_GENERAL_PURPOSE8: i32 = 83;
pub const CTL_EXT_EFF_DEPTH: i32 = 91;
pub const CTL_TREMOLO_DEPTH: i32 = 92;
pub const CTL_CHORUS_DEPTH: i32 = 93;
pub const CTL_DETUNE_DEPTH: i32 = 94;
pub const CTL_CELESTE_DEPTH: i32 = 94;
pub const CTL_PHASER_DEPTH: i32 = 95;
pub const CTL_DATA_INCREMENT: i32 = 96;
pub const CTL_DATA_DECREMENT: i32 = 97;
pub const CTL_NONREG_PARM_NUM_LSB: i32 = 98;
pub const CTL_NONREG_PARM_NUM_MSB: i32 = 99;
pub const CTL_REGIST_PARM_NUM_LSB: i32 = 100;
pub const CTL_REGIST_PARM_NUM_MSB: i32 = 101;
pub const CTRL_PITCH_BENDER: i32 = 255;
pub const CTRL_PITCH_BENDER_RANGE: i32 = 254;
pub const CTRL_EXPRESSION: i32 = 253;
pub const CTRL_MAIN_VOLUME: i32 = 252;
pub const SEQ_BALANCE: i32 = 11;
pub const SEQ_VOLMODE: i32 = 12;
pub const VOL_METHOD_ADAGIO: i32 = 1;
pub const VOL_METHOD_LINEAR: i32 = 2;
pub const SEQ_FULLSIZE: i32 = 253;
pub const SEQ_PRIVATE: i32 = 254;
pub const SEQ_EXTENDED: i32 = 255;
pub const SYNTH_TYPE_FM: i32 = 0;
pub const SYNTH_TYPE_SAMPLE: i32 = 1;
pub const SYNTH_TYPE_MIDI: i32 = 2;
pub const FM_TYPE_ADLIB: i32 = 0;
pub const FM_TYPE_OPL3: i32 = 1;
pub const MIDI_TYPE_MPU401: i32 = 1025;
pub const SAMPLE_TYPE_BASIC: i32 = 16;
pub const SAMPLE_TYPE_GUS: i32 = 16;
pub const SAMPLE_TYPE_AWE32: i32 = 32;
pub const SYNTH_CAP_PERCMODE: i32 = 1;
pub const SYNTH_CAP_OPL3: i32 = 2;
pub const SYNTH_CAP_INPUT: i32 = 4;
pub const PCM_CAP_REVISION: i32 = 255;
pub const PCM_CAP_DUPLEX: i32 = 256;
pub const PCM_CAP_REALTIME: i32 = 512;
pub const PCM_CAP_BATCH: i32 = 1024;
pub const PCM_CAP_COPROC: i32 = 2048;
pub const PCM_CAP_TRIGGER: i32 = 4096;
pub const PCM_CAP_MMAP: i32 = 8192;
pub const PCM_CAP_MULTI: i32 = 16384;
pub const PCM_CAP_BIND: i32 = 32768;
pub const PCM_CAP_INPUT: i32 = 65536;
pub const PCM_CAP_OUTPUT: i32 = 131072;
pub const PCM_CAP_VIRTUAL: i32 = 262144;
pub const PCM_CAP_ANALOGOUT: i32 = 1048576;
pub const PCM_CAP_ANALOGIN: i32 = 2097152;
pub const PCM_CAP_DIGITALOUT: i32 = 4194304;
pub const PCM_CAP_DIGITALIN: i32 = 8388608;
pub const PCM_CAP_ADMASK: i32 = 15728640;
pub const PCM_CAP_SPECIAL: i32 = 16777216;
pub const PCM_CAP_SHADOW: i32 = 0;
pub const DSP_CH_MASK: i32 = 100663296;
pub const DSP_CH_ANY: i32 = 0;
pub const DSP_CH_MONO: i32 = 33554432;
pub const DSP_CH_STEREO: i32 = 67108864;
pub const DSP_CH_MULTI: i32 = 100663296;
pub const PCM_CAP_HIDDEN: i32 = 134217728;
pub const PCM_CAP_FREERATE: i32 = 268435456;
pub const PCM_CAP_MODEM: i32 = 536870912;
pub const PCM_CAP_DEFAULT: i32 = 1073741824;
pub const DSP_CAP_ADMASK: i32 = 15728640;
pub const DSP_CAP_ANALOGIN: i32 = 2097152;
pub const DSP_CAP_ANALOGOUT: i32 = 1048576;
pub const DSP_CAP_BATCH: i32 = 1024;
pub const DSP_CAP_BIND: i32 = 32768;
pub const DSP_CAP_COPROC: i32 = 2048;
pub const DSP_CAP_DEFAULT: i32 = 1073741824;
pub const DSP_CAP_DIGITALIN: i32 = 8388608;
pub const DSP_CAP_DIGITALOUT: i32 = 4194304;
pub const DSP_CAP_DUPLEX: i32 = 256;
pub const DSP_CAP_FREERATE: i32 = 268435456;
pub const DSP_CAP_HIDDEN: i32 = 134217728;
pub const DSP_CAP_INPUT: i32 = 65536;
pub const DSP_CAP_MMAP: i32 = 8192;
pub const DSP_CAP_MODEM: i32 = 536870912;
pub const DSP_CAP_MULTI: i32 = 16384;
pub const DSP_CAP_OUTPUT: i32 = 131072;
pub const DSP_CAP_REALTIME: i32 = 512;
pub const DSP_CAP_REVISION: i32 = 255;
pub const DSP_CAP_SHADOW: i32 = 0;
pub const DSP_CAP_TRIGGER: i32 = 4096;
pub const DSP_CAP_VIRTUAL: i32 = 262144;
pub const PCM_ENABLE_INPUT: i32 = 1;
pub const PCM_ENABLE_OUTPUT: i32 = 2;
pub const CPF_NONE: i32 = 0;
pub const CPF_FIRST: i32 = 1;
pub const CPF_LAST: i32 = 2;
pub const SOUND_MIXER_NRDEVICES: i32 = 25;
pub const SOUND_MIXER_VOLUME: i32 = 0;
pub const SOUND_MIXER_BASS: i32 = 1;
pub const SOUND_MIXER_TREBLE: i32 = 2;
pub const SOUND_MIXER_SYNTH: i32 = 3;
pub const SOUND_MIXER_PCM: i32 = 4;
pub const SOUND_MIXER_SPEAKER: i32 = 5;
pub const SOUND_MIXER_LINE: i32 = 6;
pub const SOUND_MIXER_MIC: i32 = 7;
pub const SOUND_MIXER_CD: i32 = 8;
pub const SOUND_MIXER_IMIX: i32 = 9;
pub const SOUND_MIXER_ALTPCM: i32 = 10;
pub const SOUND_MIXER_RECLEV: i32 = 11;
pub const SOUND_MIXER_IGAIN: i32 = 12;
pub const SOUND_MIXER_OGAIN: i32 = 13;
pub const SOUND_MIXER_LINE1: i32 = 14;
pub const SOUND_MIXER_LINE2: i32 = 15;
pub const SOUND_MIXER_LINE3: i32 = 16;
pub const SOUND_MIXER_DIGITAL1: i32 = 17;
pub const SOUND_MIXER_DIGITAL2: i32 = 18;
pub const SOUND_MIXER_DIGITAL3: i32 = 19;
pub const SOUND_MIXER_PHONEIN: i32 = 20;
pub const SOUND_MIXER_PHONEOUT: i32 = 21;
pub const SOUND_MIXER_VIDEO: i32 = 22;
pub const SOUND_MIXER_RADIO: i32 = 23;
pub const SOUND_MIXER_MONITOR: i32 = 24;
pub const SOUND_ONOFF_MIN: i32 = 28;
pub const SOUND_ONOFF_MAX: i32 = 30;
pub const SOUND_MIXER_MUTE: i32 = 28;
pub const SOUND_MIXER_ENHANCE: i32 = 29;
pub const SOUND_MIXER_LOUD: i32 = 30;
pub const SOUND_MIXER_NONE: i32 = 31;
pub const SOUND_MIXER_RECSRC: i32 = 255;
pub const SOUND_MIXER_DEVMASK: i32 = 254;
pub const SOUND_MIXER_RECMASK: i32 = 253;
pub const SOUND_MIXER_CAPS: i32 = 252;
pub const SOUND_CAP_EXCL_INPUT: i32 = 1;
pub const SOUND_MIXER_STEREODEVS: i32 = 251;
pub const SOUND_MASK_VOLUME: i32 = 1;
pub const SOUND_MASK_BASS: i32 = 2;
pub const SOUND_MASK_TREBLE: i32 = 4;
pub const SOUND_MASK_SYNTH: i32 = 8;
pub const SOUND_MASK_PCM: i32 = 16;
pub const SOUND_MASK_SPEAKER: i32 = 32;
pub const SOUND_MASK_LINE: i32 = 64;
pub const SOUND_MASK_MIC: i32 = 128;
pub const SOUND_MASK_CD: i32 = 256;
pub const SOUND_MASK_IMIX: i32 = 512;
pub const SOUND_MASK_ALTPCM: i32 = 1024;
pub const SOUND_MASK_RECLEV: i32 = 2048;
pub const SOUND_MASK_IGAIN: i32 = 4096;
pub const SOUND_MASK_OGAIN: i32 = 8192;
pub const SOUND_MASK_LINE1: i32 = 16384;
pub const SOUND_MASK_LINE2: i32 = 32768;
pub const SOUND_MASK_LINE3: i32 = 65536;
pub const SOUND_MASK_DIGITAL1: i32 = 131072;
pub const SOUND_MASK_DIGITAL2: i32 = 262144;
pub const SOUND_MASK_DIGITAL3: i32 = 524288;
pub const SOUND_MASK_PHONEIN: i32 = 1048576;
pub const SOUND_MASK_PHONEOUT: i32 = 2097152;
pub const SOUND_MASK_RADIO: i32 = 8388608;
pub const SOUND_MASK_VIDEO: i32 = 4194304;
pub const SOUND_MASK_MONITOR: i32 = 16777216;
pub const SOUND_MASK_MUTE: i32 = 268435456;
pub const SOUND_MASK_ENHANCE: i32 = 536870912;
pub const SOUND_MASK_LOUD: i32 = 1073741824;
pub const LEFT_CHN: i32 = 0;
pub const RIGHT_CHN: i32 = 1;
pub const EV_SEQ_LOCAL: i32 = 128;
pub const EV_TIMING: i32 = 129;
pub const EV_CHN_COMMON: i32 = 146;
pub const EV_CHN_VOICE: i32 = 147;
pub const EV_SYSEX: i32 = 148;
pub const MIDI_NOTEOFF: i32 = 128;
pub const MIDI_NOTEON: i32 = 144;
pub const MIDI_KEY_PRESSURE: i32 = 160;
pub const MIDI_CTL_CHANGE: i32 = 176;
pub const MIDI_PGM_CHANGE: i32 = 192;
pub const MIDI_CHN_PRESSURE: i32 = 208;
pub const MIDI_PITCH_BEND: i32 = 224;
pub const MIDI_SYSTEM_PREFIX: i32 = 240;
pub const TMR_WAIT_REL: i32 = 1;
pub const TMR_WAIT_ABS: i32 = 2;
pub const TMR_STOP: i32 = 3;
pub const TMR_START: i32 = 4;
pub const TMR_CONTINUE: i32 = 5;
pub const TMR_TEMPO: i32 = 6;
pub const TMR_ECHO: i32 = 8;
pub const TMR_CLOCK: i32 = 9;
pub const TMR_SPP: i32 = 10;
pub const TMR_TIMESIG: i32 = 11;
pub const LOCL_STARTAUDIO: i32 = 1;
pub const OSS_LONGNAME_SIZE: i32 = 64;
pub const OSS_LABEL_SIZE: i32 = 16;
pub const OSS_DEVNODE_SIZE: i32 = 32;
pub const CHID_UNDEF: i32 = 0;
pub const CHID_L: i32 = 1;
pub const CHID_R: i32 = 2;
pub const CHID_C: i32 = 3;
pub const CHID_LFE: i32 = 4;
pub const CHID_LS: i32 = 5;
pub const CHID_RS: i32 = 6;
pub const CHID_LR: i32 = 7;
pub const CHID_RR: i32 = 8;
pub const CHNORDER_UNDEF: i32 = 0;
pub const CHNORDER_NORMAL: i64 = 2271560481;
pub const MAX_PEAK_CHANNELS: i32 = 128;
pub const DSP_BIND_QUERY: i32 = 0;
pub const DSP_BIND_FRONT: i32 = 1;
pub const DSP_BIND_SURR: i32 = 2;
pub const DSP_BIND_CENTER_LFE: i32 = 4;
pub const DSP_BIND_HANDSET: i32 = 8;
pub const DSP_BIND_MIC: i32 = 16;
pub const DSP_BIND_MODEM1: i32 = 32;
pub const DSP_BIND_MODEM2: i32 = 64;
pub const DSP_BIND_I2S: i32 = 128;
pub const DSP_BIND_SPDIF: i32 = 256;
pub const DSP_BIND_REAR: i32 = 512;
pub const MIXT_DEVROOT: i32 = 0;
pub const MIXT_GROUP: i32 = 1;
pub const MIXT_ONOFF: i32 = 2;
pub const MIXT_ENUM: i32 = 3;
pub const MIXT_MONOSLIDER: i32 = 4;
pub const MIXT_STEREOSLIDER: i32 = 5;
pub const MIXT_MESSAGE: i32 = 6;
pub const MIXT_MONOVU: i32 = 7;
pub const MIXT_STEREOVU: i32 = 8;
pub const MIXT_MONOPEAK: i32 = 9;
pub const MIXT_STEREOPEAK: i32 = 10;
pub const MIXT_RADIOGROUP: i32 = 11;
pub const MIXT_MARKER: i32 = 12;
pub const MIXT_VALUE: i32 = 13;
pub const MIXT_HEXVALUE: i32 = 14;
pub const MIXT_MONODB: i32 = 15;
pub const MIXT_STEREODB: i32 = 16;
pub const MIXT_SLIDER: i32 = 17;
pub const MIXT_3D: i32 = 18;
pub const MIXF_READABLE: i32 = 1;
pub const MIXF_WRITEABLE: i32 = 2;
pub const MIXF_POLL: i32 = 4;
pub const MIXF_HZ: i32 = 8;
pub const MIXF_STRING: i32 = 16;
pub const MIXF_DYNAMIC: i32 = 16;
pub const MIXF_OKFAIL: i32 = 32;
pub const MIXF_FLAT: i32 = 64;
pub const MIXF_LEGACY: i32 = 128;
pub const MIXEXT_SCOPE_MASK: i32 = 63;
pub const MIXEXT_SCOPE_OTHER: i32 = 0;
pub const MIXEXT_SCOPE_INPUT: i32 = 1;
pub const MIXEXT_SCOPE_OUTPUT: i32 = 2;
pub const MIXEXT_SCOPE_MONITOR: i32 = 3;
pub const MIXEXT_SCOPE_RECSWITCH: i32 = 4;
pub const OSS_ENUM_MAXVALUE: i32 = 255;
pub const OPEN_READ: i32 = 1;
pub const OPEN_WRITE: i32 = 2;
pub const OPEN_READWRITE: i32 = 3;
pub const OSS_MAX_SAMPLE_RATES: i32 = 20;
pub const MIXER_CAP_VIRTUAL: i32 = 1;
pub const MIDI_CAP_MPU401: i32 = 1;
pub const MIDI_CAP_INPUT: i32 = 2;
pub const MIDI_CAP_OUTPUT: i32 = 4;
pub const MIDI_CAP_INOUT: i32 = 6;
pub const MIDI_CAP_VIRTUAL: i32 = 8;
pub const MIDI_CAP_MTCINPUT: i32 = 16;
pub const MIDI_CAP_CLIENT: i32 = 32;
pub const MIDI_CAP_SERVER: i32 = 64;
pub const MIDI_CAP_INTERNAL: i32 = 128;
pub const MIDI_CAP_EXTERNAL: i32 = 256;
pub const MIDI_CAP_PTOP: i32 = 512;
pub const MIDI_CAP_MTC: i32 = 1024;
pub const SNDST_DSPS: &[u8; 5] = b"dsps\0";
pub const SNDST_DSPS_FROM_USER: &[u8; 10] = b"from_user\0";
pub const SNDST_DSPS_PCHAN: &[u8; 6] = b"pchan\0";
pub const SNDST_DSPS_RCHAN: &[u8; 6] = b"rchan\0";
pub const SNDST_DSPS_NAMEUNIT: &[u8; 9] = b"nameunit\0";
pub const SNDST_DSPS_DEVNODE: &[u8; 8] = b"devnode\0";
pub const SNDST_DSPS_DESC: &[u8; 5] = b"desc\0";
pub const SNDST_DSPS_PROVIDER: &[u8; 9] = b"provider\0";
pub const SNDST_DSPS_PROVIDER_INFO: &[u8; 14] = b"provider_info\0";
pub const SNDST_DSPS_INFO_PLAY: &[u8; 10] = b"info_play\0";
pub const SNDST_DSPS_INFO_REC: &[u8; 9] = b"info_rec\0";
pub const SNDST_DSPS_INFO_MIN_RATE: &[u8; 9] = b"min_rate\0";
pub const SNDST_DSPS_INFO_MAX_RATE: &[u8; 9] = b"max_rate\0";
pub const SNDST_DSPS_INFO_FORMATS: &[u8; 8] = b"formats\0";
pub const SNDST_DSPS_INFO_MIN_CHN: &[u8; 8] = b"min_chn\0";
pub const SNDST_DSPS_INFO_MAX_CHN: &[u8; 8] = b"max_chn\0";
pub const SNDST_DSPS_SOUND4_PROVIDER: &[u8; 9] = b"sound(4)\0";
pub const SNDST_DSPS_SOUND4_UNIT: &[u8; 5] = b"unit\0";
pub const SNDST_DSPS_SOUND4_STATUS: &[u8; 7] = b"status\0";
pub const SNDST_DSPS_SOUND4_BITPERFECT: &[u8; 11] = b"bitperfect\0";
pub const SNDST_DSPS_SOUND4_PVCHAN: &[u8; 7] = b"pvchan\0";
pub const SNDST_DSPS_SOUND4_PVCHANRATE: &[u8; 11] = b"pvchanrate\0";
pub const SNDST_DSPS_SOUND4_PVCHANFORMAT: &[u8; 13] = b"pvchanformat\0";
pub const SNDST_DSPS_SOUND4_RVCHAN: &[u8; 7] = b"rvchan\0";
pub const SNDST_DSPS_SOUND4_RVCHANRATE: &[u8; 11] = b"rvchanrate\0";
pub const SNDST_DSPS_SOUND4_RVCHANFORMAT: &[u8; 13] = b"rvchanformat\0";
pub const SNDST_DSPS_SOUND4_CHAN_INFO: &[u8; 13] = b"channel_info\0";
pub const SNDST_DSPS_SOUND4_CHAN_NAME: &[u8; 5] = b"name\0";
pub const SNDST_DSPS_SOUND4_CHAN_PARENTCHAN: &[u8; 11] = b"parentchan\0";
pub const SNDST_DSPS_SOUND4_CHAN_UNIT: &[u8; 5] = b"unit\0";
pub const SNDST_DSPS_SOUND4_CHAN_CAPS: &[u8; 5] = b"caps\0";
pub const SNDST_DSPS_SOUND4_CHAN_LATENCY: &[u8; 8] = b"latency\0";
pub const SNDST_DSPS_SOUND4_CHAN_RATE: &[u8; 5] = b"rate\0";
pub const SNDST_DSPS_SOUND4_CHAN_FORMAT: &[u8; 7] = b"format\0";
pub const SNDST_DSPS_SOUND4_CHAN_PID: &[u8; 4] = b"pid\0";
pub const SNDST_DSPS_SOUND4_CHAN_COMM: &[u8; 5] = b"comm\0";
pub const SNDST_DSPS_SOUND4_CHAN_INTR: &[u8; 11] = b"interrupts\0";
pub const SNDST_DSPS_SOUND4_CHAN_FEEDCNT: &[u8; 10] = b"feedcount\0";
pub const SNDST_DSPS_SOUND4_CHAN_XRUNS: &[u8; 6] = b"xruns\0";
pub const SNDST_DSPS_SOUND4_CHAN_LEFTVOL: &[u8; 12] = b"left_volume\0";
pub const SNDST_DSPS_SOUND4_CHAN_RIGHTVOL: &[u8; 13] = b"right_volume\0";
pub const SNDST_DSPS_SOUND4_CHAN_HWBUF_FORMAT: &[u8; 13] = b"hwbuf_format\0";
pub const SNDST_DSPS_SOUND4_CHAN_HWBUF_RATE: &[u8; 11] = b"hwbuf_rate\0";
pub const SNDST_DSPS_SOUND4_CHAN_HWBUF_SIZE: &[u8; 11] = b"hwbuf_size\0";
pub const SNDST_DSPS_SOUND4_CHAN_HWBUF_BLKSZ: &[u8; 12] = b"hwbuf_blksz\0";
pub const SNDST_DSPS_SOUND4_CHAN_HWBUF_BLKCNT: &[u8; 13] = b"hwbuf_blkcnt\0";
pub const SNDST_DSPS_SOUND4_CHAN_HWBUF_FREE: &[u8; 11] = b"hwbuf_free\0";
pub const SNDST_DSPS_SOUND4_CHAN_HWBUF_READY: &[u8; 12] = b"hwbuf_ready\0";
pub const SNDST_DSPS_SOUND4_CHAN_SWBUF_FORMAT: &[u8; 13] = b"swbuf_format\0";
pub const SNDST_DSPS_SOUND4_CHAN_SWBUF_RATE: &[u8; 11] = b"swbuf_rate\0";
pub const SNDST_DSPS_SOUND4_CHAN_SWBUF_SIZE: &[u8; 11] = b"swbuf_size\0";
pub const SNDST_DSPS_SOUND4_CHAN_SWBUF_BLKSZ: &[u8; 12] = b"swbuf_blksz\0";
pub const SNDST_DSPS_SOUND4_CHAN_SWBUF_BLKCNT: &[u8; 13] = b"swbuf_blkcnt\0";
pub const SNDST_DSPS_SOUND4_CHAN_SWBUF_FREE: &[u8; 11] = b"swbuf_free\0";
pub const SNDST_DSPS_SOUND4_CHAN_SWBUF_READY: &[u8; 12] = b"swbuf_ready\0";
pub const SNDST_DSPS_SOUND4_CHAN_FEEDERCHAIN: &[u8; 12] = b"feederchain\0";
pub const SNDST_UNVLBUF_MAX: i32 = 65536;
pub const SPLAY_NEGINF: i32 = -1;
pub const SPLAY_INF: i32 = 1;
pub const RB_STRICT_HST: i32 = 0;
pub const RB_NEGINF: i32 = -1;
pub const RB_INF: i32 = 1;
pub const CTL_MAXNAME: i32 = 24;
pub const CTLTYPE: i32 = 15;
pub const CTLTYPE_NODE: i32 = 1;
pub const CTLTYPE_INT: i32 = 2;
pub const CTLTYPE_STRING: i32 = 3;
pub const CTLTYPE_S64: i32 = 4;
pub const CTLTYPE_OPAQUE: i32 = 5;
pub const CTLTYPE_STRUCT: i32 = 5;
pub const CTLTYPE_UINT: i32 = 6;
pub const CTLTYPE_LONG: i32 = 7;
pub const CTLTYPE_ULONG: i32 = 8;
pub const CTLTYPE_U64: i32 = 9;
pub const CTLTYPE_U8: i32 = 10;
pub const CTLTYPE_U16: i32 = 11;
pub const CTLTYPE_S8: i32 = 12;
pub const CTLTYPE_S16: i32 = 13;
pub const CTLTYPE_S32: i32 = 14;
pub const CTLTYPE_U32: i32 = 15;
pub const CTLFLAG_RD: i64 = 2147483648;
pub const CTLFLAG_WR: i32 = 1073741824;
pub const CTLFLAG_RW: i64 = 3221225472;
pub const CTLFLAG_DORMANT: i32 = 536870912;
pub const CTLFLAG_ANYBODY: i32 = 268435456;
pub const CTLFLAG_SECURE: i32 = 134217728;
pub const CTLFLAG_PRISON: i32 = 67108864;
pub const CTLFLAG_DYN: i32 = 33554432;
pub const CTLFLAG_SKIP: i32 = 16777216;
pub const CTLMASK_SECURE: i32 = 15728640;
pub const CTLFLAG_TUN: i32 = 524288;
pub const CTLFLAG_RDTUN: i64 = 2148007936;
pub const CTLFLAG_RWTUN: i64 = 3221749760;
pub const CTLFLAG_MPSAFE: i32 = 262144;
pub const CTLFLAG_VNET: i32 = 131072;
pub const CTLFLAG_DYING: i32 = 65536;
pub const CTLFLAG_CAPRD: i32 = 32768;
pub const CTLFLAG_CAPWR: i32 = 16384;
pub const CTLFLAG_STATS: i32 = 8192;
pub const CTLFLAG_NOFETCH: i32 = 4096;
pub const CTLFLAG_CAPRW: i32 = 49152;
pub const CTLFLAG_NEEDGIANT: i32 = 2048;
pub const CTLSHIFT_SECURE: i32 = 20;
pub const CTLFLAG_SECURE1: i32 = 134217728;
pub const CTLFLAG_SECURE2: i32 = 135266304;
pub const CTLFLAG_SECURE3: i32 = 136314880;
pub const OID_AUTO: i32 = -1;
pub const CTL_AUTO_START: i32 = 256;
pub const SYSCTL_CT_ASSERT_MASK: i32 = 0;
pub const REQ_UNWIRED: i32 = 1;
pub const REQ_WIRED: i32 = 2;
pub const SCTL_MASK32: i32 = 1;
pub const CTL_SYSCTL: i32 = 0;
pub const CTL_KERN: i32 = 1;
pub const CTL_VM: i32 = 2;
pub const CTL_VFS: i32 = 3;
pub const CTL_NET: i32 = 4;
pub const CTL_DEBUG: i32 = 5;
pub const CTL_HW: i32 = 6;
pub const CTL_MACHDEP: i32 = 7;
pub const CTL_USER: i32 = 8;
pub const CTL_P1003_1B: i32 = 9;
pub const CTL_SYSCTL_DEBUG: i32 = 0;
pub const CTL_SYSCTL_NAME: i32 = 1;
pub const CTL_SYSCTL_NEXT: i32 = 2;
pub const CTL_SYSCTL_NAME2OID: i32 = 3;
pub const CTL_SYSCTL_OIDFMT: i32 = 4;
pub const CTL_SYSCTL_OIDDESCR: i32 = 5;
pub const CTL_SYSCTL_OIDLABEL: i32 = 6;
pub const CTL_SYSCTL_NEXTNOSKIP: i32 = 7;
pub const KERN_OSTYPE: i32 = 1;
pub const KERN_OSRELEASE: i32 = 2;
pub const KERN_OSREV: i32 = 3;
pub const KERN_VERSION: i32 = 4;
pub const KERN_MAXVNODES: i32 = 5;
pub const KERN_MAXPROC: i32 = 6;
pub const KERN_MAXFILES: i32 = 7;
pub const KERN_ARGMAX: i32 = 8;
pub const KERN_SECURELVL: i32 = 9;
pub const KERN_HOSTNAME: i32 = 10;
pub const KERN_HOSTID: i32 = 11;
pub const KERN_CLOCKRATE: i32 = 12;
pub const KERN_PROC: i32 = 14;
pub const KERN_FILE: i32 = 15;
pub const KERN_PROF: i32 = 16;
pub const KERN_POSIX1: i32 = 17;
pub const KERN_NGROUPS: i32 = 18;
pub const KERN_JOB_CONTROL: i32 = 19;
pub const KERN_SAVED_IDS: i32 = 20;
pub const KERN_BOOTTIME: i32 = 21;
pub const KERN_NISDOMAINNAME: i32 = 22;
pub const KERN_UPDATEINTERVAL: i32 = 23;
pub const KERN_OSRELDATE: i32 = 24;
pub const KERN_NTP_PLL: i32 = 25;
pub const KERN_BOOTFILE: i32 = 26;
pub const KERN_MAXFILESPERPROC: i32 = 27;
pub const KERN_MAXPROCPERUID: i32 = 28;
pub const KERN_DUMPDEV: i32 = 29;
pub const KERN_IPC: i32 = 30;
pub const KERN_DUMMY: i32 = 31;
pub const KERN_PS_STRINGS: i32 = 32;
pub const KERN_USRSTACK: i32 = 33;
pub const KERN_LOGSIGEXIT: i32 = 34;
pub const KERN_IOV_MAX: i32 = 35;
pub const KERN_HOSTUUID: i32 = 36;
pub const KERN_ARND: i32 = 37;
pub const KERN_MAXPHYS: i32 = 38;
pub const KERN_LOCKF: i32 = 39;
pub const KERN_PROC_ALL: i32 = 0;
pub const KERN_PROC_PID: i32 = 1;
pub const KERN_PROC_PGRP: i32 = 2;
pub const KERN_PROC_SESSION: i32 = 3;
pub const KERN_PROC_TTY: i32 = 4;
pub const KERN_PROC_UID: i32 = 5;
pub const KERN_PROC_RUID: i32 = 6;
pub const KERN_PROC_ARGS: i32 = 7;
pub const KERN_PROC_PROC: i32 = 8;
pub const KERN_PROC_SV_NAME: i32 = 9;
pub const KERN_PROC_RGID: i32 = 10;
pub const KERN_PROC_GID: i32 = 11;
pub const KERN_PROC_PATHNAME: i32 = 12;
pub const KERN_PROC_OVMMAP: i32 = 13;
pub const KERN_PROC_OFILEDESC: i32 = 14;
pub const KERN_PROC_KSTACK: i32 = 15;
pub const KERN_PROC_INC_THREAD: i32 = 16;
pub const KERN_PROC_VMMAP: i32 = 32;
pub const KERN_PROC_FILEDESC: i32 = 33;
pub const KERN_PROC_GROUPS: i32 = 34;
pub const KERN_PROC_ENV: i32 = 35;
pub const KERN_PROC_AUXV: i32 = 36;
pub const KERN_PROC_RLIMIT: i32 = 37;
pub const KERN_PROC_PS_STRINGS: i32 = 38;
pub const KERN_PROC_UMASK: i32 = 39;
pub const KERN_PROC_OSREL: i32 = 40;
pub const KERN_PROC_SIGTRAMP: i32 = 41;
pub const KERN_PROC_CWD: i32 = 42;
pub const KERN_PROC_NFDS: i32 = 43;
pub const KERN_PROC_SIGFASTBLK: i32 = 44;
pub const KERN_PROC_VM_LAYOUT: i32 = 45;
pub const KERN_PROC_RLIMIT_USAGE: i32 = 46;
pub const KERN_PROC_KQUEUE: i32 = 47;
pub const KIPC_MAXSOCKBUF: i32 = 1;
pub const KIPC_SOCKBUF_WASTE: i32 = 2;
pub const KIPC_SOMAXCONN: i32 = 3;
pub const KIPC_MAX_LINKHDR: i32 = 4;
pub const KIPC_MAX_PROTOHDR: i32 = 5;
pub const KIPC_MAX_HDR: i32 = 6;
pub const KIPC_MAX_DATALEN: i32 = 7;
pub const HW_MACHINE: i32 = 1;
pub const HW_MODEL: i32 = 2;
pub const HW_NCPU: i32 = 3;
pub const HW_BYTEORDER: i32 = 4;
pub const HW_PHYSMEM: i32 = 5;
pub const HW_USERMEM: i32 = 6;
pub const HW_PAGESIZE: i32 = 7;
pub const HW_DISKNAMES: i32 = 8;
pub const HW_DISKSTATS: i32 = 9;
pub const HW_FLOATINGPT: i32 = 10;
pub const HW_MACHINE_ARCH: i32 = 11;
pub const HW_REALMEM: i32 = 12;
pub const USER_CS_PATH: i32 = 1;
pub const USER_BC_BASE_MAX: i32 = 2;
pub const USER_BC_DIM_MAX: i32 = 3;
pub const USER_BC_SCALE_MAX: i32 = 4;
pub const USER_BC_STRING_MAX: i32 = 5;
pub const USER_COLL_WEIGHTS_MAX: i32 = 6;
pub const USER_EXPR_NEST_MAX: i32 = 7;
pub const USER_LINE_MAX: i32 = 8;
pub const USER_RE_DUP_MAX: i32 = 9;
pub const USER_POSIX2_VERSION: i32 = 10;
pub const USER_POSIX2_C_BIND: i32 = 11;
pub const USER_POSIX2_C_DEV: i32 = 12;
pub const USER_POSIX2_CHAR_TERM: i32 = 13;
pub const USER_POSIX2_FORT_DEV: i32 = 14;
pub const USER_POSIX2_FORT_RUN: i32 = 15;
pub const USER_POSIX2_LOCALEDEF: i32 = 16;
pub const USER_POSIX2_SW_DEV: i32 = 17;
pub const USER_POSIX2_UPE: i32 = 18;
pub const USER_STREAM_MAX: i32 = 19;
pub const USER_TZNAME_MAX: i32 = 20;
pub const USER_LOCALBASE: i32 = 21;
pub const CTL_P1003_1B_ASYNCHRONOUS_IO: i32 = 1;
pub const CTL_P1003_1B_MAPPED_FILES: i32 = 2;
pub const CTL_P1003_1B_MEMLOCK: i32 = 3;
pub const CTL_P1003_1B_MEMLOCK_RANGE: i32 = 4;
pub const CTL_P1003_1B_MEMORY_PROTECTION: i32 = 5;
pub const CTL_P1003_1B_MESSAGE_PASSING: i32 = 6;
pub const CTL_P1003_1B_PRIORITIZED_IO: i32 = 7;
pub const CTL_P1003_1B_PRIORITY_SCHEDULING: i32 = 8;
pub const CTL_P1003_1B_REALTIME_SIGNALS: i32 = 9;
pub const CTL_P1003_1B_SEMAPHORES: i32 = 10;
pub const CTL_P1003_1B_FSYNC: i32 = 11;
pub const CTL_P1003_1B_SHARED_MEMORY_OBJECTS: i32 = 12;
pub const CTL_P1003_1B_SYNCHRONIZED_IO: i32 = 13;
pub const CTL_P1003_1B_TIMERS: i32 = 14;
pub const CTL_P1003_1B_AIO_LISTIO_MAX: i32 = 15;
pub const CTL_P1003_1B_AIO_MAX: i32 = 16;
pub const CTL_P1003_1B_AIO_PRIO_DELTA_MAX: i32 = 17;
pub const CTL_P1003_1B_DELAYTIMER_MAX: i32 = 18;
pub const CTL_P1003_1B_MQ_OPEN_MAX: i32 = 19;
pub const CTL_P1003_1B_PAGESIZE: i32 = 20;
pub const CTL_P1003_1B_RTSIG_MAX: i32 = 21;
pub const CTL_P1003_1B_SEM_NSEMS_MAX: i32 = 22;
pub const CTL_P1003_1B_SEM_VALUE_MAX: i32 = 23;
pub const CTL_P1003_1B_SIGQUEUE_MAX: i32 = 24;
pub const CTL_P1003_1B_TIMER_MAX: i32 = 25;
pub const CTL_P1003_1B_MAXID: i32 = 26;
pub const TATTR_AP_TABLE_MASK: i64 = 6917529027641081856;
pub const TATTR_AP_TABLE_RO: i64 = 4611686018427387904;
pub const TATTR_AP_TABLE_NO_EL0: i64 = 2305843009213693952;
pub const TATTR_UXN_TABLE: i64 = 1152921504606846976;
pub const TATTR_PXN_TABLE: i64 = 576460752303423488;
pub const ATTR_SW_UNUSED1: i64 = 288230376151711744;
pub const ATTR_SW_NO_PROMOTE: i64 = 144115188075855872;
pub const ATTR_SW_MANAGED: i64 = 72057594037927936;
pub const ATTR_SW_WIRED: i64 = 36028797018963968;
pub const ATTR_S1_UXN: i64 = 18014398509481984;
pub const ATTR_S1_PXN: i64 = 9007199254740992;
pub const ATTR_S1_XN: i64 = 27021597764222976;
pub const ATTR_S2_XN_NONE: i32 = 0;
pub const ATTR_S2_XN_EL1: i32 = 1;
pub const ATTR_S2_XN_ALL: i32 = 2;
pub const ATTR_S2_XN_EL0: i32 = 3;
pub const ATTR_CONTIGUOUS: i64 = 4503599627370496;
pub const ATTR_DBM: i64 = 2251799813685248;
pub const ATTR_S1_GP_SHIFT: i32 = 50;
pub const ATTR_S1_GP: i64 = 1125899906842624;
pub const ATTR_S1_nG: i32 = 2048;
pub const ATTR_AF: i32 = 1024;
pub const ATTR_SH_NS: i32 = 0;
pub const ATTR_SH_OS: i32 = 2;
pub const ATTR_SH_IS: i32 = 3;
pub const ATTR_OA_51_50_SHIFT: i32 = 8;
pub const ATTR_OA_51_50_MASK: i32 = 768;
pub const ATTR_OA_51_50_DELTA: i32 = 42;
pub const ATTR_S1_AP_RW_BIT: i32 = 128;
pub const ATTR_S1_AP_RW: i32 = 0;
pub const ATTR_S1_AP_RO: i32 = 2;
pub const ATTR_S1_AP_USER: i32 = 1;
pub const ATTR_S1_NS: i32 = 32;
pub const ATTR_S1_IDX_MASK: i32 = 28;
pub const ATTR_S2_S2AP_MASK: i32 = 3;
pub const ATTR_S2_S2AP_READ: i32 = 1;
pub const ATTR_S2_S2AP_WRITE: i32 = 2;
pub const ATTR_S2_MEMATTR_DEVICE_nGnRnE: i32 = 0;
pub const ATTR_S2_MEMATTR_NC: i32 = 15;
pub const ATTR_S2_MEMATTR_WT: i32 = 10;
pub const ATTR_S2_MEMATTR_WB: i32 = 15;
pub const ATTR_DESCR_MASK: i32 = 3;
pub const ATTR_DESCR_VALID: i32 = 1;
pub const ATTR_DESCR_TYPE_MASK: i32 = 2;
pub const ATTR_DESCR_TYPE_TABLE: i32 = 2;
pub const ATTR_DESCR_TYPE_PAGE: i32 = 2;
pub const ATTR_DESCR_TYPE_BLOCK: i32 = 0;
pub const L0_SHIFT: i32 = 39;
pub const L1_SHIFT: i32 = 30;
pub const L2_SHIFT: i32 = 21;
pub const L3_SHIFT: i32 = 12;
pub const L0_INVAL: i32 = 0;
pub const L0_TABLE: i32 = 3;
pub const L1_INVAL: i32 = 0;
pub const L1_BLOCK: i32 = 1;
pub const L1_TABLE: i32 = 3;
pub const L2_INVAL: i32 = 0;
pub const L2_BLOCK: i32 = 1;
pub const L2_TABLE: i32 = 3;
pub const L3_SIZE: i32 = 4096;
pub const L3_OFFSET: i32 = 4095;
pub const L3_INVAL: i32 = 0;
pub const L3_PAGE: i32 = 3;
pub const L0_ENTRIES_SHIFT: i32 = 9;
pub const Ln_ENTRIES_SHIFT: i32 = 9;
pub const L0_ENTRIES: i32 = 512;
pub const L0_ADDR_MASK: i32 = 511;
pub const Ln_ENTRIES: i32 = 512;
pub const Ln_ADDR_MASK: i32 = 511;
pub const Ln_TABLE_MASK: i32 = 4095;
pub const L2C_ENTRIES: i32 = 16;
pub const L3C_ENTRIES: i32 = 16;
pub const L3C_SIZE: i32 = 65536;
pub const L3C_OFFSET: i32 = 65535;
pub const _NPCPV: i32 = 168;
pub const _NPAD: i32 = 0;
pub const PC_FREEN: i32 = -1;
pub const PC_FREEL: i64 = 1099511627775;
pub const ASID_RESERVED_FOR_PID_0: i32 = 0;
pub const ASID_RESERVED_FOR_EFI: i32 = 1;
pub const ASID_FIRST_AVAILABLE: i32 = 2;
pub const PMAP_ENTER_NOSLEEP: i32 = 256;
pub const PMAP_ENTER_WIRED: i32 = 512;
pub const PMAP_ENTER_LARGEPAGE: i32 = 1024;
pub const PMAP_ENTER_RESERVED: i64 = 4278190080;
pub const PMAP_TS_REFERENCED_MAX: i32 = 5;
pub const SNDBUF_F_MANAGED: i32 = 1;
pub const SNDBUF_NAMELEN: i32 = 48;
pub const SND_MULTICHANNEL: i32 = 1;
pub const SND_CHN_T_FL: i32 = 0;
pub const SND_CHN_T_FR: i32 = 1;
pub const SND_CHN_T_FC: i32 = 2;
pub const SND_CHN_T_LF: i32 = 3;
pub const SND_CHN_T_BL: i32 = 4;
pub const SND_CHN_T_BR: i32 = 5;
pub const SND_CHN_T_FLC: i32 = 6;
pub const SND_CHN_T_FRC: i32 = 7;
pub const SND_CHN_T_BC: i32 = 8;
pub const SND_CHN_T_SL: i32 = 9;
pub const SND_CHN_T_SR: i32 = 10;
pub const SND_CHN_T_TC: i32 = 11;
pub const SND_CHN_T_TFL: i32 = 12;
pub const SND_CHN_T_TFC: i32 = 13;
pub const SND_CHN_T_TFR: i32 = 14;
pub const SND_CHN_T_TBL: i32 = 15;
pub const SND_CHN_T_TBC: i32 = 16;
pub const SND_CHN_T_TBR: i32 = 17;
pub const SND_CHN_T_MAX: i32 = 18;
pub const SND_CHN_T_ZERO: i32 = 19;
pub const SND_CHN_T_MASK_FL: i32 = 1;
pub const SND_CHN_T_MASK_FR: i32 = 2;
pub const SND_CHN_T_MASK_FC: i32 = 4;
pub const SND_CHN_T_MASK_LF: i32 = 8;
pub const SND_CHN_T_MASK_BL: i32 = 16;
pub const SND_CHN_T_MASK_BR: i32 = 32;
pub const SND_CHN_T_MASK_FLC: i32 = 64;
pub const SND_CHN_T_MASK_FRC: i32 = 128;
pub const SND_CHN_T_MASK_BC: i32 = 256;
pub const SND_CHN_T_MASK_SL: i32 = 512;
pub const SND_CHN_T_MASK_SR: i32 = 1024;
pub const SND_CHN_T_MASK_TC: i32 = 2048;
pub const SND_CHN_T_MASK_TFL: i32 = 4096;
pub const SND_CHN_T_MASK_TFC: i32 = 8192;
pub const SND_CHN_T_MASK_TFR: i32 = 16384;
pub const SND_CHN_T_MASK_TBL: i32 = 32768;
pub const SND_CHN_T_MASK_TBC: i32 = 65536;
pub const SND_CHN_T_MASK_TBR: i32 = 131072;
pub const SND_CHN_LEFT_MASK: i32 = 37457;
pub const SND_CHN_RIGHT_MASK: i32 = 148642;
pub const SND_CHN_CENTER_MASK: i32 = 76044;
pub const SND_CHN_MATRIX_1_0: i32 = 0;
pub const SND_CHN_MATRIX_1: i32 = 0;
pub const SND_CHN_MATRIX_2_0: i32 = 1;
pub const SND_CHN_MATRIX_2: i32 = 1;
pub const SND_CHN_MATRIX_2_1: i32 = 2;
pub const SND_CHN_MATRIX_3_0: i32 = 3;
pub const SND_CHN_MATRIX_3: i32 = 3;
pub const SND_CHN_MATRIX_3_1: i32 = 4;
pub const SND_CHN_MATRIX_4_0: i32 = 5;
pub const SND_CHN_MATRIX_4: i32 = 5;
pub const SND_CHN_MATRIX_4_1: i32 = 6;
pub const SND_CHN_MATRIX_5_0: i32 = 7;
pub const SND_CHN_MATRIX_5: i32 = 7;
pub const SND_CHN_MATRIX_5_1: i32 = 8;
pub const SND_CHN_MATRIX_6_0: i32 = 9;
pub const SND_CHN_MATRIX_6: i32 = 8;
pub const SND_CHN_MATRIX_6_1: i32 = 10;
pub const SND_CHN_MATRIX_7_0: i32 = 11;
pub const SND_CHN_MATRIX_7: i32 = 10;
pub const SND_CHN_MATRIX_7_1: i32 = 12;
pub const SND_CHN_MATRIX_8: i32 = 12;
pub const SND_CHN_MATRIX_MAX: i32 = 13;
pub const SND_CHN_MATRIX_BEGIN: i32 = 0;
pub const SND_CHN_MATRIX_END: i32 = 12;
pub const SND_CHN_MATRIX_DRV: i32 = -4;
pub const SND_CHN_MATRIX_PCMCHANNEL: i32 = -3;
pub const SND_CHN_MATRIX_MISC: i32 = -2;
pub const SND_CHN_MATRIX_UNKNOWN: i32 = -1;
pub const SND_CHN_T_VOL_0DB: i32 = 18;
pub const SND_CHN_T_VOL_MAX: i32 = 19;
pub const SND_CHN_T_BEGIN: i32 = 0;
pub const SND_CHN_T_END: i32 = 17;
pub const SND_CHN_T_STEP: i32 = 1;
pub const SND_CHN_MIN: i32 = 1;
pub const SND_CHN_MAX: i32 = 8;
pub const SND_VOL_C_MASTER: i32 = 0;
pub const SND_VOL_C_PCM: i32 = 1;
pub const SND_VOL_C_PCM_VAL: i32 = 2;
pub const SND_VOL_C_MAX: i32 = 3;
pub const SND_VOL_C_BEGIN: i32 = 1;
pub const SND_VOL_C_END: i32 = 1;
pub const SND_VOL_C_STEP: i32 = 2;
pub const SND_VOL_0DB_MIN: i32 = 1;
pub const SND_VOL_0DB_MAX: i32 = 100;
pub const SND_VOL_0DB_MASTER: i32 = 100;
pub const SND_VOL_0DB_PCM: i32 = 45;
pub const SND_VOL_RESOLUTION: i32 = 8;
pub const SND_VOL_FLAT: i32 = 256;
pub const CHN_NAMELEN: i32 = 32;
pub const CHN_COMM_UNUSED: &[u8; 9] = b"<UNUSED>\0";
pub const CHN_COMM_UNKNOWN: &[u8; 10] = b"<UNKNOWN>\0";
pub const AFMTSTR_LEN: i32 = 16;
pub const PCMTRIG_START: i32 = 1;
pub const PCMTRIG_EMLDMAWR: i32 = 2;
pub const PCMTRIG_EMLDMARD: i32 = 3;
pub const PCMTRIG_STOP: i32 = 0;
pub const PCMTRIG_ABORT: i32 = -1;
pub const CHN_F_CLOSING: i32 = 1;
pub const CHN_F_ABORTING: i32 = 2;
pub const CHN_F_RUNNING: i32 = 4;
pub const CHN_F_TRIGGERED: i32 = 8;
pub const CHN_F_NOTRIGGER: i32 = 16;
pub const CHN_F_NBIO: i32 = 64;
pub const CHN_F_MMAP: i32 = 128;
pub const CHN_F_BUSY: i32 = 256;
pub const CHN_F_DIRTY: i32 = 512;
pub const CHN_F_DEAD: i32 = 1024;
pub const CHN_F_HAS_SIZE: i32 = 4096;
pub const CHN_F_HAS_VCHAN: i32 = 8192;
pub const CHN_F_VCHAN_PASSTHROUGH: i32 = 16384;
pub const CHN_F_VCHAN_ADAPTIVE: i32 = 32768;
pub const CHN_F_VCHAN_DYNAMIC: i32 = 49152;
pub const CHN_F_VIRTUAL: i32 = 268435456;
pub const CHN_F_BITPERFECT: i32 = 536870912;
pub const CHN_F_PASSTHROUGH: i32 = 1073741824;
pub const CHN_F_EXCLUSIVE: i64 = 2147483648;
pub const CHN_F_BITS : & [u8 ; 166] = b"\x10\x01CLOSING\x02ABORTING\x03RUNNING\x04TRIGGERED\x05NOTRIGGER\x07NBIO\x08MMAP\tBUSY\nDIRTY\x0BDEAD\rHAS_SIZE\x0EHAS_VCHAN\x0FVCHAN_PASSTHROUGH\x10VCHAN_ADAPTIVE\x1DVIRTUAL\x1EBITPERFECT\x1FPASSTHROUGH EXCLUSIVE\0" ;
pub const CHN_F_RESET: i64 = 3489719616;
pub const CHN_F_MMAP_INVALID: i32 = 1028;
pub const CHN_N_RATE: i32 = 1;
pub const CHN_N_FORMAT: i32 = 2;
pub const CHN_N_VOLUME: i32 = 4;
pub const CHN_N_BLOCKSIZE: i32 = 8;
pub const CHN_N_TRIGGER: i32 = 16;
pub const CHN_LATENCY_MIN: i32 = 0;
pub const CHN_LATENCY_MAX: i32 = 10;
pub const CHN_LATENCY_DEFAULT: i32 = 2;
pub const CHN_POLICY_MIN: i32 = 0;
pub const CHN_POLICY_MAX: i32 = 10;
pub const CHN_POLICY_DEFAULT: i32 = 2;
pub const CHN_LATENCY_PROFILE_MIN: i32 = 0;
pub const CHN_LATENCY_PROFILE_MAX: i32 = 1;
pub const CHN_LATENCY_PROFILE_DEFAULT: i32 = 1;
pub const CHN_TIMEOUT: i32 = 5;
pub const CHN_TIMEOUT_MIN: i32 = 1;
pub const CHN_TIMEOUT_MAX: i32 = 10;
pub const CHN_2NDBUFBLKSIZE: i32 = 2048;
pub const CHN_2NDBUFBLKNUM: i32 = 32;
pub const CHN_2NDBUFMAXSIZE: i32 = 131072;
pub const FEEDRATE_RATEMIN: i32 = 1;
pub const FEEDRATE_RATEMAX: i32 = 2016000;
pub const FEEDRATE_MIN: i32 = 1;
pub const FEEDRATE_MAX: i32 = 8388607;
pub const FEEDRATE_ROUNDHZ: i32 = 25;
pub const FEEDRATE_ROUNDHZ_MIN: i32 = 0;
pub const FEEDRATE_ROUNDHZ_MAX: i32 = 500;
pub const MIXER_CMD_DIRECT: i32 = 0;
pub const MIXER_CMD_CDEV: i32 = 1;
pub const MIXER_TYPE_PRIMARY: i32 = 0;
pub const MIXER_TYPE_SECONDARY: i32 = 1;
pub const SND_STATUSLEN: i32 = 64;
pub const SOUND_MODVER: i32 = 5;
pub const SOUND_MINVER: i32 = 5;
pub const SOUND_PREFVER: i32 = 5;
pub const SOUND_MAXVER: i32 = 5;
pub const SD_F_SIMPLEX: i32 = 1;
pub const SD_F_SOFTPCMVOL: i32 = 4;
pub const SD_F_BUSY: i32 = 8;
pub const SD_F_MPSAFE: i32 = 16;
pub const SD_F_REGISTERED: i32 = 32;
pub const SD_F_BITPERFECT: i32 = 64;
pub const SD_F_VPC: i32 = 128;
pub const SD_F_EQ: i32 = 256;
pub const SD_F_EQ_ENABLED: i32 = 512;
pub const SD_F_EQ_BYPASSED: i32 = 1024;
pub const SD_F_EQ_PC: i32 = 2048;
pub const SD_F_PVCHANS: i32 = 4096;
pub const SD_F_RVCHANS: i32 = 8192;
pub const SD_F_EQ_DEFAULT: i32 = 768;
pub const SD_F_EQ_MASK: i32 = 3840;
pub const SD_F_BITS : & [u8 ; 107] = b"\x10\x01SIMPLEX\x03SOFTPCMVOL\x04BUSY\x05MPSAFE\x06REGISTERED\x07BITPERFECT\x08VPC\tEQ\nEQ_ENABLED\x0BEQ_BYPASSED\x0CEQ_PC\rPVCHANS\x0ERVCHANS\0" ;
pub const PCM_MAXCHANS: i32 = 10000;
pub const PCM_MODE_MIXER: i32 = 1;
pub const PCM_MODE_PLAY: i32 = 2;
pub const PCM_MODE_REC: i32 = 4;
pub const AFMT_32BIT: i32 = 805367808;
pub const AFMT_24BIT: i32 = 983040;
pub const AFMT_16BIT: i32 = 432;
pub const AFMT_G711: i32 = 3;
pub const AFMT_8BIT: i32 = 75;
pub const AFMT_SIGNED: i32 = 805515376;
pub const AFMT_BIGENDIAN: i32 = 537567520;
pub const AFMT_CONVERTIBLE: i32 = 806351355;
pub const AFMT_VCHAN: i32 = 806351352;
pub const AFMT_PASSTHROUGH: i32 = 1024;
pub const AFMT_PASSTHROUGH_RATE: i32 = 48000;
pub const AFMT_PASSTHROUGH_CHANNEL: i32 = 2;
pub const AFMT_PASSTHROUGH_EXTCHANNEL: i32 = 0;
pub const AFMT_ENCODING_MASK: i64 = 4027580415;
pub const AFMT_CHANNEL_MASK: i32 = 133169152;
pub const AFMT_CHANNEL_SHIFT: i32 = 20;
pub const AFMT_CHANNEL_MAX: i32 = 127;
pub const AFMT_EXTCHANNEL_MASK: i32 = 134217728;
pub const AFMT_EXTCHANNEL_SHIFT: i32 = 27;
pub const AFMT_EXTCHANNEL_MAX: i32 = 1;
pub const AFMT_U8_NE: i32 = 8;
pub const AFMT_S8_NE: i32 = 64;
pub const AFMT_SIGNED_NE: i32 = 268505168;
pub const AFMT_NE: i32 = 268783832;
pub const VIRTIO_ID_NETWORK: i32 = 1;
pub const VIRTIO_ID_BLOCK: i32 = 2;
pub const VIRTIO_ID_CONSOLE: i32 = 3;
pub const VIRTIO_ID_ENTROPY: i32 = 4;
pub const VIRTIO_ID_BALLOON: i32 = 5;
pub const VIRTIO_ID_IOMEMORY: i32 = 6;
pub const VIRTIO_ID_RPMSG: i32 = 7;
pub const VIRTIO_ID_SCSI: i32 = 8;
pub const VIRTIO_ID_9P: i32 = 9;
pub const VIRTIO_ID_RPROC_SERIAL: i32 = 11;
pub const VIRTIO_ID_CAIF: i32 = 12;
pub const VIRTIO_ID_GPU: i32 = 16;
pub const VIRTIO_ID_INPUT: i32 = 18;
pub const VIRTIO_ID_VSOCK: i32 = 19;
pub const VIRTIO_ID_CRYPTO: i32 = 20;
pub const VIRTIO_ID_IOMMU: i32 = 23;
pub const VIRTIO_ID_SOUND: i32 = 25;
pub const VIRTIO_ID_FS: i32 = 26;
pub const VIRTIO_ID_PMEM: i32 = 27;
pub const VIRTIO_ID_RPMB: i32 = 28;
pub const VIRTIO_ID_SCMI: i32 = 32;
pub const VIRTIO_ID_GPIO: i32 = 41;
pub const VIRTIO_CONFIG_STATUS_RESET: i32 = 0;
pub const VIRTIO_CONFIG_STATUS_ACK: i32 = 1;
pub const VIRTIO_CONFIG_STATUS_DRIVER: i32 = 2;
pub const VIRTIO_CONFIG_STATUS_DRIVER_OK: i32 = 4;
pub const VIRTIO_CONFIG_S_FEATURES_OK: i32 = 8;
pub const VIRTIO_CONFIG_S_NEEDS_RESET: i32 = 64;
pub const VIRTIO_CONFIG_STATUS_FAILED: i32 = 128;
pub const VIRTIO_F_NOTIFY_ON_EMPTY: i32 = 16777216;
pub const VIRTIO_F_ANY_LAYOUT: i32 = 134217728;
pub const VIRTIO_RING_F_INDIRECT_DESC: i32 = 268435456;
pub const VIRTIO_RING_F_EVENT_IDX: i32 = 536870912;
pub const VIRTIO_F_BAD_FEATURE: i32 = 1073741824;
pub const VIRTIO_F_VERSION_1: i64 = 4294967296;
pub const VIRTIO_F_IOMMU_PLATFORM: i64 = 8589934592;
pub const VIRTIO_TRANSPORT_F_START: i32 = 28;
pub const VIRTIO_TRANSPORT_F_END: i32 = 34;
pub const VIRTIO_IVAR_DEVTYPE: i32 = 1;
pub const VIRTIO_IVAR_FEATURE_DESC: i32 = 2;
pub const VIRTIO_IVAR_VENDOR: i32 = 3;
pub const VIRTIO_IVAR_DEVICE: i32 = 4;
pub const VIRTIO_IVAR_SUBVENDOR: i32 = 5;
pub const VIRTIO_IVAR_SUBDEVICE: i32 = 6;
pub const VIRTIO_IVAR_MODERN: i32 = 7;
pub const VIRTQUEUE_MAX_NAME_SZ: i32 = 32;
pub const GPIOBUS_WAIT: i32 = 1;
pub const GPIOBUS_DONTWAIT: i32 = 2;
pub const DISK_ZONE_MODE_NONE: i32 = 0;
pub const DISK_ZONE_MODE_HOST_AWARE: i32 = 1;
pub const DISK_ZONE_MODE_DRIVE_MANAGED: i32 = 2;
pub const DISK_ZONE_MODE_HOST_MANAGED: i32 = 4;
pub const DISK_ZONE_DISK_URSWRZ: i32 = 1;
pub const DISK_ZONE_OPT_SEQ_SET: i32 = 2;
pub const DISK_ZONE_OPT_NONSEQ_SET: i32 = 4;
pub const DISK_ZONE_MAX_SEQ_SET: i32 = 8;
pub const DISK_ZONE_RZ_SUP: i32 = 16;
pub const DISK_ZONE_OPEN_SUP: i32 = 32;
pub const DISK_ZONE_CLOSE_SUP: i32 = 64;
pub const DISK_ZONE_FINISH_SUP: i32 = 128;
pub const DISK_ZONE_RWP_SUP: i32 = 256;
pub const DISK_ZONE_CMD_SUP_MASK: i32 = 496;
pub const DISK_ZONE_RWP_FLAG_NONE: i32 = 0;
pub const DISK_ZONE_RWP_FLAG_ALL: i32 = 1;
pub const DISK_ZONE_SAME_ALL_DIFFERENT: i32 = 0;
pub const DISK_ZONE_SAME_ALL_SAME: i32 = 1;
pub const DISK_ZONE_SAME_LAST_DIFFERENT: i32 = 2;
pub const DISK_ZONE_SAME_TYPES_DIFFERENT: i32 = 3;
pub const DISK_ZONE_TYPE_CONVENTIONAL: i32 = 1;
pub const DISK_ZONE_TYPE_SEQ_REQUIRED: i32 = 2;
pub const DISK_ZONE_TYPE_SEQ_PREFERRED: i32 = 3;
pub const DISK_ZONE_COND_NOT_WP: i32 = 0;
pub const DISK_ZONE_COND_EMPTY: i32 = 1;
pub const DISK_ZONE_COND_IMPLICIT_OPEN: i32 = 2;
pub const DISK_ZONE_COND_EXPLICIT_OPEN: i32 = 3;
pub const DISK_ZONE_COND_CLOSED: i32 = 4;
pub const DISK_ZONE_COND_READONLY: i32 = 13;
pub const DISK_ZONE_COND_FULL: i32 = 14;
pub const DISK_ZONE_COND_OFFLINE: i32 = 15;
pub const DISK_ZONE_FLAG_RESET: i32 = 1;
pub const DISK_ZONE_FLAG_NON_SEQ: i32 = 2;
pub const DISK_ZONE_REP_ALL: i32 = 0;
pub const DISK_ZONE_REP_EMPTY: i32 = 1;
pub const DISK_ZONE_REP_IMP_OPEN: i32 = 2;
pub const DISK_ZONE_REP_EXP_OPEN: i32 = 3;
pub const DISK_ZONE_REP_CLOSED: i32 = 4;
pub const DISK_ZONE_REP_FULL: i32 = 5;
pub const DISK_ZONE_REP_READONLY: i32 = 6;
pub const DISK_ZONE_REP_OFFLINE: i32 = 7;
pub const DISK_ZONE_REP_RWP: i32 = 16;
pub const DISK_ZONE_REP_NON_SEQ: i32 = 17;
pub const DISK_ZONE_REP_NON_WP: i32 = 63;
pub const DISK_ZONE_OPEN: i32 = 0;
pub const DISK_ZONE_CLOSE: i32 = 1;
pub const DISK_ZONE_FINISH: i32 = 2;
pub const DISK_ZONE_REPORT_ZONES: i32 = 3;
pub const DISK_ZONE_RWP: i32 = 4;
pub const DISK_ZONE_GET_PARAMS: i32 = 5;
pub const BIO_READ: i32 = 1;
pub const BIO_WRITE: i32 = 2;
pub const BIO_DELETE: i32 = 3;
pub const BIO_GETATTR: i32 = 4;
pub const BIO_FLUSH: i32 = 5;
pub const BIO_CMD0: i32 = 6;
pub const BIO_CMD1: i32 = 7;
pub const BIO_CMD2: i32 = 8;
pub const BIO_ZONE: i32 = 9;
pub const BIO_SPEEDUP: i32 = 10;
pub const BIO_ERROR: i32 = 1;
pub const BIO_DONE: i32 = 2;
pub const BIO_ONQUEUE: i32 = 4;
pub const BIO_ORDERED: i32 = 8;
pub const BIO_UNMAPPED: i32 = 16;
pub const BIO_TRANSIENT_MAPPING: i32 = 32;
pub const BIO_VLIST: i32 = 64;
pub const BIO_SWAP: i32 = 512;
pub const BIO_EXTERR: i32 = 8192;
pub const BIO_SPEEDUP_WRITE: i32 = 16384;
pub const BIO_SPEEDUP_TRIM: i32 = 32768;
pub const PRINT_BIO_FLAGS : & [u8 ; 101] = b"\x10\x10speedup_trim\x0Fspeedup_write\x0Eexterr\nswap\x07vlist\x06transient_mapping\x05unmapped\x04ordered\x03onqueue\x02done\x01error\0" ;
pub const MEMDESC_VADDR: i32 = 1;
pub const MEMDESC_PADDR: i32 = 2;
pub const MEMDESC_VLIST: i32 = 3;
pub const MEMDESC_PLIST: i32 = 4;
pub const MEMDESC_UIO: i32 = 6;
pub const MEMDESC_MBUF: i32 = 7;
pub const MEMDESC_VMPAGES: i32 = 8;
pub const UMA_SMALLEST_UNIT: i32 = 8;
pub const UMA_ZONE_UNMANAGED: i32 = 1;
pub const UMA_ZONE_ZINIT: i32 = 2;
pub const UMA_ZONE_CONTIG: i32 = 4;
pub const UMA_ZONE_NOTOUCH: i32 = 8;
pub const UMA_ZONE_MALLOC: i32 = 16;
pub const UMA_ZONE_NOFREE: i32 = 32;
pub const UMA_ZONE_MTXCLASS: i32 = 64;
pub const UMA_ZONE_VM: i32 = 128;
pub const UMA_ZONE_NOTPAGE: i32 = 256;
pub const UMA_ZONE_SECONDARY: i32 = 512;
pub const UMA_ZONE_NOBUCKET: i32 = 1024;
pub const UMA_ZONE_MAXBUCKET: i32 = 2048;
pub const UMA_ZONE_NOTRIM: i32 = 4096;
pub const UMA_ZONE_CACHESPREAD: i32 = 8192;
pub const UMA_ZONE_NODUMP: i32 = 16384;
pub const UMA_ZONE_PCPU: i32 = 32768;
pub const UMA_ZONE_FIRSTTOUCH: i32 = 65536;
pub const UMA_ZONE_ROUNDROBIN: i32 = 131072;
pub const UMA_ZONE_SMR: i32 = 262144;
pub const UMA_ZONE_NOKASAN: i32 = 524288;
pub const UMA_ZONE_INHERIT: i32 = 754104;
pub const UMA_ANYDOMAIN: i32 = -1;
pub const UMA_RECLAIM_DRAIN: i32 = 1;
pub const UMA_RECLAIM_DRAIN_CPU: i32 = 2;
pub const UMA_RECLAIM_TRIM: i32 = 3;
pub const UMA_SLAB_BOOT: i32 = 1;
pub const UMA_SLAB_KERNEL: i32 = 4;
pub const UMA_SLAB_PRIV: i32 = 8;
pub const UMA_STREAM_VERSION: i32 = 1;
pub const UTH_MAX_NAME: i32 = 32;
pub const UTH_ZONE_SECONDARY: i32 = 1;
pub const NVME_HMB_UNITS: i32 = 4096;
pub const NVME_MPS_SHIFT: i32 = 12;
pub const NVME_MIN_ADMIN_ENTRIES: i32 = 2;
pub const NVME_MAX_ADMIN_ENTRIES: i32 = 4096;
pub const NVME_MIN_IO_ENTRIES: i32 = 2;
pub const NVME_MAX_IO_ENTRIES: i32 = 65536;
pub const NVME_CAP_LO_REG_MQES_SHIFT: i32 = 0;
pub const NVME_CAP_LO_REG_MQES_MASK: i32 = 65535;
pub const NVME_CAP_LO_REG_CQR_SHIFT: i32 = 16;
pub const NVME_CAP_LO_REG_CQR_MASK: i32 = 1;
pub const NVME_CAP_LO_REG_AMS_SHIFT: i32 = 17;
pub const NVME_CAP_LO_REG_AMS_MASK: i32 = 3;
pub const NVME_CAP_LO_REG_TO_SHIFT: i32 = 24;
pub const NVME_CAP_LO_REG_TO_MASK: i32 = 255;
pub const NVME_CAP_HI_REG_DSTRD_SHIFT: i32 = 0;
pub const NVME_CAP_HI_REG_DSTRD_MASK: i32 = 15;
pub const NVME_CAP_HI_REG_NSSRS_SHIFT: i32 = 4;
pub const NVME_CAP_HI_REG_NSSRS_MASK: i32 = 1;
pub const NVME_CAP_HI_REG_CSS_SHIFT: i32 = 5;
pub const NVME_CAP_HI_REG_CSS_MASK: i32 = 255;
pub const NVME_CAP_HI_REG_CSS_NVM_SHIFT: i32 = 5;
pub const NVME_CAP_HI_REG_CSS_NVM_MASK: i32 = 1;
pub const NVME_CAP_HI_REG_BPS_SHIFT: i32 = 13;
pub const NVME_CAP_HI_REG_BPS_MASK: i32 = 1;
pub const NVME_CAP_HI_REG_CPS_SHIFT: i32 = 14;
pub const NVME_CAP_HI_REG_CPS_MASK: i32 = 3;
pub const NVME_CAP_HI_REG_MPSMIN_SHIFT: i32 = 16;
pub const NVME_CAP_HI_REG_MPSMIN_MASK: i32 = 15;
pub const NVME_CAP_HI_REG_MPSMAX_SHIFT: i32 = 20;
pub const NVME_CAP_HI_REG_MPSMAX_MASK: i32 = 15;
pub const NVME_CAP_HI_REG_PMRS_SHIFT: i32 = 24;
pub const NVME_CAP_HI_REG_PMRS_MASK: i32 = 1;
pub const NVME_CAP_HI_REG_CMBS_SHIFT: i32 = 25;
pub const NVME_CAP_HI_REG_CMBS_MASK: i32 = 1;
pub const NVME_CAP_HI_REG_NSSS_SHIFT: i32 = 26;
pub const NVME_CAP_HI_REG_NSSS_MASK: i32 = 1;
pub const NVME_CAP_HI_REG_CRWMS_SHIFT: i32 = 27;
pub const NVME_CAP_HI_REG_CRWMS_MASK: i32 = 1;
pub const NVME_CAP_HI_REG_CRIMS_SHIFT: i32 = 28;
pub const NVME_CAP_HI_REG_CRIMS_MASK: i32 = 1;
pub const NVME_CC_REG_EN_SHIFT: i32 = 0;
pub const NVME_CC_REG_EN_MASK: i32 = 1;
pub const NVME_CC_REG_CSS_SHIFT: i32 = 4;
pub const NVME_CC_REG_CSS_MASK: i32 = 7;
pub const NVME_CC_REG_MPS_SHIFT: i32 = 7;
pub const NVME_CC_REG_MPS_MASK: i32 = 15;
pub const NVME_CC_REG_AMS_SHIFT: i32 = 11;
pub const NVME_CC_REG_AMS_MASK: i32 = 7;
pub const NVME_CC_REG_SHN_SHIFT: i32 = 14;
pub const NVME_CC_REG_SHN_MASK: i32 = 3;
pub const NVME_CC_REG_IOSQES_SHIFT: i32 = 16;
pub const NVME_CC_REG_IOSQES_MASK: i32 = 15;
pub const NVME_CC_REG_IOCQES_SHIFT: i32 = 20;
pub const NVME_CC_REG_IOCQES_MASK: i32 = 15;
pub const NVME_CC_REG_CRIME_SHIFT: i32 = 24;
pub const NVME_CC_REG_CRIME_MASK: i32 = 1;
pub const NVME_CSTS_REG_RDY_SHIFT: i32 = 0;
pub const NVME_CSTS_REG_RDY_MASK: i32 = 1;
pub const NVME_CSTS_REG_CFS_SHIFT: i32 = 1;
pub const NVME_CSTS_REG_CFS_MASK: i32 = 1;
pub const NVME_CSTS_REG_SHST_SHIFT: i32 = 2;
pub const NVME_CSTS_REG_SHST_MASK: i32 = 3;
pub const NVME_CSTS_REG_NVSRO_SHIFT: i32 = 4;
pub const NVME_CSTS_REG_NVSRO_MASK: i32 = 1;
pub const NVME_CSTS_REG_PP_SHIFT: i32 = 5;
pub const NVME_CSTS_REG_PP_MASK: i32 = 1;
pub const NVME_CSTS_REG_ST_SHIFT: i32 = 6;
pub const NVME_CSTS_REG_ST_MASK: i32 = 1;
pub const NVME_AQA_REG_ASQS_SHIFT: i32 = 0;
pub const NVME_AQA_REG_ASQS_MASK: i32 = 4095;
pub const NVME_AQA_REG_ACQS_SHIFT: i32 = 16;
pub const NVME_AQA_REG_ACQS_MASK: i32 = 4095;
pub const NVME_PMRCAP_REG_RDS_SHIFT: i32 = 3;
pub const NVME_PMRCAP_REG_RDS_MASK: i32 = 1;
pub const NVME_PMRCAP_REG_WDS_SHIFT: i32 = 4;
pub const NVME_PMRCAP_REG_WDS_MASK: i32 = 1;
pub const NVME_PMRCAP_REG_BIR_SHIFT: i32 = 5;
pub const NVME_PMRCAP_REG_BIR_MASK: i32 = 7;
pub const NVME_PMRCAP_REG_PMRTU_SHIFT: i32 = 8;
pub const NVME_PMRCAP_REG_PMRTU_MASK: i32 = 3;
pub const NVME_PMRCAP_REG_PMRWBM_SHIFT: i32 = 10;
pub const NVME_PMRCAP_REG_PMRWBM_MASK: i32 = 15;
pub const NVME_PMRCAP_REG_PMRTO_SHIFT: i32 = 16;
pub const NVME_PMRCAP_REG_PMRTO_MASK: i32 = 255;
pub const NVME_PMRCAP_REG_CMSS_SHIFT: i32 = 24;
pub const NVME_PMRCAP_REG_CMSS_MASK: i32 = 1;
pub const NVME_CMD_FUSE_SHIFT: i32 = 0;
pub const NVME_CMD_FUSE_MASK: i32 = 3;
pub const NVME_CMD_PSDT_SHIFT: i32 = 6;
pub const NVME_CMD_PSDT_MASK: i32 = 3;
pub const NVME_STATUS_P_SHIFT: i32 = 0;
pub const NVME_STATUS_P_MASK: i32 = 1;
pub const NVME_STATUS_SC_SHIFT: i32 = 1;
pub const NVME_STATUS_SC_MASK: i32 = 255;
pub const NVME_STATUS_SCT_SHIFT: i32 = 9;
pub const NVME_STATUS_SCT_MASK: i32 = 7;
pub const NVME_STATUS_CRD_SHIFT: i32 = 12;
pub const NVME_STATUS_CRD_MASK: i32 = 3;
pub const NVME_STATUS_M_SHIFT: i32 = 14;
pub const NVME_STATUS_M_MASK: i32 = 1;
pub const NVME_STATUS_DNR_SHIFT: i32 = 15;
pub const NVME_STATUS_DNR_MASK: i32 = 1;
pub const NVME_PWR_ST_MPS_SHIFT: i32 = 0;
pub const NVME_PWR_ST_MPS_MASK: i32 = 1;
pub const NVME_PWR_ST_NOPS_SHIFT: i32 = 1;
pub const NVME_PWR_ST_NOPS_MASK: i32 = 1;
pub const NVME_PWR_ST_RRT_SHIFT: i32 = 0;
pub const NVME_PWR_ST_RRT_MASK: i32 = 31;
pub const NVME_PWR_ST_RRL_SHIFT: i32 = 0;
pub const NVME_PWR_ST_RRL_MASK: i32 = 31;
pub const NVME_PWR_ST_RWT_SHIFT: i32 = 0;
pub const NVME_PWR_ST_RWT_MASK: i32 = 31;
pub const NVME_PWR_ST_RWL_SHIFT: i32 = 0;
pub const NVME_PWR_ST_RWL_MASK: i32 = 31;
pub const NVME_PWR_ST_IPS_SHIFT: i32 = 6;
pub const NVME_PWR_ST_IPS_MASK: i32 = 3;
pub const NVME_PWR_ST_APW_SHIFT: i32 = 0;
pub const NVME_PWR_ST_APW_MASK: i32 = 7;
pub const NVME_PWR_ST_APS_SHIFT: i32 = 6;
pub const NVME_PWR_ST_APS_MASK: i32 = 3;
pub const NVME_CTRLR_DATA_MIC_MPORTS_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_MIC_MPORTS_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_MIC_MCTRLRS_SHIFT: i32 = 1;
pub const NVME_CTRLR_DATA_MIC_MCTRLRS_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_MIC_SRIOVVF_SHIFT: i32 = 2;
pub const NVME_CTRLR_DATA_MIC_SRIOVVF_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_MIC_ANAR_SHIFT: i32 = 3;
pub const NVME_CTRLR_DATA_MIC_ANAR_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OAES_NS_ATTR_SHIFT: i32 = 8;
pub const NVME_CTRLR_DATA_OAES_NS_ATTR_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OAES_FW_ACTIVATE_SHIFT: i32 = 9;
pub const NVME_CTRLR_DATA_OAES_FW_ACTIVATE_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OAES_ASYM_NS_CHANGE_SHIFT: i32 = 11;
pub const NVME_CTRLR_DATA_OAES_ASYM_NS_CHANGE_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OAES_PREDICT_LATENCY_SHIFT: i32 = 12;
pub const NVME_CTRLR_DATA_OAES_PREDICT_LATENCY_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OAES_LBA_STATUS_SHIFT: i32 = 13;
pub const NVME_CTRLR_DATA_OAES_LBA_STATUS_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OAES_ENDURANCE_GROUP_SHIFT: i32 = 14;
pub const NVME_CTRLR_DATA_OAES_ENDURANCE_GROUP_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OAES_NORMAL_SHUTDOWN_SHIFT: i32 = 15;
pub const NVME_CTRLR_DATA_OAES_NORMAL_SHUTDOWN_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OAES_ZONE_DESC_CHANGE_SHIFT: i32 = 27;
pub const NVME_CTRLR_DATA_OAES_ZONE_DESC_CHANGE_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OAES_LOG_PAGE_CHANGE_SHIFT: i32 = 31;
pub const NVME_CTRLR_DATA_OAES_LOG_PAGE_CHANGE_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_CTRATT_128BIT_HOSTID_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_CTRATT_128BIT_HOSTID_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_CTRATT_NONOP_POWER_STATE_SHIFT: i32 = 1;
pub const NVME_CTRLR_DATA_CTRATT_NONOP_POWER_STATE_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_CTRATT_NVM_SETS_SHIFT: i32 = 2;
pub const NVME_CTRLR_DATA_CTRATT_NVM_SETS_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_CTRATT_READ_RECOVERY_LVLS_SHIFT: i32 = 3;
pub const NVME_CTRLR_DATA_CTRATT_READ_RECOVERY_LVLS_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_CTRATT_ENDURANCE_GROUPS_SHIFT: i32 = 4;
pub const NVME_CTRLR_DATA_CTRATT_ENDURANCE_GROUPS_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_CTRATT_PREDICTABLE_LATENCY_SHIFT: i32 = 5;
pub const NVME_CTRLR_DATA_CTRATT_PREDICTABLE_LATENCY_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_CTRATT_TBKAS_SHIFT: i32 = 6;
pub const NVME_CTRLR_DATA_CTRATT_TBKAS_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_CTRATT_NAMESPACE_GRANULARITY_SHIFT: i32 = 7;
pub const NVME_CTRLR_DATA_CTRATT_NAMESPACE_GRANULARITY_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_CTRATT_SQ_ASSOCIATIONS_SHIFT: i32 = 8;
pub const NVME_CTRLR_DATA_CTRATT_SQ_ASSOCIATIONS_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_CTRATT_UUID_LIST_SHIFT: i32 = 9;
pub const NVME_CTRLR_DATA_CTRATT_UUID_LIST_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OACS_SECURITY_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_OACS_SECURITY_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OACS_FORMAT_SHIFT: i32 = 1;
pub const NVME_CTRLR_DATA_OACS_FORMAT_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OACS_FIRMWARE_SHIFT: i32 = 2;
pub const NVME_CTRLR_DATA_OACS_FIRMWARE_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OACS_NSMGMT_SHIFT: i32 = 3;
pub const NVME_CTRLR_DATA_OACS_NSMGMT_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OACS_SELFTEST_SHIFT: i32 = 4;
pub const NVME_CTRLR_DATA_OACS_SELFTEST_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OACS_DIRECTIVES_SHIFT: i32 = 5;
pub const NVME_CTRLR_DATA_OACS_DIRECTIVES_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OACS_NVMEMI_SHIFT: i32 = 6;
pub const NVME_CTRLR_DATA_OACS_NVMEMI_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OACS_VM_SHIFT: i32 = 7;
pub const NVME_CTRLR_DATA_OACS_VM_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OACS_DBBUFFER_SHIFT: i32 = 8;
pub const NVME_CTRLR_DATA_OACS_DBBUFFER_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_OACS_GETLBA_SHIFT: i32 = 9;
pub const NVME_CTRLR_DATA_OACS_GETLBA_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_FRMW_SLOT1_RO_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_FRMW_SLOT1_RO_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_FRMW_NUM_SLOTS_SHIFT: i32 = 1;
pub const NVME_CTRLR_DATA_FRMW_NUM_SLOTS_MASK: i32 = 7;
pub const NVME_CTRLR_DATA_FRMW_ACT_WO_RESET_SHIFT: i32 = 4;
pub const NVME_CTRLR_DATA_FRMW_ACT_WO_RESET_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_LPA_NS_SMART_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_LPA_NS_SMART_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_LPA_CMD_EFFECTS_SHIFT: i32 = 1;
pub const NVME_CTRLR_DATA_LPA_CMD_EFFECTS_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_LPA_EXT_DATA_SHIFT: i32 = 2;
pub const NVME_CTRLR_DATA_LPA_EXT_DATA_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_LPA_TELEMETRY_SHIFT: i32 = 3;
pub const NVME_CTRLR_DATA_LPA_TELEMETRY_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_LPA_PERSISTENT_EVENT_SHIFT: i32 = 4;
pub const NVME_CTRLR_DATA_LPA_PERSISTENT_EVENT_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_LPA_LOG_PAGES_PAGE_SHIFT: i32 = 5;
pub const NVME_CTRLR_DATA_LPA_LOG_PAGES_PAGE_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_LPA_DA4_TELEMETRY_SHIFT: i32 = 6;
pub const NVME_CTRLR_DATA_LPA_DA4_TELEMETRY_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_AVSCC_SPEC_FORMAT_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_AVSCC_SPEC_FORMAT_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_APSTA_APST_SUPP_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_APSTA_APST_SUPP_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_SANICAP_CES_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_SANICAP_CES_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_SANICAP_BES_SHIFT: i32 = 1;
pub const NVME_CTRLR_DATA_SANICAP_BES_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_SANICAP_OWS_SHIFT: i32 = 2;
pub const NVME_CTRLR_DATA_SANICAP_OWS_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_SANICAP_NDI_SHIFT: i32 = 29;
pub const NVME_CTRLR_DATA_SANICAP_NDI_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_SANICAP_NODMMAS_SHIFT: i32 = 30;
pub const NVME_CTRLR_DATA_SANICAP_NODMMAS_MASK: i32 = 3;
pub const NVME_CTRLR_DATA_SANICAP_NODMMAS_UNDEF: i32 = 0;
pub const NVME_CTRLR_DATA_SANICAP_NODMMAS_NO: i32 = 1;
pub const NVME_CTRLR_DATA_SANICAP_NODMMAS_YES: i32 = 2;
pub const NVME_CTRLR_DATA_SQES_MIN_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_SQES_MIN_MASK: i32 = 15;
pub const NVME_CTRLR_DATA_SQES_MAX_SHIFT: i32 = 4;
pub const NVME_CTRLR_DATA_SQES_MAX_MASK: i32 = 15;
pub const NVME_CTRLR_DATA_CQES_MIN_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_CQES_MIN_MASK: i32 = 15;
pub const NVME_CTRLR_DATA_CQES_MAX_SHIFT: i32 = 4;
pub const NVME_CTRLR_DATA_CQES_MAX_MASK: i32 = 15;
pub const NVME_CTRLR_DATA_ONCS_COMPARE_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_ONCS_COMPARE_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_ONCS_WRITE_UNC_SHIFT: i32 = 1;
pub const NVME_CTRLR_DATA_ONCS_WRITE_UNC_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_ONCS_DSM_SHIFT: i32 = 2;
pub const NVME_CTRLR_DATA_ONCS_DSM_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_ONCS_WRZERO_SHIFT: i32 = 3;
pub const NVME_CTRLR_DATA_ONCS_WRZERO_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_ONCS_SAVEFEAT_SHIFT: i32 = 4;
pub const NVME_CTRLR_DATA_ONCS_SAVEFEAT_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_ONCS_RESERV_SHIFT: i32 = 5;
pub const NVME_CTRLR_DATA_ONCS_RESERV_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_ONCS_TIMESTAMP_SHIFT: i32 = 6;
pub const NVME_CTRLR_DATA_ONCS_TIMESTAMP_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_ONCS_VERIFY_SHIFT: i32 = 7;
pub const NVME_CTRLR_DATA_ONCS_VERIFY_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_FUSES_CNW_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_FUSES_CNW_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_FNA_FORMAT_ALL_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_FNA_FORMAT_ALL_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_FNA_ERASE_ALL_SHIFT: i32 = 1;
pub const NVME_CTRLR_DATA_FNA_ERASE_ALL_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_FNA_CRYPTO_ERASE_SHIFT: i32 = 2;
pub const NVME_CTRLR_DATA_FNA_CRYPTO_ERASE_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_VWC_PRESENT_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_VWC_PRESENT_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_VWC_ALL_SHIFT: i32 = 1;
pub const NVME_CTRLR_DATA_VWC_ALL_MASK: i32 = 3;
pub const NVME_CTRLR_DATA_VWC_ALL_UNKNOWN: i32 = 0;
pub const NVME_CTRLR_DATA_VWC_ALL_NO: i32 = 2;
pub const NVME_CTRLR_DATA_VWC_ALL_YES: i32 = 3;
pub const NVME_CTRLR_DATA_SGLS_NVM_COMMAND_SET_SHIFT: i32 = 0;
pub const NVME_CTRLR_DATA_SGLS_NVM_COMMAND_SET_MASK: i32 = 3;
pub const NVME_CTRLR_DATA_SGLS_KEYED_DATA_BLOCK_SHIFT: i32 = 2;
pub const NVME_CTRLR_DATA_SGLS_KEYED_DATA_BLOCK_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_SGLS_BIT_BUCKET_SHIFT: i32 = 16;
pub const NVME_CTRLR_DATA_SGLS_BIT_BUCKET_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_SGLS_CONTIG_MPTR_SHIFT: i32 = 17;
pub const NVME_CTRLR_DATA_SGLS_CONTIG_MPTR_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_SGLS_OVERSIZED_SHIFT: i32 = 18;
pub const NVME_CTRLR_DATA_SGLS_OVERSIZED_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_SGLS_MPTR_SGL_SHIFT: i32 = 19;
pub const NVME_CTRLR_DATA_SGLS_MPTR_SGL_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_SGLS_ADDRESS_AS_OFFSET_SHIFT: i32 = 20;
pub const NVME_CTRLR_DATA_SGLS_ADDRESS_AS_OFFSET_MASK: i32 = 1;
pub const NVME_CTRLR_DATA_SGLS_TRANSPORT_DATA_BLOCK_SHIFT: i32 = 21;
pub const NVME_CTRLR_DATA_SGLS_TRANSPORT_DATA_BLOCK_MASK: i32 = 1;
pub const NVME_NS_DATA_NSFEAT_THIN_PROV_SHIFT: i32 = 0;
pub const NVME_NS_DATA_NSFEAT_THIN_PROV_MASK: i32 = 1;
pub const NVME_NS_DATA_NSFEAT_NA_FIELDS_SHIFT: i32 = 1;
pub const NVME_NS_DATA_NSFEAT_NA_FIELDS_MASK: i32 = 1;
pub const NVME_NS_DATA_NSFEAT_DEALLOC_SHIFT: i32 = 2;
pub const NVME_NS_DATA_NSFEAT_DEALLOC_MASK: i32 = 1;
pub const NVME_NS_DATA_NSFEAT_NO_ID_REUSE_SHIFT: i32 = 3;
pub const NVME_NS_DATA_NSFEAT_NO_ID_REUSE_MASK: i32 = 1;
pub const NVME_NS_DATA_NSFEAT_NPVALID_SHIFT: i32 = 4;
pub const NVME_NS_DATA_NSFEAT_NPVALID_MASK: i32 = 1;
pub const NVME_NS_DATA_FLBAS_FORMAT_SHIFT: i32 = 0;
pub const NVME_NS_DATA_FLBAS_FORMAT_MASK: i32 = 15;
pub const NVME_NS_DATA_FLBAS_EXTENDED_SHIFT: i32 = 4;
pub const NVME_NS_DATA_FLBAS_EXTENDED_MASK: i32 = 1;
pub const NVME_NS_DATA_MC_EXTENDED_SHIFT: i32 = 0;
pub const NVME_NS_DATA_MC_EXTENDED_MASK: i32 = 1;
pub const NVME_NS_DATA_MC_POINTER_SHIFT: i32 = 1;
pub const NVME_NS_DATA_MC_POINTER_MASK: i32 = 1;
pub const NVME_NS_DATA_DPC_PIT1_SHIFT: i32 = 0;
pub const NVME_NS_DATA_DPC_PIT1_MASK: i32 = 1;
pub const NVME_NS_DATA_DPC_PIT2_SHIFT: i32 = 1;
pub const NVME_NS_DATA_DPC_PIT2_MASK: i32 = 1;
pub const NVME_NS_DATA_DPC_PIT3_SHIFT: i32 = 2;
pub const NVME_NS_DATA_DPC_PIT3_MASK: i32 = 1;
pub const NVME_NS_DATA_DPC_MD_START_SHIFT: i32 = 3;
pub const NVME_NS_DATA_DPC_MD_START_MASK: i32 = 1;
pub const NVME_NS_DATA_DPC_MD_END_SHIFT: i32 = 4;
pub const NVME_NS_DATA_DPC_MD_END_MASK: i32 = 1;
pub const NVME_NS_DATA_DPS_PIT_SHIFT: i32 = 0;
pub const NVME_NS_DATA_DPS_PIT_MASK: i32 = 7;
pub const NVME_NS_DATA_DPS_MD_START_SHIFT: i32 = 3;
pub const NVME_NS_DATA_DPS_MD_START_MASK: i32 = 1;
pub const NVME_NS_DATA_NMIC_MAY_BE_SHARED_SHIFT: i32 = 0;
pub const NVME_NS_DATA_NMIC_MAY_BE_SHARED_MASK: i32 = 1;
pub const NVME_NS_DATA_RESCAP_PTPL_SHIFT: i32 = 0;
pub const NVME_NS_DATA_RESCAP_PTPL_MASK: i32 = 1;
pub const NVME_NS_DATA_RESCAP_WR_EX_SHIFT: i32 = 1;
pub const NVME_NS_DATA_RESCAP_WR_EX_MASK: i32 = 1;
pub const NVME_NS_DATA_RESCAP_EX_AC_SHIFT: i32 = 2;
pub const NVME_NS_DATA_RESCAP_EX_AC_MASK: i32 = 1;
pub const NVME_NS_DATA_RESCAP_WR_EX_RO_SHIFT: i32 = 3;
pub const NVME_NS_DATA_RESCAP_WR_EX_RO_MASK: i32 = 1;
pub const NVME_NS_DATA_RESCAP_EX_AC_RO_SHIFT: i32 = 4;
pub const NVME_NS_DATA_RESCAP_EX_AC_RO_MASK: i32 = 1;
pub const NVME_NS_DATA_RESCAP_WR_EX_AR_SHIFT: i32 = 5;
pub const NVME_NS_DATA_RESCAP_WR_EX_AR_MASK: i32 = 1;
pub const NVME_NS_DATA_RESCAP_EX_AC_AR_SHIFT: i32 = 6;
pub const NVME_NS_DATA_RESCAP_EX_AC_AR_MASK: i32 = 1;
pub const NVME_NS_DATA_RESCAP_IEKEY13_SHIFT: i32 = 7;
pub const NVME_NS_DATA_RESCAP_IEKEY13_MASK: i32 = 1;
pub const NVME_NS_DATA_FPI_PERC_SHIFT: i32 = 0;
pub const NVME_NS_DATA_FPI_PERC_MASK: i32 = 127;
pub const NVME_NS_DATA_FPI_SUPP_SHIFT: i32 = 7;
pub const NVME_NS_DATA_FPI_SUPP_MASK: i32 = 1;
pub const NVME_NS_DATA_DLFEAT_READ_SHIFT: i32 = 0;
pub const NVME_NS_DATA_DLFEAT_READ_MASK: i32 = 7;
pub const NVME_NS_DATA_DLFEAT_READ_NR: i32 = 0;
pub const NVME_NS_DATA_DLFEAT_READ_00: i32 = 1;
pub const NVME_NS_DATA_DLFEAT_READ_FF: i32 = 2;
pub const NVME_NS_DATA_DLFEAT_DWZ_SHIFT: i32 = 3;
pub const NVME_NS_DATA_DLFEAT_DWZ_MASK: i32 = 1;
pub const NVME_NS_DATA_DLFEAT_GCRC_SHIFT: i32 = 4;
pub const NVME_NS_DATA_DLFEAT_GCRC_MASK: i32 = 1;
pub const NVME_NS_DATA_LBAF_MS_SHIFT: i32 = 0;
pub const NVME_NS_DATA_LBAF_MS_MASK: i32 = 65535;
pub const NVME_NS_DATA_LBAF_LBADS_SHIFT: i32 = 16;
pub const NVME_NS_DATA_LBAF_LBADS_MASK: i32 = 255;
pub const NVME_NS_DATA_LBAF_RP_SHIFT: i32 = 24;
pub const NVME_NS_DATA_LBAF_RP_MASK: i32 = 3;
pub const NVME_CRIT_WARN_ST_RESERVED_MASK: i32 = 192;
pub const NVME_ASYNC_EVENT_NS_ATTRIBUTE: i32 = 256;
pub const NVME_ASYNC_EVENT_FW_ACTIVATE: i32 = 512;
pub const NVME_ASYNC_EVENT_TELEMETRY_LOG: i32 = 1024;
pub const NVME_ASYNC_EVENT_ASYM_NS_ACC: i32 = 2048;
pub const NVME_ASYNC_EVENT_PRED_LAT_DELTA: i32 = 4096;
pub const NVME_ASYNC_EVENT_LBA_STATUS: i32 = 8192;
pub const NVME_ASYNC_EVENT_ENDURANCE_DELTA: i32 = 16384;
pub const NVME_ASYNC_EVENT_NVM_SHUTDOWN: i32 = 32768;
pub const NVME_ASYNC_EVENT_ZONE_DELTA: i32 = 134217728;
pub const NVME_ASYNC_EVENT_DISCOVERY_DELTA: i64 = 2147483648;
pub const NVME_FIRMWARE_PAGE_AFI_SLOT_SHIFT: i32 = 0;
pub const NVME_FIRMWARE_PAGE_AFI_SLOT_MASK: i32 = 7;
pub const NVME_CE_PAGE_CSUP_SHIFT: i32 = 0;
pub const NVME_CE_PAGE_CSUP_MASK: i32 = 1;
pub const NVME_CE_PAGE_LBCC_SHIFT: i32 = 1;
pub const NVME_CE_PAGE_LBCC_MASK: i32 = 1;
pub const NVME_CE_PAGE_NCC_SHIFT: i32 = 2;
pub const NVME_CE_PAGE_NCC_MASK: i32 = 1;
pub const NVME_CE_PAGE_NIC_SHIFT: i32 = 3;
pub const NVME_CE_PAGE_NIC_MASK: i32 = 1;
pub const NVME_CE_PAGE_CCC_SHIFT: i32 = 4;
pub const NVME_CE_PAGE_CCC_MASK: i32 = 1;
pub const NVME_CE_PAGE_CSE_SHIFT: i32 = 16;
pub const NVME_CE_PAGE_CSE_MASK: i32 = 7;
pub const NVME_CE_PAGE_UUID_SHIFT: i32 = 19;
pub const NVME_CE_PAGE_UUID_MASK: i32 = 1;
pub const NVME_SS_PAGE_SSTAT_STATUS_SHIFT: i32 = 0;
pub const NVME_SS_PAGE_SSTAT_STATUS_MASK: i32 = 7;
pub const NVME_SS_PAGE_SSTAT_STATUS_NEVER: i32 = 0;
pub const NVME_SS_PAGE_SSTAT_STATUS_COMPLETED: i32 = 1;
pub const NVME_SS_PAGE_SSTAT_STATUS_INPROG: i32 = 2;
pub const NVME_SS_PAGE_SSTAT_STATUS_FAILED: i32 = 3;
pub const NVME_SS_PAGE_SSTAT_STATUS_COMPLETEDWD: i32 = 4;
pub const NVME_SS_PAGE_SSTAT_PASSES_SHIFT: i32 = 3;
pub const NVME_SS_PAGE_SSTAT_PASSES_MASK: i32 = 31;
pub const NVME_SS_PAGE_SSTAT_GDE_SHIFT: i32 = 8;
pub const NVME_SS_PAGE_SSTAT_GDE_MASK: i32 = 1;
pub const NVME_FEAT_GET_SEL_SHIFT: i32 = 8;
pub const NVME_FEAT_GET_SEL_MASK: i32 = 7;
pub const NVME_FEAT_GET_FID_SHIFT: i32 = 0;
pub const NVME_FEAT_GET_FID_MASK: i32 = 255;
pub const NVME_FEAT_SET_SV_SHIFT: i32 = 31;
pub const NVME_FEAT_SET_SV_MASK: i32 = 1;
pub const NVME_FEAT_SET_FID_SHIFT: i32 = 0;
pub const NVME_FEAT_SET_FID_MASK: i32 = 255;
pub const NVME_ASYNC_EVENT_TYPE_SHIFT: i32 = 0;
pub const NVME_ASYNC_EVENT_TYPE_MASK: i32 = 7;
pub const NVME_ASYNC_EVENT_INFO_SHIFT: i32 = 8;
pub const NVME_ASYNC_EVENT_INFO_MASK: i32 = 255;
pub const NVME_ASYNC_EVENT_LOG_PAGE_ID_SHIFT: i32 = 16;
pub const NVME_ASYNC_EVENT_LOG_PAGE_ID_MASK: i32 = 255;
pub const NVME_SGL_SUBTYPE_SHIFT: i32 = 0;
pub const NVME_SGL_SUBTYPE_MASK: i32 = 15;
pub const NVME_SGL_TYPE_SHIFT: i32 = 4;
pub const NVME_SGL_TYPE_MASK: i32 = 15;
pub const NVME_MAX_DSM_TRIM: i32 = 4096;
pub const NVME_SERIAL_NUMBER_LENGTH: i32 = 20;
pub const NVME_MODEL_NUMBER_LENGTH: i32 = 40;
pub const NVME_FIRMWARE_REVISION_LENGTH: i32 = 8;
pub const NVME_TEST_MAX_THREADS: i32 = 128;
pub const KERNELDUMP_COMP_NONE: i32 = 0;
pub const KERNELDUMP_COMP_GZIP: i32 = 1;
pub const KERNELDUMP_COMP_ZSTD: i32 = 2;
pub const KERNELDUMP_ENC_NONE: i32 = 0;
pub const KERNELDUMP_ENC_AES_256_CBC: i32 = 1;
pub const KERNELDUMP_ENC_CHACHA20: i32 = 2;
pub const KERNELDUMP_BUFFER_SIZE: i32 = 4096;
pub const KERNELDUMP_IV_MAX_SIZE: i32 = 32;
pub const KERNELDUMP_KEY_MAX_SIZE: i32 = 64;
pub const KERNELDUMP_ENCKEY_MAX_SIZE: i32 = 2048;
pub const KERNELDUMPMAGIC: &[u8; 20] = b"FreeBSD Kernel Dump\0";
pub const TEXTDUMPMAGIC: &[u8; 18] = b"FreeBSD Text Dump\0";
pub const KERNELDUMPMAGIC_CLEARED: &[u8; 20] = b"Cleared Kernel Dump\0";
pub const KERNELDUMPVERSION: i32 = 4;
pub const KERNELDUMP_TEXT_VERSION: i32 = 4;
pub const KERNELDUMP_AARCH64_VERSION: i32 = 1;
pub const KERNELDUMP_AMD64_VERSION: i32 = 2;
pub const KERNELDUMP_ARM_VERSION: i32 = 1;
pub const KERNELDUMP_I386_VERSION: i32 = 2;
pub const KERNELDUMP_MIPS_VERSION: i32 = 1;
pub const KERNELDUMP_POWERPC_VERSION: i32 = 1;
pub const KERNELDUMP_RISCV_VERSION: i32 = 1;
pub const KERNELDUMP_SPARC64_VERSION: i32 = 1;
pub const SOCK_STREAM: i32 = 1;
pub const SOCK_DGRAM: i32 = 2;
pub const SOCK_RAW: i32 = 3;
pub const SOCK_RDM: i32 = 4;
pub const SOCK_SEQPACKET: i32 = 5;
pub const SOCK_CLOEXEC: i32 = 268435456;
pub const SOCK_NONBLOCK: i32 = 536870912;
pub const SOCK_CLOFORK: i32 = 1073741824;
pub const ACCEPT4_INHERIT: i32 = 1;
pub const ACCEPT4_COMPAT: i32 = 2;
pub const SO_DEBUG: i32 = 1;
pub const SO_ACCEPTCONN: i32 = 2;
pub const SO_REUSEADDR: i32 = 4;
pub const SO_KEEPALIVE: i32 = 8;
pub const SO_DONTROUTE: i32 = 16;
pub const SO_BROADCAST: i32 = 32;
pub const SO_USELOOPBACK: i32 = 64;
pub const SO_LINGER: i32 = 128;
pub const SO_OOBINLINE: i32 = 256;
pub const SO_REUSEPORT: i32 = 512;
pub const SO_TIMESTAMP: i32 = 1024;
pub const SO_NOSIGPIPE: i32 = 2048;
pub const SO_ACCEPTFILTER: i32 = 4096;
pub const SO_BINTIME: i32 = 8192;
pub const SO_NO_OFFLOAD: i32 = 16384;
pub const SO_NO_DDP: i32 = 32768;
pub const SO_REUSEPORT_LB: i32 = 65536;
pub const SO_RERROR: i32 = 131072;
pub const SO_SNDBUF: i32 = 4097;
pub const SO_RCVBUF: i32 = 4098;
pub const SO_SNDLOWAT: i32 = 4099;
pub const SO_RCVLOWAT: i32 = 4100;
pub const SO_SNDTIMEO: i32 = 4101;
pub const SO_RCVTIMEO: i32 = 4102;
pub const SO_ERROR: i32 = 4103;
pub const SO_TYPE: i32 = 4104;
pub const SO_LABEL: i32 = 4105;
pub const SO_PEERLABEL: i32 = 4112;
pub const SO_LISTENQLIMIT: i32 = 4113;
pub const SO_LISTENQLEN: i32 = 4114;
pub const SO_LISTENINCQLEN: i32 = 4115;
pub const SO_FIB: i32 = 4116;
pub const SO_SETFIB: i32 = 4116;
pub const SO_USER_COOKIE: i32 = 4117;
pub const SO_PROTOCOL: i32 = 4118;
pub const SO_PROTOTYPE: i32 = 4118;
pub const SO_TS_CLOCK: i32 = 4119;
pub const SO_MAX_PACING_RATE: i32 = 4120;
pub const SO_DOMAIN: i32 = 4121;
pub const SO_SPLICE: i32 = 4131;
pub const SO_TS_REALTIME_MICRO: i32 = 0;
pub const SO_TS_BINTIME: i32 = 1;
pub const SO_TS_REALTIME: i32 = 2;
pub const SO_TS_MONOTONIC: i32 = 3;
pub const SO_TS_DEFAULT: i32 = 0;
pub const SO_TS_CLOCK_MAX: i32 = 3;
pub const SO_VENDOR: i64 = 2147483648;
pub const SOL_SOCKET: i32 = 65535;
pub const AF_UNSPEC: i32 = 0;
pub const AF_UNIX: i32 = 1;
pub const AF_INET: i32 = 2;
pub const AF_IMPLINK: i32 = 3;
pub const AF_PUP: i32 = 4;
pub const AF_CHAOS: i32 = 5;
pub const AF_NETBIOS: i32 = 6;
pub const AF_ISO: i32 = 7;
pub const AF_OSI: i32 = 7;
pub const AF_ECMA: i32 = 8;
pub const AF_DATAKIT: i32 = 9;
pub const AF_CCITT: i32 = 10;
pub const AF_SNA: i32 = 11;
pub const AF_DECnet: i32 = 12;
pub const AF_DLI: i32 = 13;
pub const AF_LAT: i32 = 14;
pub const AF_HYLINK: i32 = 15;
pub const AF_APPLETALK: i32 = 16;
pub const AF_ROUTE: i32 = 17;
pub const AF_LINK: i32 = 18;
pub const pseudo_AF_XTP: i32 = 19;
pub const AF_COIP: i32 = 20;
pub const AF_CNT: i32 = 21;
pub const pseudo_AF_RTIP: i32 = 22;
pub const AF_IPX: i32 = 23;
pub const AF_SIP: i32 = 24;
pub const pseudo_AF_PIP: i32 = 25;
pub const AF_ISDN: i32 = 26;
pub const AF_E164: i32 = 26;
pub const pseudo_AF_KEY: i32 = 27;
pub const AF_INET6: i32 = 28;
pub const AF_NATM: i32 = 29;
pub const AF_ATM: i32 = 30;
pub const pseudo_AF_HDRCMPLT: i32 = 31;
pub const AF_NETGRAPH: i32 = 32;
pub const AF_SLOW: i32 = 33;
pub const AF_SCLUSTER: i32 = 34;
pub const AF_ARP: i32 = 35;
pub const AF_BLUETOOTH: i32 = 36;
pub const AF_IEEE80211: i32 = 37;
pub const AF_NETLINK: i32 = 38;
pub const AF_INET_SDP: i32 = 40;
pub const AF_INET6_SDP: i32 = 42;
pub const AF_HYPERV: i32 = 43;
pub const AF_DIVERT: i32 = 44;
pub const AF_IPFWLOG: i32 = 46;
pub const AF_MAX: i32 = 46;
pub const AF_VENDOR00: i32 = 39;
pub const AF_VENDOR01: i32 = 41;
pub const AF_VENDOR03: i32 = 45;
pub const AF_VENDOR04: i32 = 47;
pub const AF_VENDOR05: i32 = 49;
pub const AF_VENDOR06: i32 = 51;
pub const AF_VENDOR07: i32 = 53;
pub const AF_VENDOR08: i32 = 55;
pub const AF_VENDOR09: i32 = 57;
pub const AF_VENDOR10: i32 = 59;
pub const AF_VENDOR11: i32 = 61;
pub const AF_VENDOR12: i32 = 63;
pub const AF_VENDOR13: i32 = 65;
pub const AF_VENDOR14: i32 = 67;
pub const AF_VENDOR15: i32 = 69;
pub const AF_VENDOR16: i32 = 71;
pub const AF_VENDOR17: i32 = 73;
pub const AF_VENDOR18: i32 = 75;
pub const AF_VENDOR19: i32 = 77;
pub const AF_VENDOR20: i32 = 79;
pub const AF_VENDOR21: i32 = 81;
pub const AF_VENDOR22: i32 = 83;
pub const AF_VENDOR23: i32 = 85;
pub const AF_VENDOR24: i32 = 87;
pub const AF_VENDOR25: i32 = 89;
pub const AF_VENDOR26: i32 = 91;
pub const AF_VENDOR27: i32 = 93;
pub const AF_VENDOR28: i32 = 95;
pub const AF_VENDOR29: i32 = 97;
pub const AF_VENDOR30: i32 = 99;
pub const AF_VENDOR31: i32 = 101;
pub const AF_VENDOR32: i32 = 103;
pub const AF_VENDOR33: i32 = 105;
pub const AF_VENDOR34: i32 = 107;
pub const AF_VENDOR35: i32 = 109;
pub const AF_VENDOR36: i32 = 111;
pub const AF_VENDOR37: i32 = 113;
pub const AF_VENDOR38: i32 = 115;
pub const AF_VENDOR39: i32 = 117;
pub const AF_VENDOR40: i32 = 119;
pub const AF_VENDOR41: i32 = 121;
pub const AF_VENDOR42: i32 = 123;
pub const AF_VENDOR43: i32 = 125;
pub const AF_VENDOR44: i32 = 127;
pub const AF_VENDOR45: i32 = 129;
pub const AF_VENDOR46: i32 = 131;
pub const AF_VENDOR47: i32 = 133;
pub const SOCK_MAXADDRLEN: i32 = 255;
pub const _SS_MAXSIZE: i32 = 128;
pub const PF_UNSPEC: i32 = 0;
pub const PF_INET: i32 = 2;
pub const PF_IMPLINK: i32 = 3;
pub const PF_PUP: i32 = 4;
pub const PF_CHAOS: i32 = 5;
pub const PF_NETBIOS: i32 = 6;
pub const PF_ISO: i32 = 7;
pub const PF_OSI: i32 = 7;
pub const PF_ECMA: i32 = 8;
pub const PF_DATAKIT: i32 = 9;
pub const PF_CCITT: i32 = 10;
pub const PF_SNA: i32 = 11;
pub const PF_DECnet: i32 = 12;
pub const PF_DLI: i32 = 13;
pub const PF_LAT: i32 = 14;
pub const PF_HYLINK: i32 = 15;
pub const PF_APPLETALK: i32 = 16;
pub const PF_ROUTE: i32 = 17;
pub const PF_LINK: i32 = 18;
pub const PF_XTP: i32 = 19;
pub const PF_COIP: i32 = 20;
pub const PF_CNT: i32 = 21;
pub const PF_SIP: i32 = 24;
pub const PF_IPX: i32 = 23;
pub const PF_RTIP: i32 = 22;
pub const PF_PIP: i32 = 25;
pub const PF_ISDN: i32 = 26;
pub const PF_KEY: i32 = 27;
pub const PF_INET6: i32 = 28;
pub const PF_NATM: i32 = 29;
pub const PF_ATM: i32 = 30;
pub const PF_NETGRAPH: i32 = 32;
pub const PF_SLOW: i32 = 33;
pub const PF_SCLUSTER: i32 = 34;
pub const PF_ARP: i32 = 35;
pub const PF_BLUETOOTH: i32 = 36;
pub const PF_IEEE80211: i32 = 37;
pub const PF_NETLINK: i32 = 38;
pub const PF_INET_SDP: i32 = 40;
pub const PF_INET6_SDP: i32 = 42;
pub const PF_HYPERV: i32 = 43;
pub const PF_DIVERT: i32 = 44;
pub const PF_IPFWLOG: i32 = 46;
pub const PF_MAX: i32 = 46;
pub const NET_RT_DUMP: i32 = 1;
pub const NET_RT_FLAGS: i32 = 2;
pub const NET_RT_IFLIST: i32 = 3;
pub const NET_RT_IFMALIST: i32 = 4;
pub const NET_RT_IFLISTL: i32 = 5;
pub const NET_RT_NHOP: i32 = 6;
pub const NET_RT_NHGRP: i32 = 7;
pub const SOMAXCONN: i32 = 128;
pub const MSG_OOB: i32 = 1;
pub const MSG_PEEK: i32 = 2;
pub const MSG_DONTROUTE: i32 = 4;
pub const MSG_EOR: i32 = 8;
pub const MSG_TRUNC: i32 = 16;
pub const MSG_CTRUNC: i32 = 32;
pub const MSG_WAITALL: i32 = 64;
pub const MSG_DONTWAIT: i32 = 128;
pub const MSG_EOF: i32 = 256;
pub const MSG_NOTIFICATION: i32 = 8192;
pub const MSG_NBIO: i32 = 16384;
pub const MSG_COMPAT: i32 = 32768;
pub const MSG_SOCALLBCK: i32 = 65536;
pub const MSG_NOSIGNAL: i32 = 131072;
pub const MSG_CMSG_CLOEXEC: i32 = 262144;
pub const MSG_WAITFORONE: i32 = 524288;
pub const MSG_MORETOCOME: i32 = 1048576;
pub const MSG_TLSAPPDATA: i32 = 2097152;
pub const MSG_CMSG_CLOFORK: i32 = 4194304;
pub const CMGROUP_MAX: i32 = 16;
pub const SCM_RIGHTS: i32 = 1;
pub const SCM_TIMESTAMP: i32 = 2;
pub const SCM_CREDS: i32 = 3;
pub const SCM_BINTIME: i32 = 4;
pub const SCM_REALTIME: i32 = 5;
pub const SCM_MONOTONIC: i32 = 6;
pub const SCM_TIME_INFO: i32 = 7;
pub const SCM_CREDS2: i32 = 8;
pub const ST_INFO_HW: i32 = 1;
pub const ST_INFO_HW_HPREC: i32 = 2;
pub const SF_NODISKIO: i32 = 1;
pub const SF_MNOWAIT: i32 = 2;
pub const SF_SYNC: i32 = 4;
pub const SF_USER_READAHEAD: i32 = 8;
pub const SF_NOCACHE: i32 = 16;
pub const DISK_IDENT_SIZE: i32 = 256;
pub const IF_NAMESIZE: i32 = 16;
pub const IFNAMSIZ: i32 = 16;
pub const IF_MAXUNIT: i32 = 32767;
pub const IFF_UP: i32 = 1;
pub const IFF_BROADCAST: i32 = 2;
pub const IFF_DEBUG: i32 = 4;
pub const IFF_LOOPBACK: i32 = 8;
pub const IFF_POINTOPOINT: i32 = 16;
pub const IFF_NEEDSEPOCH: i32 = 32;
pub const IFF_DRV_RUNNING: i32 = 64;
pub const IFF_NOARP: i32 = 128;
pub const IFF_PROMISC: i32 = 256;
pub const IFF_ALLMULTI: i32 = 512;
pub const IFF_DRV_OACTIVE: i32 = 1024;
pub const IFF_SIMPLEX: i32 = 2048;
pub const IFF_LINK0: i32 = 4096;
pub const IFF_LINK1: i32 = 8192;
pub const IFF_LINK2: i32 = 16384;
pub const IFF_ALTPHYS: i32 = 16384;
pub const IFF_MULTICAST: i32 = 32768;
pub const IFF_CANTCONFIG: i32 = 65536;
pub const IFF_PPROMISC: i32 = 131072;
pub const IFF_MONITOR: i32 = 262144;
pub const IFF_STATICARP: i32 = 524288;
pub const IFF_STICKYARP: i32 = 1048576;
pub const IFF_DYING: i32 = 2097152;
pub const IFF_RENAMING: i32 = 4194304;
pub const IFF_PALLMULTI: i32 = 8388608;
pub const IFF_NETLINK_1: i32 = 16777216;
pub const IFF_CANTCHANGE: i32 = 2199410;
pub const LINK_STATE_UNKNOWN: i32 = 0;
pub const LINK_STATE_DOWN: i32 = 1;
pub const LINK_STATE_UP: i32 = 2;
pub const IFCAP_B_RXCSUM: i32 = 0;
pub const IFCAP_B_TXCSUM: i32 = 1;
pub const IFCAP_B_NETCONS: i32 = 2;
pub const IFCAP_B_VLAN_MTU: i32 = 3;
pub const IFCAP_B_VLAN_HWTAGGING: i32 = 4;
pub const IFCAP_B_JUMBO_MTU: i32 = 5;
pub const IFCAP_B_POLLING: i32 = 6;
pub const IFCAP_B_VLAN_HWCSUM: i32 = 7;
pub const IFCAP_B_TSO4: i32 = 8;
pub const IFCAP_B_TSO6: i32 = 9;
pub const IFCAP_B_LRO: i32 = 10;
pub const IFCAP_B_WOL_UCAST: i32 = 11;
pub const IFCAP_B_WOL_MCAST: i32 = 12;
pub const IFCAP_B_WOL_MAGIC: i32 = 13;
pub const IFCAP_B_TOE4: i32 = 14;
pub const IFCAP_B_TOE6: i32 = 15;
pub const IFCAP_B_VLAN_HWFILTER: i32 = 16;
pub const IFCAP_B_NV: i32 = 17;
pub const IFCAP_B_VLAN_HWTSO: i32 = 18;
pub const IFCAP_B_LINKSTATE: i32 = 19;
pub const IFCAP_B_NETMAP: i32 = 20;
pub const IFCAP_B_RXCSUM_IPV6: i32 = 21;
pub const IFCAP_B_TXCSUM_IPV6: i32 = 22;
pub const IFCAP_B_HWSTATS: i32 = 23;
pub const IFCAP_B_TXRTLMT: i32 = 24;
pub const IFCAP_B_HWRXTSTMP: i32 = 25;
pub const IFCAP_B_MEXTPG: i32 = 26;
pub const IFCAP_B_TXTLS4: i32 = 27;
pub const IFCAP_B_TXTLS6: i32 = 28;
pub const IFCAP_B_VXLAN_HWCSUM: i32 = 29;
pub const IFCAP_B_VXLAN_HWTSO: i32 = 30;
pub const IFCAP_B_TXTLS_RTLMT: i32 = 31;
pub const IFCAP_B_RXTLS4: i32 = 32;
pub const IFCAP_B_RXTLS6: i32 = 33;
pub const IFCAP_B_IPSEC_OFFLOAD: i32 = 34;
pub const __IFCAP_B_SIZE: i32 = 35;
pub const IFCAP_B_SIZE: i32 = 35;
pub const IFCAP2_RXTLS4: i32 = 0;
pub const IFCAP2_RXTLS6: i32 = 1;
pub const IFCAP2_IPSEC_OFFLOAD: i32 = 2;
pub const IFCAP_ALLCAPS: i64 = 4294967295;
pub const IFQ_MAXLEN: i32 = 50;
pub const IFNET_SLOWHZ: i32 = 1;
pub const IFAN_ARRIVAL: i32 = 0;
pub const IFAN_DEPARTURE: i32 = 1;
pub const IFR_CAP_NV_MAXBUFSIZE: i32 = 2097152;
pub const IFSTATMAX: i32 = 800;
pub const IFG_ALL: &[u8; 4] = b"all\0";
pub const IFG_EGRESS: &[u8; 7] = b"egress\0";
pub const RSS_FUNC_NONE: i32 = 0;
pub const RSS_FUNC_PRIVATE: i32 = 1;
pub const RSS_FUNC_TOEPLITZ: i32 = 2;
pub const RSS_TYPE_IPV4: i32 = 1;
pub const RSS_TYPE_TCP_IPV4: i32 = 2;
pub const RSS_TYPE_IPV6: i32 = 4;
pub const RSS_TYPE_IPV6_EX: i32 = 8;
pub const RSS_TYPE_TCP_IPV6: i32 = 16;
pub const RSS_TYPE_TCP_IPV6_EX: i32 = 32;
pub const RSS_TYPE_UDP_IPV4: i32 = 64;
pub const RSS_TYPE_UDP_IPV6: i32 = 128;
pub const RSS_TYPE_UDP_IPV6_EX: i32 = 256;
pub const RSS_KEYLEN: i32 = 128;
pub const IFNET_PCP_NONE: i32 = 255;
pub const IFDR_MSG_SIZE: i32 = 64;
pub const IFDR_REASON_MSG: i32 = 1;
pub const IFDR_REASON_VENDOR: i32 = 2;
pub const IPPROTO_IP: i32 = 0;
pub const IPPROTO_ICMP: i32 = 1;
pub const IPPROTO_TCP: i32 = 6;
pub const IPPROTO_UDP: i32 = 17;
pub const IPPROTO_IPV6: i32 = 41;
pub const IPPROTO_RAW: i32 = 255;
pub const INET_ADDRSTRLEN: i32 = 16;
pub const IPPROTO_HOPOPTS: i32 = 0;
pub const IPPROTO_IGMP: i32 = 2;
pub const IPPROTO_GGP: i32 = 3;
pub const IPPROTO_IPV4: i32 = 4;
pub const IPPROTO_IPIP: i32 = 4;
pub const IPPROTO_ST: i32 = 7;
pub const IPPROTO_EGP: i32 = 8;
pub const IPPROTO_PIGP: i32 = 9;
pub const IPPROTO_RCCMON: i32 = 10;
pub const IPPROTO_NVPII: i32 = 11;
pub const IPPROTO_PUP: i32 = 12;
pub const IPPROTO_ARGUS: i32 = 13;
pub const IPPROTO_EMCON: i32 = 14;
pub const IPPROTO_XNET: i32 = 15;
pub const IPPROTO_CHAOS: i32 = 16;
pub const IPPROTO_MUX: i32 = 18;
pub const IPPROTO_MEAS: i32 = 19;
pub const IPPROTO_HMP: i32 = 20;
pub const IPPROTO_PRM: i32 = 21;
pub const IPPROTO_IDP: i32 = 22;
pub const IPPROTO_TRUNK1: i32 = 23;
pub const IPPROTO_TRUNK2: i32 = 24;
pub const IPPROTO_LEAF1: i32 = 25;
pub const IPPROTO_LEAF2: i32 = 26;
pub const IPPROTO_RDP: i32 = 27;
pub const IPPROTO_IRTP: i32 = 28;
pub const IPPROTO_TP: i32 = 29;
pub const IPPROTO_BLT: i32 = 30;
pub const IPPROTO_NSP: i32 = 31;
pub const IPPROTO_INP: i32 = 32;
pub const IPPROTO_DCCP: i32 = 33;
pub const IPPROTO_3PC: i32 = 34;
pub const IPPROTO_IDPR: i32 = 35;
pub const IPPROTO_XTP: i32 = 36;
pub const IPPROTO_DDP: i32 = 37;
pub const IPPROTO_CMTP: i32 = 38;
pub const IPPROTO_TPXX: i32 = 39;
pub const IPPROTO_IL: i32 = 40;
pub const IPPROTO_SDRP: i32 = 42;
pub const IPPROTO_ROUTING: i32 = 43;
pub const IPPROTO_FRAGMENT: i32 = 44;
pub const IPPROTO_IDRP: i32 = 45;
pub const IPPROTO_RSVP: i32 = 46;
pub const IPPROTO_GRE: i32 = 47;
pub const IPPROTO_MHRP: i32 = 48;
pub const IPPROTO_BHA: i32 = 49;
pub const IPPROTO_ESP: i32 = 50;
pub const IPPROTO_AH: i32 = 51;
pub const IPPROTO_INLSP: i32 = 52;
pub const IPPROTO_SWIPE: i32 = 53;
pub const IPPROTO_NHRP: i32 = 54;
pub const IPPROTO_MOBILE: i32 = 55;
pub const IPPROTO_TLSP: i32 = 56;
pub const IPPROTO_SKIP: i32 = 57;
pub const IPPROTO_ICMPV6: i32 = 58;
pub const IPPROTO_NONE: i32 = 59;
pub const IPPROTO_DSTOPTS: i32 = 60;
pub const IPPROTO_AHIP: i32 = 61;
pub const IPPROTO_CFTP: i32 = 62;
pub const IPPROTO_HELLO: i32 = 63;
pub const IPPROTO_SATEXPAK: i32 = 64;
pub const IPPROTO_KRYPTOLAN: i32 = 65;
pub const IPPROTO_RVD: i32 = 66;
pub const IPPROTO_IPPC: i32 = 67;
pub const IPPROTO_ADFS: i32 = 68;
pub const IPPROTO_SATMON: i32 = 69;
pub const IPPROTO_VISA: i32 = 70;
pub const IPPROTO_IPCV: i32 = 71;
pub const IPPROTO_CPNX: i32 = 72;
pub const IPPROTO_CPHB: i32 = 73;
pub const IPPROTO_WSN: i32 = 74;
pub const IPPROTO_PVP: i32 = 75;
pub const IPPROTO_BRSATMON: i32 = 76;
pub const IPPROTO_ND: i32 = 77;
pub const IPPROTO_WBMON: i32 = 78;
pub const IPPROTO_WBEXPAK: i32 = 79;
pub const IPPROTO_EON: i32 = 80;
pub const IPPROTO_VMTP: i32 = 81;
pub const IPPROTO_SVMTP: i32 = 82;
pub const IPPROTO_VINES: i32 = 83;
pub const IPPROTO_TTP: i32 = 84;
pub const IPPROTO_IGP: i32 = 85;
pub const IPPROTO_DGP: i32 = 86;
pub const IPPROTO_TCF: i32 = 87;
pub const IPPROTO_IGRP: i32 = 88;
pub const IPPROTO_OSPFIGP: i32 = 89;
pub const IPPROTO_SRPC: i32 = 90;
pub const IPPROTO_LARP: i32 = 91;
pub const IPPROTO_MTP: i32 = 92;
pub const IPPROTO_AX25: i32 = 93;
pub const IPPROTO_IPEIP: i32 = 94;
pub const IPPROTO_MICP: i32 = 95;
pub const IPPROTO_SCCSP: i32 = 96;
pub const IPPROTO_ETHERIP: i32 = 97;
pub const IPPROTO_ENCAP: i32 = 98;
pub const IPPROTO_APES: i32 = 99;
pub const IPPROTO_GMTP: i32 = 100;
pub const IPPROTO_IPCOMP: i32 = 108;
pub const IPPROTO_SCTP: i32 = 132;
pub const IPPROTO_MH: i32 = 135;
pub const IPPROTO_UDPLITE: i32 = 136;
pub const IPPROTO_HIP: i32 = 139;
pub const IPPROTO_SHIM6: i32 = 140;
pub const IPPROTO_PIM: i32 = 103;
pub const IPPROTO_CARP: i32 = 112;
pub const IPPROTO_PGM: i32 = 113;
pub const IPPROTO_MPLS: i32 = 137;
pub const IPPROTO_PFSYNC: i32 = 240;
pub const IPPROTO_RESERVED_253: i32 = 253;
pub const IPPROTO_RESERVED_254: i32 = 254;
pub const IPPROTO_OLD_DIVERT: i32 = 254;
pub const IPPROTO_MAX: i32 = 256;
pub const IPPROTO_DONE: i32 = 257;
pub const IPPROTO_DIVERT: i32 = 258;
pub const IPPROTO_SEND: i32 = 259;
pub const IPPROTO_SPACER: i32 = 32767;
pub const IPPORT_RESERVED: i32 = 1024;
pub const IPPORT_EPHEMERALFIRST: i32 = 10000;
pub const IPPORT_EPHEMERALLAST: i32 = 65535;
pub const IPPORT_HIFIRSTAUTO: i32 = 49152;
pub const IPPORT_HILASTAUTO: i32 = 65535;
pub const IPPORT_RESERVEDSTART: i32 = 600;
pub const IPPORT_MAX: i32 = 65535;
pub const IN_NETMASK_DEFAULT: i64 = 4294967040;
pub const IN_LOOPBACK_MASK_DFLT: i64 = 4278190080;
pub const VNET_MAGIC_N: i32 = 1581936424;
pub const VNET_SETNAME: &[u8; 9] = b"set_vnet\0";
pub const VNET_SYMPREFIX: &[u8; 12] = b"vnet_entry_\0";
pub const RW_LOCK_READ: i32 = 1;
pub const RW_LOCK_READ_WAITERS: i32 = 2;
pub const RW_LOCK_WRITE_WAITERS: i32 = 4;
pub const RW_LOCK_WRITE_SPINNER: i32 = 8;
pub const RW_LOCK_WRITER_RECURSED: i32 = 16;
pub const RW_LOCK_FLAGMASK: i32 = 31;
pub const RW_LOCK_WAITERS: i32 = 6;
pub const RW_READERS_SHIFT: i32 = 5;
pub const RW_ONE_READER: i32 = 32;
pub const RW_DESTROYED: i32 = 6;
pub const RW_DUPOK: i32 = 1;
pub const RW_NOPROFILE: i32 = 2;
pub const RW_NOWITNESS: i32 = 4;
pub const RW_QUIET: i32 = 8;
pub const RW_RECURSE: i32 = 16;
pub const RW_NEW: i32 = 32;
pub const RA_LOCKED: i32 = 1;
pub const RA_RLOCKED: i32 = 2;
pub const RA_WLOCKED: i32 = 4;
pub const RA_UNLOCKED: i32 = 0;
pub const RA_RECURSED: i32 = 8;
pub const RA_NOTRECURSED: i32 = 16;
pub const SX_LOCK_SHARED: i32 = 1;
pub const SX_LOCK_SHARED_WAITERS: i32 = 2;
pub const SX_LOCK_EXCLUSIVE_WAITERS: i32 = 4;
pub const SX_LOCK_WRITE_SPINNER: i32 = 8;
pub const SX_LOCK_RECURSED: i32 = 16;
pub const SX_LOCK_FLAGMASK: i32 = 31;
pub const SX_LOCK_WAITERS: i32 = 6;
pub const SX_SHARERS_SHIFT: i32 = 5;
pub const SX_ONE_SHARER: i32 = 32;
pub const SX_LOCK_DESTROYED: i32 = 6;
pub const SX_DUPOK: i32 = 1;
pub const SX_NOPROFILE: i32 = 2;
pub const SX_NOWITNESS: i32 = 4;
pub const SX_QUIET: i32 = 8;
pub const SX_RECURSE: i32 = 32;
pub const SX_NEW: i32 = 64;
pub const SX_INTERRUPTIBLE: i32 = 64;
pub const SA_LOCKED: i32 = 1;
pub const SA_SLOCKED: i32 = 2;
pub const SA_XLOCKED: i32 = 4;
pub const SA_UNLOCKED: i32 = 0;
pub const SA_RECURSED: i32 = 8;
pub const SA_NOTRECURSED: i32 = 16;
pub const SX_LOCKED: i32 = 1;
pub const SX_SLOCKED: i32 = 2;
pub const SX_XLOCKED: i32 = 4;
pub const SX_UNLOCKED: i32 = 0;
pub const SX_RECURSED: i32 = 8;
pub const SX_NOTRECURSED: i32 = 16;
pub const IP_OPTIONS: i32 = 1;
pub const IP_HDRINCL: i32 = 2;
pub const IP_TOS: i32 = 3;
pub const IP_TTL: i32 = 4;
pub const IP_RECVOPTS: i32 = 5;
pub const IP_RECVRETOPTS: i32 = 6;
pub const IP_RECVDSTADDR: i32 = 7;
pub const IP_SENDSRCADDR: i32 = 7;
pub const IP_RETOPTS: i32 = 8;
pub const IP_MULTICAST_IF: i32 = 9;
pub const IP_MULTICAST_TTL: i32 = 10;
pub const IP_MULTICAST_LOOP: i32 = 11;
pub const IP_ADD_MEMBERSHIP: i32 = 12;
pub const IP_DROP_MEMBERSHIP: i32 = 13;
pub const IP_MULTICAST_VIF: i32 = 14;
pub const IP_RSVP_ON: i32 = 15;
pub const IP_RSVP_OFF: i32 = 16;
pub const IP_RSVP_VIF_ON: i32 = 17;
pub const IP_RSVP_VIF_OFF: i32 = 18;
pub const IP_PORTRANGE: i32 = 19;
pub const IP_RECVIF: i32 = 20;
pub const IP_IPSEC_POLICY: i32 = 21;
pub const IP_ONESBCAST: i32 = 23;
pub const IP_BINDANY: i32 = 24;
pub const IP_ORIGDSTADDR: i32 = 27;
pub const IP_RECVORIGDSTADDR: i32 = 27;
pub const IP_FW_TABLE_ADD: i32 = 40;
pub const IP_FW_TABLE_DEL: i32 = 41;
pub const IP_FW_TABLE_FLUSH: i32 = 42;
pub const IP_FW_TABLE_GETSIZE: i32 = 43;
pub const IP_FW_TABLE_LIST: i32 = 44;
pub const IP_FW3: i32 = 48;
pub const IP_DUMMYNET3: i32 = 49;
pub const IP_FW_ADD: i32 = 50;
pub const IP_FW_DEL: i32 = 51;
pub const IP_FW_FLUSH: i32 = 52;
pub const IP_FW_ZERO: i32 = 53;
pub const IP_FW_GET: i32 = 54;
pub const IP_FW_RESETLOG: i32 = 55;
pub const IP_FW_NAT_CFG: i32 = 56;
pub const IP_FW_NAT_DEL: i32 = 57;
pub const IP_FW_NAT_GET_CONFIG: i32 = 58;
pub const IP_FW_NAT_GET_LOG: i32 = 59;
pub const IP_DUMMYNET_CONFIGURE: i32 = 60;
pub const IP_DUMMYNET_DEL: i32 = 61;
pub const IP_DUMMYNET_FLUSH: i32 = 62;
pub const IP_DUMMYNET_GET: i32 = 64;
pub const IP_RECVTTL: i32 = 65;
pub const IP_MINTTL: i32 = 66;
pub const IP_DONTFRAG: i32 = 67;
pub const IP_RECVTOS: i32 = 68;
pub const IP_ADD_SOURCE_MEMBERSHIP: i32 = 70;
pub const IP_DROP_SOURCE_MEMBERSHIP: i32 = 71;
pub const IP_BLOCK_SOURCE: i32 = 72;
pub const IP_UNBLOCK_SOURCE: i32 = 73;
pub const IP_MSFILTER: i32 = 74;
pub const IP_VLAN_PCP: i32 = 75;
pub const MCAST_JOIN_GROUP: i32 = 80;
pub const MCAST_LEAVE_GROUP: i32 = 81;
pub const MCAST_JOIN_SOURCE_GROUP: i32 = 82;
pub const MCAST_LEAVE_SOURCE_GROUP: i32 = 83;
pub const MCAST_BLOCK_SOURCE: i32 = 84;
pub const MCAST_UNBLOCK_SOURCE: i32 = 85;
pub const IP_FLOWID: i32 = 90;
pub const IP_FLOWTYPE: i32 = 91;
pub const IP_RSSBUCKETID: i32 = 92;
pub const IP_RECVFLOWID: i32 = 93;
pub const IP_RECVRSSBUCKETID: i32 = 94;
pub const IP_DEFAULT_MULTICAST_TTL: i32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: i32 = 1;
pub const IP_MAX_MEMBERSHIPS: i32 = 4095;
pub const IP_MAX_GROUP_SRC_FILTER: i32 = 512;
pub const IP_MAX_SOCK_SRC_FILTER: i32 = 128;
pub const IP_MAX_SOCK_MUTE_FILTER: i32 = 128;
pub const MCAST_UNDEFINED: i32 = 0;
pub const MCAST_INCLUDE: i32 = 1;
pub const MCAST_EXCLUDE: i32 = 2;
pub const IP_PORTRANGE_DEFAULT: i32 = 0;
pub const IP_PORTRANGE_HIGH: i32 = 1;
pub const IP_PORTRANGE_LOW: i32 = 2;
pub const IPCTL_FORWARDING: i32 = 1;
pub const IPCTL_SENDREDIRECTS: i32 = 2;
pub const IPCTL_DEFTTL: i32 = 3;
pub const IPCTL_SOURCEROUTE: i32 = 8;
pub const IPCTL_DIRECTEDBROADCAST: i32 = 9;
pub const IPCTL_INTRQMAXLEN: i32 = 10;
pub const IPCTL_INTRQDROPS: i32 = 11;
pub const IPCTL_STATS: i32 = 12;
pub const IPCTL_ACCEPTSOURCEROUTE: i32 = 13;
pub const IPCTL_FASTFORWARDING: i32 = 14;
pub const IPCTL_GIF_TTL: i32 = 16;
pub const IPCTL_INTRDQMAXLEN: i32 = 17;
pub const IPCTL_INTRDQDROPS: i32 = 18;
pub const __KAME_VERSION: &[u8; 8] = b"FreeBSD\0";
pub const IPV6PORT_RESERVED: i32 = 1024;
pub const IPV6PORT_ANONMIN: i32 = 49152;
pub const IPV6PORT_ANONMAX: i32 = 65535;
pub const IPV6PORT_RESERVEDMIN: i32 = 600;
pub const IPV6PORT_RESERVEDMAX: i32 = 1023;
pub const INET6_ADDRSTRLEN: i32 = 46;
pub const IPV6_ADDR_INT32_ONE: i32 = 16777216;
pub const IPV6_ADDR_INT32_TWO: i32 = 33554432;
pub const IPV6_ADDR_INT32_MNL: i32 = 511;
pub const IPV6_ADDR_INT32_MLL: i32 = 767;
pub const IPV6_ADDR_INT32_SMP: i64 = 4294901760;
pub const IPV6_ADDR_INT16_ULL: i32 = 33022;
pub const IPV6_ADDR_INT16_USL: i32 = 49406;
pub const IPV6_ADDR_INT16_MLL: i32 = 767;
pub const IPV6_ADDR_SCOPE_NODELOCAL: i32 = 1;
pub const IPV6_ADDR_SCOPE_INTFACELOCAL: i32 = 1;
pub const IPV6_ADDR_SCOPE_LINKLOCAL: i32 = 2;
pub const IPV6_ADDR_SCOPE_SITELOCAL: i32 = 5;
pub const IPV6_ADDR_SCOPE_ORGLOCAL: i32 = 8;
pub const IPV6_ADDR_SCOPE_GLOBAL: i32 = 14;
pub const MTAG_ABI_IPV6: i32 = 1444287380;
pub const IPV6_TAG_DIRECT: i32 = 0;
pub const IPV6_SOCKOPT_RESERVED1: i32 = 3;
pub const IPV6_UNICAST_HOPS: i32 = 4;
pub const IPV6_MULTICAST_IF: i32 = 9;
pub const IPV6_MULTICAST_HOPS: i32 = 10;
pub const IPV6_MULTICAST_LOOP: i32 = 11;
pub const IPV6_JOIN_GROUP: i32 = 12;
pub const IPV6_LEAVE_GROUP: i32 = 13;
pub const IPV6_PORTRANGE: i32 = 14;
pub const ICMP6_FILTER: i32 = 18;
pub const IPV6_2292PKTINFO: i32 = 19;
pub const IPV6_2292HOPLIMIT: i32 = 20;
pub const IPV6_2292NEXTHOP: i32 = 21;
pub const IPV6_2292HOPOPTS: i32 = 22;
pub const IPV6_2292DSTOPTS: i32 = 23;
pub const IPV6_2292RTHDR: i32 = 24;
pub const IPV6_2292PKTOPTIONS: i32 = 25;
pub const IPV6_CHECKSUM: i32 = 26;
pub const IPV6_V6ONLY: i32 = 27;
pub const IPV6_IPSEC_POLICY: i32 = 28;
pub const IPV6_FW_ADD: i32 = 30;
pub const IPV6_FW_DEL: i32 = 31;
pub const IPV6_FW_FLUSH: i32 = 32;
pub const IPV6_FW_ZERO: i32 = 33;
pub const IPV6_FW_GET: i32 = 34;
pub const IPV6_RTHDRDSTOPTS: i32 = 35;
pub const IPV6_RECVPKTINFO: i32 = 36;
pub const IPV6_RECVHOPLIMIT: i32 = 37;
pub const IPV6_RECVRTHDR: i32 = 38;
pub const IPV6_RECVHOPOPTS: i32 = 39;
pub const IPV6_RECVDSTOPTS: i32 = 40;
pub const IPV6_RECVRTHDRDSTOPTS: i32 = 41;
pub const IPV6_USE_MIN_MTU: i32 = 42;
pub const IPV6_RECVPATHMTU: i32 = 43;
pub const IPV6_PATHMTU: i32 = 44;
pub const IPV6_PKTINFO: i32 = 46;
pub const IPV6_HOPLIMIT: i32 = 47;
pub const IPV6_NEXTHOP: i32 = 48;
pub const IPV6_HOPOPTS: i32 = 49;
pub const IPV6_DSTOPTS: i32 = 50;
pub const IPV6_RTHDR: i32 = 51;
pub const IPV6_RECVTCLASS: i32 = 57;
pub const IPV6_AUTOFLOWLABEL: i32 = 59;
pub const IPV6_TCLASS: i32 = 61;
pub const IPV6_DONTFRAG: i32 = 62;
pub const IPV6_PREFER_TEMPADDR: i32 = 63;
pub const IPV6_BINDANY: i32 = 64;
pub const IPV6_FLOWID: i32 = 67;
pub const IPV6_FLOWTYPE: i32 = 68;
pub const IPV6_RSSBUCKETID: i32 = 69;
pub const IPV6_RECVFLOWID: i32 = 70;
pub const IPV6_RECVRSSBUCKETID: i32 = 71;
pub const IPV6_ORIGDSTADDR: i32 = 72;
pub const IPV6_RECVORIGDSTADDR: i32 = 72;
pub const IPV6_MSFILTER: i32 = 74;
pub const IPV6_VLAN_PCP: i32 = 75;
pub const IPV6_RTHDR_LOOSE: i32 = 0;
pub const IPV6_RTHDR_STRICT: i32 = 1;
pub const IPV6_RTHDR_TYPE_0: i32 = 0;
pub const IPV6_DEFAULT_MULTICAST_HOPS: i32 = 1;
pub const IPV6_DEFAULT_MULTICAST_LOOP: i32 = 1;
pub const IPV6_MAX_MEMBERSHIPS: i32 = 4095;
pub const IPV6_MAX_GROUP_SRC_FILTER: i32 = 512;
pub const IPV6_MAX_SOCK_SRC_FILTER: i32 = 128;
pub const IPV6_PORTRANGE_DEFAULT: i32 = 0;
pub const IPV6_PORTRANGE_HIGH: i32 = 1;
pub const IPV6_PORTRANGE_LOW: i32 = 2;
pub const IPV6PROTO_MAXID: i32 = 104;
pub const IPV6CTL_FORWARDING: i32 = 1;
pub const IPV6CTL_SENDREDIRECTS: i32 = 2;
pub const IPV6CTL_DEFHLIM: i32 = 3;
pub const IPV6CTL_FORWSRCRT: i32 = 5;
pub const IPV6CTL_STATS: i32 = 6;
pub const IPV6CTL_MRTSTATS: i32 = 7;
pub const IPV6CTL_MRTPROTO: i32 = 8;
pub const IPV6CTL_MAXFRAGPACKETS: i32 = 9;
pub const IPV6CTL_SOURCECHECK: i32 = 10;
pub const IPV6CTL_SOURCECHECK_LOGINT: i32 = 11;
pub const IPV6CTL_ACCEPT_RTADV: i32 = 12;
pub const IPV6CTL_LOG_INTERVAL: i32 = 14;
pub const IPV6CTL_HDRNESTLIMIT: i32 = 15;
pub const IPV6CTL_DAD_COUNT: i32 = 16;
pub const IPV6CTL_AUTO_FLOWLABEL: i32 = 17;
pub const IPV6CTL_DEFMCASTHLIM: i32 = 18;
pub const IPV6CTL_GIF_HLIM: i32 = 19;
pub const IPV6CTL_KAME_VERSION: i32 = 20;
pub const IPV6CTL_USE_DEPRECATED: i32 = 21;
pub const IPV6CTL_RR_PRUNE: i32 = 22;
pub const IPV6CTL_V6ONLY: i32 = 24;
pub const IPV6CTL_STABLEADDR_NETIFSRC: i32 = 30;
pub const IPV6CTL_STABLEADDR_MAXRETRIES: i32 = 31;
pub const IPV6CTL_USETEMPADDR: i32 = 32;
pub const IPV6CTL_TEMPPLTIME: i32 = 33;
pub const IPV6CTL_TEMPVLTIME: i32 = 34;
pub const IPV6CTL_AUTO_LINKLOCAL: i32 = 35;
pub const IPV6CTL_RIP6STATS: i32 = 36;
pub const IPV6CTL_PREFER_TEMPADDR: i32 = 37;
pub const IPV6CTL_ADDRCTLPOLICY: i32 = 38;
pub const IPV6CTL_USE_DEFAULTZONE: i32 = 39;
pub const IPV6CTL_USESTABLEADDR: i32 = 40;
pub const IPV6CTL_MAXFRAGS: i32 = 41;
pub const IPV6CTL_MCAST_PMTU: i32 = 44;
pub const IPV6CTL_STEALTH: i32 = 45;
pub const ICMPV6CTL_ND6_ONLINKNSRFC4861: i32 = 47;
pub const IPV6CTL_NO_RADR: i32 = 48;
pub const IPV6CTL_NORBIT_RAIF: i32 = 49;
pub const IPV6CTL_RFC6204W3: i32 = 50;
pub const IPV6CTL_INTRQMAXLEN: i32 = 51;
pub const IPV6CTL_INTRDQMAXLEN: i32 = 52;
pub const IPV6CTL_MAXFRAGSPERPACKET: i32 = 53;
pub const IPV6CTL_MAXFRAGBUCKETSIZE: i32 = 54;
pub const IPV6CTL_MAXID: i32 = 55;
pub const KDA_REMOVE: i32 = 255;
pub const KDA_REMOVE_ALL: i32 = 254;
pub const KDA_REMOVE_DEV: i32 = 253;
pub const KDA_APPEND: i32 = 252;
pub const IDT32_PCI_ID: i64 = 2161119517;
pub const IDT8_PCI_ID: i64 = 2161250589;
pub const NVME_ADMIN_TRACKERS: i32 = 16;
pub const NVME_ADMIN_ENTRIES: i32 = 128;
pub const NVME_IO_ENTRIES: i32 = 256;
pub const NVME_IO_TRACKERS: i32 = 128;
pub const NVME_MIN_IO_TRACKERS: i32 = 4;
pub const NVME_MAX_IO_TRACKERS: i32 = 1024;
pub const NVME_INT_COAL_TIME: i32 = 0;
pub const NVME_INT_COAL_THRESHOLD: i32 = 0;
pub const NVME_MAX_NAMESPACES: i32 = 16;
pub const NVME_MAX_CONSUMERS: i32 = 2;
pub const NVME_MAX_ASYNC_EVENTS: i32 = 8;
pub const NVME_ADMIN_TIMEOUT_PERIOD: i32 = 60;
pub const NVME_DEFAULT_TIMEOUT_PERIOD: i32 = 30;
pub const NVME_MIN_TIMEOUT_PERIOD: i32 = 5;
pub const NVME_MAX_TIMEOUT_PERIOD: i32 = 120;
pub const NVME_DEFAULT_RETRY_COUNT: i32 = 4;
pub const NVME_MAX_AER_LOG_SIZE: i32 = 4096;
pub const NVME_GONE: i64 = 4294967295;
pub const QUIRK_DELAY_B4_CHK_RDY: i32 = 1;
pub const QUIRK_DISABLE_TIMEOUT: i32 = 2;
pub const QUIRK_INTEL_ALIGNMENT: i32 = 4;
pub const QUIRK_AHCI: i32 = 8;
pub const IRQ_TYPE_NONE: i32 = 0;
pub const IRQ_TYPE_EDGE_RISING: i32 = 1;
pub const IRQ_TYPE_EDGE_FALLING: i32 = 2;
pub const IRQ_TYPE_EDGE_BOTH: i32 = 3;
pub const IRQ_TYPE_LEVEL_HIGH: i32 = 4;
pub const IRQ_TYPE_LEVEL_LOW: i32 = 8;
pub const AIC_IRQ: i32 = 0;
pub const AIC_FIQ: i32 = 1;
pub const AIC_TMR_HV_PHYS: i32 = 0;
pub const AIC_TMR_HV_VIRT: i32 = 1;
pub const AIC_TMR_GUEST_PHYS: i32 = 2;
pub const AIC_TMR_GUEST_VIRT: i32 = 3;
pub const AIC_CPU_PMU_E: i32 = 4;
pub const AIC_CPU_PMU_P: i32 = 5;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_long;
pub type __uint64_t = ::core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __int_least16_t = __int16_t;
pub type __int_least32_t = __int32_t;
pub type __int_least64_t = __int64_t;
pub type __intmax_t = __int64_t;
pub type __uint_least8_t = __uint8_t;
pub type __uint_least16_t = __uint16_t;
pub type __uint_least32_t = __uint32_t;
pub type __uint_least64_t = __uint64_t;
pub type __uintmax_t = __uint64_t;
pub type __intptr_t = __int64_t;
pub type __intfptr_t = __int64_t;
pub type __uintptr_t = __uint64_t;
pub type __uintfptr_t = __uint64_t;
pub type __vm_offset_t = __uint64_t;
pub type __vm_size_t = __uint64_t;
pub type __size_t = __uint64_t;
pub type __ssize_t = __int64_t;
pub type __ptrdiff_t = __int64_t;
pub type __clock_t = __int32_t;
pub type __critical_t = __int64_t;
pub type __double_t = f64;
pub type __float_t = f32;
pub type __int_fast8_t = __int32_t;
pub type __int_fast16_t = __int32_t;
pub type __int_fast32_t = __int32_t;
pub type __int_fast64_t = __int64_t;
pub type __register_t = __int64_t;
pub type __segsz_t = __int64_t;
pub type __time_t = __int64_t;
pub type __uint_fast8_t = __uint32_t;
pub type __uint_fast16_t = __uint32_t;
pub type __uint_fast32_t = __uint32_t;
pub type __uint_fast64_t = __uint64_t;
pub type __u_register_t = __uint64_t;
pub type __vm_paddr_t = __uint64_t;
pub type ___wchar_t = ::core::ffi::c_uint;
pub type __blksize_t = __int32_t;
pub type __blkcnt_t = __int64_t;
pub type __clockid_t = __int32_t;
pub type __fflags_t = __uint32_t;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint64_t;
pub type __gid_t = __uint32_t;
pub type __id_t = __int64_t;
pub type __ino_t = __uint64_t;
pub type __key_t = ::core::ffi::c_long;
pub type __lwpid_t = __int32_t;
pub type __mode_t = __uint16_t;
pub type __accmode_t = ::core::ffi::c_int;
pub type __nl_item = ::core::ffi::c_int;
pub type __nlink_t = __uint64_t;
pub type __off_t = __int64_t;
pub type __off64_t = __int64_t;
pub type __pid_t = __int32_t;
pub type __sbintime_t = __int64_t;
pub type __rlim_t = __int64_t;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __suseconds_t = ::core::ffi::c_long;
#[repr(C)]
#[derive(Debug)]
pub struct __timer {
    _unused: [u8; 0],
}
pub type __timer_t = *mut __timer;
#[repr(C)]
#[derive(Debug)]
pub struct __mq {
    _unused: [u8; 0],
}
pub type __mqd_t = *mut __mq;
pub type __uid_t = __uint32_t;
pub type __useconds_t = ::core::ffi::c_uint;
pub type __cpuwhich_t = ::core::ffi::c_int;
pub type __cpulevel_t = ::core::ffi::c_int;
pub type __cpusetid_t = ::core::ffi::c_int;
pub type __daddr_t = __int64_t;
pub type __ct_rune_t = ::core::ffi::c_int;
pub type __rune_t = __ct_rune_t;
pub type __wint_t = __ct_rune_t;
pub type __char16_t = __uint_least16_t;
pub type __char32_t = __uint_least32_t;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default)]
pub struct __max_align_t {
    pub __max_align1: ::core::ffi::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align2: u128,
}
pub type __acl_tag_t = __uint32_t;
pub type __acl_perm_t = __uint32_t;
pub type __acl_entry_type_t = __uint16_t;
pub type __acl_flag_t = __uint16_t;
pub type __acl_type_t = __uint32_t;
pub type __acl_permset_t = *mut __uint32_t;
pub type __acl_flagset_t = *mut __uint16_t;
pub type __dev_t = __uint64_t;
pub type __fixpt_t = __uint32_t;
#[repr(C)]
pub struct __mbstate_t {
    pub __mbstate8: __BindgenUnionField<[::core::ffi::c_char; 128usize]>,
    pub _mbstateL: __BindgenUnionField<__int64_t>,
    pub bindgen_union_field: [u64; 16usize],
}
impl Default for __mbstate_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __rman_res_t = __uintmax_t;
pub type __gnuc_va_list = __va_list;
#[repr(C)]
#[derive(Debug)]
pub struct pthread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct pthread_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct pthread_cond {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct pthread_cond_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct pthread_mutex {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct pthread_mutex_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct pthread_rwlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct pthread_rwlockattr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct pthread_barrier {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct pthread_barrier_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct pthread_spinlock {
    _unused: [u8; 0],
}
pub type pthread_t = *mut pthread;
pub type pthread_attr_t = *mut pthread_attr;
pub type pthread_mutex_t = *mut pthread_mutex;
pub type pthread_mutexattr_t = *mut pthread_mutex_attr;
pub type pthread_cond_t = *mut pthread_cond;
pub type pthread_condattr_t = *mut pthread_cond_attr;
pub type pthread_key_t = ::core::ffi::c_int;
pub type pthread_once_t = pthread_once;
pub type pthread_rwlock_t = *mut pthread_rwlock;
pub type pthread_rwlockattr_t = *mut pthread_rwlockattr;
pub type pthread_barrier_t = *mut pthread_barrier;
#[repr(C)]
#[derive(Debug)]
pub struct pthread_barrierattr {
    _unused: [u8; 0],
}
pub type pthread_barrierattr_t = *mut pthread_barrierattr;
pub type pthread_spinlock_t = *mut pthread_spinlock;
pub type pthread_addr_t = *mut ::core::ffi::c_void;
pub type pthread_startroutine_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void,
>;
#[repr(C)]
#[derive(Debug)]
pub struct pthread_once {
    pub state: ::core::ffi::c_int,
    pub mutex: pthread_mutex_t,
}
impl Default for pthread_once {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type u_char = ::core::ffi::c_uchar;
pub type u_short = ::core::ffi::c_ushort;
pub type u_int = ::core::ffi::c_uint;
pub type u_long = ::core::ffi::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type u_quad_t = __uint64_t;
pub type quad_t = __int64_t;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::core::ffi::c_char;
pub type c_caddr_t = *const ::core::ffi::c_char;
pub type blksize_t = __blksize_t;
pub type cpuwhich_t = __cpuwhich_t;
pub type cpulevel_t = __cpulevel_t;
pub type cpusetid_t = __cpusetid_t;
pub type blkcnt_t = __blkcnt_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type critical_t = __critical_t;
pub type daddr_t = __daddr_t;
pub type dev_t = __dev_t;
pub type fflags_t = __fflags_t;
pub type fixpt_t = __fixpt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type gid_t = __gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type key_t = __key_t;
pub type lwpid_t = __lwpid_t;
pub type mode_t = __mode_t;
pub type accmode_t = __accmode_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type register_t = __register_t;
pub type rlim_t = __rlim_t;
pub type sbintime_t = __sbintime_t;
pub type segsz_t = __segsz_t;
pub type suseconds_t = __suseconds_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type mqd_t = __mqd_t;
pub type u_register_t = __u_register_t;
pub type uid_t = __uid_t;
pub type useconds_t = __useconds_t;
pub type cap_ioctl_t = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug)]
pub struct cap_rights {
    _unused: [u8; 0],
}
pub type cap_rights_t = cap_rights;
pub type kpaddr_t = __uint64_t;
pub type kvaddr_t = __uint64_t;
pub type ksize_t = __uint64_t;
pub type kssize_t = __int64_t;
pub type vm_offset_t = __vm_offset_t;
pub type vm_ooffset_t = __uint64_t;
pub type vm_paddr_t = __vm_paddr_t;
pub type vm_pindex_t = __uint64_t;
pub type vm_size_t = __vm_size_t;
pub type rman_res_t = __rman_res_t;
pub type syscallarg_t = __register_t;
pub type boolean_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct _device {
    _unused: [u8; 0],
}
pub type intfptr_t = __intfptr_t;
pub type intrmask_t = __uint32_t;
pub type uintfptr_t = __uintfptr_t;
pub type uoff_t = __uint64_t;
pub type vm_memattr_t = ::core::ffi::c_char;
#[repr(C)]
#[derive(Debug)]
pub struct vm_page {
    _unused: [u8; 0],
}
pub type vm_page_t = *mut vm_page;
pub type bool_ = bool;
#[repr(C)]
#[derive(Debug, Default)]
pub struct __sigset {
    pub __bits: [__uint32_t; 4usize],
}
pub type __sigset_t = __sigset;
#[repr(C)]
#[derive(Debug, Default)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
pub type __fd_mask = ::core::ffi::c_ulong;
pub type fd_mask = __fd_mask;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct timezone {
    pub tz_minuteswest: ::core::ffi::c_int,
    pub tz_dsttime: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct bintime {
    pub sec: time_t,
    pub frac: u64,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct clockinfo {
    pub hz: ::core::ffi::c_int,
    pub tick: ::core::ffi::c_int,
    pub spare: ::core::ffi::c_int,
    pub stathz: ::core::ffi::c_int,
    pub profhz: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct priority {
    pub pri_class: u_char,
    pub pri_level: u_char,
    pub pri_native: u_char,
    pub pri_user: u_char,
}
pub type bus_addr_t = u_long;
pub type bus_size_t = u_long;
pub type bus_space_handle_t = u_long;
pub type bus_space_tag_t = *mut bus_space;
pub type bus_dmasync_op_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug)]
pub struct bus_dma_tag {
    _unused: [u8; 0],
}
pub type bus_dma_tag_t = *mut bus_dma_tag;
#[repr(C)]
#[derive(Debug)]
pub struct bus_dmamap {
    _unused: [u8; 0],
}
pub type bus_dmamap_t = *mut bus_dmamap;
pub const BUS_DMA_LOCK: bus_dma_lock_op_t = 1;
pub const BUS_DMA_UNLOCK: bus_dma_lock_op_t = 2;
pub type bus_dma_lock_op_t = ::core::ffi::c_uint;
pub type bus_dma_lock_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: bus_dma_lock_op_t),
>;
#[doc = " @brief Interface information structure."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct u_businfo {
    #[doc = "< @brief interface version"]
    pub ub_version: ::core::ffi::c_int,
    #[doc = "< @brief generation count"]
    pub ub_generation: ::core::ffi::c_int,
}
#[doc = "< @brief not probed or probe failed"]
pub const DS_NOTPRESENT: device_state = 10;
#[doc = "< @brief probe succeeded"]
pub const DS_ALIVE: device_state = 20;
#[doc = "< @brief currently attaching"]
pub const DS_ATTACHING: device_state = 25;
#[doc = "< @brief attach method called"]
pub const DS_ATTACHED: device_state = 30;
#[doc = " @brief State of the device."]
pub type device_state = ::core::ffi::c_uint;
#[doc = " @brief State of the device."]
pub use self::device_state as device_state_t;
pub const DEVICE_PROP_ANY: device_property_type = 0;
pub const DEVICE_PROP_BUFFER: device_property_type = 1;
pub const DEVICE_PROP_UINT32: device_property_type = 2;
pub const DEVICE_PROP_UINT64: device_property_type = 3;
pub const DEVICE_PROP_HANDLE: device_property_type = 4;
#[doc = " @brief Device proprty types.\n\n Those are used by bus logic to encode requested properties,\n e.g. in DT all properties are stored as BE and need to be converted\n to host endianness."]
pub type device_property_type = ::core::ffi::c_uint;
#[doc = " @brief Device proprty types.\n\n Those are used by bus logic to encode requested properties,\n e.g. in DT all properties are stored as BE and need to be converted\n to host endianness."]
pub use self::device_property_type as device_property_type_t;
#[repr(C)]
#[derive(Debug)]
pub struct u_device {
    pub dv_handle: usize,
    pub dv_parent: usize,
    #[doc = "< @brief API Flags for device"]
    pub dv_devflags: u32,
    #[doc = "< @brief flags for dev state"]
    pub dv_flags: u16,
    #[doc = "< @brief State of attachment"]
    pub dv_state: device_state_t,
    #[doc = "< @brief NUL terminated fields"]
    pub dv_fields: [::core::ffi::c_char; 3072usize],
}
impl Default for u_device {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Device request structure used for ioctl's.\n\n Used for ioctl's on /dev/devctl2.  All device ioctl's\n must have parameter definitions which begin with dr_name."]
#[repr(C)]
#[derive(Debug)]
pub struct devreq_buffer {
    pub buffer: *mut ::core::ffi::c_void,
    pub length: usize,
}
impl Default for devreq_buffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct devreq {
    pub dr_name: [::core::ffi::c_char; 128usize],
    pub dr_flags: ::core::ffi::c_int,
    pub dr_dru: devreq__bindgen_ty_1,
}
#[repr(C)]
pub struct devreq__bindgen_ty_1 {
    pub dru_buffer: __BindgenUnionField<devreq_buffer>,
    pub dru_data: __BindgenUnionField<*mut ::core::ffi::c_void>,
    pub bindgen_union_field: [u64; 2usize],
}
impl Default for devreq__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for devreq {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry {
    pub ee_link: eventhandler_entry__bindgen_ty_1,
    pub ee_priority: ::core::ffi::c_int,
    pub ee_arg: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry__bindgen_ty_1 {
    pub tqe_next: *mut eventhandler_entry,
    pub tqe_prev: *mut *mut eventhandler_entry,
}
impl Default for eventhandler_entry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for eventhandler_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type eventhandler_tag = *mut eventhandler_entry;
pub type kobj_t = *mut kobj;
pub type kobj_class_t = *mut kobj_class;
pub type kobj_method_t = kobj_method;
pub type kobjop_t = ::core::option::Option<unsafe extern "C" fn()>;
pub type kobj_ops_t = *mut kobj_ops;
pub type kobjop_desc_t = *mut kobjop_desc;
#[repr(C)]
#[derive(Debug)]
pub struct kobj_method {
    pub desc: kobjop_desc_t,
    pub func: kobjop_t,
}
impl Default for kobj_method {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct kobj_class {
    pub name: *const ::core::ffi::c_char,
    pub methods: *const kobj_method,
    pub size: usize,
    pub baseclasses: *mut kobj_class_t,
    pub refs: u_int,
    pub ops: kobj_ops_t,
}
impl Default for kobj_class {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct kobj {
    pub ops: kobj_ops_t,
}
impl Default for kobj {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct kobj_ops {
    pub cache: [*const kobj_method; 256usize],
    pub cls: kobj_class_t,
}
impl Default for kobj_ops {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct kobjop_desc {
    pub id: ::core::ffi::c_uint,
    pub deflt: kobj_method_t,
}
impl Default for kobjop_desc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct callout_list {
    pub lh_first: *mut callout,
}
impl Default for callout_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct callout_slist {
    pub slh_first: *mut callout,
}
impl Default for callout_slist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct callout_tailq {
    pub tqh_first: *mut callout,
    pub tqh_last: *mut *mut callout,
}
impl Default for callout_tailq {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type callout_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
#[repr(C)]
pub struct callout {
    pub c_links: callout__bindgen_ty_1,
    pub c_time: __sbintime_t,
    pub c_precision: __sbintime_t,
    pub c_arg: *mut ::core::ffi::c_void,
    pub c_func: callout_func_t,
    pub c_lock: *mut lock_object,
    pub c_flags: ::core::ffi::c_short,
    pub c_iflags: ::core::ffi::c_short,
    pub c_cpu: ::core::ffi::c_int,
}
#[repr(C)]
pub struct callout__bindgen_ty_1 {
    pub le: __BindgenUnionField<callout__bindgen_ty_1__bindgen_ty_1>,
    pub sle: __BindgenUnionField<callout__bindgen_ty_1__bindgen_ty_2>,
    pub tqe: __BindgenUnionField<callout__bindgen_ty_1__bindgen_ty_3>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct callout__bindgen_ty_1__bindgen_ty_1 {
    pub le_next: *mut callout,
    pub le_prev: *mut *mut callout,
}
impl Default for callout__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct callout__bindgen_ty_1__bindgen_ty_2 {
    pub sle_next: *mut callout,
}
impl Default for callout__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct callout__bindgen_ty_1__bindgen_ty_3 {
    pub tqe_next: *mut callout,
    pub tqe_prev: *mut *mut callout,
}
impl Default for callout__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for callout__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for callout {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = __int_fast8_t;
pub type int_fast16_t = __int_fast16_t;
pub type int_fast32_t = __int_fast32_t;
pub type int_fast64_t = __int_fast64_t;
pub type uint_fast8_t = __uint_fast8_t;
pub type uint_fast16_t = __uint_fast16_t;
pub type uint_fast32_t = __uint_fast32_t;
pub type uint_fast64_t = __uint_fast64_t;
pub const VM_GUEST_NO: VM_GUEST = 0;
pub const VM_GUEST_VM: VM_GUEST = 1;
pub const VM_GUEST_XEN: VM_GUEST = 2;
pub const VM_GUEST_HV: VM_GUEST = 3;
pub const VM_GUEST_VMWARE: VM_GUEST = 4;
pub const VM_GUEST_KVM: VM_GUEST = 5;
pub const VM_GUEST_BHYVE: VM_GUEST = 6;
pub const VM_GUEST_VBOX: VM_GUEST = 7;
pub const VM_GUEST_PARALLELS: VM_GUEST = 8;
pub const VM_GUEST_NVMM: VM_GUEST = 9;
pub const VM_GUEST_LAST: VM_GUEST = 10;
pub type VM_GUEST = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default)]
pub struct bitset {
    pub __bits: [::core::ffi::c_ulong; 1usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct _cpuset {
    pub __bits: [::core::ffi::c_ulong; 16usize],
}
pub type cpuset_t = _cpuset;
#[repr(C)]
#[derive(Debug)]
pub struct lock_object {
    pub lo_name: *const ::core::ffi::c_char,
    pub lo_flags: ::core::ffi::c_uint,
    pub lo_data: ::core::ffi::c_uint,
    pub lo_witness: *mut witness,
}
impl Default for lock_object {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct mtx {
    pub lock_object: lock_object,
    pub mtx_lock: __uintptr_t,
}
impl Default for mtx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(128))]
#[derive(Debug)]
pub struct mtx_padalign {
    pub lock_object: lock_object,
    pub mtx_lock: __uintptr_t,
}
impl Default for mtx_padalign {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct sx {
    pub lock_object: lock_object,
    pub sx_lock: __uintptr_t,
}
impl Default for sx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct rmpriolist {
    pub lh_first: *mut rm_priotracker,
}
impl Default for rmpriolist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct rm_queue {
    pub rmq_next: *mut rm_queue,
    pub rmq_prev: *mut rm_queue,
}
impl Default for rm_queue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct rmlock {
    pub lock_object: lock_object,
    pub rm_writecpus: cpuset_t,
    pub rm_activeReaders: rmlock__bindgen_ty_1,
    pub _rm_lock: rmlock__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug)]
pub struct rmlock__bindgen_ty_1 {
    pub lh_first: *mut rm_priotracker,
}
impl Default for rmlock__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct rmlock__bindgen_ty_2 {
    pub _rm_wlock_object: __BindgenUnionField<lock_object>,
    pub _rm_lock_mtx: __BindgenUnionField<mtx>,
    pub _rm_lock_sx: __BindgenUnionField<sx>,
    pub bindgen_union_field: [u64; 4usize],
}
impl Default for rmlock__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for rmlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct rm_priotracker {
    pub rmp_cpuQueue: rm_queue,
    pub rmp_rmlock: *mut rmlock,
    pub rmp_thread: *mut thread,
    pub rmp_flags: ::core::ffi::c_int,
    pub rmp_qentry: rm_priotracker__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug)]
pub struct rm_priotracker__bindgen_ty_1 {
    pub le_next: *mut rm_priotracker,
    pub le_prev: *mut *mut rm_priotracker,
}
impl Default for rm_priotracker__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for rm_priotracker {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct rmslock_pcpu {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct rmslock {
    pub mtx: mtx,
    pub owner: *mut thread,
    pub pcpu: *mut rmslock_pcpu,
    pub writers: ::core::ffi::c_int,
    pub readers: ::core::ffi::c_int,
    pub debug_readers: ::core::ffi::c_int,
}
impl Default for rmslock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::core::ffi::c_long,
    pub ru_ixrss: ::core::ffi::c_long,
    pub ru_idrss: ::core::ffi::c_long,
    pub ru_isrss: ::core::ffi::c_long,
    pub ru_minflt: ::core::ffi::c_long,
    pub ru_majflt: ::core::ffi::c_long,
    pub ru_nswap: ::core::ffi::c_long,
    pub ru_inblock: ::core::ffi::c_long,
    pub ru_oublock: ::core::ffi::c_long,
    pub ru_msgsnd: ::core::ffi::c_long,
    pub ru_msgrcv: ::core::ffi::c_long,
    pub ru_nsignals: ::core::ffi::c_long,
    pub ru_nvcsw: ::core::ffi::c_long,
    pub ru_nivcsw: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __wrusage {
    pub wru_self: rusage,
    pub wru_children: rusage,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct orlimit {
    pub rlim_cur: __int32_t,
    pub rlim_max: __int32_t,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct loadavg {
    pub ldavg: [__fixpt_t; 3usize],
    pub fscale: ::core::ffi::c_long,
}
pub type stack_t = sigaltstack;
#[repr(C)]
#[derive(Debug)]
pub struct sigaltstack {
    pub ss_sp: *mut ::core::ffi::c_void,
    pub ss_size: __size_t,
    pub ss_flags: ::core::ffi::c_int,
}
impl Default for sigaltstack {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct sigval {
    pub sival_int: __BindgenUnionField<::core::ffi::c_int>,
    pub sival_ptr: __BindgenUnionField<*mut ::core::ffi::c_void>,
    pub sigval_int: __BindgenUnionField<::core::ffi::c_int>,
    pub sigval_ptr: __BindgenUnionField<*mut ::core::ffi::c_void>,
    pub bindgen_union_field: u64,
}
impl Default for sigval {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct sigval32 {
    pub sival_int: __BindgenUnionField<::core::ffi::c_int>,
    pub sival_ptr: __BindgenUnionField<__uint32_t>,
    pub sigval_int: __BindgenUnionField<::core::ffi::c_int>,
    pub sigval_ptr: __BindgenUnionField<__uint32_t>,
    pub bindgen_union_field: u32,
}
impl Default for sigval32 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sig_atomic_t = ::core::ffi::c_long;
#[repr(C)]
#[derive(Debug, Default)]
pub struct sigcontext {
    pub _dummy: ::core::ffi::c_int,
}
pub type __sighandler_t = ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>;
#[repr(C)]
pub struct sigevent {
    pub sigev_notify: ::core::ffi::c_int,
    pub sigev_signo: ::core::ffi::c_int,
    pub sigev_value: sigval,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
pub struct sigevent__bindgen_ty_1 {
    pub _threadid: __BindgenUnionField<__lwpid_t>,
    pub _sigev_thread: __BindgenUnionField<sigevent__bindgen_ty_1__bindgen_ty_1>,
    pub _kevent_flags: __BindgenUnionField<::core::ffi::c_ushort>,
    pub __spare__: __BindgenUnionField<[::core::ffi::c_long; 8usize]>,
    pub bindgen_union_field: [u64; 8usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::core::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub _attribute: *mut *mut pthread_attr,
}
impl Default for sigevent__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sigevent__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sigevent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct __siginfo {
    pub si_signo: ::core::ffi::c_int,
    pub si_errno: ::core::ffi::c_int,
    pub si_code: ::core::ffi::c_int,
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::core::ffi::c_int,
    pub si_addr: *mut ::core::ffi::c_void,
    pub si_value: sigval,
    pub _reason: __siginfo__bindgen_ty_1,
}
#[repr(C)]
pub struct __siginfo__bindgen_ty_1 {
    pub _fault: __BindgenUnionField<__siginfo__bindgen_ty_1__bindgen_ty_1>,
    pub _timer: __BindgenUnionField<__siginfo__bindgen_ty_1__bindgen_ty_2>,
    pub _mesgq: __BindgenUnionField<__siginfo__bindgen_ty_1__bindgen_ty_3>,
    pub _poll: __BindgenUnionField<__siginfo__bindgen_ty_1__bindgen_ty_4>,
    pub _capsicum: __BindgenUnionField<__siginfo__bindgen_ty_1__bindgen_ty_5>,
    pub __spare__: __BindgenUnionField<__siginfo__bindgen_ty_1__bindgen_ty_6>,
    pub bindgen_union_field: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_1 {
    pub _trapno: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_2 {
    pub _timerid: ::core::ffi::c_int,
    pub _overrun: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_3 {
    pub _mqd: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_4 {
    pub _band: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_5 {
    pub _syscall: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_6 {
    pub __spare1__: ::core::ffi::c_long,
    pub __spare2__: [::core::ffi::c_int; 7usize],
}
impl Default for __siginfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __siginfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type siginfo_t = __siginfo;
#[repr(C)]
pub struct __siginfo32 {
    pub si_signo: ::core::ffi::c_int,
    pub si_errno: ::core::ffi::c_int,
    pub si_code: ::core::ffi::c_int,
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::core::ffi::c_int,
    pub si_addr: u32,
    pub si_value: sigval32,
    pub _reason: __siginfo32__bindgen_ty_1,
}
#[repr(C)]
pub struct __siginfo32__bindgen_ty_1 {
    pub _fault: __BindgenUnionField<__siginfo32__bindgen_ty_1__bindgen_ty_1>,
    pub _timer: __BindgenUnionField<__siginfo32__bindgen_ty_1__bindgen_ty_2>,
    pub _mesgq: __BindgenUnionField<__siginfo32__bindgen_ty_1__bindgen_ty_3>,
    pub _poll: __BindgenUnionField<__siginfo32__bindgen_ty_1__bindgen_ty_4>,
    pub __spare__: __BindgenUnionField<__siginfo32__bindgen_ty_1__bindgen_ty_5>,
    pub bindgen_union_field: [u32; 8usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __siginfo32__bindgen_ty_1__bindgen_ty_1 {
    pub _trapno: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __siginfo32__bindgen_ty_1__bindgen_ty_2 {
    pub _timerid: ::core::ffi::c_int,
    pub _overrun: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __siginfo32__bindgen_ty_1__bindgen_ty_3 {
    pub _mqd: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __siginfo32__bindgen_ty_1__bindgen_ty_4 {
    pub _band: i32,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __siginfo32__bindgen_ty_1__bindgen_ty_5 {
    pub __spare1__: i32,
    pub __spare2__: [::core::ffi::c_int; 7usize],
}
impl Default for __siginfo32__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __siginfo32 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct sigaction {
    pub __sigaction_u: sigaction__bindgen_ty_1,
    pub sa_flags: ::core::ffi::c_int,
    pub sa_mask: sigset_t,
}
#[repr(C)]
pub struct sigaction__bindgen_ty_1 {
    pub __sa_handler:
        __BindgenUnionField<::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>>,
    pub __sa_sigaction: __BindgenUnionField<
        ::core::option::Option<
            unsafe extern "C" fn(
                arg1: ::core::ffi::c_int,
                arg2: *mut __siginfo,
                arg3: *mut ::core::ffi::c_void,
            ),
        >,
    >,
    pub bindgen_union_field: u64,
}
impl Default for sigaction__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sigaction {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sig_t = __sighandler_t;
pub type __siginfohandler_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: ::core::ffi::c_int,
        arg2: *mut __siginfo,
        arg3: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Default)]
pub struct sigvec {
    pub sv_handler: __sighandler_t,
    pub sv_mask: ::core::ffi::c_int,
    pub sv_flags: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct sigstack {
    pub ss_sp: *mut ::core::ffi::c_void,
    pub ss_onstack: ::core::ffi::c_int,
}
impl Default for sigstack {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct gpregs {
    pub gp_x: [__register_t; 30usize],
    pub gp_lr: __register_t,
    pub gp_sp: __register_t,
    pub gp_elr: __register_t,
    pub gp_spsr: __uint64_t,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default)]
pub struct fpregs {
    pub fp_q: [__uint128_t; 32usize],
    pub fp_sr: __uint32_t,
    pub fp_cr: __uint32_t,
    pub fp_flags: ::core::ffi::c_int,
    pub fp_pad: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct arm64_reg_context {
    pub ctx_id: __uint32_t,
    pub ctx_size: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct sve_context {
    pub sve_ctx: arm64_reg_context,
    pub sve_vector_len: __uint16_t,
    pub sve_flags: __uint16_t,
    pub sve_reserved: [__uint16_t; 2usize],
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default)]
pub struct __mcontext {
    pub mc_gpregs: gpregs,
    pub mc_fpregs: fpregs,
    pub mc_flags: ::core::ffi::c_int,
    pub mc_pad: ::core::ffi::c_int,
    pub mc_ptr: __uint64_t,
    pub mc_spare: [__uint64_t; 7usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct sigaltstack32 {
    pub ss_sp: u32,
    pub ss_size: u32,
    pub ss_flags: ::core::ffi::c_int,
}
#[repr(C)]
pub struct osigevent32 {
    pub sigev_notify: ::core::ffi::c_int,
    pub __sigev_u: osigevent32__bindgen_ty_1,
    pub sigev_value: sigval32,
}
#[repr(C)]
pub struct osigevent32__bindgen_ty_1 {
    pub __sigev_signo: __BindgenUnionField<::core::ffi::c_int>,
    pub __sigev_notify_kqueue: __BindgenUnionField<::core::ffi::c_int>,
    pub bindgen_union_field: u32,
}
impl Default for osigevent32__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for osigevent32 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct sigevent32 {
    pub sigev_notify: ::core::ffi::c_int,
    pub sigev_signo: ::core::ffi::c_int,
    pub sigev_value: sigval32,
    pub _sigev_un: sigevent32__bindgen_ty_1,
}
#[repr(C)]
pub struct sigevent32__bindgen_ty_1 {
    pub _threadid: __BindgenUnionField<__lwpid_t>,
    pub _sigev_thread: __BindgenUnionField<sigevent32__bindgen_ty_1__bindgen_ty_1>,
    pub _kevent_flags: __BindgenUnionField<::core::ffi::c_ushort>,
    pub __spare__: __BindgenUnionField<[u32; 8usize]>,
    pub bindgen_union_field: [u32; 8usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct sigevent32__bindgen_ty_1__bindgen_ty_1 {
    pub _function: u32,
    pub _attribute: u32,
}
impl Default for sigevent32__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sigevent32 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct __mcontext32 {
    pub mc_gregset: [u32; 17usize],
    pub mc_vfp_size: u32,
    pub mc_vfp_ptr: u32,
    pub mc_spare: [u32; 33usize],
}
impl Default for __mcontext32 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mcontext32_t = __mcontext32;
#[repr(C)]
#[derive(Debug)]
pub struct __ucontext32 {
    pub uc_sigmask: sigset_t,
    pub uc_mcontext: mcontext32_t,
    pub uc_link: u_int32_t,
    pub uc_stack: sigaltstack32,
    pub uc_flags: u_int32_t,
    pub __spare__: [u_int32_t; 4usize],
}
impl Default for __ucontext32 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ucontext32_t = __ucontext32;
#[repr(C)]
#[derive(Debug, Default)]
pub struct __mcontext32_vfp {
    pub mcv_reg: [__uint64_t; 32usize],
    pub mcv_fpscr: __uint32_t,
}
pub type mcontext32_vfp_t = __mcontext32_vfp;
#[repr(C)]
#[repr(align(16))]
pub struct __ucontext {
    pub uc_sigmask: __sigset_t,
    pub uc_mcontext: mcontext_t,
    pub uc_link: *mut __ucontext,
    pub uc_stack: sigaltstack,
    pub uc_flags: ::core::ffi::c_int,
    pub __spare__: [::core::ffi::c_int; 4usize],
}
impl Default for __ucontext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ucontext_t = __ucontext;
#[repr(C)]
#[derive(Debug, Default)]
pub struct trapframe {
    pub tf_sp: u64,
    pub tf_lr: u64,
    pub tf_elr: u64,
    pub tf_spsr: u64,
    pub tf_esr: u64,
    pub tf_far: u64,
    pub tf_x: [u64; 30usize],
}
#[repr(C)]
#[repr(align(16))]
pub struct sigframe {
    pub sf_si: siginfo_t,
    pub sf_uc: ucontext_t,
}
impl Default for sigframe {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct frame {
    pub dummy: ::core::ffi::c_int,
}
#[repr(C)]
pub struct sigframe32 {
    pub sf_si: __siginfo32,
    pub sf_uc: ucontext32_t,
    pub sf_vfp: mcontext32_vfp_t,
}
impl Default for sigframe32 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct arm64_addr_mask {
    _unused: [u8; 0],
}
pub type cpu_reset_hook_t = ::core::option::Option<unsafe extern "C" fn()>;
pub type pcpu_bp_harden = ::core::option::Option<unsafe extern "C" fn() -> ::core::ffi::c_int>;
pub type pcpu_ssbd =
    ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int>;
#[repr(C)]
#[repr(align(128))]
pub struct pcpu {
    pub pc_curthread: *mut thread,
    pub pc_idlethread: *mut thread,
    pub pc_fpcurthread: *mut thread,
    pub pc_deadthread: *mut thread,
    pub pc_curpcb: *mut pcb,
    pub pc_sched: *mut ::core::ffi::c_void,
    pub pc_switchtime: u64,
    pub pc_switchticks: ::core::ffi::c_int,
    pub pc_cpuid: u_int,
    pub pc_allcpu: pcpu__bindgen_ty_1,
    pub pc_spinlocks: *mut lock_list_entry,
    pub pc_cp_time: [::core::ffi::c_long; 5usize],
    pub pc_device: *mut _device,
    pub pc_netisr: *mut ::core::ffi::c_void,
    pub pc_vfs_freevnodes: i8,
    pub pc_unused1: [::core::ffi::c_char; 3usize],
    pub pc_domain: ::core::ffi::c_int,
    pub pc_rm_queue: rm_queue,
    pub pc_dynamic: usize,
    pub pc_early_dummy_counter: u64,
    pub pc_zpcpu_offset: usize,
    pub pc_acpi_id: u_int,
    pub pc_midr: u_int,
    pub pc_clock: u64,
    pub pc_bp_harden: pcpu_bp_harden,
    pub pc_ssbd: pcpu_ssbd,
    pub pc_curpmap: *mut pmap,
    pub pc_curvmpmap: *mut pmap,
    pub pc_mpidr: u64,
    pub pc_bcast_tlbi_workaround: u_int,
    pub pc_release_addr: u64,
    pub __pad: [::core::ffi::c_char; 189usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct pcpu__bindgen_ty_1 {
    pub stqe_next: *mut pcpu,
}
impl Default for pcpu__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for pcpu {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cpuhead {
    pub stqh_first: *mut pcpu,
    pub stqh_last: *mut *mut pcpu,
}
impl Default for cpuhead {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct thread_lite {
    pub pad_td_owepreempt: [u_char; 312usize],
    pub td_owepreempt: u_char,
    pub pad_td_pinned: [u_char; 67usize],
    pub td_pinned: ::core::ffi::c_int,
    pub pad_td_priority: [u_char; 634usize],
    pub td_priority: u_char,
    pub pad_td_critnest: [u_char; 257usize],
    pub td_critnest: u_int,
}
impl Default for thread_lite {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct inpcb {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct socket {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct tty {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct _jmp_buf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct eventtimer {
    _unused: [u8; 0],
}
pub type cpu_tick_f = ::core::option::Option<unsafe extern "C" fn() -> u64>;
#[repr(C)]
#[derive(Debug)]
pub struct root_hold_token {
    pub flags: ::core::ffi::c_int,
    pub who: *const ::core::ffi::c_char,
    pub list: root_hold_token__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug)]
pub struct root_hold_token__bindgen_ty_1 {
    pub tqe_next: *mut root_hold_token,
    pub tqe_prev: *mut *mut root_hold_token,
}
impl Default for root_hold_token__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for root_hold_token {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct unrhdr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct unrhdr64 {
    pub counter: u64,
}
pub type send_event_f = ::core::option::Option<
    unsafe extern "C" fn(
        system: *const ::core::ffi::c_char,
        subsystem: *const ::core::ffi::c_char,
        type_: *const ::core::ffi::c_char,
        data: *const ::core::ffi::c_char,
    ),
>;
#[doc = " Device name parsers.  Hook to allow device enumerators to map\n scheme-specific names to a device."]
pub type dev_lookup_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::core::ffi::c_void,
        name: *const ::core::ffi::c_char,
        result: *mut device_t,
    ),
>;
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_dev_lookup {
    pub ee: eventhandler_entry,
    pub eh_func: dev_lookup_fn,
}
impl Default for eventhandler_entry_dev_lookup {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct __hack {
    _unused: [u8; 0],
}
#[doc = " @brief A device driver.\n\n Provides an abstraction layer for driver dispatch."]
pub type driver_t = kobj_class;
#[repr(C)]
#[derive(Debug)]
pub struct devclass {
    _unused: [u8; 0],
}
#[doc = " @brief A device class\n\n The devclass object has two main functions in the system. The first\n is to manage the allocation of unit numbers for device instances\n and the second is to hold the list of device drivers for a\n particular bus type. Each devclass has a name and there cannot be\n two devclasses with the same name. This ensures that unique unit\n numbers are allocated to device instances.\n\n Drivers that support several different bus attachments (e.g. isa,\n pci, pccard) should all use the same devclass to ensure that unit\n numbers do not conflict.\n\n Each devclass may also have a parent devclass. This is used when\n searching for device drivers to allow a form of inheritance. When\n matching drivers with devices, first the driver list of the parent\n device's devclass is searched. If no driver is found in that list,\n the search continues in the parent devclass (if any)."]
pub type devclass_t = *mut devclass;
#[doc = " @brief Driver interrupt service routines\n\n The filter routine is run in primary interrupt context and may not\n block or use regular mutexes.  It may only use spin mutexes for\n synchronization.  The filter may either completely handle the\n interrupt or it may perform some of the work and defer more\n expensive work to the regular interrupt handler.  If a filter\n routine is not registered by the driver, then the regular interrupt\n handler is always used to handle interrupts from this device.\n\n The regular interrupt handler executes in its own thread context\n and may use regular mutexes.  However, it is prohibited from\n sleeping on a sleep queue."]
pub type driver_filter_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
>;
pub type driver_intr_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
pub const INTR_TYPE_TTY: intr_type = 1;
pub const INTR_TYPE_BIO: intr_type = 2;
pub const INTR_TYPE_NET: intr_type = 4;
pub const INTR_TYPE_CAM: intr_type = 8;
pub const INTR_TYPE_MISC: intr_type = 16;
pub const INTR_TYPE_CLK: intr_type = 32;
pub const INTR_TYPE_AV: intr_type = 64;
pub const INTR_EXCL: intr_type = 256;
pub const INTR_MPSAFE: intr_type = 512;
pub const INTR_ENTROPY: intr_type = 1024;
pub const INTR_SLEEPABLE: intr_type = 2048;
pub const INTR_MD1: intr_type = 4096;
pub const INTR_MD2: intr_type = 8192;
pub const INTR_MD3: intr_type = 16384;
pub const INTR_MD4: intr_type = 32768;
#[doc = " @brief Interrupt type bits.\n\n These flags may be passed by drivers to bus_setup_intr(9) when\n registering a new interrupt handler. The field is overloaded to\n specify both the interrupt's type and any special properties.\n\n The INTR_TYPE* bits will be passed to intr_priority(9) to determine\n the scheduling priority of the handler's ithread. Historically, each\n type was assigned a unique scheduling preference, but now only\n INTR_TYPE_CLK receives a default priority higher than other\n interrupts. See sys/priority.h.\n\n Buses may choose to modify or augment these flags as appropriate,\n e.g. nexus may apply INTR_EXCL."]
pub type intr_type = ::core::ffi::c_uint;
pub const INTR_TRIGGER_INVALID: intr_trigger = -1;
pub const INTR_TRIGGER_CONFORM: intr_trigger = 0;
pub const INTR_TRIGGER_EDGE: intr_trigger = 1;
pub const INTR_TRIGGER_LEVEL: intr_trigger = 2;
pub type intr_trigger = ::core::ffi::c_int;
pub const INTR_POLARITY_CONFORM: intr_polarity = 0;
pub const INTR_POLARITY_HIGH: intr_polarity = 1;
pub const INTR_POLARITY_LOW: intr_polarity = 2;
pub type intr_polarity = ::core::ffi::c_uint;
pub const LOCAL_CPUS: cpu_sets = 0;
pub const INTR_CPUS: cpu_sets = 1;
#[doc = " CPU sets supported by bus_get_cpus().  Note that not all sets may be\n supported for a given device.  If a request is not supported by a\n device (or its parents), then bus_get_cpus() will fail with EINVAL."]
pub type cpu_sets = ::core::ffi::c_uint;
#[doc = " @brief A resource mapping."]
#[repr(C)]
#[derive(Debug)]
pub struct resource_map {
    pub r_bustag: bus_space_tag_t,
    pub r_bushandle: bus_space_handle_t,
    pub r_size: bus_size_t,
    pub r_vaddr: *mut ::core::ffi::c_void,
}
impl Default for resource_map {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Optional properties of a resource mapping request."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct resource_map_request {
    pub size: usize,
    pub offset: rman_res_t,
    pub length: rman_res_t,
    pub memattr: vm_memattr_t,
}
#[doc = " @brief An entry for a single resource in a resource list."]
#[repr(C)]
#[derive(Debug)]
pub struct resource_list_entry {
    pub link: resource_list_entry__bindgen_ty_1,
    #[doc = "< @brief type argument to alloc_resource"]
    pub type_: ::core::ffi::c_int,
    #[doc = "< @brief resource identifier"]
    pub rid: ::core::ffi::c_int,
    #[doc = "< @brief resource flags"]
    pub flags: ::core::ffi::c_int,
    #[doc = "< @brief the real resource when allocated"]
    pub res: *mut resource,
    #[doc = "< @brief start of resource range"]
    pub start: rman_res_t,
    #[doc = "< @brief end of resource range"]
    pub end: rman_res_t,
    #[doc = "< @brief count within range"]
    pub count: rman_res_t,
}
#[repr(C)]
#[derive(Debug)]
pub struct resource_list_entry__bindgen_ty_1 {
    pub stqe_next: *mut resource_list_entry,
}
impl Default for resource_list_entry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for resource_list_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct resource_list {
    pub stqh_first: *mut resource_list_entry,
    pub stqh_last: *mut *mut resource_list_entry,
}
impl Default for resource_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct resource_spec {
    pub type_: ::core::ffi::c_int,
    pub rid: ::core::ffi::c_int,
    pub flags: ::core::ffi::c_int,
}
#[doc = " @brief A function implementing the DEVICE_PROBE() method"]
pub type device_probe_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t) -> ::core::ffi::c_int>;
#[doc = " @brief A function implementing the DEVICE_IDENTIFY() method"]
pub type device_identify_t =
    ::core::option::Option<unsafe extern "C" fn(driver: *mut driver_t, parent: device_t)>;
#[doc = " @brief A function implementing the DEVICE_ATTACH() method"]
pub type device_attach_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t) -> ::core::ffi::c_int>;
#[doc = " @brief A function implementing the DEVICE_DETACH() method"]
pub type device_detach_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t) -> ::core::ffi::c_int>;
#[doc = " @brief A function implementing the DEVICE_SHUTDOWN() method"]
pub type device_shutdown_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t) -> ::core::ffi::c_int>;
#[doc = " @brief A function implementing the DEVICE_SUSPEND() method"]
pub type device_suspend_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t) -> ::core::ffi::c_int>;
#[doc = " @brief A function implementing the DEVICE_RESUME() method"]
pub type device_resume_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t) -> ::core::ffi::c_int>;
#[doc = " @brief A function implementing the DEVICE_QUIESCE() method"]
pub type device_quiesce_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t) -> ::core::ffi::c_int>;
#[doc = " @brief A function implementing the DEVICE_REGISTER() method"]
pub type device_register_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t) -> *mut ::core::ffi::c_void>;
#[doc = " @brief A function implementing the BUS_PRINT_CHILD() method"]
pub type bus_print_child_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_PROBE_NOMATCH() method"]
pub type bus_probe_nomatch_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t, _child: device_t)>;
#[doc = " @brief A function implementing the BUS_READ_IVAR() method"]
pub type bus_read_ivar_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _index: ::core::ffi::c_int,
        _result: *mut usize,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_WRITE_IVAR() method"]
pub type bus_write_ivar_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _indx: ::core::ffi::c_int,
        _value: usize,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_CHILD_DELETED() method"]
pub type bus_child_deleted_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t, _child: device_t)>;
#[doc = " @brief A function implementing the BUS_CHILD_DETACHED() method"]
pub type bus_child_detached_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t, _child: device_t)>;
#[doc = " @brief A function implementing the BUS_DRIVER_ADDED() method"]
pub type bus_driver_added_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t, _driver: *mut driver_t)>;
#[doc = " @brief A function implementing the BUS_ADD_CHILD() method"]
pub type bus_add_child_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _order: u_int,
        _name: *const ::core::ffi::c_char,
        _unit: ::core::ffi::c_int,
    ) -> device_t,
>;
#[doc = " @brief A function implementing the BUS_RESCAN() method"]
pub type bus_rescan_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t) -> ::core::ffi::c_int>;
#[doc = " @brief A function implementing the BUS_ALLOC_RESOURCE() method"]
pub type bus_alloc_resource_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _type: ::core::ffi::c_int,
        _rid: *mut ::core::ffi::c_int,
        _start: rman_res_t,
        _end: rman_res_t,
        _count: rman_res_t,
        _flags: u_int,
    ) -> *mut resource,
>;
#[doc = " @brief A function implementing the BUS_ACTIVATE_RESOURCE() method"]
pub type bus_activate_resource_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t, _r: *mut resource) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_MAP_RESOURCE() method"]
pub type bus_map_resource_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _r: *mut resource,
        _args: *mut resource_map_request,
        _map: *mut resource_map,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_UNMAP_RESOURCE() method"]
pub type bus_unmap_resource_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _r: *mut resource,
        _map: *mut resource_map,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_DEACTIVATE_RESOURCE() method"]
pub type bus_deactivate_resource_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t, _r: *mut resource) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_ADJUST_RESOURCE() method"]
pub type bus_adjust_resource_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _res: *mut resource,
        _start: rman_res_t,
        _end: rman_res_t,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_TRANSLATE_RESOURCE() method"]
pub type bus_translate_resource_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _type: ::core::ffi::c_int,
        _start: rman_res_t,
        _newstart: *mut rman_res_t,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_RELEASE_RESOURCE() method"]
pub type bus_release_resource_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _res: *mut resource,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_SETUP_INTR() method"]
pub type bus_setup_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _irq: *mut resource,
        _flags: ::core::ffi::c_int,
        _filter: driver_filter_t,
        _intr: driver_intr_t,
        _arg: *mut ::core::ffi::c_void,
        _cookiep: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_TEARDOWN_INTR() method"]
pub type bus_teardown_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _irq: *mut resource,
        _cookie: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_SUSPEND_INTR() method"]
pub type bus_suspend_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _irq: *mut resource,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_RESUME_INTR() method"]
pub type bus_resume_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _irq: *mut resource,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_SET_RESOURCE() method"]
pub type bus_set_resource_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _type: ::core::ffi::c_int,
        _rid: ::core::ffi::c_int,
        _start: rman_res_t,
        _count: rman_res_t,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_GET_RESOURCE() method"]
pub type bus_get_resource_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _type: ::core::ffi::c_int,
        _rid: ::core::ffi::c_int,
        _startp: *mut rman_res_t,
        _countp: *mut rman_res_t,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_DELETE_RESOURCE() method"]
pub type bus_delete_resource_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _type: ::core::ffi::c_int,
        _rid: ::core::ffi::c_int,
    ),
>;
#[doc = " @brief A function implementing the BUS_GET_RESOURCE_LIST() method"]
pub type bus_get_resource_list_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t) -> *mut resource_list,
>;
#[doc = " @brief A function implementing the BUS_GET_RMAN() method"]
pub type bus_get_rman_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _type: ::core::ffi::c_int, _flags: u_int) -> *mut rman,
>;
#[doc = " @brief A function implementing the BUS_CHILD_PRESENT() method"]
pub type bus_child_present_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_CHILD_PNPINFO() method"]
pub type bus_child_pnpinfo_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t, _sb: *mut sbuf) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_CHILD_LOCATION() method"]
pub type bus_child_location_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t, _sb: *mut sbuf) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_BIND_INTR() method"]
pub type bus_bind_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _irq: *mut resource,
        _cpu: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_CONFIG_INTR() method"]
pub type bus_config_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _irq: ::core::ffi::c_int,
        _trig: intr_trigger,
        _pol: intr_polarity,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_DESCRIBE_INTR() method"]
pub type bus_describe_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _irq: *mut resource,
        _cookie: *mut ::core::ffi::c_void,
        _descr: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_HINTED_CHILD() method"]
pub type bus_hinted_child_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _dname: *const ::core::ffi::c_char,
        _dunit: ::core::ffi::c_int,
    ),
>;
#[doc = " @brief A function implementing the BUS_GET_DMA_TAG() method"]
pub type bus_get_dma_tag_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t, _child: device_t) -> bus_dma_tag_t>;
#[doc = " @brief A function implementing the BUS_GET_BUS_TAG() method"]
pub type bus_get_bus_tag_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t) -> bus_space_tag_t,
>;
#[doc = " @brief A function implementing the BUS_HINT_DEVICE_UNIT() method"]
pub type bus_hint_device_unit_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _name: *const ::core::ffi::c_char,
        _unitp: *mut ::core::ffi::c_int,
    ),
>;
#[doc = " @brief A function implementing the BUS_NEW_PASS() method"]
pub type bus_new_pass_t = ::core::option::Option<unsafe extern "C" fn(_dev: device_t)>;
#[doc = " @brief A function implementing the BUS_REMAP_INTR() method"]
pub type bus_remap_intr_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t, _irq: u_int) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_SUSPEND_CHILD() method"]
pub type bus_suspend_child_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_RESUME_CHILD() method"]
pub type bus_resume_child_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_GET_DOMAIN() method"]
pub type bus_get_domain_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _domain: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_GET_CPUS() method"]
pub type bus_get_cpus_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _op: cpu_sets,
        _setsize: usize,
        _cpuset: *mut _cpuset,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_RESET_PREPARE() method"]
pub type bus_reset_prepare_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_RESET_POST() method"]
pub type bus_reset_post_t = ::core::option::Option<
    unsafe extern "C" fn(_dev: device_t, _child: device_t) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_RESET_CHILD() method"]
pub type bus_reset_child_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the BUS_GET_PROPERTY() method"]
pub type bus_get_property_t = ::core::option::Option<
    unsafe extern "C" fn(
        _dev: device_t,
        _child: device_t,
        _propname: *const ::core::ffi::c_char,
        _propvalue: *mut ::core::ffi::c_void,
        _size: usize,
        type_: device_property_type_t,
    ) -> isize,
>;
#[doc = " @brief A function implementing the BUS_GET_DEVICE_PATH() method"]
pub type bus_get_device_path_t = ::core::option::Option<
    unsafe extern "C" fn(
        _bus: device_t,
        _child: device_t,
        _locator: *const ::core::ffi::c_char,
        _sb: *mut sbuf,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug)]
pub struct module {
    _unused: [u8; 0],
}
#[doc = " Module support for automatically adding drivers to buses."]
#[repr(C)]
#[derive(Debug)]
pub struct driver_module_data {
    pub dmd_chainevh: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut module,
            arg2: ::core::ffi::c_int,
            arg3: *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    pub dmd_chainarg: *mut ::core::ffi::c_void,
    pub dmd_busname: *const ::core::ffi::c_char,
    pub dmd_driver: kobj_class_t,
    pub dmd_devclass: *mut devclass_t,
    pub dmd_pass: ::core::ffi::c_int,
}
impl Default for driver_module_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct device_location_cache {
    _unused: [u8; 0],
}
pub type device_location_cache_t = device_location_cache;
pub type device_prop_dtr_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: device_t,
        name: *const ::core::ffi::c_char,
        val: *mut ::core::ffi::c_void,
        dtr_ctx: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug)]
pub struct setlist {
    pub lh_first: *mut cpuset,
}
impl Default for setlist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cpuset {
    pub cs_ref: u_int,
    pub cs_flags: ::core::ffi::c_int,
    pub cs_link: cpuset__bindgen_ty_1,
    pub cs_siblings: cpuset__bindgen_ty_2,
    pub cs_children: setlist,
    pub cs_domain: *mut domainset,
    pub cs_id: cpusetid_t,
    pub cs_parent: *mut cpuset,
    pub cs_mask: cpuset_t,
}
#[repr(C)]
#[derive(Debug)]
pub struct cpuset__bindgen_ty_1 {
    pub le_next: *mut cpuset,
    pub le_prev: *mut *mut cpuset,
}
impl Default for cpuset__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cpuset__bindgen_ty_2 {
    pub le_next: *mut cpuset,
    pub le_prev: *mut *mut cpuset,
}
impl Default for cpuset__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for cpuset {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct prison {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct cpuset_copy_cb {
    pub cpuset_copyin: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::core::ffi::c_void,
            arg2: *mut ::core::ffi::c_void,
            arg3: usize,
        ) -> ::core::ffi::c_int,
    >,
    pub cpuset_copyout: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::core::ffi::c_void,
            arg2: *mut ::core::ffi::c_void,
            arg3: usize,
        ) -> ::core::ffi::c_int,
    >,
}
pub type ihandle_t = u32;
pub type phandle_t = u32;
pub type pcell_t = u32;
#[repr(C)]
#[derive(Debug, Default)]
pub struct malloc_type_stats {
    pub mts_memalloced: u64,
    pub mts_memfreed: u64,
    pub mts_numallocs: u64,
    pub mts_numfrees: u64,
    pub mts_size: u64,
    pub _mts_reserved1: u64,
    pub _mts_reserved2: u64,
    pub _mts_reserved3: u64,
}
#[repr(C)]
#[derive(Debug)]
pub struct malloc_type_internal {
    pub mti_probes: [u32; 2usize],
    pub mti_zone: u_char,
    pub mti_stats: *mut malloc_type_stats,
    pub mti_spare: [u_long; 8usize],
}
impl Default for malloc_type_internal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct malloc_type {
    pub ks_next: *mut malloc_type,
    pub ks_version: u_long,
    pub ks_shortdesc: *const ::core::ffi::c_char,
    pub ks_mti: malloc_type_internal,
}
impl Default for malloc_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct malloc_type_stream_header {
    pub mtsh_version: u32,
    pub mtsh_maxcpus: u32,
    pub mtsh_count: u32,
    pub _mtsh_pad: u32,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct malloc_type_header {
    pub mth_name: [::core::ffi::c_char; 32usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct domainset {
    _unused: [u8; 0],
}
pub type malloc_type_list_func_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut malloc_type, arg2: *mut ::core::ffi::c_void),
>;
pub type vm_inherit_t = ::core::ffi::c_char;
pub type vm_prot_t = u_char;
pub const OBJT_RESERVED: obj_type = 0;
pub const OBJT_SWAP: obj_type = 1;
pub const OBJT_DEFAULT: obj_type = 1;
pub const OBJT_VNODE: obj_type = 2;
pub const OBJT_DEVICE: obj_type = 3;
pub const OBJT_PHYS: obj_type = 4;
pub const OBJT_DEAD: obj_type = 5;
pub const OBJT_SG: obj_type = 6;
pub const OBJT_MGTDEVICE: obj_type = 7;
pub const OBJT_FIRST_DYN: obj_type = 8;
pub type obj_type = ::core::ffi::c_uint;
pub type objtype_t = u_char;
#[repr(C)]
pub struct vm_map_object {
    _unused: [u8; 0],
}
pub type vm_map_object_t = vm_map_object;
#[repr(C)]
#[derive(Debug)]
pub struct vm_map_entry {
    _unused: [u8; 0],
}
pub type vm_map_entry_t = *mut vm_map_entry;
#[repr(C)]
#[derive(Debug)]
pub struct vm_map {
    _unused: [u8; 0],
}
pub type vm_map_t = *mut vm_map;
#[repr(C)]
#[derive(Debug)]
pub struct vm_object {
    _unused: [u8; 0],
}
pub type vm_object_t = *mut vm_object;
#[repr(C)]
#[derive(Debug)]
pub struct vm_reserv {
    _unused: [u8; 0],
}
pub type vm_reserv_t = *mut vm_reserv;
#[repr(C)]
#[derive(Debug, Default)]
pub struct kva_md_info {
    pub buffer_sva: vm_offset_t,
    pub buffer_eva: vm_offset_t,
    pub clean_sva: vm_offset_t,
    pub clean_eva: vm_offset_t,
}
pub type cell_t = u32;
#[repr(C)]
#[derive(Debug, Default)]
pub struct mem_region {
    pub mr_start: vm_offset_t,
    pub mr_size: vm_size_t,
}
pub const INTR_MAP_DATA_ACPI: intr_map_data_type = 0;
pub const INTR_MAP_DATA_FDT: intr_map_data_type = 1;
pub const INTR_MAP_DATA_GPIO: intr_map_data_type = 2;
pub const INTR_MAP_DATA_MSI: intr_map_data_type = 3;
pub const INTR_MAP_DATA_PLAT_1: intr_map_data_type = 1000;
pub const INTR_MAP_DATA_PLAT_2: intr_map_data_type = 1001;
pub const INTR_MAP_DATA_PLAT_3: intr_map_data_type = 1002;
pub const INTR_MAP_DATA_PLAT_4: intr_map_data_type = 1003;
pub const INTR_MAP_DATA_PLAT_5: intr_map_data_type = 1004;
pub type intr_map_data_type = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct intr_map_data {
    pub len: usize,
    pub type_: intr_map_data_type,
}
impl Default for intr_map_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct intr_map_data_msi {
    pub hdr: intr_map_data,
    pub isrc: *mut intr_irqsrc,
}
impl Default for intr_map_data_msi {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type intr_irq_filter_t = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
>;
pub type intr_child_irq_filter_t = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, irq: usize) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug)]
pub struct intr_pic {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct intr_irqsrc {
    pub isrc_dev: device_t,
    pub isrc_irq: u_int,
    pub isrc_flags: u_int,
    pub isrc_name: [::core::ffi::c_char; 20usize],
    pub isrc_cpu: cpuset_t,
    pub isrc_index: u_int,
    pub isrc_count: *mut u_long,
    pub isrc_handlers: u_int,
    pub isrc_event: *mut intr_event,
    pub isrc_iommu: *mut ::core::ffi::c_void,
}
impl Default for intr_irqsrc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type intr_ipi_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
pub const SI_SUB_DUMMY: sysinit_sub_id = 0;
pub const SI_SUB_TUNABLES: sysinit_sub_id = 7340032;
pub const SI_SUB_COPYRIGHT: sysinit_sub_id = 8388609;
pub const SI_SUB_VM: sysinit_sub_id = 16777216;
pub const SI_SUB_COUNTER: sysinit_sub_id = 17825792;
pub const SI_SUB_KMEM: sysinit_sub_id = 25165824;
pub const SI_SUB_HYPERVISOR: sysinit_sub_id = 27525120;
pub const SI_SUB_WITNESS: sysinit_sub_id = 27787264;
pub const SI_SUB_MTX_POOL_DYNAMIC: sysinit_sub_id = 28049408;
pub const SI_SUB_LOCK: sysinit_sub_id = 28311552;
pub const SI_SUB_EVENTHANDLER: sysinit_sub_id = 29360128;
pub const SI_SUB_VNET_PRELINK: sysinit_sub_id = 31457280;
pub const SI_SUB_KLD: sysinit_sub_id = 33554432;
pub const SI_SUB_KHELP: sysinit_sub_id = 34078720;
pub const SI_SUB_CPU: sysinit_sub_id = 34603008;
pub const SI_SUB_RACCT: sysinit_sub_id = 34668544;
pub const SI_SUB_KDTRACE: sysinit_sub_id = 34865152;
pub const SI_SUB_RANDOM: sysinit_sub_id = 34996224;
pub const SI_SUB_MAC: sysinit_sub_id = 35127296;
pub const SI_SUB_MAC_POLICY: sysinit_sub_id = 35389440;
pub const SI_SUB_MAC_LATE: sysinit_sub_id = 35454976;
pub const SI_SUB_VNET: sysinit_sub_id = 35520512;
pub const SI_SUB_INTRINSIC: sysinit_sub_id = 35651584;
pub const SI_SUB_VM_CONF: sysinit_sub_id = 36700160;
pub const SI_SUB_DDB_SERVICES: sysinit_sub_id = 37224448;
pub const SI_SUB_RUN_QUEUE: sysinit_sub_id = 37748736;
pub const SI_SUB_KTRACE: sysinit_sub_id = 38273024;
pub const SI_SUB_OPENSOLARIS: sysinit_sub_id = 38338560;
pub const SI_SUB_AUDIT: sysinit_sub_id = 38535168;
pub const SI_SUB_CREATE_INIT: sysinit_sub_id = 38797312;
pub const SI_SUB_SCHED_IDLE: sysinit_sub_id = 39845888;
pub const SI_SUB_MBUF: sysinit_sub_id = 40894464;
pub const SI_SUB_INTR: sysinit_sub_id = 41943040;
pub const SI_SUB_TASKQ: sysinit_sub_id = 42467328;
pub const SI_SUB_EPOCH: sysinit_sub_id = 42500096;
pub const SI_SUB_SOFTINTR: sysinit_sub_id = 44040192;
pub const SI_SUB_DEVFS: sysinit_sub_id = 49283072;
pub const SI_SUB_INIT_IF: sysinit_sub_id = 50331648;
pub const SI_SUB_NETGRAPH: sysinit_sub_id = 50397184;
pub const SI_SUB_DTRACE: sysinit_sub_id = 50462720;
pub const SI_SUB_DTRACE_PROVIDER: sysinit_sub_id = 50626560;
pub const SI_SUB_DTRACE_ANON: sysinit_sub_id = 50905088;
pub const SI_SUB_DRIVERS: sysinit_sub_id = 51380224;
pub const SI_SUB_CONFIGURE: sysinit_sub_id = 58720256;
pub const SI_SUB_VFS: sysinit_sub_id = 67108864;
pub const SI_SUB_CLOCKS: sysinit_sub_id = 75497472;
pub const SI_SUB_SYSV_SHM: sysinit_sub_id = 104857600;
pub const SI_SUB_SYSV_SEM: sysinit_sub_id = 109051904;
pub const SI_SUB_SYSV_MSG: sysinit_sub_id = 113246208;
pub const SI_SUB_P1003_1B: sysinit_sub_id = 115343360;
pub const SI_SUB_PSEUDO: sysinit_sub_id = 117440512;
pub const SI_SUB_EXEC: sysinit_sub_id = 121634816;
pub const SI_SUB_PROTO_BEGIN: sysinit_sub_id = 134217728;
pub const SI_SUB_PROTO_PFIL: sysinit_sub_id = 135266304;
pub const SI_SUB_PROTO_IF: sysinit_sub_id = 138412032;
pub const SI_SUB_PROTO_DOMAININIT: sysinit_sub_id = 140509184;
pub const SI_SUB_PROTO_MC: sysinit_sub_id = 141557760;
pub const SI_SUB_PROTO_DOMAIN: sysinit_sub_id = 142606336;
pub const SI_SUB_PROTO_FIREWALL: sysinit_sub_id = 142630912;
pub const SI_SUB_PROTO_IFATTACHDOMAIN: sysinit_sub_id = 142639104;
pub const SI_SUB_PROTO_END: sysinit_sub_id = 150994943;
pub const SI_SUB_KPROF: sysinit_sub_id = 150994944;
pub const SI_SUB_KICK_SCHEDULER: sysinit_sub_id = 167772160;
pub const SI_SUB_INT_CONFIG_HOOKS: sysinit_sub_id = 176160768;
pub const SI_SUB_ROOT_CONF: sysinit_sub_id = 184549376;
pub const SI_SUB_INTRINSIC_POST: sysinit_sub_id = 218103808;
pub const SI_SUB_SYSCALLS: sysinit_sub_id = 226492416;
pub const SI_SUB_VNET_DONE: sysinit_sub_id = 230686720;
pub const SI_SUB_KTHREAD_INIT: sysinit_sub_id = 234881024;
pub const SI_SUB_KTHREAD_PAGE: sysinit_sub_id = 239075328;
pub const SI_SUB_KTHREAD_VM: sysinit_sub_id = 243269632;
pub const SI_SUB_KTHREAD_BUF: sysinit_sub_id = 245366784;
pub const SI_SUB_KTHREAD_UPDATE: sysinit_sub_id = 247463936;
pub const SI_SUB_KTHREAD_IDLE: sysinit_sub_id = 249561088;
pub const SI_SUB_SMP: sysinit_sub_id = 251658240;
pub const SI_SUB_RACCTD: sysinit_sub_id = 252706816;
pub const SI_SUB_LAST: sysinit_sub_id = 268435455;
pub type sysinit_sub_id = ::core::ffi::c_uint;
pub const SI_ORDER_FIRST: sysinit_elem_order = 0;
pub const SI_ORDER_SECOND: sysinit_elem_order = 1;
pub const SI_ORDER_THIRD: sysinit_elem_order = 2;
pub const SI_ORDER_FOURTH: sysinit_elem_order = 3;
pub const SI_ORDER_FIFTH: sysinit_elem_order = 4;
pub const SI_ORDER_SIXTH: sysinit_elem_order = 5;
pub const SI_ORDER_SEVENTH: sysinit_elem_order = 6;
pub const SI_ORDER_EIGHTH: sysinit_elem_order = 7;
pub const SI_ORDER_MIDDLE: sysinit_elem_order = 16777216;
pub const SI_ORDER_ANY: sysinit_elem_order = 268435455;
pub type sysinit_elem_order = ::core::ffi::c_uint;
pub type sysinit_nfunc_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
pub type sysinit_cfunc_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *const ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug)]
pub struct sysinit {
    pub subsystem: sysinit_sub_id,
    pub order: sysinit_elem_order,
    pub next: sysinit__bindgen_ty_1,
    pub func: sysinit_cfunc_t,
    pub udata: *const ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug)]
pub struct sysinit__bindgen_ty_1 {
    pub stqe_next: *mut sysinit,
}
impl Default for sysinit__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sysinit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct tunable_int {
    pub path: *const ::core::ffi::c_char,
    pub var: *mut ::core::ffi::c_int,
}
impl Default for tunable_int {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct tunable_long {
    pub path: *const ::core::ffi::c_char,
    pub var: *mut ::core::ffi::c_long,
}
impl Default for tunable_long {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct tunable_ulong {
    pub path: *const ::core::ffi::c_char,
    pub var: *mut ::core::ffi::c_ulong,
}
impl Default for tunable_ulong {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct tunable_int64 {
    pub path: *const ::core::ffi::c_char,
    pub var: *mut i64,
}
impl Default for tunable_int64 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct tunable_uint64 {
    pub path: *const ::core::ffi::c_char,
    pub var: *mut u64,
}
impl Default for tunable_uint64 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct tunable_quad {
    pub path: *const ::core::ffi::c_char,
    pub var: *mut quad_t,
}
impl Default for tunable_quad {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct tunable_bool {
    pub path: *const ::core::ffi::c_char,
    pub var: *mut bool_,
}
impl Default for tunable_bool {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct tunable_str {
    pub path: *const ::core::ffi::c_char,
    pub var: *mut ::core::ffi::c_char,
    pub size: ::core::ffi::c_int,
}
impl Default for tunable_str {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ich_func_t = ::core::option::Option<unsafe extern "C" fn(_arg: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug)]
pub struct intr_config_hook {
    pub ich_links: intr_config_hook__bindgen_ty_1,
    pub ich_state: usize,
    pub ich_func: ich_func_t,
    pub ich_arg: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug)]
pub struct intr_config_hook__bindgen_ty_1 {
    pub stqe_next: *mut intr_config_hook,
}
impl Default for intr_config_hook__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for intr_config_hook {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct lock_list_entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct lock_class {
    pub lc_name: *const ::core::ffi::c_char,
    pub lc_flags: u_int,
    pub lc_assert: ::core::option::Option<
        unsafe extern "C" fn(lock: *const lock_object, what: ::core::ffi::c_int),
    >,
    pub lc_ddb_show: ::core::option::Option<unsafe extern "C" fn(lock: *const lock_object)>,
    pub lc_lock: ::core::option::Option<unsafe extern "C" fn(lock: *mut lock_object, how: usize)>,
    pub lc_owner: ::core::option::Option<
        unsafe extern "C" fn(
            lock: *const lock_object,
            owner: *mut *mut thread,
        ) -> ::core::ffi::c_int,
    >,
    pub lc_unlock: ::core::option::Option<unsafe extern "C" fn(lock: *mut lock_object) -> usize>,
    pub lc_trylock: ::core::option::Option<
        unsafe extern "C" fn(lock: *mut lock_object, how: usize) -> ::core::ffi::c_int,
    >,
}
impl Default for lock_class {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct lock_delay_config {
    pub base: u_short,
    pub max: u_short,
}
#[repr(C)]
#[derive(Debug)]
pub struct lock_delay_arg {
    pub config: *mut lock_delay_config,
    pub delay: u_int,
    pub spin_cnt: u_int,
}
impl Default for lock_delay_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const MOD_LOAD: modeventtype = 0;
pub const MOD_UNLOAD: modeventtype = 1;
pub const MOD_SHUTDOWN: modeventtype = 2;
pub const MOD_QUIESCE: modeventtype = 3;
pub type modeventtype = ::core::ffi::c_uint;
pub use self::modeventtype as modeventtype_t;
pub type module_t = *mut module;
pub type modeventhand_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: module_t,
        arg2: ::core::ffi::c_int,
        arg3: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug)]
pub struct moduledata {
    pub name: *const ::core::ffi::c_char,
    pub evhand: modeventhand_t,
    pub priv_: *mut ::core::ffi::c_void,
}
impl Default for moduledata {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type moduledata_t = moduledata;
#[repr(C)]
pub struct modspecific {
    pub intval: __BindgenUnionField<::core::ffi::c_int>,
    pub uintval: __BindgenUnionField<u_int>,
    pub longval: __BindgenUnionField<::core::ffi::c_long>,
    pub ulongval: __BindgenUnionField<u_long>,
    pub bindgen_union_field: u64,
}
impl Default for modspecific {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type modspecific_t = modspecific;
#[repr(C)]
#[derive(Debug, Default)]
pub struct mod_depend {
    pub md_ver_minimum: ::core::ffi::c_int,
    pub md_ver_preferred: ::core::ffi::c_int,
    pub md_ver_maximum: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct mod_version {
    pub mv_version: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct mod_metadata {
    pub md_version: ::core::ffi::c_int,
    pub md_type: ::core::ffi::c_int,
    pub md_data: *const ::core::ffi::c_void,
    pub md_cval: *const ::core::ffi::c_char,
}
impl Default for mod_metadata {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct mod_pnp_match_info {
    pub descr: *const ::core::ffi::c_char,
    pub bus: *const ::core::ffi::c_char,
    pub table: *const ::core::ffi::c_void,
    pub entry_len: ::core::ffi::c_int,
    pub num_entry: ::core::ffi::c_int,
}
impl Default for mod_pnp_match_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct linker_file {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct module_stat {
    pub version: ::core::ffi::c_int,
    pub name: [::core::ffi::c_char; 1024usize],
    pub refs: ::core::ffi::c_int,
    pub id: ::core::ffi::c_int,
    pub data: modspecific_t,
}
impl Default for module_stat {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct lock_profile_object {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct lpohead {
    pub lh_first: *mut lock_profile_object,
}
impl Default for lpohead {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct sdt_tracepoint {
    pub probe: *mut sdt_probe,
    pub patchpoint: usize,
    pub target: usize,
    pub tracepoint_entry: sdt_tracepoint__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug)]
pub struct sdt_tracepoint__bindgen_ty_1 {
    pub stqe_next: *mut sdt_tracepoint,
}
impl Default for sdt_tracepoint__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sdt_tracepoint {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sdt_probe_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: u32,
        arg0: usize,
        arg1: usize,
        arg2: usize,
        arg3: usize,
        arg4: usize,
        arg5: usize,
    ),
>;
#[repr(C)]
#[derive(Debug)]
pub struct sdt_argtype {
    pub ndx: ::core::ffi::c_int,
    pub type_: *const ::core::ffi::c_char,
    pub xtype: *const ::core::ffi::c_char,
    pub argtype_entry: sdt_argtype__bindgen_ty_1,
    pub probe: *mut sdt_probe,
}
#[repr(C)]
#[derive(Debug)]
pub struct sdt_argtype__bindgen_ty_1 {
    pub tqe_next: *mut sdt_argtype,
    pub tqe_prev: *mut *mut sdt_argtype,
}
impl Default for sdt_argtype__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sdt_argtype {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct sdt_probe {
    pub version: ::core::ffi::c_int,
    pub prov: *mut sdt_provider,
    pub probe_entry: sdt_probe__bindgen_ty_1,
    pub argtype_list: sdt_probe__bindgen_ty_2,
    pub tracepoint_list: sdt_probe__bindgen_ty_3,
    pub mod_: *const ::core::ffi::c_char,
    pub func: *const ::core::ffi::c_char,
    pub name: *const ::core::ffi::c_char,
    pub id: id_t,
    pub n_args: ::core::ffi::c_int,
    pub sdtp_lf: *mut linker_file,
}
#[repr(C)]
#[derive(Debug)]
pub struct sdt_probe__bindgen_ty_1 {
    pub tqe_next: *mut sdt_probe,
    pub tqe_prev: *mut *mut sdt_probe,
}
impl Default for sdt_probe__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct sdt_probe__bindgen_ty_2 {
    pub tqh_first: *mut sdt_argtype,
    pub tqh_last: *mut *mut sdt_argtype,
}
impl Default for sdt_probe__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct sdt_probe__bindgen_ty_3 {
    pub stqh_first: *mut sdt_tracepoint,
    pub stqh_last: *mut *mut sdt_tracepoint,
}
impl Default for sdt_probe__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sdt_probe {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct sdt_provider {
    pub name: *mut ::core::ffi::c_char,
    pub prov_entry: sdt_provider__bindgen_ty_1,
    pub id: usize,
    pub sdt_refs: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct sdt_provider__bindgen_ty_1 {
    pub tqe_next: *mut sdt_provider,
    pub tqe_prev: *mut *mut sdt_provider,
}
impl Default for sdt_provider__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sdt_provider {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct mtx_pool {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct mtx_args {
    pub ma_mtx: *mut ::core::ffi::c_void,
    pub ma_desc: *const ::core::ffi::c_char,
    pub ma_opts: ::core::ffi::c_int,
}
impl Default for mtx_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct kevent {
    pub ident: __uintptr_t,
    pub filter: ::core::ffi::c_short,
    pub flags: ::core::ffi::c_ushort,
    pub fflags: ::core::ffi::c_uint,
    pub data: __int64_t,
    pub udata: *mut ::core::ffi::c_void,
    pub ext: [__uint64_t; 4usize],
}
impl Default for kevent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct kevent32 {
    pub ident: __uint32_t,
    pub filter: ::core::ffi::c_short,
    pub flags: ::core::ffi::c_ushort,
    pub fflags: ::core::ffi::c_uint,
    pub pad0: __uint32_t,
    pub data1: __uint32_t,
    pub data2: __uint32_t,
    pub udata: __uint32_t,
    pub pad1: __uint32_t,
    pub ext64: [__uint32_t; 8usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct klist {
    pub slh_first: *mut knote,
}
impl Default for klist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct kqueue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct kqlist {
    pub tqh_first: *mut kqueue,
    pub tqh_last: *mut *mut kqueue,
}
impl Default for kqlist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct knlist {
    pub kl_list: klist,
    pub kl_lock: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
    pub kl_unlock: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
    pub kl_assert_lock: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: ::core::ffi::c_int),
    >,
    pub kl_lockarg: *mut ::core::ffi::c_void,
    pub kl_autodestroy: ::core::ffi::c_int,
}
impl Default for knlist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct kinfo_knote {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct filterops {
    pub f_isfd: ::core::ffi::c_int,
    pub f_attach:
        ::core::option::Option<unsafe extern "C" fn(kn: *mut knote) -> ::core::ffi::c_int>,
    pub f_detach: ::core::option::Option<unsafe extern "C" fn(kn: *mut knote)>,
    pub f_event: ::core::option::Option<
        unsafe extern "C" fn(kn: *mut knote, hint: ::core::ffi::c_long) -> ::core::ffi::c_int,
    >,
    pub f_touch: ::core::option::Option<
        unsafe extern "C" fn(kn: *mut knote, kev: *mut kevent, type_: u_long),
    >,
    pub f_userdump: ::core::option::Option<
        unsafe extern "C" fn(
            p: *mut proc_,
            kn: *mut knote,
            kin: *mut kinfo_knote,
        ) -> ::core::ffi::c_int,
    >,
    pub f_copy: ::core::option::Option<
        unsafe extern "C" fn(kn: *mut knote, p1: *mut proc_) -> ::core::ffi::c_int,
    >,
}
#[repr(C)]
pub struct knote {
    pub kn_link: knote__bindgen_ty_1,
    pub kn_selnext: knote__bindgen_ty_2,
    pub kn_knlist: *mut knlist,
    pub kn_tqe: knote__bindgen_ty_3,
    pub kn_kq: *mut kqueue,
    pub kn_kevent: kevent,
    pub kn_hook: *mut ::core::ffi::c_void,
    pub kn_hookid: ::core::ffi::c_int,
    pub kn_status: ::core::ffi::c_int,
    pub kn_influx: ::core::ffi::c_int,
    pub kn_sfflags: ::core::ffi::c_int,
    pub kn_sdata: i64,
    pub kn_ptr: knote__bindgen_ty_4,
    pub kn_fop: *const filterops,
}
#[repr(C)]
#[derive(Debug)]
pub struct knote__bindgen_ty_1 {
    pub sle_next: *mut knote,
}
impl Default for knote__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct knote__bindgen_ty_2 {
    pub sle_next: *mut knote,
}
impl Default for knote__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct knote__bindgen_ty_3 {
    pub tqe_next: *mut knote,
    pub tqe_prev: *mut *mut knote,
}
impl Default for knote__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct knote__bindgen_ty_4 {
    pub p_fp: __BindgenUnionField<*mut file>,
    pub p_proc: __BindgenUnionField<*mut proc_>,
    pub p_aio: __BindgenUnionField<*mut kaiocb>,
    pub p_lio: __BindgenUnionField<*mut aioliojob>,
    pub p_prison: __BindgenUnionField<*mut prison>,
    pub p_v: __BindgenUnionField<*mut ::core::ffi::c_void>,
    pub bindgen_union_field: u64,
}
impl Default for knote__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for knote {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct kevent_copyops {
    pub arg: *mut ::core::ffi::c_void,
    pub k_copyout: ::core::option::Option<
        unsafe extern "C" fn(
            arg: *mut ::core::ffi::c_void,
            kevp: *mut kevent,
            count: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub k_copyin: ::core::option::Option<
        unsafe extern "C" fn(
            arg: *mut ::core::ffi::c_void,
            kevp: *mut kevent,
            count: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub kevent_size: usize,
}
impl Default for kevent_copyops {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct kexterr {
    pub error: ::core::ffi::c_int,
    pub msg: *const ::core::ffi::c_char,
    pub p1: __uint64_t,
    pub p2: __uint64_t,
    pub cat: ::core::ffi::c_uint,
    pub src_line: ::core::ffi::c_uint,
}
impl Default for kexterr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cv {
    pub cv_description: *const ::core::ffi::c_char,
    pub cv_waiters: ::core::ffi::c_int,
}
impl Default for cv {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct osd {
    pub osd_nslots: u_int,
    pub osd_slots: *mut *mut ::core::ffi::c_void,
    pub osd_next: osd__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug)]
pub struct osd__bindgen_ty_1 {
    pub le_next: *mut osd,
    pub le_prev: *mut *mut osd,
}
impl Default for osd__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for osd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type osd_destructor_t =
    ::core::option::Option<unsafe extern "C" fn(value: *mut ::core::ffi::c_void)>;
pub type osd_method_t = ::core::option::Option<
    unsafe extern "C" fn(
        obj: *mut ::core::ffi::c_void,
        data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Default)]
pub struct rtprio {
    pub type_: u_short,
    pub prio: u_short,
}
#[repr(C)]
pub struct sigio {
    pub sio_u: sigio__bindgen_ty_1,
    pub sio_pgsigio: sigio__bindgen_ty_2,
    pub sio_myref: *mut *mut sigio,
    pub sio_ucred: *mut ucred,
    pub sio_pgid: pid_t,
}
#[repr(C)]
pub struct sigio__bindgen_ty_1 {
    pub siu_proc: __BindgenUnionField<*mut proc_>,
    pub siu_pgrp: __BindgenUnionField<*mut pgrp>,
    pub bindgen_union_field: u64,
}
impl Default for sigio__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct sigio__bindgen_ty_2 {
    pub sle_next: *mut sigio,
}
impl Default for sigio__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sigio {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct sigiolst {
    pub slh_first: *mut sigio,
}
impl Default for sigiolst {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct sigacts {
    pub ps_sigact: [sig_t; 128usize],
    pub ps_catchmask: [sigset_t; 128usize],
    pub ps_sigonstack: sigset_t,
    pub ps_sigintr: sigset_t,
    pub ps_sigreset: sigset_t,
    pub ps_signodefer: sigset_t,
    pub ps_siginfo: sigset_t,
    pub ps_sigignore: sigset_t,
    pub ps_sigcatch: sigset_t,
    pub ps_freebsd4: sigset_t,
    pub ps_osigset: sigset_t,
    pub ps_usertramp: sigset_t,
    pub ps_flag: ::core::ffi::c_int,
    pub ps_refcnt: u_int,
    pub ps_mtx: mtx,
}
impl Default for sigacts {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ksiginfo {
    pub ksi_link: ksiginfo__bindgen_ty_1,
    pub ksi_info: siginfo_t,
    pub ksi_flags: ::core::ffi::c_int,
    pub ksi_sigq: *mut sigqueue,
}
#[repr(C)]
#[derive(Debug)]
pub struct ksiginfo__bindgen_ty_1 {
    pub tqe_next: *mut ksiginfo,
    pub tqe_prev: *mut *mut ksiginfo,
}
impl Default for ksiginfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ksiginfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ksiginfo_t = ksiginfo;
#[repr(C)]
#[derive(Debug)]
pub struct sigqueue {
    pub sq_signals: sigset_t,
    pub sq_kill: sigset_t,
    pub sq_ptrace: sigset_t,
    pub sq_list: sigqueue__bindgen_ty_1,
    pub sq_proc: *mut proc_,
    pub sq_flags: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct sigqueue__bindgen_ty_1 {
    pub tqh_first: *mut ksiginfo,
    pub tqh_last: *mut *mut ksiginfo,
}
impl Default for sigqueue__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sigqueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sigqueue_t = sigqueue;
pub type au_id_t = uid_t;
pub type au_asid_t = pid_t;
pub type au_event_t = u_int16_t;
pub type au_emod_t = u_int16_t;
pub type au_class_t = u_int32_t;
pub type au_asflgs_t = u_int64_t;
#[repr(C)]
#[derive(Debug, Default)]
pub struct au_tid {
    pub port: u_int32_t,
    pub machine: u_int32_t,
}
pub type au_tid_t = au_tid;
#[repr(C)]
#[derive(Debug, Default)]
pub struct au_tid_addr {
    pub at_port: u_int32_t,
    pub at_type: u_int32_t,
    pub at_addr: [u_int32_t; 4usize],
}
pub type au_tid_addr_t = au_tid_addr;
#[repr(C)]
#[derive(Debug, Default)]
pub struct au_mask {
    pub am_success: ::core::ffi::c_uint,
    pub am_failure: ::core::ffi::c_uint,
}
pub type au_mask_t = au_mask;
#[repr(C)]
#[derive(Debug, Default)]
pub struct auditinfo {
    pub ai_auid: au_id_t,
    pub ai_mask: au_mask_t,
    pub ai_termid: au_tid_t,
    pub ai_asid: au_asid_t,
}
pub type auditinfo_t = auditinfo;
#[repr(C)]
#[derive(Debug, Default)]
pub struct auditinfo_addr {
    pub ai_auid: au_id_t,
    pub ai_mask: au_mask_t,
    pub ai_termid: au_tid_addr_t,
    pub ai_asid: au_asid_t,
    pub ai_flags: au_asflgs_t,
}
pub type auditinfo_addr_t = auditinfo_addr;
#[repr(C)]
#[derive(Debug, Default)]
pub struct auditpinfo {
    pub ap_pid: pid_t,
    pub ap_auid: au_id_t,
    pub ap_mask: au_mask_t,
    pub ap_termid: au_tid_t,
    pub ap_asid: au_asid_t,
}
pub type auditpinfo_t = auditpinfo;
#[repr(C)]
#[derive(Debug, Default)]
pub struct auditpinfo_addr {
    pub ap_pid: pid_t,
    pub ap_auid: au_id_t,
    pub ap_mask: au_mask_t,
    pub ap_termid: au_tid_addr_t,
    pub ap_asid: au_asid_t,
    pub ap_flags: au_asflgs_t,
}
pub type auditpinfo_addr_t = auditpinfo_addr;
#[repr(C)]
#[derive(Debug)]
pub struct au_session {
    pub as_aia_p: *mut auditinfo_addr_t,
    pub as_mask: au_mask_t,
}
impl Default for au_session {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type au_session_t = au_session;
#[repr(C)]
#[derive(Debug)]
pub struct au_token {
    _unused: [u8; 0],
}
pub type token_t = au_token;
#[repr(C)]
#[derive(Debug, Default)]
pub struct au_qctrl {
    pub aq_hiwater: ::core::ffi::c_int,
    pub aq_lowater: ::core::ffi::c_int,
    pub aq_bufsz: ::core::ffi::c_int,
    pub aq_delay: ::core::ffi::c_int,
    pub aq_minfree: ::core::ffi::c_int,
}
pub type au_qctrl_t = au_qctrl;
#[repr(C)]
#[derive(Debug, Default)]
pub struct audit_stat {
    pub as_version: ::core::ffi::c_uint,
    pub as_numevent: ::core::ffi::c_uint,
    pub as_generated: ::core::ffi::c_int,
    pub as_nonattrib: ::core::ffi::c_int,
    pub as_kernel: ::core::ffi::c_int,
    pub as_audit: ::core::ffi::c_int,
    pub as_auditctl: ::core::ffi::c_int,
    pub as_enqueue: ::core::ffi::c_int,
    pub as_written: ::core::ffi::c_int,
    pub as_wblocked: ::core::ffi::c_int,
    pub as_rblocked: ::core::ffi::c_int,
    pub as_dropped: ::core::ffi::c_int,
    pub as_totalsize: ::core::ffi::c_int,
    pub as_memused: ::core::ffi::c_uint,
}
pub type au_stat_t = audit_stat;
#[repr(C)]
#[derive(Debug, Default)]
pub struct audit_fstat {
    pub af_filesz: u_int64_t,
    pub af_currsz: u_int64_t,
}
pub type au_fstat_t = audit_fstat;
#[repr(C)]
#[derive(Debug, Default)]
pub struct au_evclass_map {
    pub ec_number: au_event_t,
    pub ec_class: au_class_t,
}
pub type au_evclass_map_t = au_evclass_map;
#[repr(C)]
#[derive(Debug)]
pub struct au_evname_map {
    pub en_number: au_event_t,
    pub en_name: [::core::ffi::c_char; 64usize],
}
impl Default for au_evname_map {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type au_evname_map_t = au_evname_map;
#[repr(C)]
#[derive(Debug)]
pub struct label {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct loginclass {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct uidinfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ucred {
    pub cr_mtx: mtx,
    pub cr_ref: ::core::ffi::c_long,
    pub cr_users: u_int,
    pub cr_flags: u_int,
    pub cr_audit: auditinfo_addr,
    pub cr_ngroups: ::core::ffi::c_int,
    pub cr_uid: uid_t,
    pub cr_ruid: uid_t,
    pub cr_svuid: uid_t,
    pub cr_gid: gid_t,
    pub cr_rgid: gid_t,
    pub cr_svgid: gid_t,
    pub cr_uidinfo: *mut uidinfo,
    pub cr_ruidinfo: *mut uidinfo,
    pub cr_prison: *mut prison,
    pub cr_loginclass: *mut loginclass,
    pub cr_pspare2: [*mut ::core::ffi::c_void; 2usize],
    pub cr_label: *mut label,
    pub cr_groups: *mut gid_t,
    pub cr_agroups: ::core::ffi::c_int,
    pub cr_smallgroups: [gid_t; 16usize],
}
impl Default for ucred {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct xucred {
    pub cr_version: u_int,
    pub cr_uid: uid_t,
    pub cr_ngroups: ::core::ffi::c_short,
    pub __bindgen_anon_1: xucred__bindgen_ty_1,
    pub __bindgen_anon_2: xucred__bindgen_ty_2,
}
#[repr(C)]
pub struct xucred__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<xucred__bindgen_ty_1__bindgen_ty_1>,
    pub cr_groups: __BindgenUnionField<[gid_t; 16usize]>,
    pub bindgen_union_field: [u32; 16usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct xucred__bindgen_ty_1__bindgen_ty_1 {
    pub cr_gid: gid_t,
    pub cr_sgroups: [gid_t; 15usize],
}
impl Default for xucred__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct xucred__bindgen_ty_2 {
    pub _cr_unused1: __BindgenUnionField<*mut ::core::ffi::c_void>,
    pub cr_pid: __BindgenUnionField<pid_t>,
    pub bindgen_union_field: u64,
}
impl Default for xucred__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for xucred {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct mac {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct setcred {
    pub sc_uid: uid_t,
    pub sc_ruid: uid_t,
    pub sc_svuid: uid_t,
    pub sc_gid: gid_t,
    pub sc_rgid: gid_t,
    pub sc_svgid: gid_t,
    pub sc_pad: u_int,
    pub sc_supp_groups_nb: u_int,
    pub sc_supp_groups: *mut gid_t,
    pub sc_label: *mut mac,
}
impl Default for setcred {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct setcred32 {
    pub sc_uid: uid_t,
    pub sc_ruid: uid_t,
    pub sc_svuid: uid_t,
    pub sc_gid: gid_t,
    pub sc_rgid: gid_t,
    pub sc_svgid: gid_t,
    pub sc_pad: u_int,
    pub sc_supp_groups_nb: u_int,
    pub sc_supp_groups: u32,
    pub sc_label: u32,
}
#[repr(C)]
#[derive(Debug)]
pub struct credbatch {
    pub cred: *mut ucred,
    pub users: u_int,
    pub ref_: ::core::ffi::c_long,
}
impl Default for credbatch {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct _domainset {
    pub __bits: [::core::ffi::c_ulong; 1usize],
}
pub type domainset_t = _domainset;
#[repr(C)]
#[derive(Debug)]
pub struct domainset_ref {
    pub dr_policy: *mut domainset,
    pub dr_iter: ::core::ffi::c_uint,
}
impl Default for domainset_ref {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct ptrauth_key {
    pub pa_key_lo: u64,
    pub pa_key_hi: u64,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct mdthread {
    pub md_spinlock_count: ::core::ffi::c_int,
    pub md_saved_daif: register_t,
    pub md_canary: usize,
    pub md_ptrauth_user: mdthread__bindgen_ty_1,
    pub md_ptrauth_kern: mdthread__bindgen_ty_2,
    pub md_efirt_tmp: u64,
    pub md_efirt_dis_pf: ::core::ffi::c_int,
    pub md_reserved0: ::core::ffi::c_int,
    pub md_reserved: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct mdthread__bindgen_ty_1 {
    pub apia: ptrauth_key,
    pub apib: ptrauth_key,
    pub apda: ptrauth_key,
    pub apdb: ptrauth_key,
    pub apga: ptrauth_key,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct mdthread__bindgen_ty_2 {
    pub apia: ptrauth_key,
}
#[repr(C)]
#[derive(Default)]
pub struct mdproc {
    pub md_tcr: u64,
    pub md_reserved: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct session {
    pub s_count: u_int,
    pub s_leader: *mut proc_,
    pub s_ttyvp: *mut vnode,
    pub s_ttydp: *mut cdev_priv,
    pub s_ttyp: *mut tty,
    pub s_sid: pid_t,
    pub s_login: [::core::ffi::c_char; 40usize],
    pub s_mtx: mtx,
}
impl Default for session {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pgrp {
    pub pg_hash: pgrp__bindgen_ty_1,
    pub pg_members: pgrp__bindgen_ty_2,
    pub pg_session: *mut session,
    pub pg_sigiolst: sigiolst,
    pub pg_id: pid_t,
    pub pg_mtx: mtx,
    pub pg_flags: ::core::ffi::c_int,
    pub pg_killsx: sx,
}
#[repr(C)]
#[derive(Debug)]
pub struct pgrp__bindgen_ty_1 {
    pub le_next: *mut pgrp,
    pub le_prev: *mut *mut pgrp,
}
impl Default for pgrp__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pgrp__bindgen_ty_2 {
    pub lh_first: *mut proc_,
}
impl Default for pgrp__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for pgrp {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct pargs {
    pub ar_ref: u_int,
    pub ar_length: u_int,
    pub ar_args: [u_char; 1usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct filecaps {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct filemon {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct kaioinfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct kaudit_record {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct kcov_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct kdtrace_proc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct kdtrace_thread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct kmsan_td {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct kq_timer_cb_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct mqueue_notifier {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct p_sched {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct procdesc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct racct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct sleepqueue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct td_sched {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct turnstile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct epoch_tracker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct syscall_args {
    pub code: u_int,
    pub original_code: u_int,
    pub callp: *mut sysent,
    pub args: [register_t; 8usize],
}
impl Default for syscall_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct rusage_ext {
    pub rux_runtime: u64,
    pub rux_uticks: u64,
    pub rux_sticks: u64,
    pub rux_iticks: u64,
    pub rux_uu: u64,
    pub rux_su: u64,
    pub rux_tu: u64,
}
#[repr(C)]
pub struct thread {
    pub td_lock: *mut mtx,
    pub td_proc: *mut proc_,
    pub td_plist: thread__bindgen_ty_1,
    pub td_runq: thread__bindgen_ty_2,
    pub __bindgen_anon_1: thread__bindgen_ty_3,
    pub td_lockq: thread__bindgen_ty_4,
    pub td_hash: thread__bindgen_ty_5,
    pub td_cpuset: *mut cpuset,
    pub td_domain: domainset_ref,
    pub td_sel: *mut seltd,
    pub td_sleepqueue: *mut sleepqueue,
    pub td_turnstile: *mut turnstile,
    pub td_pad1: *mut ::core::ffi::c_void,
    pub td_umtxq: *mut umtx_q,
    pub td_tid: lwpid_t,
    pub td_sigqueue: sigqueue_t,
    pub td_lend_user_pri: u_char,
    pub td_allocdomain: u_char,
    pub td_base_ithread_pri: u_char,
    pub td_kmsan: *mut kmsan_td,
    pub td_flags: ::core::ffi::c_int,
    pub td_ast: ::core::ffi::c_int,
    pub td_inhibitors: ::core::ffi::c_int,
    pub td_pflags: ::core::ffi::c_int,
    pub td_pflags2: ::core::ffi::c_int,
    pub td_dupfd: ::core::ffi::c_int,
    pub td_sqqueue: ::core::ffi::c_int,
    pub td_wchan: *const ::core::ffi::c_void,
    pub td_wmesg: *const ::core::ffi::c_char,
    pub td_owepreempt: u_char,
    pub td_tsqueue: u_char,
    pub _td_pad0: [u_char; 2usize],
    pub td_locks: ::core::ffi::c_int,
    pub td_rw_rlocks: ::core::ffi::c_int,
    pub td_sx_slocks: ::core::ffi::c_int,
    pub td_lk_slocks: ::core::ffi::c_int,
    pub td_wantedlock: *mut lock_object,
    pub td_blocked: *mut turnstile,
    pub td_lockname: *const ::core::ffi::c_char,
    pub td_contested: thread__bindgen_ty_6,
    pub td_sleeplocks: *mut lock_list_entry,
    pub td_intr_nesting_level: ::core::ffi::c_int,
    pub td_pinned: ::core::ffi::c_int,
    pub td_realucred: *mut ucred,
    pub td_ucred: *mut ucred,
    pub td_limit: *mut plimit,
    pub td_slptick: ::core::ffi::c_int,
    pub td_blktick: ::core::ffi::c_int,
    pub td_swvoltick: ::core::ffi::c_int,
    pub td_swinvoltick: ::core::ffi::c_int,
    pub td_cow: u_int,
    pub td_ru: rusage,
    pub td_rux: rusage_ext,
    pub td_incruntime: u64,
    pub td_runtime: u64,
    pub td_pticks: u_int,
    pub td_sticks: u_int,
    pub td_iticks: u_int,
    pub td_uticks: u_int,
    pub td_intrval: ::core::ffi::c_int,
    pub td_oldsigmask: sigset_t,
    pub td_generation: u_int,
    pub td_sigstk: stack_t,
    pub td_xsig: ::core::ffi::c_int,
    pub td_profil_addr: u_long,
    pub td_profil_ticks: u_int,
    pub td_name: [::core::ffi::c_char; 20usize],
    pub td_fpop: *mut file,
    pub td_dbgflags: ::core::ffi::c_int,
    pub td_si: siginfo_t,
    pub td_ng_outbound: ::core::ffi::c_int,
    pub td_osd: osd,
    pub td_map_def_user: *mut vm_map_entry,
    pub td_dbg_forked: pid_t,
    pub td_no_sleeping: u_int,
    pub td_vp_reserved: *mut vnode,
    pub td_su: *mut ::core::ffi::c_void,
    pub td_sleeptimo: sbintime_t,
    pub td_rtcgen: ::core::ffi::c_int,
    pub td_errno: ::core::ffi::c_int,
    pub td_vslock_sz: usize,
    pub td_kcov_info: *mut kcov_info,
    pub td_ucredref: ::core::ffi::c_long,
    pub td_kexterr: kexterr,
    pub td_sigmask: sigset_t,
    pub td_rqindex: u_char,
    pub td_base_pri: u_char,
    pub td_priority: u_char,
    pub td_pri_class: u_char,
    pub td_user_pri: u_char,
    pub td_base_user_pri: u_char,
    pub td_rb_list: usize,
    pub td_rbp_list: usize,
    pub td_rb_inact: usize,
    pub td_sa: syscall_args,
    pub td_sigblock_ptr: *mut ::core::ffi::c_void,
    pub td_sigblock_val: u32,
    pub td_exterr_ptr: *mut ::core::ffi::c_void,
    pub td_pcb: *mut pcb,
    pub td_state: thread_td_states,
    pub td_uretoff: thread__bindgen_ty_7,
    pub td_cowgen: u_int,
    pub td_slpcallout: callout,
    pub td_frame: *mut trapframe,
    pub td_kstack: vm_offset_t,
    pub td_kstack_pages: u_short,
    pub td_kstack_domain: u_short,
    pub td_critnest: u_int,
    pub td_md: mdthread,
    pub td_ar: *mut kaudit_record,
    pub td_lprof: [lpohead; 2usize],
    pub td_dtrace: *mut kdtrace_thread,
    pub td_vnet: *mut vnet,
    pub td_vnet_lpush: *const ::core::ffi::c_char,
    pub td_intr_frame: *mut trapframe,
    pub td_rfppwait_p: *mut proc_,
    pub td_ma: *mut *mut vm_page,
    pub td_ma_cnt: ::core::ffi::c_int,
    pub td_emuldata: *mut ::core::ffi::c_void,
    pub td_lastcpu: ::core::ffi::c_int,
    pub td_oncpu: ::core::ffi::c_int,
    pub td_lkpi_task: *mut ::core::ffi::c_void,
    pub td_pmcpend: ::core::ffi::c_int,
    pub td_remotereq: *mut ::core::ffi::c_void,
    pub td_ktr_io_lim: off_t,
}
#[repr(C)]
#[derive(Debug)]
pub struct thread__bindgen_ty_1 {
    pub tqe_next: *mut thread,
    pub tqe_prev: *mut *mut thread,
}
impl Default for thread__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct thread__bindgen_ty_2 {
    pub tqe_next: *mut thread,
    pub tqe_prev: *mut *mut thread,
}
impl Default for thread__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct thread__bindgen_ty_3 {
    pub td_slpq: __BindgenUnionField<thread__bindgen_ty_3__bindgen_ty_1>,
    pub td_zombie: __BindgenUnionField<*mut thread>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct thread__bindgen_ty_3__bindgen_ty_1 {
    pub tqe_next: *mut thread,
    pub tqe_prev: *mut *mut thread,
}
impl Default for thread__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for thread__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct thread__bindgen_ty_4 {
    pub tqe_next: *mut thread,
    pub tqe_prev: *mut *mut thread,
}
impl Default for thread__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct thread__bindgen_ty_5 {
    pub le_next: *mut thread,
    pub le_prev: *mut *mut thread,
}
impl Default for thread__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct thread__bindgen_ty_6 {
    pub lh_first: *mut turnstile,
}
impl Default for thread__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const TDS_INACTIVE: thread_td_states = 0;
pub const TDS_INHIBITED: thread_td_states = 1;
pub const TDS_CAN_RUN: thread_td_states = 2;
pub const TDS_RUNQ: thread_td_states = 3;
pub const TDS_RUNNING: thread_td_states = 4;
pub type thread_td_states = ::core::ffi::c_uint;
#[repr(C)]
pub struct thread__bindgen_ty_7 {
    pub tdu_retval: __BindgenUnionField<[syscallarg_t; 2usize]>,
    pub tdu_off: __BindgenUnionField<off_t>,
    pub bindgen_union_field: [u64; 2usize],
}
impl Default for thread__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for thread {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct thread0_storage {
    pub t0st_thread: thread,
    pub t0st_sched: [u64; 10usize],
}
impl Default for thread0_storage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const TDA_AST: _bindgen_ty_1 = 0;
pub const TDA_OWEUPC: _bindgen_ty_1 = 1;
pub const TDA_HWPMC: _bindgen_ty_1 = 2;
pub const TDA_VFORK: _bindgen_ty_1 = 3;
pub const TDA_ALRM: _bindgen_ty_1 = 4;
pub const TDA_PROF: _bindgen_ty_1 = 5;
pub const TDA_MAC: _bindgen_ty_1 = 6;
pub const TDA_SCHED: _bindgen_ty_1 = 7;
pub const TDA_UFS: _bindgen_ty_1 = 8;
pub const TDA_GEOM: _bindgen_ty_1 = 9;
pub const TDA_KQUEUE: _bindgen_ty_1 = 10;
pub const TDA_RACCT: _bindgen_ty_1 = 11;
pub const TDA_MOD1: _bindgen_ty_1 = 12;
pub const TDA_MOD2: _bindgen_ty_1 = 13;
pub const TDA_PSELECT: _bindgen_ty_1 = 14;
pub const TDA_SIG: _bindgen_ty_1 = 15;
pub const TDA_KTRACE: _bindgen_ty_1 = 16;
pub const TDA_SUSPEND: _bindgen_ty_1 = 17;
pub const TDA_SIGSUSPEND: _bindgen_ty_1 = 18;
pub const TDA_MOD3: _bindgen_ty_1 = 19;
pub const TDA_MOD4: _bindgen_ty_1 = 20;
pub const TDA_MAX: _bindgen_ty_1 = 21;
pub type _bindgen_ty_1 = ::core::ffi::c_uint;
#[repr(C)]
pub struct proc_ {
    pub p_list: proc__bindgen_ty_1,
    pub p_threads: proc__bindgen_ty_2,
    pub p_slock: mtx,
    pub p_ucred: *mut ucred,
    pub p_fd: *mut filedesc,
    pub p_fdtol: *mut filedesc_to_leader,
    pub p_pd: *mut pwddesc,
    pub p_stats: *mut pstats,
    pub p_limit: *mut plimit,
    pub p_limco: callout,
    pub p_sigacts: *mut sigacts,
    pub p_flag: ::core::ffi::c_int,
    pub p_flag2: ::core::ffi::c_int,
    pub p_state: proc_p_states,
    pub p_pid: pid_t,
    pub p_hash: proc__bindgen_ty_3,
    pub p_pglist: proc__bindgen_ty_4,
    pub p_pptr: *mut proc_,
    pub p_sibling: proc__bindgen_ty_5,
    pub p_children: proc__bindgen_ty_6,
    pub p_reaper: *mut proc_,
    pub p_reaplist: proc__bindgen_ty_7,
    pub p_reapsibling: proc__bindgen_ty_8,
    pub p_mtx: mtx,
    pub p_statmtx: mtx,
    pub p_itimmtx: mtx,
    pub p_profmtx: mtx,
    pub p_ksi: *mut ksiginfo,
    pub p_sigqueue: sigqueue_t,
    pub p_oppid: pid_t,
    pub p_vmspace: *mut vmspace,
    pub p_swtick: u_int,
    pub p_cowgen: u_int,
    pub p_realtimer: itimerval,
    pub p_ru: rusage,
    pub p_rux: rusage_ext,
    pub p_crux: rusage_ext,
    pub p_profthreads: ::core::ffi::c_int,
    pub p_exitthreads: ::core::ffi::c_int,
    pub p_traceflag: ::core::ffi::c_int,
    pub p_ktrioparms: *mut ktr_io_params,
    pub p_textvp: *mut vnode,
    pub p_textdvp: *mut vnode,
    pub p_binname: *mut ::core::ffi::c_char,
    pub p_lock: u_int,
    pub p_sigiolst: sigiolst,
    pub p_sigparent: ::core::ffi::c_int,
    pub p_sig: ::core::ffi::c_int,
    pub p_ptevents: u_int,
    pub p_aioinfo: *mut kaioinfo,
    pub p_singlethread: *mut thread,
    pub p_suspcount: ::core::ffi::c_int,
    pub p_xthread: *mut thread,
    pub p_boundary_count: ::core::ffi::c_int,
    pub p_pendingcnt: ::core::ffi::c_int,
    pub p_itimers: *mut itimers,
    pub p_procdesc: *mut procdesc,
    pub p_treeflag: u_int,
    pub p_pendingexits: ::core::ffi::c_int,
    pub p_filemon: *mut filemon,
    pub p_pdeathsig: ::core::ffi::c_int,
    pub p_magic: u_int,
    pub p_osrel: ::core::ffi::c_int,
    pub p_fctl0: u32,
    pub p_comm: [::core::ffi::c_char; 20usize],
    pub p_sysent: *mut sysentvec,
    pub p_args: *mut pargs,
    pub p_cpulimit: rlim_t,
    pub p_nice: ::core::ffi::c_schar,
    pub p_fibnum: ::core::ffi::c_int,
    pub p_reapsubtree: pid_t,
    pub p_elf_flags: u64,
    pub p_elf_brandinfo: *const ::core::ffi::c_void,
    pub p_umtx_min_timeout: sbintime_t,
    pub p_xexit: u_int,
    pub p_xsig: u_int,
    pub p_pgrp: *mut pgrp,
    pub p_klist: *mut knlist,
    pub p_numthreads: ::core::ffi::c_int,
    pub p_md: mdproc,
    pub p_itcallout: callout,
    pub p_acflag: u_short,
    pub p_peers: *mut proc_,
    pub p_leader: *mut proc_,
    pub p_emuldata: *mut ::core::ffi::c_void,
    pub p_label: *mut label,
    pub p_ktr: proc__bindgen_ty_9,
    pub p_mqnotifier: proc__bindgen_ty_10,
    pub p_dtrace: *mut kdtrace_proc,
    pub p_pwait: cv,
    pub p_racct: *mut racct,
    pub p_throttled: ::core::ffi::c_int,
    pub p_orphan: proc__bindgen_ty_11,
    pub p_orphans: proc__bindgen_ty_12,
    pub p_kqtim_stop: proc__bindgen_ty_13,
    pub p_jaillist: proc__bindgen_ty_14,
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_1 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
impl Default for proc__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_2 {
    pub tqh_first: *mut thread,
    pub tqh_last: *mut *mut thread,
}
impl Default for proc__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const PRS_NEW: proc_p_states = 0;
pub const PRS_NORMAL: proc_p_states = 1;
pub const PRS_ZOMBIE: proc_p_states = 2;
pub type proc_p_states = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_3 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
impl Default for proc__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_4 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
impl Default for proc__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_5 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
impl Default for proc__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_6 {
    pub lh_first: *mut proc_,
}
impl Default for proc__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_7 {
    pub lh_first: *mut proc_,
}
impl Default for proc__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_8 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
impl Default for proc__bindgen_ty_8 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_9 {
    pub stqh_first: *mut ktr_request,
    pub stqh_last: *mut *mut ktr_request,
}
impl Default for proc__bindgen_ty_9 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_10 {
    pub lh_first: *mut mqueue_notifier,
}
impl Default for proc__bindgen_ty_10 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_11 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
impl Default for proc__bindgen_ty_11 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_12 {
    pub lh_first: *mut proc_,
}
impl Default for proc__bindgen_ty_12 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_13 {
    pub tqh_first: *mut kq_timer_cb_data,
    pub tqh_last: *mut *mut kq_timer_cb_data,
}
impl Default for proc__bindgen_ty_13 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct proc__bindgen_ty_14 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
impl Default for proc__bindgen_ty_14 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for proc_ {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pidhashhead {
    pub lh_first: *mut proc_,
}
impl Default for pidhashhead {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pgrphashhead {
    pub lh_first: *mut pgrp,
}
impl Default for pgrphashhead {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct vmspace {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct proclist {
    pub lh_first: *mut proc_,
}
impl Default for proclist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct procqueue {
    pub tqh_first: *mut proc_,
    pub tqh_last: *mut *mut proc_,
}
impl Default for procqueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct threadqueue {
    pub tqh_first: *mut thread,
    pub tqh_last: *mut *mut thread,
}
impl Default for threadqueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct uma_zone {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct fork_req {
    pub fr_flags: ::core::ffi::c_int,
    pub fr_pages: ::core::ffi::c_int,
    pub fr_pidp: *mut ::core::ffi::c_int,
    pub fr_procp: *mut *mut proc_,
    pub fr_pd_fd: *mut ::core::ffi::c_int,
    pub fr_pd_flags: ::core::ffi::c_int,
    pub fr_pd_fcaps: *mut filecaps,
    pub fr_flags2: ::core::ffi::c_int,
}
impl Default for fork_req {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const RMAN_UNINIT: rman_type = 0;
pub const RMAN_GAUGE: rman_type = 1;
pub const RMAN_ARRAY: rman_type = 2;
pub type rman_type = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default)]
pub struct u_resource {
    pub r_handle: usize,
    pub r_parent: usize,
    pub r_device: usize,
    pub r_devname: [::core::ffi::c_char; 32usize],
    pub r_start: rman_res_t,
    pub r_size: rman_res_t,
    pub r_flags: u_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct u_rman {
    pub rm_handle: usize,
    pub rm_descr: [::core::ffi::c_char; 32usize],
    pub rm_start: rman_res_t,
    pub rm_size: rman_res_t,
    pub rm_type: rman_type,
}
impl Default for u_rman {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct resource {
    pub __r_i: *mut resource_i,
    pub r_bustag: bus_space_tag_t,
    pub r_bushandle: bus_space_handle_t,
}
impl Default for resource {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct resource_i {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct resource_head {
    pub tqh_first: *mut resource_i,
    pub tqh_last: *mut *mut resource_i,
}
impl Default for resource_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct rman {
    pub rm_list: resource_head,
    pub rm_mtx: *mut mtx,
    pub rm_link: rman__bindgen_ty_1,
    pub rm_start: rman_res_t,
    pub rm_end: rman_res_t,
    pub rm_type: rman_type,
    pub rm_descr: *const ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug)]
pub struct rman__bindgen_ty_1 {
    pub tqe_next: *mut rman,
    pub tqe_prev: *mut *mut rman,
}
impl Default for rman__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for rman {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct rman_head {
    pub tqh_first: *mut rman,
    pub tqh_last: *mut *mut rman,
}
impl Default for rman_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct sglist_seg {
    pub ss_paddr: vm_paddr_t,
    pub ss_len: usize,
}
#[repr(C)]
#[derive(Debug)]
pub struct sglist {
    pub sg_segs: *mut sglist_seg,
    pub sg_refs: u_int,
    pub sg_nseg: u_short,
    pub sg_maxseg: u_short,
}
impl Default for sglist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct mbuf {
    _unused: [u8; 0],
}
pub const TOPO_TYPE_DUMMY: topo_node_type = 0;
pub const TOPO_TYPE_PU: topo_node_type = 1;
pub const TOPO_TYPE_CORE: topo_node_type = 2;
pub const TOPO_TYPE_CACHE: topo_node_type = 3;
pub const TOPO_TYPE_PKG: topo_node_type = 4;
pub const TOPO_TYPE_NODE: topo_node_type = 5;
pub const TOPO_TYPE_GROUP: topo_node_type = 6;
pub const TOPO_TYPE_SYSTEM: topo_node_type = 7;
pub type topo_node_type = ::core::ffi::c_uint;
pub type hwid_t = ::core::ffi::c_uint;
pub type cpuid_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug)]
pub struct topo_node {
    pub parent: *mut topo_node,
    pub children: topo_node_topo_children,
    pub siblings: topo_node__bindgen_ty_1,
    pub cpuset: cpuset_t,
    pub type_: topo_node_type,
    pub subtype: usize,
    pub hwid: hwid_t,
    pub id: cpuid_t,
    pub nchildren: ::core::ffi::c_int,
    pub cpu_count: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct topo_node_topo_children {
    pub tqh_first: *mut topo_node,
    pub tqh_last: *mut *mut topo_node,
}
impl Default for topo_node_topo_children {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct topo_node__bindgen_ty_1 {
    pub tqe_next: *mut topo_node,
    pub tqe_prev: *mut *mut topo_node,
}
impl Default for topo_node__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for topo_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cpu_group {
    pub cg_parent: *mut cpu_group,
    pub cg_child: *mut cpu_group,
    pub cg_mask: cpuset_t,
    pub cg_count: i32,
    pub cg_first: i32,
    pub cg_last: i32,
    pub cg_children: i16,
    pub cg_level: i8,
    pub cg_flags: i8,
}
impl Default for cpu_group {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cpu_group_t = *mut cpu_group;
pub const TOPO_LEVEL_PKG: topo_level = 0;
pub const TOPO_LEVEL_GROUP: topo_level = 1;
pub const TOPO_LEVEL_CACHEGROUP: topo_level = 2;
pub const TOPO_LEVEL_CORE: topo_level = 3;
pub const TOPO_LEVEL_THREAD: topo_level = 4;
pub const TOPO_LEVEL_COUNT: topo_level = 5;
pub type topo_level = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default)]
pub struct topo_analysis {
    pub entities: [::core::ffi::c_int; 5usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct smp_rendezvous_cpus_retry_arg {
    pub cpus: cpuset_t,
}
pub type task_fn_t = ::core::option::Option<
    unsafe extern "C" fn(context: *mut ::core::ffi::c_void, pending: ::core::ffi::c_int),
>;
#[repr(C)]
#[derive(Debug)]
pub struct task {
    pub ta_link: task__bindgen_ty_1,
    pub ta_pending: u16,
    pub ta_priority: u8,
    pub ta_flags: u8,
    pub ta_func: task_fn_t,
    pub ta_context: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug)]
pub struct task__bindgen_ty_1 {
    pub stqe_next: *mut task,
}
impl Default for task__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for task {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct taskqueue {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct timeout_task {
    pub q: *mut taskqueue,
    pub t: task,
    pub c: callout,
    pub f: ::core::ffi::c_int,
}
impl Default for timeout_task {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type gtask_fn_t =
    ::core::option::Option<unsafe extern "C" fn(context: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug)]
pub struct gtask {
    pub ta_link: gtask__bindgen_ty_1,
    pub ta_flags: u16,
    pub ta_priority: u_short,
    pub ta_func: gtask_fn_t,
    pub ta_context: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug)]
pub struct gtask__bindgen_ty_1 {
    pub stqe_next: *mut gtask,
}
impl Default for gtask__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for gtask {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct taskqgroup {
    _unused: [u8; 0],
}
pub const TASKQUEUE_CALLBACK_TYPE_INIT: taskqueue_callback_type = 0;
pub const TASKQUEUE_CALLBACK_TYPE_SHUTDOWN: taskqueue_callback_type = 1;
pub type taskqueue_callback_type = ::core::ffi::c_uint;
pub type taskqueue_callback_fn =
    ::core::option::Option<unsafe extern "C" fn(context: *mut ::core::ffi::c_void)>;
pub type taskqueue_enqueue_fn =
    ::core::option::Option<unsafe extern "C" fn(context: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug)]
pub struct bus_space {
    pub bs_cookie: *mut ::core::ffi::c_void,
    pub bs_map: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_addr_t,
            arg3: bus_size_t,
            arg4: ::core::ffi::c_int,
            arg5: *mut bus_space_handle_t,
        ) -> ::core::ffi::c_int,
    >,
    pub bs_unmap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
        ),
    >,
    pub bs_subregion: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: bus_size_t,
            arg5: *mut bus_space_handle_t,
        ) -> ::core::ffi::c_int,
    >,
    pub bs_alloc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_addr_t,
            arg3: bus_addr_t,
            arg4: bus_size_t,
            arg5: bus_size_t,
            arg6: bus_size_t,
            arg7: ::core::ffi::c_int,
            arg8: *mut bus_addr_t,
            arg9: *mut bus_space_handle_t,
        ) -> ::core::ffi::c_int,
    >,
    pub bs_free: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
        ),
    >,
    pub bs_barrier: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: bus_size_t,
            arg5: ::core::ffi::c_int,
        ),
    >,
    pub bs_r_1: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
        ) -> u_int8_t,
    >,
    pub bs_r_2: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
        ) -> u_int16_t,
    >,
    pub bs_r_4: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
        ) -> u_int32_t,
    >,
    pub bs_r_8: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
        ) -> u_int64_t,
    >,
    pub bs_rm_1: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int8_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rm_2: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int16_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rm_4: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int32_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rm_8: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int64_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rr_1: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int8_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rr_2: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int16_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rr_4: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int32_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rr_8: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int64_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_w_1: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int8_t,
        ),
    >,
    pub bs_w_2: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int16_t,
        ),
    >,
    pub bs_w_4: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int32_t,
        ),
    >,
    pub bs_w_8: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int64_t,
        ),
    >,
    pub bs_wm_1: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int8_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wm_2: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int16_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wm_4: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int32_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wm_8: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int64_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wr_1: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int8_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wr_2: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int16_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wr_4: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int32_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wr_8: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int64_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_sm_1: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int8_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_sm_2: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int16_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_sm_4: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int32_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_sm_8: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int64_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_sr_1: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int8_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_sr_2: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int16_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_sr_4: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int32_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_sr_8: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int64_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_c_1: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: bus_space_handle_t,
            arg5: bus_size_t,
            arg6: bus_size_t,
        ),
    >,
    pub bs_c_2: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: bus_space_handle_t,
            arg5: bus_size_t,
            arg6: bus_size_t,
        ),
    >,
    pub bs_c_4: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: bus_space_handle_t,
            arg5: bus_size_t,
            arg6: bus_size_t,
        ),
    >,
    pub bs_c_8: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: bus_space_handle_t,
            arg5: bus_size_t,
            arg6: bus_size_t,
        ),
    >,
    pub bs_r_1_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
        ) -> u_int8_t,
    >,
    pub bs_r_2_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
        ) -> u_int16_t,
    >,
    pub bs_r_4_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
        ) -> u_int32_t,
    >,
    pub bs_r_8_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
        ) -> u_int64_t,
    >,
    pub bs_rm_1_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int8_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rm_2_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int16_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rm_4_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int32_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rm_8_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int64_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rr_1_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int8_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rr_2_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int16_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rr_4_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int32_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_rr_8_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u_int64_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_w_1_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int8_t,
        ),
    >,
    pub bs_w_2_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int16_t,
        ),
    >,
    pub bs_w_4_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int32_t,
        ),
    >,
    pub bs_w_8_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u_int64_t,
        ),
    >,
    pub bs_wm_1_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int8_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wm_2_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int16_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wm_4_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int32_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wm_8_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int64_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wr_1_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int8_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wr_2_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int16_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wr_4_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int32_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_wr_8_s: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *const u_int64_t,
            arg5: bus_size_t,
        ),
    >,
    pub bs_peek_1: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u8,
        ) -> ::core::ffi::c_int,
    >,
    pub bs_peek_2: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u16,
        ) -> ::core::ffi::c_int,
    >,
    pub bs_peek_4: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u32,
        ) -> ::core::ffi::c_int,
    >,
    pub bs_peek_8: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: *mut u64,
        ) -> ::core::ffi::c_int,
    >,
    pub bs_poke_1: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u8,
        ) -> ::core::ffi::c_int,
    >,
    pub bs_poke_2: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u16,
        ) -> ::core::ffi::c_int,
    >,
    pub bs_poke_4: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u32,
        ) -> ::core::ffi::c_int,
    >,
    pub bs_poke_8: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: bus_space_handle_t,
            arg3: bus_size_t,
            arg4: u64,
        ) -> ::core::ffi::c_int,
    >,
}
impl Default for bus_space {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ccb {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct crypto_buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct cryptop {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct bus_dma_segment {
    pub ds_addr: bus_addr_t,
    pub ds_len: bus_size_t,
}
pub type bus_dma_segment_t = bus_dma_segment;
pub type bus_dma_filter_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: bus_addr_t) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug)]
pub struct bus_dma_template_t {
    pub parent: bus_dma_tag_t,
    pub alignment: bus_size_t,
    pub boundary: bus_addr_t,
    pub lowaddr: bus_addr_t,
    pub highaddr: bus_addr_t,
    pub maxsize: bus_size_t,
    pub nsegments: ::core::ffi::c_int,
    pub maxsegsize: bus_size_t,
    pub flags: ::core::ffi::c_int,
    pub lockfunc: bus_dma_lock_t,
    pub lockfuncarg: *mut ::core::ffi::c_void,
    pub name: *const ::core::ffi::c_char,
}
impl Default for bus_dma_template_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const BD_PARAM_INVALID: bus_dma_param_key_t = 0;
pub const BD_PARAM_PARENT: bus_dma_param_key_t = 1;
pub const BD_PARAM_ALIGNMENT: bus_dma_param_key_t = 2;
pub const BD_PARAM_BOUNDARY: bus_dma_param_key_t = 3;
pub const BD_PARAM_LOWADDR: bus_dma_param_key_t = 4;
pub const BD_PARAM_HIGHADDR: bus_dma_param_key_t = 5;
pub const BD_PARAM_MAXSIZE: bus_dma_param_key_t = 6;
pub const BD_PARAM_NSEGMENTS: bus_dma_param_key_t = 7;
pub const BD_PARAM_MAXSEGSIZE: bus_dma_param_key_t = 8;
pub const BD_PARAM_FLAGS: bus_dma_param_key_t = 9;
pub const BD_PARAM_LOCKFUNC: bus_dma_param_key_t = 10;
pub const BD_PARAM_LOCKFUNCARG: bus_dma_param_key_t = 11;
pub const BD_PARAM_NAME: bus_dma_param_key_t = 12;
pub type bus_dma_param_key_t = ::core::ffi::c_uint;
#[repr(C)]
pub struct bus_dma_param_t {
    pub key: bus_dma_param_key_t,
    pub __bindgen_anon_1: bus_dma_param_t__bindgen_ty_1,
}
#[repr(C)]
pub struct bus_dma_param_t__bindgen_ty_1 {
    pub ptr: __BindgenUnionField<*mut ::core::ffi::c_void>,
    pub pa: __BindgenUnionField<vm_paddr_t>,
    pub num: __BindgenUnionField<uintmax_t>,
    pub bindgen_union_field: u64,
}
impl Default for bus_dma_param_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bus_dma_param_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type bus_dmamap_callback_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut bus_dma_segment_t,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
    ),
>;
pub type bus_dmamap_callback2_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut bus_dma_segment_t,
        arg3: ::core::ffi::c_int,
        arg4: bus_size_t,
        arg5: ::core::ffi::c_int,
    ),
>;
#[repr(C)]
#[derive(Debug)]
pub struct bus_dma_tag_common {
    pub impl_: *mut bus_dma_impl,
    pub alignment: bus_size_t,
    pub boundary: bus_addr_t,
    pub lowaddr: bus_addr_t,
    pub highaddr: bus_addr_t,
    pub maxsize: bus_size_t,
    pub nsegments: u_int,
    pub maxsegsz: bus_size_t,
    pub flags: ::core::ffi::c_int,
    pub lockfunc: bus_dma_lock_t,
    pub lockfuncarg: *mut ::core::ffi::c_void,
    pub domain: ::core::ffi::c_int,
}
impl Default for bus_dma_tag_common {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct bus_dma_impl {
    pub tag_create: ::core::option::Option<
        unsafe extern "C" fn(
            parent: bus_dma_tag_t,
            alignment: bus_size_t,
            boundary: bus_addr_t,
            lowaddr: bus_addr_t,
            highaddr: bus_addr_t,
            maxsize: bus_size_t,
            nsegments: ::core::ffi::c_int,
            maxsegsz: bus_size_t,
            flags: ::core::ffi::c_int,
            lockfunc: bus_dma_lock_t,
            lockfuncarg: *mut ::core::ffi::c_void,
            dmat: *mut bus_dma_tag_t,
        ) -> ::core::ffi::c_int,
    >,
    pub tag_destroy:
        ::core::option::Option<unsafe extern "C" fn(dmat: bus_dma_tag_t) -> ::core::ffi::c_int>,
    pub tag_set_domain:
        ::core::option::Option<unsafe extern "C" fn(arg1: bus_dma_tag_t) -> ::core::ffi::c_int>,
    pub id_mapped: ::core::option::Option<
        unsafe extern "C" fn(arg1: bus_dma_tag_t, arg2: vm_paddr_t, arg3: bus_size_t) -> bool_,
    >,
    pub map_create: ::core::option::Option<
        unsafe extern "C" fn(
            dmat: bus_dma_tag_t,
            flags: ::core::ffi::c_int,
            mapp: *mut bus_dmamap_t,
        ) -> ::core::ffi::c_int,
    >,
    pub map_destroy: ::core::option::Option<
        unsafe extern "C" fn(dmat: bus_dma_tag_t, map: bus_dmamap_t) -> ::core::ffi::c_int,
    >,
    pub mem_alloc: ::core::option::Option<
        unsafe extern "C" fn(
            dmat: bus_dma_tag_t,
            vaddr: *mut *mut ::core::ffi::c_void,
            flags: ::core::ffi::c_int,
            mapp: *mut bus_dmamap_t,
        ) -> ::core::ffi::c_int,
    >,
    pub mem_free: ::core::option::Option<
        unsafe extern "C" fn(
            dmat: bus_dma_tag_t,
            vaddr: *mut ::core::ffi::c_void,
            map: bus_dmamap_t,
        ),
    >,
    pub load_ma: ::core::option::Option<
        unsafe extern "C" fn(
            dmat: bus_dma_tag_t,
            map: bus_dmamap_t,
            ma: *mut *mut vm_page,
            tlen: bus_size_t,
            ma_offs: ::core::ffi::c_int,
            flags: ::core::ffi::c_int,
            segs: *mut bus_dma_segment_t,
            segp: *mut ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub load_phys: ::core::option::Option<
        unsafe extern "C" fn(
            dmat: bus_dma_tag_t,
            map: bus_dmamap_t,
            buf: vm_paddr_t,
            buflen: bus_size_t,
            flags: ::core::ffi::c_int,
            segs: *mut bus_dma_segment_t,
            segp: *mut ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub load_buffer: ::core::option::Option<
        unsafe extern "C" fn(
            dmat: bus_dma_tag_t,
            map: bus_dmamap_t,
            buf: *mut ::core::ffi::c_void,
            buflen: bus_size_t,
            pmap: *mut pmap,
            flags: ::core::ffi::c_int,
            segs: *mut bus_dma_segment_t,
            segp: *mut ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub map_waitok: ::core::option::Option<
        unsafe extern "C" fn(
            dmat: bus_dma_tag_t,
            map: bus_dmamap_t,
            mem: *mut memdesc,
            callback: bus_dmamap_callback_t,
            callback_arg: *mut ::core::ffi::c_void,
        ),
    >,
    pub map_complete: ::core::option::Option<
        unsafe extern "C" fn(
            dmat: bus_dma_tag_t,
            map: bus_dmamap_t,
            segs: *mut bus_dma_segment_t,
            nsegs: ::core::ffi::c_int,
            error: ::core::ffi::c_int,
        ) -> *mut bus_dma_segment_t,
    >,
    pub map_unload:
        ::core::option::Option<unsafe extern "C" fn(dmat: bus_dma_tag_t, map: bus_dmamap_t)>,
    pub map_sync: ::core::option::Option<
        unsafe extern "C" fn(dmat: bus_dma_tag_t, map: bus_dmamap_t, op: bus_dmasync_op_t),
    >,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct arm64_bootparams {
    pub modulep: vm_offset_t,
    pub kern_stack: vm_offset_t,
    pub kern_ttbr0: vm_paddr_t,
    pub boot_el: ::core::ffi::c_int,
    pub pad: ::core::ffi::c_int,
}
pub const ARM64_BUS_NONE: arm64_bus = 0;
pub const ARM64_BUS_FDT: arm64_bus = 1;
pub const ARM64_BUS_ACPI: arm64_bus = 2;
pub type arm64_bus = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default)]
pub struct debug_monitor_state {
    pub dbg_enable_count: u32,
    pub dbg_flags: u32,
    pub dbg_bcr: [u64; 16usize],
    pub dbg_bvr: [u64; 16usize],
    pub dbg_wcr: [u64; 16usize],
    pub dbg_wvr: [u64; 16usize],
}
pub const HW_BREAKPOINT_X: dbg_access_t = 0;
pub const HW_BREAKPOINT_R: dbg_access_t = 1;
pub const HW_BREAKPOINT_W: dbg_access_t = 2;
pub const HW_BREAKPOINT_RW: dbg_access_t = 3;
pub type dbg_access_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct fpu_kern_ctx {
    _unused: [u8; 0],
}
pub const IPI_AST: _bindgen_ty_2 = 0;
pub const IPI_PREEMPT: _bindgen_ty_2 = 1;
pub const IPI_RENDEZVOUS: _bindgen_ty_2 = 2;
pub const IPI_STOP: _bindgen_ty_2 = 3;
pub const IPI_STOP_HARD: _bindgen_ty_2 = 4;
pub const IPI_HARDCLOCK: _bindgen_ty_2 = 5;
pub const IPI_OFF: _bindgen_ty_2 = 6;
pub const INTR_IPI_COUNT: _bindgen_ty_2 = 7;
pub type _bindgen_ty_2 = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct ofw_bus_devinfo {
    pub obd_node: phandle_t,
    pub obd_compat: *mut ::core::ffi::c_char,
    pub obd_model: *mut ::core::ffi::c_char,
    pub obd_name: *mut ::core::ffi::c_char,
    pub obd_type: *mut ::core::ffi::c_char,
    pub obd_status: *mut ::core::ffi::c_char,
}
impl Default for ofw_bus_devinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief A function implementing the OFW_BUS_GET_DEVINFO() method"]
pub type ofw_bus_get_devinfo_t = ::core::option::Option<
    unsafe extern "C" fn(bus: device_t, dev: device_t) -> *const ofw_bus_devinfo,
>;
#[doc = " @brief A function implementing the OFW_BUS_GET_COMPAT() method"]
pub type ofw_bus_get_compat_t = ::core::option::Option<
    unsafe extern "C" fn(bus: device_t, dev: device_t) -> *const ::core::ffi::c_char,
>;
#[doc = " @brief A function implementing the OFW_BUS_GET_MODEL() method"]
pub type ofw_bus_get_model_t = ::core::option::Option<
    unsafe extern "C" fn(bus: device_t, dev: device_t) -> *const ::core::ffi::c_char,
>;
#[doc = " @brief A function implementing the OFW_BUS_GET_NAME() method"]
pub type ofw_bus_get_name_t = ::core::option::Option<
    unsafe extern "C" fn(bus: device_t, dev: device_t) -> *const ::core::ffi::c_char,
>;
#[doc = " @brief A function implementing the OFW_BUS_GET_NODE() method"]
pub type ofw_bus_get_node_t =
    ::core::option::Option<unsafe extern "C" fn(bus: device_t, dev: device_t) -> phandle_t>;
#[doc = " @brief A function implementing the OFW_BUS_GET_TYPE() method"]
pub type ofw_bus_get_type_t = ::core::option::Option<
    unsafe extern "C" fn(bus: device_t, dev: device_t) -> *const ::core::ffi::c_char,
>;
#[doc = " @brief A function implementing the OFW_BUS_MAP_INTR() method"]
pub type ofw_bus_map_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        bus: device_t,
        dev: device_t,
        iparent: phandle_t,
        icells: ::core::ffi::c_int,
        interrupt: *mut pcell_t,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Default)]
pub struct simplebus_range {
    pub bus: u64,
    pub host: u64,
    pub size: u64,
}
#[repr(C)]
pub struct simplebus_softc {
    pub dev: device_t,
    pub node: phandle_t,
    pub ranges: *mut simplebus_range,
    pub nranges: ::core::ffi::c_int,
    pub flags: ::core::ffi::c_int,
    pub acells: pcell_t,
    pub scells: pcell_t,
}
impl Default for simplebus_softc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct simplebus_devinfo {
    pub obdinfo: ofw_bus_devinfo,
    pub rl: resource_list,
}
impl Default for simplebus_devinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct ofw_bus_iinfo {
    pub opi_imap: *mut u8,
    pub opi_imapmsk: *mut u8,
    pub opi_imapsz: ::core::ffi::c_int,
    pub opi_addrc: pcell_t,
}
impl Default for ofw_bus_iinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct ofw_compat_data {
    pub ocd_str: *const ::core::ffi::c_char,
    pub ocd_data: usize,
}
impl Default for ofw_compat_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct intr_map_data_fdt {
    pub hdr: intr_map_data,
    pub iparent: phandle_t,
    pub ncells: u_int,
    pub cells: __IncompleteArrayField<pcell_t>,
}
impl Default for intr_map_data_fdt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct ktr_entry {
    pub ktr_timestamp: u_int64_t,
    pub ktr_cpu: ::core::ffi::c_int,
    pub ktr_line: ::core::ffi::c_int,
    pub ktr_file: *const ::core::ffi::c_char,
    pub ktr_desc: *const ::core::ffi::c_char,
    pub ktr_thread: *mut thread,
    pub ktr_parms: [u_long; 6usize],
}
impl Default for ktr_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const POWER_STYPE_AWAKE: power_stype = 0;
pub const POWER_STYPE_STANDBY: power_stype = 1;
pub const POWER_STYPE_SUSPEND_TO_MEM: power_stype = 2;
pub const POWER_STYPE_SUSPEND_TO_IDLE: power_stype = 3;
pub const POWER_STYPE_HIBERNATE: power_stype = 4;
pub const POWER_STYPE_POWEROFF: power_stype = 5;
pub const POWER_STYPE_COUNT: power_stype = 6;
pub const POWER_STYPE_UNKNOWN: power_stype = 7;
pub type power_stype = ::core::ffi::c_uint;
pub type power_pm_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        _cmd: u_long,
        _arg: *mut ::core::ffi::c_void,
        _stype: power_stype,
    ) -> ::core::ffi::c_int,
>;
pub type power_profile_change_hook = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: ::core::ffi::c_int),
>;
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_power_profile_change {
    pub ee: eventhandler_entry,
    pub eh_func: power_profile_change_hook,
}
impl Default for eventhandler_entry_power_profile_change {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_vimage {
    pub func: ::core::option::Option<unsafe extern "C" fn()>,
    pub ee_arg: *mut ::core::ffi::c_void,
    pub sparep: [*mut ::core::ffi::c_void; 2usize],
}
impl Default for eventhandler_entry_vimage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_list {
    pub el_name: *mut ::core::ffi::c_char,
    pub el_flags: ::core::ffi::c_int,
    pub el_runcount: u_int,
    pub el_lock: mtx,
    pub el_link: eventhandler_list__bindgen_ty_1,
    pub el_entries: eventhandler_list__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_list__bindgen_ty_1 {
    pub tqe_next: *mut eventhandler_list,
    pub tqe_prev: *mut *mut eventhandler_list,
}
impl Default for eventhandler_list__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_list__bindgen_ty_2 {
    pub tqh_first: *mut eventhandler_entry,
    pub tqh_last: *mut *mut eventhandler_entry,
}
impl Default for eventhandler_list__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for eventhandler_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vimage_iterator_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, ...)>;
pub type shutdown_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: ::core::ffi::c_int),
>;
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_shutdown_pre_sync {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
impl Default for eventhandler_entry_shutdown_pre_sync {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_shutdown_post_sync {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
impl Default for eventhandler_entry_shutdown_post_sync {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_shutdown_final {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
impl Default for eventhandler_entry_shutdown_final {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type power_change_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, stype: power_stype),
>;
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_power_resume {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
impl Default for eventhandler_entry_power_resume {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_power_suspend {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
impl Default for eventhandler_entry_power_suspend {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_power_suspend_early {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
impl Default for eventhandler_entry_power_suspend_early {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vm_lowmem_handler_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: ::core::ffi::c_int),
>;
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_vm_lowmem {
    pub ee: eventhandler_entry,
    pub eh_func: vm_lowmem_handler_t,
}
impl Default for eventhandler_entry_vm_lowmem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_mbuf_lowmem {
    pub ee: eventhandler_entry,
    pub eh_func: vm_lowmem_handler_t,
}
impl Default for eventhandler_entry_mbuf_lowmem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mountroot_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_mountroot {
    pub ee: eventhandler_entry,
    pub eh_func: mountroot_handler_t,
}
impl Default for eventhandler_entry_mountroot {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct mount {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct vnode {
    _unused: [u8; 0],
}
pub type vfs_mounted_notify_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut mount,
        arg3: *mut vnode,
        arg4: *mut thread,
    ),
>;
pub type vfs_unmounted_notify_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *mut mount, arg3: *mut thread),
>;
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_vfs_mounted {
    pub ee: eventhandler_entry,
    pub eh_func: vfs_mounted_notify_fn,
}
impl Default for eventhandler_entry_vfs_mounted {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_vfs_unmounted {
    pub ee: eventhandler_entry,
    pub eh_func: vfs_unmounted_notify_fn,
}
impl Default for eventhandler_entry_vfs_unmounted {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct image_params {
    _unused: [u8; 0],
}
pub type exitlist_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *mut proc_)>;
pub type forklist_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut proc_,
        arg3: *mut proc_,
        arg4: ::core::ffi::c_int,
    ),
>;
pub type execlist_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *mut proc_, arg3: *mut image_params),
>;
pub type proc_ctor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *mut proc_)>;
pub type proc_dtor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *mut proc_)>;
pub type proc_init_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *mut proc_)>;
pub type proc_fini_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *mut proc_)>;
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_process_ctor {
    pub ee: eventhandler_entry,
    pub eh_func: proc_ctor_fn,
}
impl Default for eventhandler_entry_process_ctor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_process_dtor {
    pub ee: eventhandler_entry,
    pub eh_func: proc_dtor_fn,
}
impl Default for eventhandler_entry_process_dtor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_process_init {
    pub ee: eventhandler_entry,
    pub eh_func: proc_init_fn,
}
impl Default for eventhandler_entry_process_init {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_process_fini {
    pub ee: eventhandler_entry,
    pub eh_func: proc_fini_fn,
}
impl Default for eventhandler_entry_process_fini {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_process_exit {
    pub ee: eventhandler_entry,
    pub eh_func: exitlist_fn,
}
impl Default for eventhandler_entry_process_exit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_process_fork {
    pub ee: eventhandler_entry,
    pub eh_func: forklist_fn,
}
impl Default for eventhandler_entry_process_fork {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_process_exec {
    pub ee: eventhandler_entry,
    pub eh_func: execlist_fn,
}
impl Default for eventhandler_entry_process_exec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type app_coredump_start_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut thread,
        name: *mut ::core::ffi::c_char,
    ),
>;
pub type app_coredump_progress_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        td: *mut thread,
        byte_count: ::core::ffi::c_int,
    ),
>;
pub type app_coredump_finish_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, td: *mut thread)>;
pub type app_coredump_error_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        td: *mut thread,
        msg: *mut ::core::ffi::c_char,
        ...
    ),
>;
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_app_coredump_start {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_start_fn,
}
impl Default for eventhandler_entry_app_coredump_start {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_app_coredump_progress {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_progress_fn,
}
impl Default for eventhandler_entry_app_coredump_progress {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_app_coredump_finish {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_finish_fn,
}
impl Default for eventhandler_entry_app_coredump_finish {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_app_coredump_error {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_error_fn,
}
impl Default for eventhandler_entry_app_coredump_error {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type thread_ctor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *mut thread)>;
pub type thread_dtor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *mut thread)>;
pub type thread_fini_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *mut thread)>;
pub type thread_init_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *mut thread)>;
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_thread_ctor {
    pub ee: eventhandler_entry,
    pub eh_func: thread_ctor_fn,
}
impl Default for eventhandler_entry_thread_ctor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_thread_dtor {
    pub ee: eventhandler_entry,
    pub eh_func: thread_dtor_fn,
}
impl Default for eventhandler_entry_thread_dtor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_thread_init {
    pub ee: eventhandler_entry,
    pub eh_func: thread_init_fn,
}
impl Default for eventhandler_entry_thread_init {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_thread_fini {
    pub ee: eventhandler_entry,
    pub eh_func: thread_fini_fn,
}
impl Default for eventhandler_entry_thread_fini {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type uma_zone_chfn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_nmbclusters_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
impl Default for eventhandler_entry_nmbclusters_change {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_nmbufs_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
impl Default for eventhandler_entry_nmbufs_change {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_maxsockets_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
impl Default for eventhandler_entry_maxsockets_change {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type kld_load_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *mut linker_file),
>;
pub type kld_unload_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_char,
        arg3: caddr_t,
        arg4: usize,
    ),
>;
pub type kld_unload_try_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut linker_file,
        arg3: *mut ::core::ffi::c_int,
    ),
>;
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_kld_load {
    pub ee: eventhandler_entry,
    pub eh_func: kld_load_fn,
}
impl Default for eventhandler_entry_kld_load {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_kld_unload {
    pub ee: eventhandler_entry,
    pub eh_func: kld_unload_fn,
}
impl Default for eventhandler_entry_kld_unload {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_kld_unload_try {
    pub ee: eventhandler_entry,
    pub eh_func: kld_unload_try_fn,
}
impl Default for eventhandler_entry_kld_unload_try {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct fb_info {
    _unused: [u8; 0],
}
pub type register_framebuffer_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *mut fb_info),
>;
pub type unregister_framebuffer_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *mut fb_info),
>;
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_register_framebuffer {
    pub ee: eventhandler_entry,
    pub eh_func: register_framebuffer_fn,
}
impl Default for eventhandler_entry_register_framebuffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_unregister_framebuffer {
    pub ee: eventhandler_entry,
    pub eh_func: unregister_framebuffer_fn,
}
impl Default for eventhandler_entry_unregister_framebuffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cam_path {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ata_params {
    _unused: [u8; 0],
}
pub type ada_probe_veto_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut cam_path,
        arg3: *mut ata_params,
        arg4: *mut ::core::ffi::c_int,
    ),
>;
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_ada_probe_veto {
    pub ee: eventhandler_entry,
    pub eh_func: ada_probe_veto_fn,
}
impl Default for eventhandler_entry_ada_probe_veto {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct swdevt {
    _unused: [u8; 0],
}
pub type swapon_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *mut swdevt)>;
pub type swapoff_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *mut swdevt)>;
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_swapon {
    pub ee: eventhandler_entry,
    pub eh_func: swapon_fn,
}
impl Default for eventhandler_entry_swapon {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_swapoff {
    pub ee: eventhandler_entry,
    pub eh_func: swapoff_fn,
}
impl Default for eventhandler_entry_swapoff {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const EVHDEV_DETACH_BEGIN: evhdev_detach = 0;
pub const EVHDEV_DETACH_COMPLETE: evhdev_detach = 1;
pub const EVHDEV_DETACH_FAILED: evhdev_detach = 2;
pub type evhdev_detach = ::core::ffi::c_uint;
pub type device_attach_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: device_t)>;
pub type device_detach_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: device_t, arg3: evhdev_detach),
>;
pub type device_nomatch_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: device_t)>;
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_device_attach {
    pub ee: eventhandler_entry,
    pub eh_func: device_attach_fn,
}
impl Default for eventhandler_entry_device_attach {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_device_detach {
    pub ee: eventhandler_entry,
    pub eh_func: device_detach_fn,
}
impl Default for eventhandler_entry_device_detach {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_device_nomatch {
    pub ee: eventhandler_entry,
    pub eh_func: device_nomatch_fn,
}
impl Default for eventhandler_entry_device_nomatch {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct ifaddr {
    _unused: [u8; 0],
}
pub type rt_addrmsg_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut ifaddr,
        arg3: ::core::ffi::c_int,
    ),
>;
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_rt_addrmsg {
    pub ee: eventhandler_entry,
    pub eh_func: rt_addrmsg_fn,
}
impl Default for eventhandler_entry_rt_addrmsg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type env_change_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *const ::core::ffi::c_char),
>;
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_setenv {
    pub ee: eventhandler_entry,
    pub eh_func: env_change_fn,
}
impl Default for eventhandler_entry_setenv {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_unsetenv {
    pub ee: eventhandler_entry,
    pub eh_func: env_change_fn,
}
impl Default for eventhandler_entry_unsetenv {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct fiodgname_arg {
    pub len: ::core::ffi::c_int,
    pub buf: *mut ::core::ffi::c_void,
}
impl Default for fiodgname_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct fiobmap2_arg {
    pub bn: __daddr_t,
    pub runp: ::core::ffi::c_int,
    pub runb: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct fiodgname_arg32 {
    pub len: ::core::ffi::c_int,
    pub buf: u32,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct flock {
    pub l_start: off_t,
    pub l_len: off_t,
    pub l_pid: pid_t,
    pub l_type: ::core::ffi::c_short,
    pub l_whence: ::core::ffi::c_short,
    pub l_sysid: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __oflock {
    pub l_start: off_t,
    pub l_len: off_t,
    pub l_pid: pid_t,
    pub l_type: ::core::ffi::c_short,
    pub l_whence: ::core::ffi::c_short,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct spacectl_range {
    pub r_offset: off_t,
    pub r_len: off_t,
}
#[repr(C)]
#[derive(Debug)]
pub struct selfd {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct selfdlist {
    pub tqh_first: *mut selfd,
    pub tqh_last: *mut *mut selfd,
}
impl Default for selfdlist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct selinfo {
    pub si_tdlist: selfdlist,
    pub si_note: knlist,
    pub si_mtx: *mut mtx,
}
impl Default for selinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct snapdata {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct devfs_dirent {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct cdev {
    pub si_spare0: *mut ::core::ffi::c_void,
    pub si_flags: u_int,
    pub si_atime: timespec,
    pub si_ctime: timespec,
    pub si_mtime: timespec,
    pub si_uid: uid_t,
    pub si_gid: gid_t,
    pub si_mode: mode_t,
    pub si_cred: *mut ucred,
    pub si_drv0: ::core::ffi::c_int,
    pub si_refcount: ::core::ffi::c_int,
    pub si_list: cdev__bindgen_ty_1,
    pub si_clone: cdev__bindgen_ty_2,
    pub si_children: cdev__bindgen_ty_3,
    pub si_siblings: cdev__bindgen_ty_4,
    pub si_parent: *mut cdev,
    pub si_mountpt: *mut mount,
    pub si_drv1: *mut ::core::ffi::c_void,
    pub si_drv2: *mut ::core::ffi::c_void,
    pub si_devsw: *mut cdevsw,
    pub si_iosize_max: ::core::ffi::c_int,
    pub si_usecount: u_long,
    pub si_threadcount: u_long,
    pub __si_u: cdev__bindgen_ty_5,
    pub si_name: [::core::ffi::c_char; 256usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct cdev__bindgen_ty_1 {
    pub le_next: *mut cdev,
    pub le_prev: *mut *mut cdev,
}
impl Default for cdev__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cdev__bindgen_ty_2 {
    pub le_next: *mut cdev,
    pub le_prev: *mut *mut cdev,
}
impl Default for cdev__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cdev__bindgen_ty_3 {
    pub lh_first: *mut cdev,
}
impl Default for cdev__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cdev__bindgen_ty_4 {
    pub le_next: *mut cdev,
    pub le_prev: *mut *mut cdev,
}
impl Default for cdev__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct cdev__bindgen_ty_5 {
    pub __sid_snapdata: __BindgenUnionField<*mut snapdata>,
    pub bindgen_union_field: u64,
}
impl Default for cdev__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for cdev {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct buf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct clonedevs {
    _unused: [u8; 0],
}
pub type d_open_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: *mut cdev,
        oflags: ::core::ffi::c_int,
        devtype: ::core::ffi::c_int,
        td: *mut thread,
    ) -> ::core::ffi::c_int,
>;
pub type d_fdopen_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: *mut cdev,
        oflags: ::core::ffi::c_int,
        td: *mut thread,
        fp: *mut file,
    ) -> ::core::ffi::c_int,
>;
pub type d_close_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: *mut cdev,
        fflag: ::core::ffi::c_int,
        devtype: ::core::ffi::c_int,
        td: *mut thread,
    ) -> ::core::ffi::c_int,
>;
pub type d_strategy_t = ::core::option::Option<unsafe extern "C" fn(bp: *mut bio)>;
pub type d_ioctl_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: *mut cdev,
        cmd: u_long,
        data: caddr_t,
        fflag: ::core::ffi::c_int,
        td: *mut thread,
    ) -> ::core::ffi::c_int,
>;
pub type d_read_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: *mut cdev,
        uio: *mut uio,
        ioflag: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
pub type d_write_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: *mut cdev,
        uio: *mut uio,
        ioflag: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
pub type d_poll_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: *mut cdev,
        events: ::core::ffi::c_int,
        td: *mut thread,
    ) -> ::core::ffi::c_int,
>;
pub type d_kqfilter_t = ::core::option::Option<
    unsafe extern "C" fn(dev: *mut cdev, kn: *mut knote) -> ::core::ffi::c_int,
>;
pub type d_mmap_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: *mut cdev,
        offset: vm_ooffset_t,
        paddr: *mut vm_paddr_t,
        nprot: ::core::ffi::c_int,
        memattr: *mut vm_memattr_t,
    ) -> ::core::ffi::c_int,
>;
pub type d_mmap_single_t = ::core::option::Option<
    unsafe extern "C" fn(
        cdev: *mut cdev,
        offset: *mut vm_ooffset_t,
        size: vm_size_t,
        object: *mut *mut vm_object,
        nprot: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
pub type d_purge_t = ::core::option::Option<unsafe extern "C" fn(dev: *mut cdev)>;
pub type dumper_t = ::core::option::Option<
    unsafe extern "C" fn(
        _priv: *mut ::core::ffi::c_void,
        _virtual: *mut ::core::ffi::c_void,
        _offset: off_t,
        _length: usize,
    ) -> ::core::ffi::c_int,
>;
pub type dumper_start_t = ::core::option::Option<
    unsafe extern "C" fn(
        di: *mut dumperinfo,
        key: *mut ::core::ffi::c_void,
        keysize: u32,
    ) -> ::core::ffi::c_int,
>;
pub type dumper_hdr_t = ::core::option::Option<
    unsafe extern "C" fn(di: *mut dumperinfo, kdh: *mut kerneldumpheader) -> ::core::ffi::c_int,
>;
#[repr(C)]
pub struct cdevsw {
    pub d_version: ::core::ffi::c_int,
    pub d_flags: u_int,
    pub d_name: *const ::core::ffi::c_char,
    pub d_open: d_open_t,
    pub d_fdopen: d_fdopen_t,
    pub d_close: d_close_t,
    pub d_read: d_read_t,
    pub d_write: d_write_t,
    pub d_ioctl: d_ioctl_t,
    pub d_poll: d_poll_t,
    pub d_mmap: d_mmap_t,
    pub d_strategy: d_strategy_t,
    pub d_spare0: *mut ::core::ffi::c_void,
    pub d_kqfilter: d_kqfilter_t,
    pub d_purge: d_purge_t,
    pub d_mmap_single: d_mmap_single_t,
    pub d_spare1: [i32; 3usize],
    pub d_spare2: [*mut ::core::ffi::c_void; 3usize],
    pub d_devs: cdevsw__bindgen_ty_1,
    pub d_spare3: ::core::ffi::c_int,
    pub __d_giant: cdevsw__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug)]
pub struct cdevsw__bindgen_ty_1 {
    pub lh_first: *mut cdev,
}
impl Default for cdevsw__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct cdevsw__bindgen_ty_2 {
    pub gianttrick: __BindgenUnionField<*mut cdevsw>,
    pub postfree_list: __BindgenUnionField<cdevsw__bindgen_ty_2__bindgen_ty_1>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug)]
pub struct cdevsw__bindgen_ty_2__bindgen_ty_1 {
    pub sle_next: *mut cdevsw,
}
impl Default for cdevsw__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for cdevsw__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for cdevsw {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct devsw_module_data {
    pub chainevh: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut module,
            arg2: ::core::ffi::c_int,
            arg3: *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    pub chainarg: *mut ::core::ffi::c_void,
}
impl Default for devsw_module_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct make_dev_args {
    pub mda_size: usize,
    pub mda_flags: ::core::ffi::c_int,
    pub mda_devsw: *mut cdevsw,
    pub mda_cr: *mut ucred,
    pub mda_uid: uid_t,
    pub mda_gid: gid_t,
    pub mda_mode: ::core::ffi::c_int,
    pub mda_unit: ::core::ffi::c_int,
    pub mda_si_drv1: *mut ::core::ffi::c_void,
    pub mda_si_drv2: *mut ::core::ffi::c_void,
}
impl Default for make_dev_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type d_priv_dtor_t =
    ::core::option::Option<unsafe extern "C" fn(data: *mut ::core::ffi::c_void)>;
pub type dev_clone_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::core::ffi::c_void,
        cred: *mut ucred,
        name: *mut ::core::ffi::c_char,
        namelen: ::core::ffi::c_int,
        result: *mut *mut cdev,
    ),
>;
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_dev_clone {
    pub ee: eventhandler_entry,
    pub eh_func: dev_clone_fn,
}
impl Default for eventhandler_entry_dev_clone {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct kerneldumpcrypto {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct dumperinfo {
    pub dumper: dumper_t,
    pub dumper_start: dumper_start_t,
    pub dumper_hdr: dumper_hdr_t,
    pub priv_: *mut ::core::ffi::c_void,
    pub blocksize: u_int,
    pub maxiosize: u_int,
    pub mediaoffset: off_t,
    pub mediasize: off_t,
    pub blockbuf: *mut ::core::ffi::c_void,
    pub dumpoff: off_t,
    pub origdumpoff: off_t,
    pub kdcrypto: *mut kerneldumpcrypto,
    pub kdcomp: *mut kerneldumpcomp,
    pub di_next: dumperinfo__bindgen_ty_1,
    pub di_devname: __IncompleteArrayField<::core::ffi::c_char>,
}
#[repr(C)]
#[derive(Debug)]
pub struct dumperinfo__bindgen_ty_1 {
    pub tqe_next: *mut dumperinfo,
    pub tqe_prev: *mut *mut dumperinfo,
}
impl Default for dumperinfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for dumperinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct filedesc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct stat {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct nameidata {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct kaiocb {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct kinfo_file {
    _unused: [u8; 0],
}
pub type fo_rdwr_t = ::core::option::Option<
    unsafe extern "C" fn(
        fp: *mut file,
        uio: *mut uio,
        active_cred: *mut ucred,
        flags: ::core::ffi::c_int,
        td: *mut thread,
    ) -> ::core::ffi::c_int,
>;
pub type fo_truncate_t = ::core::option::Option<
    unsafe extern "C" fn(
        fp: *mut file,
        length: off_t,
        active_cred: *mut ucred,
        td: *mut thread,
    ) -> ::core::ffi::c_int,
>;
pub type fo_ioctl_t = ::core::option::Option<
    unsafe extern "C" fn(
        fp: *mut file,
        com: u_long,
        data: *mut ::core::ffi::c_void,
        active_cred: *mut ucred,
        td: *mut thread,
    ) -> ::core::ffi::c_int,
>;
pub type fo_poll_t = ::core::option::Option<
    unsafe extern "C" fn(
        fp: *mut file,
        events: ::core::ffi::c_int,
        active_cred: *mut ucred,
        td: *mut thread,
    ) -> ::core::ffi::c_int,
>;
pub type fo_kqfilter_t = ::core::option::Option<
    unsafe extern "C" fn(fp: *mut file, kn: *mut knote) -> ::core::ffi::c_int,
>;
pub type fo_stat_t = ::core::option::Option<
    unsafe extern "C" fn(
        fp: *mut file,
        sb: *mut stat,
        active_cred: *mut ucred,
    ) -> ::core::ffi::c_int,
>;
pub type fo_close_t = ::core::option::Option<
    unsafe extern "C" fn(fp: *mut file, td: *mut thread) -> ::core::ffi::c_int,
>;
pub type fo_fdclose_t = ::core::option::Option<
    unsafe extern "C" fn(fp: *mut file, fd: ::core::ffi::c_int, td: *mut thread),
>;
pub type fo_chmod_t = ::core::option::Option<
    unsafe extern "C" fn(
        fp: *mut file,
        mode: mode_t,
        active_cred: *mut ucred,
        td: *mut thread,
    ) -> ::core::ffi::c_int,
>;
pub type fo_chown_t = ::core::option::Option<
    unsafe extern "C" fn(
        fp: *mut file,
        uid: uid_t,
        gid: gid_t,
        active_cred: *mut ucred,
        td: *mut thread,
    ) -> ::core::ffi::c_int,
>;
pub type fo_sendfile_t = ::core::option::Option<
    unsafe extern "C" fn(
        fp: *mut file,
        sockfd: ::core::ffi::c_int,
        hdr_uio: *mut uio,
        trl_uio: *mut uio,
        offset: off_t,
        nbytes: usize,
        sent: *mut off_t,
        flags: ::core::ffi::c_int,
        td: *mut thread,
    ) -> ::core::ffi::c_int,
>;
pub type fo_seek_t = ::core::option::Option<
    unsafe extern "C" fn(
        fp: *mut file,
        offset: off_t,
        whence: ::core::ffi::c_int,
        td: *mut thread,
    ) -> ::core::ffi::c_int,
>;
pub type fo_fill_kinfo_t = ::core::option::Option<
    unsafe extern "C" fn(
        fp: *mut file,
        kif: *mut kinfo_file,
        fdp: *mut filedesc,
    ) -> ::core::ffi::c_int,
>;
pub type fo_mmap_t = ::core::option::Option<
    unsafe extern "C" fn(
        fp: *mut file,
        map: vm_map_t,
        addr: *mut vm_offset_t,
        size: vm_size_t,
        prot: vm_prot_t,
        cap_maxprot: vm_prot_t,
        flags: ::core::ffi::c_int,
        foff: vm_ooffset_t,
        td: *mut thread,
    ) -> ::core::ffi::c_int,
>;
pub type fo_aio_queue_t = ::core::option::Option<
    unsafe extern "C" fn(fp: *mut file, job: *mut kaiocb) -> ::core::ffi::c_int,
>;
pub type fo_add_seals_t = ::core::option::Option<
    unsafe extern "C" fn(fp: *mut file, flags: ::core::ffi::c_int) -> ::core::ffi::c_int,
>;
pub type fo_get_seals_t = ::core::option::Option<
    unsafe extern "C" fn(fp: *mut file, flags: *mut ::core::ffi::c_int) -> ::core::ffi::c_int,
>;
pub type fo_fallocate_t = ::core::option::Option<
    unsafe extern "C" fn(
        fp: *mut file,
        offset: off_t,
        len: off_t,
        td: *mut thread,
    ) -> ::core::ffi::c_int,
>;
pub type fo_fspacectl_t = ::core::option::Option<
    unsafe extern "C" fn(
        fp: *mut file,
        cmd: ::core::ffi::c_int,
        offset: *mut off_t,
        length: *mut off_t,
        flags: ::core::ffi::c_int,
        active_cred: *mut ucred,
        td: *mut thread,
    ) -> ::core::ffi::c_int,
>;
pub type fo_cmp_t = ::core::option::Option<
    unsafe extern "C" fn(fp: *mut file, fp1: *mut file, td: *mut thread) -> ::core::ffi::c_int,
>;
pub type fo_fork_t = ::core::option::Option<
    unsafe extern "C" fn(
        fdp: *mut filedesc,
        fp: *mut file,
        fp1: *mut *mut file,
        p1: *mut proc_,
        td: *mut thread,
    ) -> ::core::ffi::c_int,
>;
pub type fo_spare_t =
    ::core::option::Option<unsafe extern "C" fn(fp: *mut file) -> ::core::ffi::c_int>;
pub type fo_flags_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Default)]
pub struct fileops {
    pub fo_read: fo_rdwr_t,
    pub fo_write: fo_rdwr_t,
    pub fo_truncate: fo_truncate_t,
    pub fo_ioctl: fo_ioctl_t,
    pub fo_poll: fo_poll_t,
    pub fo_kqfilter: fo_kqfilter_t,
    pub fo_stat: fo_stat_t,
    pub fo_close: fo_close_t,
    pub fo_fdclose: fo_fdclose_t,
    pub fo_chmod: fo_chmod_t,
    pub fo_chown: fo_chown_t,
    pub fo_sendfile: fo_sendfile_t,
    pub fo_seek: fo_seek_t,
    pub fo_fill_kinfo: fo_fill_kinfo_t,
    pub fo_mmap: fo_mmap_t,
    pub fo_aio_queue: fo_aio_queue_t,
    pub fo_add_seals: fo_add_seals_t,
    pub fo_get_seals: fo_get_seals_t,
    pub fo_fallocate: fo_fallocate_t,
    pub fo_fspacectl: fo_fspacectl_t,
    pub fo_cmp: fo_cmp_t,
    pub fo_fork: fo_fork_t,
    pub fo_spares: [fo_spare_t; 8usize],
    pub fo_flags: fo_flags_t,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct fadvise_info {
    pub fa_advice: ::core::ffi::c_int,
    pub fa_start: off_t,
    pub fa_end: off_t,
}
#[repr(C)]
pub struct file {
    pub f_flag: u_int,
    pub f_count: u_int,
    pub f_data: *mut ::core::ffi::c_void,
    pub f_ops: *const fileops,
    pub f_vnode: *mut vnode,
    pub f_cred: *mut ucred,
    pub f_type: ::core::ffi::c_short,
    pub f_vflags: ::core::ffi::c_short,
    pub __bindgen_anon_1: file__bindgen_ty_1,
    pub f_nextoff: [off_t; 2usize],
    pub f_vnun: file__bindgen_ty_2,
    pub f_offset: off_t,
}
#[repr(C)]
pub struct file__bindgen_ty_1 {
    pub f_seqcount: __BindgenUnionField<[i16; 2usize]>,
    pub f_pipegen: __BindgenUnionField<::core::ffi::c_int>,
    pub bindgen_union_field: u32,
}
impl Default for file__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct file__bindgen_ty_2 {
    pub fvn_cdevpriv: __BindgenUnionField<*mut cdev_privdata>,
    pub fvn_advice: __BindgenUnionField<*mut fadvise_info>,
    pub bindgen_union_field: u64,
}
impl Default for file__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for file {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct xfile {
    pub xf_size: ksize_t,
    pub xf_pid: pid_t,
    pub xf_uid: uid_t,
    pub xf_fd: ::core::ffi::c_int,
    pub _xf_int_pad1: ::core::ffi::c_int,
    pub xf_file: kvaddr_t,
    pub xf_type: ::core::ffi::c_short,
    pub _xf_short_pad1: ::core::ffi::c_short,
    pub xf_count: ::core::ffi::c_int,
    pub xf_msgcount: ::core::ffi::c_int,
    pub _xf_int_pad2: ::core::ffi::c_int,
    pub xf_offset: off_t,
    pub xf_data: kvaddr_t,
    pub xf_vnode: kvaddr_t,
    pub xf_flag: u_int,
    pub _xf_int_pad3: ::core::ffi::c_int,
    pub _xf_int64_pad: [i64; 6usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct iovec {
    pub iov_base: *mut ::core::ffi::c_void,
    pub iov_len: usize,
}
impl Default for iovec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const UIO_READ: uio_rw = 0;
pub const UIO_WRITE: uio_rw = 1;
pub type uio_rw = ::core::ffi::c_uint;
pub const UIO_USERSPACE: uio_seg = 0;
pub const UIO_SYSSPACE: uio_seg = 1;
pub const UIO_NOCOPY: uio_seg = 2;
pub type uio_seg = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct uio {
    pub uio_iov: *mut iovec,
    pub uio_iovcnt: ::core::ffi::c_int,
    pub uio_offset: off_t,
    pub uio_resid: isize,
    pub uio_segflg: uio_seg,
    pub uio_rw: uio_rw,
    pub uio_td: *mut thread,
}
impl Default for uio {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct shm_largepage_conf {
    pub psind: ::core::ffi::c_int,
    pub alloc_policy: ::core::ffi::c_int,
    pub pad: [::core::ffi::c_int; 10usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct rl_q_entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct rangelock {
    pub head: usize,
    pub sleepers: bool_,
}
#[repr(C)]
#[derive(Debug)]
pub struct shmfd {
    pub shm_size: vm_ooffset_t,
    pub shm_object: vm_object_t,
    pub shm_pages: vm_pindex_t,
    pub shm_refs: ::core::ffi::c_int,
    pub shm_uid: uid_t,
    pub shm_gid: gid_t,
    pub shm_mode: mode_t,
    pub shm_kmappings: ::core::ffi::c_int,
    pub shm_atime: timespec,
    pub shm_mtime: timespec,
    pub shm_ctime: timespec,
    pub shm_birthtime: timespec,
    pub shm_ino: ino_t,
    pub shm_label: *mut label,
    pub shm_path: *const ::core::ffi::c_char,
    pub shm_rl: rangelock,
    pub shm_mtx: mtx,
    pub shm_flags: ::core::ffi::c_int,
    pub shm_seals: ::core::ffi::c_int,
    pub shm_lp_psind: ::core::ffi::c_int,
    pub shm_lp_alloc_policy: ::core::ffi::c_int,
}
impl Default for shmfd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nfds_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default)]
pub struct pollfd {
    pub fd: ::core::ffi::c_int,
    pub events: ::core::ffi::c_short,
    pub revents: ::core::ffi::c_short,
}
pub type sbuf_drain_func = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug)]
pub struct sbuf {
    pub s_buf: *mut ::core::ffi::c_char,
    pub s_drain_func: sbuf_drain_func,
    pub s_drain_arg: *mut ::core::ffi::c_void,
    pub s_error: ::core::ffi::c_int,
    pub s_size: isize,
    pub s_len: isize,
    pub s_flags: ::core::ffi::c_int,
    pub s_sect_len: isize,
    pub s_rec_off: isize,
}
impl Default for sbuf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct snd_size {
    pub play_size: ::core::ffi::c_int,
    pub rec_size: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct _snd_chan_param {
    pub play_rate: u_long,
    pub rec_rate: u_long,
    pub play_format: u_long,
    pub rec_format: u_long,
}
pub type snd_chan_param = _snd_chan_param;
#[repr(C)]
#[derive(Debug, Default)]
pub struct _snd_mix_param {
    pub subdev: u_char,
    pub line: u_char,
    pub left: u_char,
    pub right: u_char,
}
pub type snd_mix_param = _snd_mix_param;
#[repr(C)]
#[derive(Debug, Default)]
pub struct _snd_sync_parm {
    pub chan: ::core::ffi::c_long,
    pub pos: ::core::ffi::c_long,
}
pub type snd_sync_parm = _snd_sync_parm;
#[repr(C)]
#[derive(Debug, Default)]
pub struct _snd_capabilities {
    pub rate_min: u_long,
    pub rate_max: u_long,
    pub formats: u_long,
    pub bufsize: u_long,
    pub mixers: u_long,
    pub inputs: u_long,
    pub left: u_short,
    pub right: u_short,
}
pub type snd_capabilities = _snd_capabilities;
#[repr(C)]
#[derive(Debug, Default)]
pub struct seq_event_rec {
    pub arr: [u_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct patch_info {
    pub key: ::core::ffi::c_short,
    pub device_no: ::core::ffi::c_short,
    pub instr_no: ::core::ffi::c_short,
    pub mode: u_long,
    pub len: ::core::ffi::c_long,
    pub loop_start: ::core::ffi::c_long,
    pub loop_end: ::core::ffi::c_long,
    pub base_freq: u_int,
    pub base_note: u_long,
    pub high_note: u_long,
    pub low_note: u_long,
    pub panning: ::core::ffi::c_int,
    pub detuning: ::core::ffi::c_int,
    pub env_rate: [u_char; 6usize],
    pub env_offset: [u_char; 6usize],
    pub tremolo_sweep: u_char,
    pub tremolo_rate: u_char,
    pub tremolo_depth: u_char,
    pub vibrato_sweep: u_char,
    pub vibrato_rate: u_char,
    pub vibrato_depth: u_char,
    pub scale_frequency: ::core::ffi::c_int,
    pub scale_factor: u_int,
    pub volume: ::core::ffi::c_int,
    pub spare: [::core::ffi::c_int; 4usize],
    pub data: [::core::ffi::c_char; 1usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct sysex_info {
    pub key: ::core::ffi::c_short,
    pub device_no: ::core::ffi::c_short,
    pub len: ::core::ffi::c_long,
    pub data: [u_char; 1usize],
}
#[repr(C)]
pub struct patmgr_info {
    pub key: u_long,
    pub device: ::core::ffi::c_int,
    pub command: ::core::ffi::c_int,
    pub parm1: ::core::ffi::c_long,
    pub parm2: ::core::ffi::c_long,
    pub parm3: ::core::ffi::c_long,
    pub data: patmgr_info__bindgen_ty_1,
}
#[repr(C)]
pub struct patmgr_info__bindgen_ty_1 {
    pub data8: __BindgenUnionField<[u_char; 4000usize]>,
    pub data16: __BindgenUnionField<[u_short; 2000usize]>,
    pub data32: __BindgenUnionField<[u_long; 1000usize]>,
    pub patch: __BindgenUnionField<patch_info>,
    pub bindgen_union_field: [u64; 1000usize],
}
impl Default for patmgr_info__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for patmgr_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sbi_instr_data = [u_char; 32usize];
#[repr(C)]
#[derive(Debug, Default)]
pub struct sbi_instrument {
    pub key: u_short,
    pub device: ::core::ffi::c_short,
    pub channel: ::core::ffi::c_int,
    pub operators: sbi_instr_data,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct synth_info {
    pub name: [::core::ffi::c_char; 30usize],
    pub device: ::core::ffi::c_int,
    pub synth_type: ::core::ffi::c_int,
    pub synth_subtype: ::core::ffi::c_int,
    pub perc_mode: ::core::ffi::c_int,
    pub nr_voices: ::core::ffi::c_int,
    pub nr_drums: ::core::ffi::c_int,
    pub instr_bank_size: ::core::ffi::c_int,
    pub capabilities: u_long,
    pub dummies: [::core::ffi::c_int; 19usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct sound_timer_info {
    pub name: [::core::ffi::c_char; 32usize],
    pub caps: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct midi_info {
    pub name: [::core::ffi::c_char; 30usize],
    pub device: ::core::ffi::c_int,
    pub capabilities: u_long,
    pub dev_type: ::core::ffi::c_int,
    pub dummies: [::core::ffi::c_int; 18usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct mpu_command_rec {
    pub cmd: u_char,
    pub nr_args: ::core::ffi::c_char,
    pub nr_returns: ::core::ffi::c_char,
    pub data: [u_char; 30usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct audio_buf_info {
    pub fragments: ::core::ffi::c_int,
    pub fragstotal: ::core::ffi::c_int,
    pub fragsize: ::core::ffi::c_int,
    pub bytes: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct count_info {
    pub bytes: ::core::ffi::c_int,
    pub blocks: ::core::ffi::c_int,
    pub ptr: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct buffmem_desc {
    pub buffer: caddr_t,
    pub size: ::core::ffi::c_int,
}
impl Default for buffmem_desc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct copr_buffer {
    pub command: ::core::ffi::c_int,
    pub flags: ::core::ffi::c_int,
    pub len: ::core::ffi::c_int,
    pub offs: ::core::ffi::c_int,
    pub data: [u_char; 4000usize],
}
impl Default for copr_buffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct copr_debug_buf {
    pub command: ::core::ffi::c_int,
    pub parm1: ::core::ffi::c_int,
    pub parm2: ::core::ffi::c_int,
    pub flags: ::core::ffi::c_int,
    pub len: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct copr_msg {
    pub len: ::core::ffi::c_int,
    pub data: [u_char; 4000usize],
}
impl Default for copr_msg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct mixer_info {
    pub id: [::core::ffi::c_char; 16usize],
    pub name: [::core::ffi::c_char; 32usize],
    pub modify_counter: ::core::ffi::c_int,
    pub fillers: [::core::ffi::c_int; 10usize],
}
pub type oss_longname_t = [::core::ffi::c_char; 64usize];
pub type oss_label_t = [::core::ffi::c_char; 16usize];
pub type oss_devnode_t = [::core::ffi::c_char; 32usize];
#[repr(C)]
#[derive(Debug, Default)]
pub struct audio_errinfo {
    pub play_underruns: ::core::ffi::c_int,
    pub rec_overruns: ::core::ffi::c_int,
    pub play_ptradjust: ::core::ffi::c_uint,
    pub rec_ptradjust: ::core::ffi::c_uint,
    pub play_errorcount: ::core::ffi::c_int,
    pub rec_errorcount: ::core::ffi::c_int,
    pub play_lasterror: ::core::ffi::c_int,
    pub rec_lasterror: ::core::ffi::c_int,
    pub play_errorparm: ::core::ffi::c_long,
    pub rec_errorparm: ::core::ffi::c_long,
    pub filler: [::core::ffi::c_int; 16usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct oss_syncgroup {
    pub id: ::core::ffi::c_int,
    pub mode: ::core::ffi::c_int,
    pub filler: [::core::ffi::c_int; 16usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct oss_count_t {
    pub samples: ::core::ffi::c_longlong,
    pub fifo_samples: ::core::ffi::c_int,
    pub filler: [::core::ffi::c_int; 32usize],
}
pub type oss_peaks_t = [::core::ffi::c_ushort; 128usize];
#[doc = " @brief\tArgument for SNDCTL_SYSINFO ioctl.\n\n For use w/ the SNDCTL_SYSINFO ioctl available on audio (/dev/dsp*),\n mixer, and MIDI devices."]
#[repr(C)]
#[derive(Debug)]
pub struct oss_sysinfo {
    pub product: [::core::ffi::c_char; 32usize],
    pub version: [::core::ffi::c_char; 32usize],
    pub versionnum: ::core::ffi::c_int,
    pub options: [::core::ffi::c_char; 128usize],
    pub numaudios: ::core::ffi::c_int,
    pub openedaudio: [::core::ffi::c_int; 8usize],
    pub numsynths: ::core::ffi::c_int,
    pub nummidis: ::core::ffi::c_int,
    pub numtimers: ::core::ffi::c_int,
    pub nummixers: ::core::ffi::c_int,
    pub openedmidi: [::core::ffi::c_int; 8usize],
    pub numcards: ::core::ffi::c_int,
    pub numaudioengines: ::core::ffi::c_int,
    pub license: [::core::ffi::c_char; 16usize],
    pub revision_info: [::core::ffi::c_char; 256usize],
    pub filler: [::core::ffi::c_int; 172usize],
}
impl Default for oss_sysinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct oss_mixext {
    pub dev: ::core::ffi::c_int,
    pub ctrl: ::core::ffi::c_int,
    pub type_: ::core::ffi::c_int,
    pub maxvalue: ::core::ffi::c_int,
    pub minvalue: ::core::ffi::c_int,
    pub flags: ::core::ffi::c_int,
    pub id: [::core::ffi::c_char; 16usize],
    pub parent: ::core::ffi::c_int,
    pub dummy: ::core::ffi::c_int,
    pub timestamp: ::core::ffi::c_int,
    pub data: [::core::ffi::c_char; 64usize],
    pub enum_present: [::core::ffi::c_uchar; 32usize],
    pub control_no: ::core::ffi::c_int,
    pub desc: ::core::ffi::c_uint,
    pub extname: [::core::ffi::c_char; 32usize],
    pub update_counter: ::core::ffi::c_int,
    pub filler: [::core::ffi::c_int; 7usize],
}
impl Default for oss_mixext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct oss_mixext_root {
    pub id: [::core::ffi::c_char; 16usize],
    pub name: [::core::ffi::c_char; 48usize],
}
impl Default for oss_mixext_root {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct oss_mixer_value {
    pub dev: ::core::ffi::c_int,
    pub ctrl: ::core::ffi::c_int,
    pub value: ::core::ffi::c_int,
    pub flags: ::core::ffi::c_int,
    pub timestamp: ::core::ffi::c_int,
    pub filler: [::core::ffi::c_int; 8usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct oss_mixer_enuminfo {
    pub dev: ::core::ffi::c_int,
    pub ctrl: ::core::ffi::c_int,
    pub nvalues: ::core::ffi::c_int,
    pub version: ::core::ffi::c_int,
    pub strindex: [::core::ffi::c_short; 255usize],
    pub strings: [::core::ffi::c_char; 3000usize],
}
impl Default for oss_mixer_enuminfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief\tArgument for SNDCTL_AUDIOINFO ioctl.\n\n For use w/ the SNDCTL_AUDIOINFO ioctl available on audio (/dev/dsp*)\n devices."]
#[repr(C)]
#[derive(Debug)]
pub struct oss_audioinfo {
    pub dev: ::core::ffi::c_int,
    pub name: [::core::ffi::c_char; 64usize],
    pub busy: ::core::ffi::c_int,
    pub pid: ::core::ffi::c_int,
    pub caps: ::core::ffi::c_int,
    pub iformats: ::core::ffi::c_int,
    pub oformats: ::core::ffi::c_int,
    pub magic: ::core::ffi::c_int,
    pub cmd: [::core::ffi::c_char; 64usize],
    pub card_number: ::core::ffi::c_int,
    pub port_number: ::core::ffi::c_int,
    pub mixer_dev: ::core::ffi::c_int,
    pub legacy_device: ::core::ffi::c_int,
    pub enabled: ::core::ffi::c_int,
    pub flags: ::core::ffi::c_int,
    pub min_rate: ::core::ffi::c_int,
    pub max_rate: ::core::ffi::c_int,
    pub min_channels: ::core::ffi::c_int,
    pub max_channels: ::core::ffi::c_int,
    pub binding: ::core::ffi::c_int,
    pub rate_source: ::core::ffi::c_int,
    pub handle: [::core::ffi::c_char; 32usize],
    pub nrates: ::core::ffi::c_uint,
    pub rates: [::core::ffi::c_uint; 20usize],
    pub song_name: oss_longname_t,
    pub label: oss_label_t,
    pub latency: ::core::ffi::c_int,
    pub devnode: oss_devnode_t,
    pub next_play_engine: ::core::ffi::c_int,
    pub next_rec_engine: ::core::ffi::c_int,
    pub filler: [::core::ffi::c_int; 184usize],
}
impl Default for oss_audioinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct oss_mixerinfo {
    pub dev: ::core::ffi::c_int,
    pub id: [::core::ffi::c_char; 16usize],
    pub name: [::core::ffi::c_char; 32usize],
    pub modify_counter: ::core::ffi::c_int,
    pub card_number: ::core::ffi::c_int,
    pub port_number: ::core::ffi::c_int,
    pub handle: [::core::ffi::c_char; 32usize],
    pub magic: ::core::ffi::c_int,
    pub enabled: ::core::ffi::c_int,
    pub caps: ::core::ffi::c_int,
    pub flags: ::core::ffi::c_int,
    pub nrext: ::core::ffi::c_int,
    pub priority: ::core::ffi::c_int,
    pub devnode: oss_devnode_t,
    pub legacy_device: ::core::ffi::c_int,
    pub filler: [::core::ffi::c_int; 245usize],
}
impl Default for oss_mixerinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct oss_midi_info {
    pub dev: ::core::ffi::c_int,
    pub name: [::core::ffi::c_char; 64usize],
    pub busy: ::core::ffi::c_int,
    pub pid: ::core::ffi::c_int,
    pub cmd: [::core::ffi::c_char; 64usize],
    pub caps: ::core::ffi::c_int,
    pub magic: ::core::ffi::c_int,
    pub card_number: ::core::ffi::c_int,
    pub port_number: ::core::ffi::c_int,
    pub enabled: ::core::ffi::c_int,
    pub flags: ::core::ffi::c_int,
    pub handle: [::core::ffi::c_char; 32usize],
    pub song_name: oss_longname_t,
    pub label: oss_label_t,
    pub latency: ::core::ffi::c_int,
    pub filler: [::core::ffi::c_int; 244usize],
}
impl Default for oss_midi_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct oss_card_info {
    pub card: ::core::ffi::c_int,
    pub shortname: [::core::ffi::c_char; 16usize],
    pub longname: [::core::ffi::c_char; 128usize],
    pub flags: ::core::ffi::c_int,
    pub hw_info: [::core::ffi::c_char; 400usize],
    pub intr_count: ::core::ffi::c_int,
    pub ack_count: ::core::ffi::c_int,
    pub filler: [::core::ffi::c_int; 154usize],
}
impl Default for oss_card_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct sndstioc_nv_arg {
    pub nbytes: usize,
    pub buf: *mut ::core::ffi::c_void,
}
impl Default for sndstioc_nv_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct sndstioc_nv_arg32 {
    pub nbytes: u32,
    pub buf: u32,
}
#[repr(C)]
#[derive(Debug)]
pub struct sysctl_req {
    pub td: *mut thread,
    pub lock: ::core::ffi::c_int,
    pub oldptr: *mut ::core::ffi::c_void,
    pub oldlen: usize,
    pub oldidx: usize,
    pub oldfunc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sysctl_req,
            arg2: *const ::core::ffi::c_void,
            arg3: usize,
        ) -> ::core::ffi::c_int,
    >,
    pub newptr: *const ::core::ffi::c_void,
    pub newlen: usize,
    pub newidx: usize,
    pub newfunc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sysctl_req,
            arg2: *mut ::core::ffi::c_void,
            arg3: usize,
        ) -> ::core::ffi::c_int,
    >,
    pub validlen: usize,
    pub flags: ::core::ffi::c_int,
}
impl Default for sysctl_req {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct sysctl_oid_list {
    pub rbh_root: *mut sysctl_oid,
}
impl Default for sysctl_oid_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct sysctl_oid {
    pub oid_children: sysctl_oid_list,
    pub oid_parent: *mut sysctl_oid_list,
    pub oid_link: sysctl_oid__bindgen_ty_1,
    pub oid_number: ::core::ffi::c_int,
    pub oid_kind: u_int,
    pub oid_arg1: *mut ::core::ffi::c_void,
    pub oid_arg2: intmax_t,
    pub oid_name: *const ::core::ffi::c_char,
    pub oid_handler: ::core::option::Option<
        unsafe extern "C" fn(
            oidp: *mut sysctl_oid,
            arg1: *mut ::core::ffi::c_void,
            arg2: intmax_t,
            req: *mut sysctl_req,
        ) -> ::core::ffi::c_int,
    >,
    pub oid_fmt: *const ::core::ffi::c_char,
    pub oid_refcnt: ::core::ffi::c_int,
    pub oid_running: u_int,
    pub oid_descr: *const ::core::ffi::c_char,
    pub oid_label: *const ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug)]
pub struct sysctl_oid__bindgen_ty_1 {
    pub rbe_link: [*mut sysctl_oid; 3usize],
}
impl Default for sysctl_oid__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sysctl_oid {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct sysctl_ctx_entry {
    pub entry: *mut sysctl_oid,
    pub link: sysctl_ctx_entry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug)]
pub struct sysctl_ctx_entry__bindgen_ty_1 {
    pub tqe_next: *mut sysctl_ctx_entry,
    pub tqe_prev: *mut *mut sysctl_ctx_entry,
}
impl Default for sysctl_ctx_entry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sysctl_ctx_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct sysctl_ctx_list {
    pub tqh_first: *mut sysctl_ctx_entry,
    pub tqh_last: *mut *mut sysctl_ctx_entry,
}
impl Default for sysctl_ctx_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct pmap_statistics {
    pub resident_count: ::core::ffi::c_long,
    pub wired_count: ::core::ffi::c_long,
}
pub type pmap_statistics_t = *mut pmap_statistics;
pub type pd_entry_t = u64;
pub type pt_entry_t = u64;
#[repr(C)]
#[derive(Debug)]
pub struct pv_entry {
    pub pv_va: vm_offset_t,
    pub pv_next: pv_entry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug)]
pub struct pv_entry__bindgen_ty_1 {
    pub tqe_next: *mut pv_entry,
    pub tqe_prev: *mut *mut pv_entry,
}
impl Default for pv_entry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for pv_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pv_entry_t = *mut pv_entry;
#[repr(C)]
#[derive(Debug)]
pub struct pv_chunk_header {
    pub pc_pmap: *mut pmap,
    pub pc_list: pv_chunk_header__bindgen_ty_1,
    pub pc_map: [::core::ffi::c_ulong; 3usize],
    pub pc_lru: pv_chunk_header__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug)]
pub struct pv_chunk_header__bindgen_ty_1 {
    pub tqe_next: *mut pv_chunk,
    pub tqe_prev: *mut *mut pv_chunk,
}
impl Default for pv_chunk_header__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pv_chunk_header__bindgen_ty_2 {
    pub tqe_next: *mut pv_chunk,
    pub tqe_prev: *mut *mut pv_chunk,
}
impl Default for pv_chunk_header__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for pv_chunk_header {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pv_chunk {
    pub pc_pmap: *mut pmap,
    pub pc_list: pv_chunk__bindgen_ty_1,
    pub pc_map: [::core::ffi::c_ulong; 3usize],
    pub pc_lru: pv_chunk__bindgen_ty_2,
    pub pc_pventry: [pv_entry; 168usize],
    pub pc_pad: __IncompleteArrayField<::core::ffi::c_ulong>,
}
#[repr(C)]
#[derive(Debug)]
pub struct pv_chunk__bindgen_ty_1 {
    pub tqe_next: *mut pv_chunk,
    pub tqe_prev: *mut *mut pv_chunk,
}
impl Default for pv_chunk__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pv_chunk__bindgen_ty_2 {
    pub tqe_next: *mut pv_chunk,
    pub tqe_prev: *mut *mut pv_chunk,
}
impl Default for pv_chunk__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for pv_chunk {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pctrie_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct pctrie {
    pub pt_root: *mut pctrie_node,
}
impl Default for pctrie {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct vm_radix {
    pub rt_trie: pctrie,
}
impl Default for vm_radix {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct rangeset {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct md_page {
    pub pv_list: md_page__bindgen_ty_1,
    pub pv_gen: ::core::ffi::c_int,
    pub pv_memattr: vm_memattr_t,
    pub pv_reserve: [u8; 3usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct md_page__bindgen_ty_1 {
    pub tqh_first: *mut pv_entry,
    pub tqh_last: *mut *mut pv_entry,
}
impl Default for md_page__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for md_page {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const PM_INVALID: pmap_stage = 0;
pub const PM_STAGE1: pmap_stage = 1;
pub const PM_STAGE2: pmap_stage = 2;
pub type pmap_stage = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct pmap {
    pub pm_mtx: mtx,
    pub pm_stats: pmap_statistics,
    pub pm_ttbr: u64,
    pub pm_l0_paddr: vm_paddr_t,
    pub pm_l0: *mut pd_entry_t,
    pub pm_pvchunk: pmap__bindgen_ty_1,
    pub pm_root: vm_radix,
    pub pm_cookie: ::core::ffi::c_long,
    pub pm_asid_set: *mut asid_set,
    pub pm_stage: pmap_stage,
    pub pm_levels: ::core::ffi::c_int,
    pub pm_bti: *mut rangeset,
    pub pm_reserved: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct pmap__bindgen_ty_1 {
    pub tqh_first: *mut pv_chunk,
    pub tqh_last: *mut *mut pv_chunk,
}
impl Default for pmap__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for pmap {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pmap_t = *mut pmap;
#[repr(C)]
#[derive(Debug)]
pub struct snd_mixer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct snd_dbuf {
    pub buf: *mut u_int8_t,
    pub tmpbuf: *mut u_int8_t,
    #[doc = "< shadow buffer used w/ S_D_SILENCE/SKIP"]
    pub shadbuf: *mut u_int8_t,
    #[doc = "< shadbuf ready length in # of bytes"]
    pub sl: ::core::ffi::c_int,
    pub bufsize: ::core::ffi::c_uint,
    pub maxsize: ::core::ffi::c_uint,
    pub allocsize: ::core::ffi::c_uint,
    pub dl: ::core::ffi::c_int,
    pub rp: ::core::ffi::c_int,
    pub rl: ::core::ffi::c_int,
    pub hp: ::core::ffi::c_int,
    pub total: u_int64_t,
    pub prev_total: u_int64_t,
    pub dmachan: ::core::ffi::c_int,
    pub fmt: u_int32_t,
    pub spd: u_int32_t,
    pub bps: u_int32_t,
    pub align: u_int32_t,
    pub blksz: ::core::ffi::c_uint,
    pub blkcnt: ::core::ffi::c_uint,
    pub xrun: ::core::ffi::c_int,
    pub flags: u_int32_t,
    pub dmamap: bus_dmamap_t,
    pub dmatag: bus_dma_tag_t,
    pub buf_addr: bus_addr_t,
    pub dmaflags: ::core::ffi::c_int,
    pub sel: selinfo,
    pub channel: *mut pcm_channel,
    pub name: [::core::ffi::c_char; 48usize],
}
impl Default for snd_dbuf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pcmchan_caps {
    pub minspeed: u_int32_t,
    pub maxspeed: u_int32_t,
    pub fmtlist: *mut u_int32_t,
    pub caps: u_int32_t,
}
impl Default for pcmchan_caps {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct pcmchan_matrix {
    pub id: ::core::ffi::c_int,
    pub channels: u8,
    pub ext: u8,
    pub map: [pcmchan_matrix__bindgen_ty_1; 19usize],
    pub mask: u32,
    pub offset: [i8; 18usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct pcmchan_matrix__bindgen_ty_1 {
    pub type_: ::core::ffi::c_int,
    pub members: u32,
}
#[repr(C)]
#[derive(Debug)]
pub struct pcm_synclist {
    pub slh_first: *mut pcmchan_syncgroup,
}
impl Default for pcm_synclist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Specifies an audio device sync group"]
#[repr(C)]
#[derive(Debug)]
pub struct pcmchan_syncgroup {
    pub link: pcmchan_syncgroup__bindgen_ty_1,
    pub members: pcmchan_syncgroup__bindgen_ty_2,
    #[doc = "< Group identifier; set to address of group."]
    pub id: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct pcmchan_syncgroup__bindgen_ty_1 {
    pub sle_next: *mut pcmchan_syncgroup,
}
impl Default for pcmchan_syncgroup__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pcmchan_syncgroup__bindgen_ty_2 {
    pub slh_first: *mut pcmchan_syncmember,
}
impl Default for pcmchan_syncgroup__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for pcmchan_syncgroup {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Specifies a container for members of a sync group"]
#[repr(C)]
#[derive(Debug)]
pub struct pcmchan_syncmember {
    pub link: pcmchan_syncmember__bindgen_ty_1,
    #[doc = "< group head"]
    pub parent: *mut pcmchan_syncgroup,
    pub ch: *mut pcm_channel,
}
#[repr(C)]
#[derive(Debug)]
pub struct pcmchan_syncmember__bindgen_ty_1 {
    pub sle_next: *mut pcmchan_syncmember,
}
impl Default for pcmchan_syncmember__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for pcmchan_syncmember {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct pcm_channel {
    pub methods: kobj_t,
    pub pid: pid_t,
    pub feeder: *mut pcm_feeder,
    pub align: u_int32_t,
    pub latency: ::core::ffi::c_int,
    pub speed: u_int32_t,
    pub format: u_int32_t,
    pub flags: u_int32_t,
    pub feederflags: u_int32_t,
    pub blocks: u_int64_t,
    pub direction: ::core::ffi::c_int,
    pub interrupts: ::core::ffi::c_uint,
    pub xruns: ::core::ffi::c_uint,
    pub feedcount: ::core::ffi::c_uint,
    pub timeout: ::core::ffi::c_uint,
    pub bufhard: *mut snd_dbuf,
    pub bufsoft: *mut snd_dbuf,
    pub parentsnddev: *mut snddev_info,
    pub parentchannel: *mut pcm_channel,
    pub devinfo: *mut ::core::ffi::c_void,
    pub dev: device_t,
    pub unit: ::core::ffi::c_int,
    pub type_: ::core::ffi::c_int,
    pub name: [::core::ffi::c_char; 32usize],
    pub comm: [::core::ffi::c_char; 20usize],
    pub lock: mtx,
    pub trigger: ::core::ffi::c_int,
    #[doc = " For interrupt manipulations."]
    pub intr_cv: cv,
    #[doc = " Increment,decrement this around operations that temporarily yield\n lock."]
    pub inprog: ::core::ffi::c_uint,
    pub sleeping: ::core::ffi::c_uint,
    #[doc = " Special channel operations should examine @c inprog after acquiring\n lock.  If zero, operations may continue.  Else, thread should\n wait on this cv for previous operation to finish."]
    pub cv: cv,
    #[doc = " Low water mark for select()/poll().\n\n This is initialized to the channel's fragment size, and will be\n overwritten if a new fragment size is set.  Users may alter this\n value directly with the @c SNDCTL_DSP_LOW_WATER ioctl."]
    pub lw: ::core::ffi::c_uint,
    #[doc = " If part of a sync group, this will point to the syncmember\n container."]
    pub sm: *mut pcmchan_syncmember,
    pub children: pcm_channel__bindgen_ty_1,
    pub channels: pcm_channel__bindgen_ty_2,
    pub matrix: pcmchan_matrix,
    pub matrix_scratch: pcmchan_matrix,
    pub volume: [[i16; 19usize]; 3usize],
    pub muted: [[i8; 19usize]; 3usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct pcm_channel__bindgen_ty_1 {
    pub head: pcm_channel__bindgen_ty_1__bindgen_ty_1,
    pub link: pcm_channel__bindgen_ty_1__bindgen_ty_2,
    pub busy: pcm_channel__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug)]
pub struct pcm_channel__bindgen_ty_1__bindgen_ty_1 {
    pub slh_first: *mut pcm_channel,
}
impl Default for pcm_channel__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pcm_channel__bindgen_ty_1__bindgen_ty_2 {
    pub sle_next: *mut pcm_channel,
}
impl Default for pcm_channel__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pcm_channel__bindgen_ty_1__bindgen_ty_3 {
    pub head: pcm_channel__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
    pub link: pcm_channel__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug)]
pub struct pcm_channel__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    pub slh_first: *mut pcm_channel,
}
impl Default for pcm_channel__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pcm_channel__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 {
    pub sle_next: *mut pcm_channel,
}
impl Default for pcm_channel__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for pcm_channel__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for pcm_channel__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pcm_channel__bindgen_ty_2 {
    pub pcm: pcm_channel__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug)]
pub struct pcm_channel__bindgen_ty_2__bindgen_ty_1 {
    pub link: pcm_channel__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub busy: pcm_channel__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    pub opened: pcm_channel__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3,
    pub primary: pcm_channel__bindgen_ty_2__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug)]
pub struct pcm_channel__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub sle_next: *mut pcm_channel,
}
impl Default for pcm_channel__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pcm_channel__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    pub link: pcm_channel__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug)]
pub struct pcm_channel__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub sle_next: *mut pcm_channel,
}
impl Default for pcm_channel__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for pcm_channel__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pcm_channel__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3 {
    pub link: pcm_channel__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug)]
pub struct pcm_channel__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    pub sle_next: *mut pcm_channel,
}
impl Default for pcm_channel__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for pcm_channel__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pcm_channel__bindgen_ty_2__bindgen_ty_1__bindgen_ty_4 {
    pub link: pcm_channel__bindgen_ty_2__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug)]
pub struct pcm_channel__bindgen_ty_2__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub sle_next: *mut pcm_channel,
}
impl Default for pcm_channel__bindgen_ty_2__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for pcm_channel__bindgen_ty_2__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for pcm_channel__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for pcm_channel__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for pcm_channel {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief A function implementing the CHANNEL_INIT() method"]
pub type channel_init_t = ::core::option::Option<
    unsafe extern "C" fn(
        obj: kobj_t,
        devinfo: *mut ::core::ffi::c_void,
        b: *mut snd_dbuf,
        c: *mut pcm_channel,
        dir: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void,
>;
#[doc = " @brief A function implementing the CHANNEL_FREE() method"]
pub type channel_free_t = ::core::option::Option<
    unsafe extern "C" fn(obj: kobj_t, data: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the CHANNEL_RESET() method"]
pub type channel_reset_t = ::core::option::Option<
    unsafe extern "C" fn(obj: kobj_t, data: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the CHANNEL_RESETDONE() method"]
pub type channel_resetdone_t = ::core::option::Option<
    unsafe extern "C" fn(obj: kobj_t, data: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the CHANNEL_SETFORMAT() method"]
pub type channel_setformat_t = ::core::option::Option<
    unsafe extern "C" fn(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        format: u_int32_t,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the CHANNEL_SETSPEED() method"]
pub type channel_setspeed_t = ::core::option::Option<
    unsafe extern "C" fn(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        speed: u_int32_t,
    ) -> u_int32_t,
>;
#[doc = " @brief A function implementing the CHANNEL_SETBLOCKSIZE() method"]
pub type channel_setblocksize_t = ::core::option::Option<
    unsafe extern "C" fn(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        blocksize: u_int32_t,
    ) -> u_int32_t,
>;
#[doc = " @brief A function implementing the CHANNEL_SETFRAGMENTS() method"]
pub type channel_setfragments_t = ::core::option::Option<
    unsafe extern "C" fn(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        blocksize: u_int32_t,
        blockcount: u_int32_t,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the CHANNEL_TRIGGER() method"]
pub type channel_trigger_t = ::core::option::Option<
    unsafe extern "C" fn(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        go: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the CHANNEL_GETPTR() method"]
pub type channel_getptr_t = ::core::option::Option<
    unsafe extern "C" fn(obj: kobj_t, data: *mut ::core::ffi::c_void) -> u_int32_t,
>;
#[doc = " @brief A function implementing the CHANNEL_GETCAPS() method"]
pub type channel_getcaps_t = ::core::option::Option<
    unsafe extern "C" fn(obj: kobj_t, data: *mut ::core::ffi::c_void) -> *mut pcmchan_caps,
>;
#[doc = " @brief A function implementing the CHANNEL_NOTIFY() method"]
pub type channel_notify_t = ::core::option::Option<
    unsafe extern "C" fn(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        changed: u_int32_t,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the CHANNEL_GETPEAKS() method"]
pub type channel_getpeaks_t = ::core::option::Option<
    unsafe extern "C" fn(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        lpeak: *mut ::core::ffi::c_int,
        rpeak: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the CHANNEL_GETRATES() method"]
pub type channel_getrates_t = ::core::option::Option<
    unsafe extern "C" fn(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        rates: *mut *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the CHANNEL_GETMATRIX() method"]
pub type channel_getmatrix_t = ::core::option::Option<
    unsafe extern "C" fn(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        format: u_int32_t,
    ) -> *mut pcmchan_matrix,
>;
#[doc = " @brief A function implementing the CHANNEL_SETMATRIX() method"]
pub type channel_setmatrix_t = ::core::option::Option<
    unsafe extern "C" fn(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        m: *mut pcmchan_matrix,
    ) -> ::core::ffi::c_int,
>;
pub const PCMDIR_PLAY: _bindgen_ty_3 = 1;
pub const PCMDIR_PLAY_VIRTUAL: _bindgen_ty_3 = 2;
pub const PCMDIR_REC: _bindgen_ty_3 = 3;
pub const PCMDIR_REC_VIRTUAL: _bindgen_ty_3 = 4;
pub type _bindgen_ty_3 = ::core::ffi::c_uint;
pub const FEEDER_ROOT: feeder_type = 0;
pub const FEEDER_FORMAT: feeder_type = 1;
pub const FEEDER_MIXER: feeder_type = 2;
pub const FEEDER_RATE: feeder_type = 3;
pub const FEEDER_EQ: feeder_type = 4;
pub const FEEDER_VOLUME: feeder_type = 5;
pub const FEEDER_MATRIX: feeder_type = 6;
pub const FEEDER_LAST: feeder_type = 7;
pub type feeder_type = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default)]
pub struct pcm_feederdesc {
    pub in_: u_int32_t,
    pub out: u_int32_t,
}
#[repr(C)]
#[derive(Debug)]
pub struct feeder_class {
    pub name: *const ::core::ffi::c_char,
    pub methods: *const kobj_method,
    pub size: usize,
    pub baseclasses: *mut kobj_class_t,
    pub refs: u_int,
    pub ops: kobj_ops_t,
    pub type_: feeder_type,
    pub link: feeder_class__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug)]
pub struct feeder_class__bindgen_ty_1 {
    pub sle_next: *mut feeder_class,
}
impl Default for feeder_class__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for feeder_class {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pcm_feeder {
    pub ops: kobj_ops_t,
    pub align: ::core::ffi::c_int,
    pub desc: *mut pcm_feederdesc,
    pub desc_static: pcm_feederdesc,
    pub data: *mut ::core::ffi::c_void,
    pub class: *mut feeder_class,
    pub source: *mut pcm_feeder,
    pub parent: *mut pcm_feeder,
}
impl Default for pcm_feeder {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const FEEDFORMAT_CHANNELS: _bindgen_ty_4 = 0;
pub type _bindgen_ty_4 = ::core::ffi::c_uint;
pub const FEEDMIXER_CHANNELS: _bindgen_ty_5 = 0;
pub type _bindgen_ty_5 = ::core::ffi::c_uint;
pub const FEEDRATE_SRC: _bindgen_ty_6 = 0;
pub const FEEDRATE_DST: _bindgen_ty_6 = 1;
pub const FEEDRATE_QUALITY: _bindgen_ty_6 = 2;
pub const FEEDRATE_CHANNELS: _bindgen_ty_6 = 3;
pub type _bindgen_ty_6 = ::core::ffi::c_uint;
pub const FEEDEQ_CHANNELS: _bindgen_ty_7 = 0;
pub const FEEDEQ_RATE: _bindgen_ty_7 = 1;
pub const FEEDEQ_TREBLE: _bindgen_ty_7 = 2;
pub const FEEDEQ_BASS: _bindgen_ty_7 = 3;
pub const FEEDEQ_PREAMP: _bindgen_ty_7 = 4;
pub const FEEDEQ_STATE: _bindgen_ty_7 = 5;
pub const FEEDEQ_DISABLE: _bindgen_ty_7 = 6;
pub const FEEDEQ_ENABLE: _bindgen_ty_7 = 7;
pub const FEEDEQ_BYPASS: _bindgen_ty_7 = 8;
pub const FEEDEQ_UNKNOWN: _bindgen_ty_7 = 9;
pub type _bindgen_ty_7 = ::core::ffi::c_uint;
pub const FEEDVOLUME_CLASS: _bindgen_ty_8 = 0;
pub const FEEDVOLUME_CHANNELS: _bindgen_ty_8 = 1;
pub const FEEDVOLUME_STATE: _bindgen_ty_8 = 2;
pub const FEEDVOLUME_ENABLE: _bindgen_ty_8 = 3;
pub const FEEDVOLUME_BYPASS: _bindgen_ty_8 = 4;
pub type _bindgen_ty_8 = ::core::ffi::c_uint;
pub const SCF_PCM: _bindgen_ty_9 = 0;
pub const SCF_MIDI: _bindgen_ty_9 = 1;
pub type _bindgen_ty_9 = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct sndcard_func {
    pub func: ::core::ffi::c_int,
    pub varinfo: *mut ::core::ffi::c_void,
}
impl Default for sndcard_func {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct snddev_info {
    pub channels: snddev_info__bindgen_ty_1,
    pub playcount: ::core::ffi::c_uint,
    pub reccount: ::core::ffi::c_uint,
    pub pvchancount: ::core::ffi::c_uint,
    pub rvchancount: ::core::ffi::c_uint,
    pub flags: ::core::ffi::c_uint,
    pub bufsz: ::core::ffi::c_uint,
    pub devinfo: *mut ::core::ffi::c_void,
    pub dev: device_t,
    pub status: [::core::ffi::c_char; 64usize],
    pub lock: mtx,
    pub mixer_dev: *mut cdev,
    pub dsp_dev: *mut cdev,
    pub pvchanrate: u32,
    pub pvchanformat: u32,
    pub pvchanmode: u32,
    pub rvchanrate: u32,
    pub rvchanformat: u32,
    pub rvchanmode: u32,
    pub eqpreamp: i32,
    pub play_sysctl_ctx: sysctl_ctx_list,
    pub rec_sysctl_ctx: sysctl_ctx_list,
    pub play_sysctl_tree: *mut sysctl_oid,
    pub rec_sysctl_tree: *mut sysctl_oid,
    pub cv: cv,
    pub p_unr: *mut unrhdr,
    pub vp_unr: *mut unrhdr,
    pub r_unr: *mut unrhdr,
    pub vr_unr: *mut unrhdr,
}
#[repr(C)]
#[derive(Debug)]
pub struct snddev_info__bindgen_ty_1 {
    pub pcm: snddev_info__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug)]
pub struct snddev_info__bindgen_ty_1__bindgen_ty_1 {
    pub head: snddev_info__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub busy: snddev_info__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    pub opened: snddev_info__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3,
    pub primary: snddev_info__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug)]
pub struct snddev_info__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub slh_first: *mut pcm_channel,
}
impl Default for snddev_info__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct snddev_info__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub head: snddev_info__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug)]
pub struct snddev_info__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub slh_first: *mut pcm_channel,
}
impl Default for snddev_info__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for snddev_info__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct snddev_info__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3 {
    pub head: snddev_info__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug)]
pub struct snddev_info__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    pub slh_first: *mut pcm_channel,
}
impl Default for snddev_info__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for snddev_info__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct snddev_info__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4 {
    pub head: snddev_info__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug)]
pub struct snddev_info__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub slh_first: *mut pcm_channel,
}
impl Default for snddev_info__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for snddev_info__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for snddev_info__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for snddev_info__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for snddev_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct virtio_feature_desc {
    pub vfd_val: u64,
    pub vfd_str: *const ::core::ffi::c_char,
}
impl Default for virtio_feature_desc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct virtio_pnp_match {
    pub device_type: u32,
    pub description: *const ::core::ffi::c_char,
}
impl Default for virtio_pnp_match {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct virtqueue {
    _unused: [u8; 0],
}
pub type virtqueue_intr_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
pub const VQ_POSTPONE_SHORT: vq_postpone_t = 0;
pub const VQ_POSTPONE_LONG: vq_postpone_t = 1;
pub const VQ_POSTPONE_EMPTIED: vq_postpone_t = 2;
pub type vq_postpone_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct vq_alloc_info {
    pub vqai_name: [::core::ffi::c_char; 32usize],
    pub vqai_maxindirsz: ::core::ffi::c_int,
    pub vqai_intr: virtqueue_intr_t,
    pub vqai_intr_arg: *mut ::core::ffi::c_void,
    pub vqai_vq: *mut *mut virtqueue,
}
impl Default for vq_alloc_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief A function implementing the GPIO_GET_BUS() method"]
pub type gpio_get_bus_t = ::core::option::Option<unsafe extern "C" fn(dev: device_t) -> device_t>;
#[doc = " @brief A function implementing the GPIO_PIN_MAX() method"]
pub type gpio_pin_max_t = ::core::option::Option<
    unsafe extern "C" fn(dev: device_t, maxpin: *mut ::core::ffi::c_int) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the GPIO_PIN_SET() method"]
pub type gpio_pin_set_t = ::core::option::Option<
    unsafe extern "C" fn(dev: device_t, pin_num: u32, pin_value: u32) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the GPIO_PIN_GET() method"]
pub type gpio_pin_get_t = ::core::option::Option<
    unsafe extern "C" fn(dev: device_t, pin_num: u32, pin_value: *mut u32) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the GPIO_PIN_TOGGLE() method"]
pub type gpio_pin_toggle_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t, pin_num: u32) -> ::core::ffi::c_int>;
#[doc = " @brief A function implementing the GPIO_PIN_GETCAPS() method"]
pub type gpio_pin_getcaps_t = ::core::option::Option<
    unsafe extern "C" fn(dev: device_t, pin_num: u32, caps: *mut u32) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the GPIO_PIN_GETFLAGS() method"]
pub type gpio_pin_getflags_t = ::core::option::Option<
    unsafe extern "C" fn(dev: device_t, pin_num: u32, flags: *mut u32) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the GPIO_PIN_GETNAME() method"]
pub type gpio_pin_getname_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: device_t,
        pin_num: u32,
        name: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the GPIO_PIN_SETFLAGS() method"]
pub type gpio_pin_setflags_t = ::core::option::Option<
    unsafe extern "C" fn(dev: device_t, pin_num: u32, flags: u32) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the GPIO_MAP_GPIOS() method"]
pub type gpio_map_gpios_t = ::core::option::Option<
    unsafe extern "C" fn(
        bus: device_t,
        dev: phandle_t,
        gparent: phandle_t,
        gcells: ::core::ffi::c_int,
        gpios: *mut pcell_t,
        pin: *mut u32,
        flags: *mut u32,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the GPIO_PIN_ACCESS_32() method"]
pub type gpio_pin_access_32_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: device_t,
        first_pin: u32,
        clear_pins: u32,
        change_pins: u32,
        orig_pins: *mut u32,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the GPIO_PIN_CONFIG_32() method"]
pub type gpio_pin_config_32_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: device_t,
        first_pin: u32,
        num_pins: u32,
        pin_flags: *mut u32,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the GPIO_GET_PIN_LIST() method"]
pub type gpio_get_pin_list_t = ::core::option::Option<
    unsafe extern "C" fn(dev: device_t, pin_list: *mut u32) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug)]
pub struct gpiobus_pin_data {
    pub mapped: ::core::ffi::c_int,
    pub name: *mut ::core::ffi::c_char,
}
impl Default for gpiobus_pin_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct intr_map_data_gpio {
    pub hdr: intr_map_data,
    pub gpio_pin_num: u_int,
    pub gpio_pin_flags: u_int,
    pub gpio_intr_mode: u_int,
}
impl Default for intr_map_data_gpio {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct gpiobus_softc {
    pub sc_mtx: mtx,
    pub sc_intr_rman: rman,
    pub sc_busdev: device_t,
    pub sc_owner: device_t,
    pub sc_dev: device_t,
    pub sc_npins: ::core::ffi::c_int,
    pub sc_pins: *mut gpiobus_pin_data,
}
impl Default for gpiobus_softc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct gpiobus_pin {
    pub dev: device_t,
    pub flags: u32,
    pub pin: u32,
}
impl Default for gpiobus_pin {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type gpio_pin_t = *mut gpiobus_pin;
#[repr(C)]
#[derive(Debug)]
pub struct gpiobus_ivar {
    pub rl: resource_list,
    pub npins: u32,
    pub pins: *mut u32,
}
impl Default for gpiobus_ivar {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const GPIOBUS_IVAR_NPINS: gpiobus_ivars = 10500;
pub const GPIOBUS_IVAR_PINS: gpiobus_ivars = 10501;
pub type gpiobus_ivars = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct ofw_gpiobus_devinfo {
    pub opd_dinfo: gpiobus_ivar,
    pub opd_obdinfo: ofw_bus_devinfo,
}
impl Default for ofw_gpiobus_devinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct disk_zone_disk_params {
    pub zone_mode: u32,
    pub flags: u64,
    pub optimal_seq_zones: u64,
    pub optimal_nonseq_zones: u64,
    pub max_seq_zones: u64,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct disk_zone_rwp {
    pub id: u64,
    pub flags: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct disk_zone_rep_header {
    pub same: u8,
    pub maximum_lba: u64,
    pub reserved: [u8; 64usize],
}
impl Default for disk_zone_rep_header {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct disk_zone_rep_entry {
    pub zone_type: u8,
    pub zone_condition: u8,
    pub zone_flags: u8,
    pub zone_length: u64,
    pub zone_start_lba: u64,
    pub write_pointer_lba: u64,
    pub reserved: [u8; 32usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct disk_zone_report {
    pub starting_id: u64,
    pub rep_options: u8,
    pub header: disk_zone_rep_header,
    pub entries_allocated: u32,
    pub entries_filled: u32,
    pub entries_available: u32,
    pub entries: *mut disk_zone_rep_entry,
}
impl Default for disk_zone_report {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct disk_zone_params {
    pub disk_params: __BindgenUnionField<disk_zone_disk_params>,
    pub rwp: __BindgenUnionField<disk_zone_rwp>,
    pub report: __BindgenUnionField<disk_zone_report>,
    pub bindgen_union_field: [u64; 15usize],
}
impl Default for disk_zone_params {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct disk_zone_args {
    pub zone_cmd: u8,
    pub zone_params: disk_zone_params,
}
impl Default for disk_zone_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct disk {
    _unused: [u8; 0],
}
pub type bio_task_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
#[repr(C)]
pub struct bio {
    pub bio_cmd: u16,
    pub bio_flags: u16,
    pub bio_cflags: u16,
    pub bio_pflags: u16,
    pub bio_dev: *mut cdev,
    pub bio_disk: *mut disk,
    pub bio_offset: off_t,
    pub bio_bcount: ::core::ffi::c_long,
    pub bio_data: caddr_t,
    pub bio_ma: *mut *mut vm_page,
    pub bio_ma_offset: ::core::ffi::c_int,
    pub bio_ma_n: ::core::ffi::c_int,
    pub bio_resid: ::core::ffi::c_long,
    pub bio_done: ::core::option::Option<unsafe extern "C" fn(arg1: *mut bio)>,
    pub bio_driver1: *mut ::core::ffi::c_void,
    pub bio_driver2: *mut ::core::ffi::c_void,
    pub bio_caller1: *mut ::core::ffi::c_void,
    pub bio_caller2: *mut ::core::ffi::c_void,
    pub bio_queue: bio__bindgen_ty_1,
    pub bio_attribute: *const ::core::ffi::c_char,
    pub bio_zone: disk_zone_args,
    pub bio_from: *mut g_consumer,
    pub bio_to: *mut g_provider,
    pub bio_length: off_t,
    pub bio_completed: off_t,
    pub bio_children: u_int,
    pub bio_inbed: u_int,
    pub bio_parent: *mut bio,
    pub bio_t0: bintime,
    pub bio_task: bio_task_t,
    pub bio_task_arg: *mut ::core::ffi::c_void,
    pub bio_spare1: *mut ::core::ffi::c_void,
    pub bio_spare2: *mut ::core::ffi::c_void,
    pub bio_track_bp: *mut buf,
    pub bio_pblkno: daddr_t,
    pub bio_exterr: kexterr,
}
#[repr(C)]
#[derive(Debug)]
pub struct bio__bindgen_ty_1 {
    pub tqe_next: *mut bio,
    pub tqe_prev: *mut *mut bio,
}
impl Default for bio__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bio {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct devstat {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct bio_queue_head {
    pub queue: bio_queue_head_bio_queue,
    pub last_offset: off_t,
    pub insert_point: *mut bio,
    pub total: ::core::ffi::c_int,
    pub batched: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct bio_queue_head_bio_queue {
    pub tqh_first: *mut bio,
    pub tqh_last: *mut *mut bio,
}
impl Default for bio_queue_head_bio_queue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for bio_queue_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type counter_u64_t = *mut u64;
#[repr(C)]
#[derive(Debug)]
pub struct counter_rate {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct memdesc {
    pub u: memdesc__bindgen_ty_1,
    pub __bindgen_anon_1: memdesc__bindgen_ty_2,
    pub __bindgen_anon_2: memdesc__bindgen_ty_3,
    pub md_type: u32,
}
#[repr(C)]
pub struct memdesc__bindgen_ty_1 {
    pub md_vaddr: __BindgenUnionField<*mut ::core::ffi::c_void>,
    pub md_paddr: __BindgenUnionField<vm_paddr_t>,
    pub md_list: __BindgenUnionField<*mut bus_dma_segment>,
    pub md_uio: __BindgenUnionField<*mut uio>,
    pub md_mbuf: __BindgenUnionField<*mut mbuf>,
    pub md_ma: __BindgenUnionField<*mut *mut vm_page>,
    pub bindgen_union_field: u64,
}
impl Default for memdesc__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct memdesc__bindgen_ty_2 {
    pub md_len: __BindgenUnionField<usize>,
    pub md_nseg: __BindgenUnionField<::core::ffi::c_int>,
    pub bindgen_union_field: u64,
}
impl Default for memdesc__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct memdesc__bindgen_ty_3 {
    pub md_offset: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
impl Default for memdesc__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for memdesc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type memdesc_alloc_ext_mbuf_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::core::ffi::c_int,
        arg3: *mut ::core::ffi::c_void,
        arg4: usize,
    ) -> *mut mbuf,
>;
pub type memdesc_alloc_extpg_mbuf_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: ::core::ffi::c_int) -> *mut mbuf,
>;
pub type smr_seq_t = u32;
pub type smr_delta_t = i32;
#[repr(C)]
#[derive(Debug)]
pub struct smr {
    _unused: [u8; 0],
}
pub type smr_t = *mut smr;
pub type uma_zone_t = *mut uma_zone;
pub type uma_ctor = ::core::option::Option<
    unsafe extern "C" fn(
        mem: *mut ::core::ffi::c_void,
        size: ::core::ffi::c_int,
        arg: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
pub type uma_dtor = ::core::option::Option<
    unsafe extern "C" fn(
        mem: *mut ::core::ffi::c_void,
        size: ::core::ffi::c_int,
        arg: *mut ::core::ffi::c_void,
    ),
>;
pub type uma_init = ::core::option::Option<
    unsafe extern "C" fn(
        mem: *mut ::core::ffi::c_void,
        size: ::core::ffi::c_int,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
pub type uma_fini = ::core::option::Option<
    unsafe extern "C" fn(mem: *mut ::core::ffi::c_void, size: ::core::ffi::c_int),
>;
pub type uma_import = ::core::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::core::ffi::c_void,
        store: *mut *mut ::core::ffi::c_void,
        count: ::core::ffi::c_int,
        domain: ::core::ffi::c_int,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
pub type uma_release = ::core::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::core::ffi::c_void,
        store: *mut *mut ::core::ffi::c_void,
        count: ::core::ffi::c_int,
    ),
>;
pub type uma_alloc = ::core::option::Option<
    unsafe extern "C" fn(
        zone: uma_zone_t,
        size: vm_size_t,
        domain: ::core::ffi::c_int,
        pflag: *mut u8,
        wait: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void,
>;
pub type uma_free = ::core::option::Option<
    unsafe extern "C" fn(item: *mut ::core::ffi::c_void, size: vm_size_t, pflag: u8),
>;
pub type uma_maxaction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: uma_zone_t, arg2: ::core::ffi::c_int)>;
#[repr(C)]
#[derive(Debug, Default)]
pub struct uma_stream_header {
    pub ush_version: u32,
    pub ush_maxcpus: u32,
    pub ush_count: u32,
    pub _ush_pad: u32,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct uma_type_header {
    pub uth_name: [::core::ffi::c_char; 32usize],
    pub uth_align: u32,
    pub uth_size: u32,
    pub uth_rsize: u32,
    pub uth_maxpages: u32,
    pub uth_limit: u32,
    pub uth_pages: u32,
    pub uth_keg_free: u32,
    pub uth_zone_free: u32,
    pub uth_bucketsize: u32,
    pub uth_zone_flags: u32,
    pub uth_allocs: u64,
    pub uth_frees: u64,
    pub uth_fails: u64,
    pub uth_sleeps: u64,
    pub uth_xdomain: u64,
    pub _uth_reserved1: [u64; 1usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct uma_percpu_stat {
    pub ups_allocs: u64,
    pub ups_frees: u64,
    pub ups_cache_free: u64,
    pub _ups_reserved: [u64; 5usize],
}
pub const NVME_FUSE_NORMAL: nvme_fuse = 0;
pub const NVME_FUSE_FIRST: nvme_fuse = 1;
pub const NVME_FUSE_SECOND: nvme_fuse = 2;
pub type nvme_fuse = ::core::ffi::c_uint;
pub const NVME_PSDT_PRP: nvme_psdt = 0;
pub const NVME_PSDT_SGL: nvme_psdt = 1;
pub const NVME_PSDT_SGL_MPTR: nvme_psdt = 2;
pub type nvme_psdt = ::core::ffi::c_uint;
pub const NVME_CRIT_WARN_ST_AVAILABLE_SPARE: nvme_critical_warning_state = 1;
pub const NVME_CRIT_WARN_ST_TEMPERATURE: nvme_critical_warning_state = 2;
pub const NVME_CRIT_WARN_ST_DEVICE_RELIABILITY: nvme_critical_warning_state = 4;
pub const NVME_CRIT_WARN_ST_READ_ONLY: nvme_critical_warning_state = 8;
pub const NVME_CRIT_WARN_ST_VOLATILE_MEMORY_BACKUP: nvme_critical_warning_state = 16;
pub const NVME_CRIT_WARN_ST_PERSISTENT_MEMORY_REGION: nvme_critical_warning_state = 32;
pub type nvme_critical_warning_state = ::core::ffi::c_uint;
pub const NVME_SHN_NORMAL: shn_value = 1;
pub const NVME_SHN_ABRUPT: shn_value = 2;
pub type shn_value = ::core::ffi::c_uint;
pub const NVME_SHST_NORMAL: shst_value = 0;
pub const NVME_SHST_OCCURRING: shst_value = 1;
pub const NVME_SHST_COMPLETE: shst_value = 2;
pub type shst_value = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct nvme_registers {
    pub cap_lo: u32,
    pub cap_hi: u32,
    pub vs: u32,
    pub intms: u32,
    pub intmc: u32,
    pub cc: u32,
    pub reserved1: u32,
    pub csts: u32,
    pub nssr: u32,
    pub aqa: u32,
    pub asq: u64,
    pub acq: u64,
    pub cmbloc: u32,
    pub cmbsz: u32,
    pub bpinfo: u32,
    pub bprsel: u32,
    pub bpmbl: u64,
    pub cmbmsc: u64,
    pub cmbsts: u32,
    pub cmbebs: u32,
    pub cmbswtp: u32,
    pub nssd: u32,
    pub crto: u32,
    pub reserved3: [u8; 3476usize],
    pub pmrcap: u32,
    pub pmrctl: u32,
    pub pmrsts: u32,
    pub pmrebs: u32,
    pub pmrswtp: u32,
    pub pmrmsc_lo: u32,
    pub pmrmsc_hi: u32,
    pub reserved4: [u8; 484usize],
    pub doorbell: [nvme_registers__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct nvme_registers__bindgen_ty_1 {
    pub sq_tdbl: u32,
    pub cq_hdbl: u32,
}
impl Default for nvme_registers {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const NVME_SGL_TYPE_DATA_BLOCK: nvme_sgl_type = 0;
pub const NVME_SGL_TYPE_BIT_BUCKET: nvme_sgl_type = 1;
pub const NVME_SGL_TYPE_SEGMENT: nvme_sgl_type = 2;
pub const NVME_SGL_TYPE_LAST_SEGMENT: nvme_sgl_type = 3;
pub const NVME_SGL_TYPE_KEYED_DATA_BLOCK: nvme_sgl_type = 4;
pub const NVME_SGL_TYPE_TRANSPORT_DATA_BLOCK: nvme_sgl_type = 5;
pub type nvme_sgl_type = ::core::ffi::c_uint;
pub const NVME_SGL_SUBTYPE_ADDRESS: nvme_sgl_subtype = 0;
pub const NVME_SGL_SUBTYPE_OFFSET: nvme_sgl_subtype = 1;
pub const NVME_SGL_SUBTYPE_TRANSPORT: nvme_sgl_subtype = 10;
pub type nvme_sgl_subtype = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default)]
pub struct nvme_sgl_descriptor {
    pub address: u64,
    pub length: u32,
    pub reserved: [u8; 3usize],
    pub type_: u8,
}
#[repr(C)]
pub struct nvme_command {
    pub opc: u8,
    pub fuse: u8,
    pub cid: u16,
    pub nsid: u32,
    pub rsvd2: u32,
    pub rsvd3: u32,
    pub mptr: u64,
    pub __bindgen_anon_1: nvme_command__bindgen_ty_1,
    pub cdw10: u32,
    pub cdw11: u32,
    pub cdw12: u32,
    pub cdw13: u32,
    pub cdw14: u32,
    pub cdw15: u32,
}
#[repr(C)]
pub struct nvme_command__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<nvme_command__bindgen_ty_1__bindgen_ty_1>,
    pub sgl: __BindgenUnionField<nvme_sgl_descriptor>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct nvme_command__bindgen_ty_1__bindgen_ty_1 {
    pub prp1: u64,
    pub prp2: u64,
}
impl Default for nvme_command__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for nvme_command {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default)]
pub struct nvme_completion {
    pub cdw0: u32,
    pub rsvd1: u32,
    pub sqhd: u16,
    pub sqid: u16,
    pub cid: u16,
    pub status: u16,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct nvme_dsm_range {
    pub attributes: u32,
    pub length: u32,
    pub starting_lba: u64,
}
pub const NVME_SCT_GENERIC: nvme_status_code_type = 0;
pub const NVME_SCT_COMMAND_SPECIFIC: nvme_status_code_type = 1;
pub const NVME_SCT_MEDIA_ERROR: nvme_status_code_type = 2;
pub const NVME_SCT_PATH_RELATED: nvme_status_code_type = 3;
pub const NVME_SCT_VENDOR_SPECIFIC: nvme_status_code_type = 7;
pub type nvme_status_code_type = ::core::ffi::c_uint;
pub const NVME_SC_SUCCESS: nvme_generic_command_status_code = 0;
pub const NVME_SC_INVALID_OPCODE: nvme_generic_command_status_code = 1;
pub const NVME_SC_INVALID_FIELD: nvme_generic_command_status_code = 2;
pub const NVME_SC_COMMAND_ID_CONFLICT: nvme_generic_command_status_code = 3;
pub const NVME_SC_DATA_TRANSFER_ERROR: nvme_generic_command_status_code = 4;
pub const NVME_SC_ABORTED_POWER_LOSS: nvme_generic_command_status_code = 5;
pub const NVME_SC_INTERNAL_DEVICE_ERROR: nvme_generic_command_status_code = 6;
pub const NVME_SC_ABORTED_BY_REQUEST: nvme_generic_command_status_code = 7;
pub const NVME_SC_ABORTED_SQ_DELETION: nvme_generic_command_status_code = 8;
pub const NVME_SC_ABORTED_FAILED_FUSED: nvme_generic_command_status_code = 9;
pub const NVME_SC_ABORTED_MISSING_FUSED: nvme_generic_command_status_code = 10;
pub const NVME_SC_INVALID_NAMESPACE_OR_FORMAT: nvme_generic_command_status_code = 11;
pub const NVME_SC_COMMAND_SEQUENCE_ERROR: nvme_generic_command_status_code = 12;
pub const NVME_SC_INVALID_SGL_SEGMENT_DESCR: nvme_generic_command_status_code = 13;
pub const NVME_SC_INVALID_NUMBER_OF_SGL_DESCR: nvme_generic_command_status_code = 14;
pub const NVME_SC_DATA_SGL_LENGTH_INVALID: nvme_generic_command_status_code = 15;
pub const NVME_SC_METADATA_SGL_LENGTH_INVALID: nvme_generic_command_status_code = 16;
pub const NVME_SC_SGL_DESCRIPTOR_TYPE_INVALID: nvme_generic_command_status_code = 17;
pub const NVME_SC_INVALID_USE_OF_CMB: nvme_generic_command_status_code = 18;
pub const NVME_SC_PRP_OFFET_INVALID: nvme_generic_command_status_code = 19;
pub const NVME_SC_ATOMIC_WRITE_UNIT_EXCEEDED: nvme_generic_command_status_code = 20;
pub const NVME_SC_OPERATION_DENIED: nvme_generic_command_status_code = 21;
pub const NVME_SC_SGL_OFFSET_INVALID: nvme_generic_command_status_code = 22;
pub const NVME_SC_HOST_ID_INCONSISTENT_FORMAT: nvme_generic_command_status_code = 24;
pub const NVME_SC_KEEP_ALIVE_TIMEOUT_EXPIRED: nvme_generic_command_status_code = 25;
pub const NVME_SC_KEEP_ALIVE_TIMEOUT_INVALID: nvme_generic_command_status_code = 26;
pub const NVME_SC_ABORTED_DUE_TO_PREEMPT: nvme_generic_command_status_code = 27;
pub const NVME_SC_SANITIZE_FAILED: nvme_generic_command_status_code = 28;
pub const NVME_SC_SANITIZE_IN_PROGRESS: nvme_generic_command_status_code = 29;
pub const NVME_SC_SGL_DATA_BLOCK_GRAN_INVALID: nvme_generic_command_status_code = 30;
pub const NVME_SC_NOT_SUPPORTED_IN_CMB: nvme_generic_command_status_code = 31;
pub const NVME_SC_NAMESPACE_IS_WRITE_PROTECTED: nvme_generic_command_status_code = 32;
pub const NVME_SC_COMMAND_INTERRUPTED: nvme_generic_command_status_code = 33;
pub const NVME_SC_TRANSIENT_TRANSPORT_ERROR: nvme_generic_command_status_code = 34;
pub const NVME_SC_LBA_OUT_OF_RANGE: nvme_generic_command_status_code = 128;
pub const NVME_SC_CAPACITY_EXCEEDED: nvme_generic_command_status_code = 129;
pub const NVME_SC_NAMESPACE_NOT_READY: nvme_generic_command_status_code = 130;
pub const NVME_SC_RESERVATION_CONFLICT: nvme_generic_command_status_code = 131;
pub const NVME_SC_FORMAT_IN_PROGRESS: nvme_generic_command_status_code = 132;
pub type nvme_generic_command_status_code = ::core::ffi::c_uint;
pub const NVME_SC_COMPLETION_QUEUE_INVALID: nvme_command_specific_status_code = 0;
pub const NVME_SC_INVALID_QUEUE_IDENTIFIER: nvme_command_specific_status_code = 1;
pub const NVME_SC_MAXIMUM_QUEUE_SIZE_EXCEEDED: nvme_command_specific_status_code = 2;
pub const NVME_SC_ABORT_COMMAND_LIMIT_EXCEEDED: nvme_command_specific_status_code = 3;
pub const NVME_SC_ASYNC_EVENT_REQUEST_LIMIT_EXCEEDED: nvme_command_specific_status_code = 5;
pub const NVME_SC_INVALID_FIRMWARE_SLOT: nvme_command_specific_status_code = 6;
pub const NVME_SC_INVALID_FIRMWARE_IMAGE: nvme_command_specific_status_code = 7;
pub const NVME_SC_INVALID_INTERRUPT_VECTOR: nvme_command_specific_status_code = 8;
pub const NVME_SC_INVALID_LOG_PAGE: nvme_command_specific_status_code = 9;
pub const NVME_SC_INVALID_FORMAT: nvme_command_specific_status_code = 10;
pub const NVME_SC_FIRMWARE_REQUIRES_RESET: nvme_command_specific_status_code = 11;
pub const NVME_SC_INVALID_QUEUE_DELETION: nvme_command_specific_status_code = 12;
pub const NVME_SC_FEATURE_NOT_SAVEABLE: nvme_command_specific_status_code = 13;
pub const NVME_SC_FEATURE_NOT_CHANGEABLE: nvme_command_specific_status_code = 14;
pub const NVME_SC_FEATURE_NOT_NS_SPECIFIC: nvme_command_specific_status_code = 15;
pub const NVME_SC_FW_ACT_REQUIRES_NVMS_RESET: nvme_command_specific_status_code = 16;
pub const NVME_SC_FW_ACT_REQUIRES_RESET: nvme_command_specific_status_code = 17;
pub const NVME_SC_FW_ACT_REQUIRES_TIME: nvme_command_specific_status_code = 18;
pub const NVME_SC_FW_ACT_PROHIBITED: nvme_command_specific_status_code = 19;
pub const NVME_SC_OVERLAPPING_RANGE: nvme_command_specific_status_code = 20;
pub const NVME_SC_NS_INSUFFICIENT_CAPACITY: nvme_command_specific_status_code = 21;
pub const NVME_SC_NS_ID_UNAVAILABLE: nvme_command_specific_status_code = 22;
pub const NVME_SC_NS_ALREADY_ATTACHED: nvme_command_specific_status_code = 24;
pub const NVME_SC_NS_IS_PRIVATE: nvme_command_specific_status_code = 25;
pub const NVME_SC_NS_NOT_ATTACHED: nvme_command_specific_status_code = 26;
pub const NVME_SC_THIN_PROV_NOT_SUPPORTED: nvme_command_specific_status_code = 27;
pub const NVME_SC_CTRLR_LIST_INVALID: nvme_command_specific_status_code = 28;
pub const NVME_SC_SELF_TEST_IN_PROGRESS: nvme_command_specific_status_code = 29;
pub const NVME_SC_BOOT_PART_WRITE_PROHIB: nvme_command_specific_status_code = 30;
pub const NVME_SC_INVALID_CTRLR_ID: nvme_command_specific_status_code = 31;
pub const NVME_SC_INVALID_SEC_CTRLR_STATE: nvme_command_specific_status_code = 32;
pub const NVME_SC_INVALID_NUM_OF_CTRLR_RESRC: nvme_command_specific_status_code = 33;
pub const NVME_SC_INVALID_RESOURCE_ID: nvme_command_specific_status_code = 34;
pub const NVME_SC_SANITIZE_PROHIBITED_WPMRE: nvme_command_specific_status_code = 35;
pub const NVME_SC_ANA_GROUP_ID_INVALID: nvme_command_specific_status_code = 36;
pub const NVME_SC_ANA_ATTACH_FAILED: nvme_command_specific_status_code = 37;
pub const NVME_SC_CONFLICTING_ATTRIBUTES: nvme_command_specific_status_code = 128;
pub const NVME_SC_INVALID_PROTECTION_INFO: nvme_command_specific_status_code = 129;
pub const NVME_SC_ATTEMPTED_WRITE_TO_RO_PAGE: nvme_command_specific_status_code = 130;
pub type nvme_command_specific_status_code = ::core::ffi::c_uint;
pub const NVME_SC_WRITE_FAULTS: nvme_media_error_status_code = 128;
pub const NVME_SC_UNRECOVERED_READ_ERROR: nvme_media_error_status_code = 129;
pub const NVME_SC_GUARD_CHECK_ERROR: nvme_media_error_status_code = 130;
pub const NVME_SC_APPLICATION_TAG_CHECK_ERROR: nvme_media_error_status_code = 131;
pub const NVME_SC_REFERENCE_TAG_CHECK_ERROR: nvme_media_error_status_code = 132;
pub const NVME_SC_COMPARE_FAILURE: nvme_media_error_status_code = 133;
pub const NVME_SC_ACCESS_DENIED: nvme_media_error_status_code = 134;
pub const NVME_SC_DEALLOCATED_OR_UNWRITTEN: nvme_media_error_status_code = 135;
pub type nvme_media_error_status_code = ::core::ffi::c_uint;
pub const NVME_SC_INTERNAL_PATH_ERROR: nvme_path_related_status_code = 0;
pub const NVME_SC_ASYMMETRIC_ACCESS_PERSISTENT_LOSS: nvme_path_related_status_code = 1;
pub const NVME_SC_ASYMMETRIC_ACCESS_INACCESSIBLE: nvme_path_related_status_code = 2;
pub const NVME_SC_ASYMMETRIC_ACCESS_TRANSITION: nvme_path_related_status_code = 3;
pub const NVME_SC_CONTROLLER_PATHING_ERROR: nvme_path_related_status_code = 96;
pub const NVME_SC_HOST_PATHING_ERROR: nvme_path_related_status_code = 112;
pub const NVME_SC_COMMAND_ABORTED_BY_HOST: nvme_path_related_status_code = 113;
pub type nvme_path_related_status_code = ::core::ffi::c_uint;
pub const NVME_OPC_DELETE_IO_SQ: nvme_admin_opcode = 0;
pub const NVME_OPC_CREATE_IO_SQ: nvme_admin_opcode = 1;
pub const NVME_OPC_GET_LOG_PAGE: nvme_admin_opcode = 2;
pub const NVME_OPC_DELETE_IO_CQ: nvme_admin_opcode = 4;
pub const NVME_OPC_CREATE_IO_CQ: nvme_admin_opcode = 5;
pub const NVME_OPC_IDENTIFY: nvme_admin_opcode = 6;
pub const NVME_OPC_ABORT: nvme_admin_opcode = 8;
pub const NVME_OPC_SET_FEATURES: nvme_admin_opcode = 9;
pub const NVME_OPC_GET_FEATURES: nvme_admin_opcode = 10;
pub const NVME_OPC_ASYNC_EVENT_REQUEST: nvme_admin_opcode = 12;
pub const NVME_OPC_NAMESPACE_MANAGEMENT: nvme_admin_opcode = 13;
pub const NVME_OPC_FIRMWARE_ACTIVATE: nvme_admin_opcode = 16;
pub const NVME_OPC_FIRMWARE_IMAGE_DOWNLOAD: nvme_admin_opcode = 17;
pub const NVME_OPC_DEVICE_SELF_TEST: nvme_admin_opcode = 20;
pub const NVME_OPC_NAMESPACE_ATTACHMENT: nvme_admin_opcode = 21;
pub const NVME_OPC_KEEP_ALIVE: nvme_admin_opcode = 24;
pub const NVME_OPC_DIRECTIVE_SEND: nvme_admin_opcode = 25;
pub const NVME_OPC_DIRECTIVE_RECEIVE: nvme_admin_opcode = 26;
pub const NVME_OPC_VIRTUALIZATION_MANAGEMENT: nvme_admin_opcode = 28;
pub const NVME_OPC_NVME_MI_SEND: nvme_admin_opcode = 29;
pub const NVME_OPC_NVME_MI_RECEIVE: nvme_admin_opcode = 30;
pub const NVME_OPC_CAPACITY_MANAGEMENT: nvme_admin_opcode = 32;
pub const NVME_OPC_LOCKDOWN: nvme_admin_opcode = 36;
pub const NVME_OPC_DOORBELL_BUFFER_CONFIG: nvme_admin_opcode = 124;
pub const NVME_OPC_FABRICS_COMMANDS: nvme_admin_opcode = 127;
pub const NVME_OPC_FORMAT_NVM: nvme_admin_opcode = 128;
pub const NVME_OPC_SECURITY_SEND: nvme_admin_opcode = 129;
pub const NVME_OPC_SECURITY_RECEIVE: nvme_admin_opcode = 130;
pub const NVME_OPC_SANITIZE: nvme_admin_opcode = 132;
pub const NVME_OPC_GET_LBA_STATUS: nvme_admin_opcode = 134;
pub type nvme_admin_opcode = ::core::ffi::c_uint;
pub const NVME_OPC_FLUSH: nvme_nvm_opcode = 0;
pub const NVME_OPC_WRITE: nvme_nvm_opcode = 1;
pub const NVME_OPC_READ: nvme_nvm_opcode = 2;
pub const NVME_OPC_WRITE_UNCORRECTABLE: nvme_nvm_opcode = 4;
pub const NVME_OPC_COMPARE: nvme_nvm_opcode = 5;
pub const NVME_OPC_WRITE_ZEROES: nvme_nvm_opcode = 8;
pub const NVME_OPC_DATASET_MANAGEMENT: nvme_nvm_opcode = 9;
pub const NVME_OPC_VERIFY: nvme_nvm_opcode = 12;
pub const NVME_OPC_RESERVATION_REGISTER: nvme_nvm_opcode = 13;
pub const NVME_OPC_RESERVATION_REPORT: nvme_nvm_opcode = 14;
pub const NVME_OPC_RESERVATION_ACQUIRE: nvme_nvm_opcode = 17;
pub const NVME_OPC_RESERVATION_RELEASE: nvme_nvm_opcode = 21;
pub const NVME_OPC_COPY: nvme_nvm_opcode = 25;
pub type nvme_nvm_opcode = ::core::ffi::c_uint;
pub const NVME_FEAT_ARBITRATION: nvme_feature = 1;
pub const NVME_FEAT_POWER_MANAGEMENT: nvme_feature = 2;
pub const NVME_FEAT_LBA_RANGE_TYPE: nvme_feature = 3;
pub const NVME_FEAT_TEMPERATURE_THRESHOLD: nvme_feature = 4;
pub const NVME_FEAT_ERROR_RECOVERY: nvme_feature = 5;
pub const NVME_FEAT_VOLATILE_WRITE_CACHE: nvme_feature = 6;
pub const NVME_FEAT_NUMBER_OF_QUEUES: nvme_feature = 7;
pub const NVME_FEAT_INTERRUPT_COALESCING: nvme_feature = 8;
pub const NVME_FEAT_INTERRUPT_VECTOR_CONFIGURATION: nvme_feature = 9;
pub const NVME_FEAT_WRITE_ATOMICITY: nvme_feature = 10;
pub const NVME_FEAT_ASYNC_EVENT_CONFIGURATION: nvme_feature = 11;
pub const NVME_FEAT_AUTONOMOUS_POWER_STATE_TRANSITION: nvme_feature = 12;
pub const NVME_FEAT_HOST_MEMORY_BUFFER: nvme_feature = 13;
pub const NVME_FEAT_TIMESTAMP: nvme_feature = 14;
pub const NVME_FEAT_KEEP_ALIVE_TIMER: nvme_feature = 15;
pub const NVME_FEAT_HOST_CONTROLLED_THERMAL_MGMT: nvme_feature = 16;
pub const NVME_FEAT_NON_OP_POWER_STATE_CONFIG: nvme_feature = 17;
pub const NVME_FEAT_READ_RECOVERY_LEVEL_CONFIG: nvme_feature = 18;
pub const NVME_FEAT_PREDICTABLE_LATENCY_MODE_CONFIG: nvme_feature = 19;
pub const NVME_FEAT_PREDICTABLE_LATENCY_MODE_WINDOW: nvme_feature = 20;
pub const NVME_FEAT_LBA_STATUS_INFORMATION_ATTRIBUTES: nvme_feature = 21;
pub const NVME_FEAT_HOST_BEHAVIOR_SUPPORT: nvme_feature = 22;
pub const NVME_FEAT_SANITIZE_CONFIG: nvme_feature = 23;
pub const NVME_FEAT_ENDURANCE_GROUP_EVENT_CONFIGURATION: nvme_feature = 24;
pub const NVME_FEAT_SOFTWARE_PROGRESS_MARKER: nvme_feature = 128;
pub const NVME_FEAT_HOST_IDENTIFIER: nvme_feature = 129;
pub const NVME_FEAT_RESERVATION_NOTIFICATION_MASK: nvme_feature = 130;
pub const NVME_FEAT_RESERVATION_PERSISTENCE: nvme_feature = 131;
pub const NVME_FEAT_NAMESPACE_WRITE_PROTECTION_CONFIG: nvme_feature = 132;
pub type nvme_feature = ::core::ffi::c_uint;
pub const NVME_DSM_ATTR_INTEGRAL_READ: nvme_dsm_attribute = 1;
pub const NVME_DSM_ATTR_INTEGRAL_WRITE: nvme_dsm_attribute = 2;
pub const NVME_DSM_ATTR_DEALLOCATE: nvme_dsm_attribute = 4;
pub type nvme_dsm_attribute = ::core::ffi::c_uint;
pub const NVME_AA_REPLACE_NO_ACTIVATE: nvme_activate_action = 0;
pub const NVME_AA_REPLACE_ACTIVATE: nvme_activate_action = 1;
pub const NVME_AA_ACTIVATE: nvme_activate_action = 2;
pub type nvme_activate_action = ::core::ffi::c_uint;
#[repr(C, packed)]
pub struct nvme_power_state {
    #[doc = " Maximum Power"]
    pub mp: u16,
    pub ps_rsvd1: u8,
    pub mps_nops: u8,
    pub enlat: u32,
    pub exlat: u32,
    pub rrt: u8,
    pub rrl: u8,
    pub rwt: u8,
    pub rwl: u8,
    pub idlp: u16,
    pub ips: u8,
    pub ps_rsvd8: u8,
    pub actp: u16,
    pub apw_aps: u8,
    pub ps_rsvd10: [u8; 9usize],
}
impl Default for nvme_power_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct nvme_controller_data {
    #[doc = " pci vendor id"]
    pub vid: u16,
    #[doc = " pci subsystem vendor id"]
    pub ssvid: u16,
    #[doc = " serial number"]
    pub sn: [u8; 20usize],
    #[doc = " model number"]
    pub mn: [u8; 40usize],
    #[doc = " firmware revision"]
    pub fr: [u8; 8usize],
    #[doc = " recommended arbitration burst"]
    pub rab: u8,
    #[doc = " ieee oui identifier"]
    pub ieee: [u8; 3usize],
    #[doc = " multi-interface capabilities"]
    pub mic: u8,
    #[doc = " maximum data transfer size"]
    pub mdts: u8,
    #[doc = " Controller ID"]
    pub ctrlr_id: u16,
    #[doc = " Version"]
    pub ver: u32,
    #[doc = " RTD3 Resume Latency"]
    pub rtd3r: u32,
    #[doc = " RTD3 Enter Latency"]
    pub rtd3e: u32,
    #[doc = " Optional Asynchronous Events Supported"]
    pub oaes: u32,
    #[doc = " Controller Attributes"]
    pub ctratt: u32,
    #[doc = " Read Recovery Levels Supported"]
    pub rrls: u16,
    pub reserved1: [u8; 9usize],
    #[doc = " Controller Type"]
    pub cntrltype: u8,
    #[doc = " FRU Globally Unique Identifier"]
    pub fguid: [u8; 16usize],
    #[doc = " Command Retry Delay Time 1"]
    pub crdt1: u16,
    #[doc = " Command Retry Delay Time 2"]
    pub crdt2: u16,
    #[doc = " Command Retry Delay Time 3"]
    pub crdt3: u16,
    pub reserved2: [u8; 122usize],
    #[doc = " optional admin command support"]
    pub oacs: u16,
    #[doc = " abort command limit"]
    pub acl: u8,
    #[doc = " asynchronous event request limit"]
    pub aerl: u8,
    #[doc = " firmware updates"]
    pub frmw: u8,
    #[doc = " log page attributes"]
    pub lpa: u8,
    #[doc = " error log page entries"]
    pub elpe: u8,
    #[doc = " number of power states supported"]
    pub npss: u8,
    #[doc = " admin vendor specific command configuration"]
    pub avscc: u8,
    #[doc = " Autonomous Power State Transition Attributes"]
    pub apsta: u8,
    #[doc = " Warning Composite Temperature Threshold"]
    pub wctemp: u16,
    #[doc = " Critical Composite Temperature Threshold"]
    pub cctemp: u16,
    #[doc = " Maximum Time for Firmware Activation"]
    pub mtfa: u16,
    #[doc = " Host Memory Buffer Preferred Size"]
    pub hmpre: u32,
    #[doc = " Host Memory Buffer Minimum Size"]
    pub hmmin: u32,
    pub untncap: nvme_controller_data__bindgen_ty_1,
    #[doc = " Replay Protected Memory Block Support"]
    pub rpmbs: u32,
    #[doc = " Extended Device Self-test Time"]
    pub edstt: u16,
    #[doc = " Device Self-test Options"]
    pub dsto: u8,
    #[doc = " Firmware Update Granularity"]
    pub fwug: u8,
    #[doc = " Keep Alive Support"]
    pub kas: u16,
    #[doc = " Host Controlled Thermal Management Attributes"]
    pub hctma: u16,
    #[doc = " Minimum Thermal Management Temperature"]
    pub mntmt: u16,
    #[doc = " Maximum Thermal Management Temperature"]
    pub mxtmt: u16,
    #[doc = " Sanitize Capabilities"]
    pub sanicap: u32,
    #[doc = " Host Memory Buffer Minimum Descriptor Entry Size"]
    pub hmminds: u32,
    #[doc = " Host Memory Maximum Descriptors Entries"]
    pub hmmaxd: u16,
    #[doc = " NVM Set Identifier Maximum"]
    pub nsetidmax: u16,
    #[doc = " Endurance Group Identifier Maximum"]
    pub endgidmax: u16,
    #[doc = " ANA Transition Time"]
    pub anatt: u8,
    #[doc = " Asymmetric Namespace Access Capabilities"]
    pub anacap: u8,
    #[doc = " ANA Group Identifier Maximum"]
    pub anagrpmax: u32,
    #[doc = " Number of ANA Group Identifiers"]
    pub nanagrpid: u32,
    #[doc = " Persistent Event Log Size"]
    pub pels: u32,
    pub reserved3: [u8; 156usize],
    #[doc = " submission queue entry size"]
    pub sqes: u8,
    #[doc = " completion queue entry size"]
    pub cqes: u8,
    #[doc = " Maximum Outstanding Commands"]
    pub maxcmd: u16,
    #[doc = " number of namespaces"]
    pub nn: u32,
    #[doc = " optional nvm command support"]
    pub oncs: u16,
    #[doc = " fused operation support"]
    pub fuses: u16,
    #[doc = " format nvm attributes"]
    pub fna: u8,
    #[doc = " volatile write cache"]
    pub vwc: u8,
    #[doc = " Atomic Write Unit Normal"]
    pub awun: u16,
    #[doc = " Atomic Write Unit Power Fail"]
    pub awupf: u16,
    #[doc = " NVM Vendor Specific Command Configuration"]
    pub nvscc: u8,
    #[doc = " Namespace Write Protection Capabilities"]
    pub nwpc: u8,
    #[doc = " Atomic Compare & Write Unit"]
    pub acwu: u16,
    pub reserved6: u16,
    #[doc = " SGL Support"]
    pub sgls: u32,
    #[doc = " Maximum Number of Allowed Namespaces"]
    pub mnan: u32,
    pub reserved7: [u8; 224usize],
    #[doc = " NVM Subsystem NVMe Qualified Name"]
    pub subnqn: [u8; 256usize],
    pub reserved8: [u8; 768usize],
    pub ioccsz: u32,
    pub iorcsz: u32,
    pub icdoff: u16,
    pub fcatt: u8,
    pub msdbd: u8,
    pub ofcs: u16,
    pub reserved9: [u8; 242usize],
    pub power_state: [nvme_power_state; 32usize],
    pub vs: [u8; 1024usize],
}
#[doc = " Name space capabilities"]
#[repr(C, packed)]
pub struct nvme_controller_data__bindgen_ty_1 {
    pub tnvmcap: [u8; 16usize],
    pub unvmcap: [u8; 16usize],
}
impl Default for nvme_controller_data__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for nvme_controller_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct nvme_namespace_data {
    #[doc = " namespace size"]
    pub nsze: u64,
    #[doc = " namespace capacity"]
    pub ncap: u64,
    #[doc = " namespace utilization"]
    pub nuse: u64,
    #[doc = " namespace features"]
    pub nsfeat: u8,
    #[doc = " number of lba formats"]
    pub nlbaf: u8,
    #[doc = " formatted lba size"]
    pub flbas: u8,
    #[doc = " metadata capabilities"]
    pub mc: u8,
    #[doc = " end-to-end data protection capabilities"]
    pub dpc: u8,
    #[doc = " end-to-end data protection type settings"]
    pub dps: u8,
    #[doc = " Namespace Multi-path I/O and Namespace Sharing Capabilities"]
    pub nmic: u8,
    #[doc = " Reservation Capabilities"]
    pub rescap: u8,
    #[doc = " Format Progress Indicator"]
    pub fpi: u8,
    #[doc = " Deallocate Logical Block Features"]
    pub dlfeat: u8,
    #[doc = " Namespace Atomic Write Unit Normal"]
    pub nawun: u16,
    #[doc = " Namespace Atomic Write Unit Power Fail"]
    pub nawupf: u16,
    #[doc = " Namespace Atomic Compare & Write Unit"]
    pub nacwu: u16,
    #[doc = " Namespace Atomic Boundary Size Normal"]
    pub nabsn: u16,
    #[doc = " Namespace Atomic Boundary Offset"]
    pub nabo: u16,
    #[doc = " Namespace Atomic Boundary Size Power Fail"]
    pub nabspf: u16,
    #[doc = " Namespace Optimal IO Boundary"]
    pub noiob: u16,
    #[doc = " NVM Capacity"]
    pub nvmcap: [u8; 16usize],
    #[doc = " Namespace Preferred Write Granularity"]
    pub npwg: u16,
    #[doc = " Namespace Preferred Write Alignment"]
    pub npwa: u16,
    #[doc = " Namespace Preferred Deallocate Granularity"]
    pub npdg: u16,
    #[doc = " Namespace Preferred Deallocate Alignment"]
    pub npda: u16,
    #[doc = " Namespace Optimal Write Size"]
    pub nows: u16,
    pub reserved5: [u8; 18usize],
    #[doc = " ANA Group Identifier"]
    pub anagrpid: u32,
    pub reserved6: [u8; 3usize],
    #[doc = " Namespace Attributes"]
    pub nsattr: u8,
    #[doc = " NVM Set Identifier"]
    pub nvmsetid: u16,
    #[doc = " Endurance Group Identifier"]
    pub endgid: u16,
    #[doc = " Namespace Globally Unique Identifier"]
    pub nguid: [u8; 16usize],
    #[doc = " IEEE Extended Unique Identifier"]
    pub eui64: [u8; 8usize],
    #[doc = " lba format support"]
    pub lbaf: [u32; 64usize],
    pub vendor_specific: [u8; 3712usize],
}
impl Default for nvme_namespace_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const NVME_LOG_ERROR: nvme_log_page = 1;
pub const NVME_LOG_HEALTH_INFORMATION: nvme_log_page = 2;
pub const NVME_LOG_FIRMWARE_SLOT: nvme_log_page = 3;
pub const NVME_LOG_CHANGED_NAMESPACE: nvme_log_page = 4;
pub const NVME_LOG_COMMAND_EFFECT: nvme_log_page = 5;
pub const NVME_LOG_DEVICE_SELF_TEST: nvme_log_page = 6;
pub const NVME_LOG_TELEMETRY_HOST_INITIATED: nvme_log_page = 7;
pub const NVME_LOG_TELEMETRY_CONTROLLER_INITIATED: nvme_log_page = 8;
pub const NVME_LOG_ENDURANCE_GROUP_INFORMATION: nvme_log_page = 9;
pub const NVME_LOG_PREDICTABLE_LATENCY_PER_NVM_SET: nvme_log_page = 10;
pub const NVME_LOG_PREDICTABLE_LATENCY_EVENT_AGGREGATE: nvme_log_page = 11;
pub const NVME_LOG_ASYMMETRIC_NAMESPACE_ACCESS: nvme_log_page = 12;
pub const NVME_LOG_PERSISTENT_EVENT_LOG: nvme_log_page = 13;
pub const NVME_LOG_LBA_STATUS_INFORMATION: nvme_log_page = 14;
pub const NVME_LOG_ENDURANCE_GROUP_EVENT_AGGREGATE: nvme_log_page = 15;
pub const NVME_LOG_DISCOVERY: nvme_log_page = 112;
pub const NVME_LOG_RES_NOTIFICATION: nvme_log_page = 128;
pub const NVME_LOG_SANITIZE_STATUS: nvme_log_page = 129;
pub const INTEL_LOG_READ_LAT_LOG: nvme_log_page = 193;
pub const INTEL_LOG_WRITE_LAT_LOG: nvme_log_page = 194;
pub const INTEL_LOG_TEMP_STATS: nvme_log_page = 197;
pub const INTEL_LOG_ADD_SMART: nvme_log_page = 202;
pub const INTEL_LOG_DRIVE_MKT_NAME: nvme_log_page = 221;
pub const HGST_INFO_LOG: nvme_log_page = 193;
pub type nvme_log_page = ::core::ffi::c_uint;
#[repr(C, packed(4))]
pub struct nvme_error_information_entry {
    pub error_count: u64,
    pub sqid: u16,
    pub cid: u16,
    pub status: u16,
    pub error_location: u16,
    pub lba: u64,
    pub nsid: u32,
    pub vendor_specific: u8,
    pub trtype: u8,
    pub reserved30: u16,
    pub csi: u64,
    pub ttsi: u16,
    pub reserved: [u8; 22usize],
}
impl Default for nvme_error_information_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(8))]
pub struct nvme_health_information_page {
    pub critical_warning: u8,
    pub temperature: u16,
    pub available_spare: u8,
    pub available_spare_threshold: u8,
    pub percentage_used: u8,
    pub reserved: [u8; 26usize],
    pub data_units_read: [u64; 2usize],
    pub data_units_written: [u64; 2usize],
    pub host_read_commands: [u64; 2usize],
    pub host_write_commands: [u64; 2usize],
    pub controller_busy_time: [u64; 2usize],
    pub power_cycles: [u64; 2usize],
    pub power_on_hours: [u64; 2usize],
    pub unsafe_shutdowns: [u64; 2usize],
    pub media_errors: [u64; 2usize],
    pub num_error_info_log_entries: [u64; 2usize],
    pub warning_temp_time: u32,
    pub error_temp_time: u32,
    pub temp_sensor: [u16; 8usize],
    pub tmt1tc: u32,
    pub tmt2tc: u32,
    pub ttftmt1: u32,
    pub ttftmt2: u32,
    pub reserved2: [u8; 280usize],
}
impl Default for nvme_health_information_page {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(4))]
pub struct nvme_firmware_page {
    pub afi: u8,
    pub reserved: [u8; 7usize],
    pub revision: [[u8; 8usize]; 7usize],
    pub reserved2: [u8; 448usize],
}
impl Default for nvme_firmware_page {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct nvme_ns_list {
    pub ns: [u32; 1024usize],
}
impl Default for nvme_ns_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct nvme_command_effects_page {
    pub acs: [u32; 256usize],
    pub iocs: [u32; 256usize],
    pub reserved: [u8; 2048usize],
}
impl Default for nvme_command_effects_page {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(4))]
pub struct nvme_device_self_test_page {
    pub curr_operation: u8,
    pub curr_compl: u8,
    pub rsvd2: [u8; 2usize],
    pub result: [nvme_device_self_test_page__bindgen_ty_1; 20usize],
}
#[repr(C, packed)]
pub struct nvme_device_self_test_page__bindgen_ty_1 {
    pub status: u8,
    pub segment_num: u8,
    pub valid_diag_info: u8,
    pub rsvd3: u8,
    pub poh: u64,
    pub nsid: u32,
    pub failing_lba: [u8; 8usize],
    pub status_code_type: u8,
    pub status_code: u8,
    pub vendor_specific: [u8; 2usize],
}
impl Default for nvme_device_self_test_page__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for nvme_device_self_test_page {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct nvme_telemetry_log_page {
    pub identifier: u8,
    pub rsvd: [u8; 4usize],
    pub oui: [u8; 3usize],
    pub da1_last: u16,
    pub da2_last: u16,
    pub da3_last: u16,
    pub rsvd2: [u8; 2usize],
    pub da4_last: u32,
    pub rsvd3: [u8; 361usize],
    pub hi_gen: u8,
    pub ci_avail: u8,
    pub ci_gen: u8,
    pub reason: [u8; 128usize],
}
impl Default for nvme_telemetry_log_page {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(4))]
pub struct nvme_discovery_log_entry {
    pub trtype: u8,
    pub adrfam: u8,
    pub subtype: u8,
    pub treq: u8,
    pub portid: u16,
    pub cntlid: u16,
    pub aqsz: u16,
    pub reserved1: [u8; 22usize],
    pub trsvcid: [u8; 32usize],
    pub reserved2: [u8; 192usize],
    pub subnqn: [u8; 256usize],
    pub traddr: [u8; 256usize],
    pub tsas: nvme_discovery_log_entry__bindgen_ty_1,
}
#[repr(C)]
pub struct nvme_discovery_log_entry__bindgen_ty_1 {
    pub rdma: __BindgenUnionField<nvme_discovery_log_entry__bindgen_ty_1__bindgen_ty_1>,
    pub tcp: __BindgenUnionField<nvme_discovery_log_entry__bindgen_ty_1__bindgen_ty_2>,
    pub reserved: __BindgenUnionField<[u8; 256usize]>,
    pub bindgen_union_field: [u16; 128usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct nvme_discovery_log_entry__bindgen_ty_1__bindgen_ty_1 {
    pub rdma_qptype: u8,
    pub rdma_prtype: u8,
    pub rdma_cms: u8,
    pub reserved: [u8; 5usize],
    pub rdma_pkey: u16,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct nvme_discovery_log_entry__bindgen_ty_1__bindgen_ty_2 {
    pub sectype: u8,
}
impl Default for nvme_discovery_log_entry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for nvme_discovery_log_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct nvme_discovery_log {
    pub genctr: u64,
    pub numrec: u64,
    pub recfmt: u16,
    pub reserved: [u8; 1006usize],
    pub entries: __IncompleteArrayField<nvme_discovery_log_entry>,
}
impl Default for nvme_discovery_log {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct nvme_res_notification_page {
    pub log_page_count: u64,
    pub log_page_type: u8,
    pub available_log_pages: u8,
    pub reserved2: u8,
    pub nsid: u32,
    pub reserved: [u8; 48usize],
}
impl Default for nvme_res_notification_page {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct nvme_sanitize_status_page {
    pub sprog: u16,
    pub sstat: u16,
    pub scdw10: u32,
    pub etfo: u32,
    pub etfbe: u32,
    pub etfce: u32,
    pub etfownd: u32,
    pub etfbewnd: u32,
    pub etfcewnd: u32,
    pub reserved: [u8; 480usize],
}
impl Default for nvme_sanitize_status_page {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct intel_log_temp_stats {
    pub current: u64,
    pub overtemp_flag_last: u64,
    pub overtemp_flag_life: u64,
    pub max_temp: u64,
    pub min_temp: u64,
    pub _rsvd: [u64; 5usize],
    pub max_oper_temp: u64,
    pub min_oper_temp: u64,
    pub est_offset: u64,
}
impl Default for intel_log_temp_stats {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct nvme_resv_reg_ctrlr {
    pub ctrlr_id: u16,
    pub rcsts: u8,
    pub reserved3: [u8; 5usize],
    pub hostid: u64,
    pub rkey: u64,
}
impl Default for nvme_resv_reg_ctrlr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct nvme_resv_reg_ctrlr_ext {
    pub ctrlr_id: u16,
    pub rcsts: u8,
    pub reserved3: [u8; 5usize],
    pub rkey: u64,
    pub hostid: [u64; 2usize],
    pub reserved32: [u8; 32usize],
}
impl Default for nvme_resv_reg_ctrlr_ext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct nvme_resv_status {
    pub gen_: u32,
    pub rtype: u8,
    pub regctl: [u8; 2usize],
    pub reserved7: [u8; 2usize],
    pub ptpls: u8,
    pub reserved10: [u8; 14usize],
    pub ctrlr: __IncompleteArrayField<nvme_resv_reg_ctrlr>,
}
impl Default for nvme_resv_status {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
pub struct nvme_resv_status_ext {
    pub gen_: u32,
    pub rtype: u8,
    pub regctl: [u8; 2usize],
    pub reserved7: [u8; 2usize],
    pub ptpls: u8,
    pub reserved10: [u8; 14usize],
    pub reserved24: [u8; 40usize],
    pub ctrlr: __IncompleteArrayField<nvme_resv_reg_ctrlr_ext>,
}
impl Default for nvme_resv_status_ext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nvme_io_test {
    pub opc: nvme_nvm_opcode,
    pub size: u32,
    pub time: u32,
    pub num_threads: u32,
    pub flags: u32,
    pub io_completed: [u64; 128usize],
}
impl Default for nvme_io_test {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const NVME_TEST_FLAG_REFTHREAD: nvme_io_test_flags = 1;
pub type nvme_io_test_flags = ::core::ffi::c_uint;
#[repr(C)]
pub struct nvme_pt_command {
    pub cmd: nvme_command,
    pub cpl: nvme_completion,
    pub buf: *mut ::core::ffi::c_void,
    pub len: u32,
    pub is_read: u32,
    pub driver_lock: *mut mtx,
}
impl Default for nvme_pt_command {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nvme_get_nsid {
    pub cdev: [::core::ffi::c_char; 256usize],
    pub nsid: u32,
}
impl Default for nvme_get_nsid {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct nvme_hmb_desc {
    pub addr: u64,
    pub size: u32,
    pub reserved: u32,
}
#[repr(C)]
#[derive(Debug)]
pub struct kerneldumpheader {
    pub magic: [::core::ffi::c_char; 20usize],
    pub architecture: [::core::ffi::c_char; 12usize],
    pub version: u32,
    pub architectureversion: u32,
    pub dumplength: u64,
    pub dumptime: u64,
    pub dumpkeysize: u32,
    pub blocksize: u32,
    pub hostname: [::core::ffi::c_char; 64usize],
    pub versionstring: [::core::ffi::c_char; 192usize],
    pub panicstring: [::core::ffi::c_char; 175usize],
    pub compression: u8,
    pub dumpextent: u64,
    pub unused: [::core::ffi::c_char; 4usize],
    pub parity: u32,
}
impl Default for kerneldumpheader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct kerneldumpkey {
    pub kdk_encryption: u8,
    pub kdk_iv: [u8; 32usize],
    pub kdk_encryptedkeysize: u32,
    pub kdk_encryptedkey: __IncompleteArrayField<u8>,
}
impl Default for kerneldumpkey {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct dump_pa {
    pub pa_start: vm_paddr_t,
    pub pa_size: vm_paddr_t,
}
#[repr(C)]
#[derive(Debug)]
pub struct minidumpstate {
    pub msgbufp: *mut msgbuf,
    pub dump_bitset: *mut bitset,
}
impl Default for minidumpstate {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type dumpsys_callback_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut dump_pa,
        arg2: ::core::ffi::c_int,
        arg3: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
pub type livedump_start_fn = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, errorp: *mut ::core::ffi::c_int),
>;
pub type livedump_dump_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::core::ffi::c_void,
        virtual_: *mut ::core::ffi::c_void,
        offset: off_t,
        len: usize,
        errorp: *mut ::core::ffi::c_int,
    ),
>;
pub type livedump_finish_fn =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_livedumper_start {
    pub ee: eventhandler_entry,
    pub eh_func: livedump_start_fn,
}
impl Default for eventhandler_entry_livedumper_start {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_livedumper_dump {
    pub ee: eventhandler_entry,
    pub eh_func: livedump_dump_fn,
}
impl Default for eventhandler_entry_livedumper_dump {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct eventhandler_entry_livedumper_finish {
    pub ee: eventhandler_entry,
    pub eh_func: livedump_finish_fn,
}
impl Default for eventhandler_entry_livedumper_finish {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sa_family_t = __sa_family_t;
pub type socklen_t = __socklen_t;
#[repr(C)]
#[derive(Debug, Default)]
pub struct linger {
    pub l_onoff: ::core::ffi::c_int,
    pub l_linger: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct accept_filter_arg {
    pub af_name: [::core::ffi::c_char; 16usize],
    pub af_arg: [::core::ffi::c_char; 240usize],
}
impl Default for accept_filter_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct sockaddr {
    pub sa_len: ::core::ffi::c_uchar,
    pub sa_family: sa_family_t,
    pub sa_data: [::core::ffi::c_char; 14usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct sockproto {
    pub sp_family: ::core::ffi::c_ushort,
    pub sp_protocol: ::core::ffi::c_ushort,
}
#[repr(C)]
#[derive(Debug)]
pub struct sockaddr_storage {
    pub ss_len: ::core::ffi::c_uchar,
    pub ss_family: sa_family_t,
    pub __ss_pad1: [::core::ffi::c_char; 6usize],
    pub __ss_align: __int64_t,
    pub __ss_pad2: [::core::ffi::c_char; 112usize],
}
impl Default for sockaddr_storage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct msghdr {
    pub msg_name: *mut ::core::ffi::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: ::core::ffi::c_int,
    pub msg_control: *mut ::core::ffi::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: ::core::ffi::c_int,
}
impl Default for msghdr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct cmsghdr {
    pub cmsg_len: socklen_t,
    pub cmsg_level: ::core::ffi::c_int,
    pub cmsg_type: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct cmsgcred {
    pub cmcred_pid: pid_t,
    pub cmcred_uid: uid_t,
    pub cmcred_euid: uid_t,
    pub cmcred_gid: gid_t,
    pub cmcred_ngroups: ::core::ffi::c_short,
    pub cmcred_groups: [gid_t; 16usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct sockcred {
    pub sc_uid: uid_t,
    pub sc_euid: uid_t,
    pub sc_gid: gid_t,
    pub sc_egid: gid_t,
    pub sc_ngroups: ::core::ffi::c_int,
    pub sc_groups: [gid_t; 1usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct sockcred2 {
    pub sc_version: ::core::ffi::c_int,
    pub sc_pid: pid_t,
    pub sc_uid: uid_t,
    pub sc_euid: uid_t,
    pub sc_gid: gid_t,
    pub sc_egid: gid_t,
    pub sc_ngroups: ::core::ffi::c_int,
    pub sc_groups: [gid_t; 1usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct sock_timestamp_info {
    pub st_info_flags: __uint32_t,
    pub st_info_pad0: __uint32_t,
    pub st_info_rsv: [__uint64_t; 7usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct osockaddr {
    pub sa_family: ::core::ffi::c_ushort,
    pub sa_data: [::core::ffi::c_char; 14usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct omsghdr {
    pub msg_name: *mut ::core::ffi::c_char,
    pub msg_namelen: ::core::ffi::c_int,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: ::core::ffi::c_int,
    pub msg_accrights: *mut ::core::ffi::c_char,
    pub msg_accrightslen: ::core::ffi::c_int,
}
impl Default for omsghdr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const SHUT_RD: shutdown_how = 0;
pub const SHUT_WR: shutdown_how = 1;
pub const SHUT_RDWR: shutdown_how = 2;
pub type shutdown_how = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct sf_hdtr {
    pub headers: *mut iovec,
    pub hdr_cnt: ::core::ffi::c_int,
    pub trailers: *mut iovec,
    pub trl_cnt: ::core::ffi::c_int,
}
impl Default for sf_hdtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct mmsghdr {
    pub msg_hdr: msghdr,
    pub msg_len: isize,
}
impl Default for mmsghdr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct splice {
    pub sp_fd: ::core::ffi::c_int,
    pub sp_max: off_t,
    pub sp_idle: timeval,
}
#[repr(C)]
pub struct diocgattr_arg {
    pub name: [::core::ffi::c_char; 64usize],
    pub len: ::core::ffi::c_int,
    pub value: diocgattr_arg__bindgen_ty_1,
}
#[repr(C)]
pub struct diocgattr_arg__bindgen_ty_1 {
    pub str_: __BindgenUnionField<[::core::ffi::c_char; 256usize]>,
    pub off: __BindgenUnionField<off_t>,
    pub i: __BindgenUnionField<::core::ffi::c_int>,
    pub u16_: __BindgenUnionField<u16>,
    pub bindgen_union_field: [u64; 32usize],
}
impl Default for diocgattr_arg__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for diocgattr_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct if_clonereq {
    pub ifcr_total: ::core::ffi::c_int,
    pub ifcr_count: ::core::ffi::c_int,
    pub ifcr_buffer: *mut ::core::ffi::c_char,
}
impl Default for if_clonereq {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct if_data {
    pub ifi_type: u8,
    pub ifi_physical: u8,
    pub ifi_addrlen: u8,
    pub ifi_hdrlen: u8,
    pub ifi_link_state: u8,
    pub ifi_vhid: u8,
    pub ifi_datalen: u16,
    pub ifi_mtu: u32,
    pub ifi_metric: u32,
    pub ifi_baudrate: u64,
    pub ifi_ipackets: u64,
    pub ifi_ierrors: u64,
    pub ifi_opackets: u64,
    pub ifi_oerrors: u64,
    pub ifi_collisions: u64,
    pub ifi_ibytes: u64,
    pub ifi_obytes: u64,
    pub ifi_imcasts: u64,
    pub ifi_omcasts: u64,
    pub ifi_iqdrops: u64,
    pub ifi_oqdrops: u64,
    pub ifi_noproto: u64,
    pub ifi_hwassist: u64,
    pub __ifi_epoch: if_data__bindgen_ty_1,
    pub __ifi_lastchange: if_data__bindgen_ty_2,
}
#[repr(C)]
pub struct if_data__bindgen_ty_1 {
    pub tt: __BindgenUnionField<time_t>,
    pub ph: __BindgenUnionField<u64>,
    pub bindgen_union_field: u64,
}
impl Default for if_data__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct if_data__bindgen_ty_2 {
    pub tv: __BindgenUnionField<timeval>,
    pub ph: __BindgenUnionField<if_data__bindgen_ty_2__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct if_data__bindgen_ty_2__bindgen_ty_1 {
    pub ph1: u64,
    pub ph2: u64,
}
impl Default for if_data__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for if_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct if_msghdr {
    pub ifm_msglen: u_short,
    pub ifm_version: u_char,
    pub ifm_type: u_char,
    pub ifm_addrs: ::core::ffi::c_int,
    pub ifm_flags: ::core::ffi::c_int,
    pub ifm_index: u_short,
    pub _ifm_spare1: u_short,
    pub ifm_data: if_data,
}
impl Default for if_msghdr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct if_msghdrl {
    pub ifm_msglen: u_short,
    pub ifm_version: u_char,
    pub ifm_type: u_char,
    pub ifm_addrs: ::core::ffi::c_int,
    pub ifm_flags: ::core::ffi::c_int,
    pub ifm_index: u_short,
    pub _ifm_spare1: u_short,
    pub ifm_len: u_short,
    pub ifm_data_off: u_short,
    pub _ifm_spare2: ::core::ffi::c_int,
    pub ifm_data: if_data,
}
impl Default for if_msghdrl {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct ifa_msghdr {
    pub ifam_msglen: u_short,
    pub ifam_version: u_char,
    pub ifam_type: u_char,
    pub ifam_addrs: ::core::ffi::c_int,
    pub ifam_flags: ::core::ffi::c_int,
    pub ifam_index: u_short,
    pub _ifam_spare1: u_short,
    pub ifam_metric: ::core::ffi::c_int,
}
#[repr(C)]
pub struct ifa_msghdrl {
    pub ifam_msglen: u_short,
    pub ifam_version: u_char,
    pub ifam_type: u_char,
    pub ifam_addrs: ::core::ffi::c_int,
    pub ifam_flags: ::core::ffi::c_int,
    pub ifam_index: u_short,
    pub _ifam_spare1: u_short,
    pub ifam_len: u_short,
    pub ifam_data_off: u_short,
    pub ifam_metric: ::core::ffi::c_int,
    pub ifam_data: if_data,
}
impl Default for ifa_msghdrl {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct ifma_msghdr {
    pub ifmam_msglen: u_short,
    pub ifmam_version: u_char,
    pub ifmam_type: u_char,
    pub ifmam_addrs: ::core::ffi::c_int,
    pub ifmam_flags: ::core::ffi::c_int,
    pub ifmam_index: u_short,
    pub _ifmam_spare1: u_short,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct if_announcemsghdr {
    pub ifan_msglen: u_short,
    pub ifan_version: u_char,
    pub ifan_type: u_char,
    pub ifan_index: u_short,
    pub ifan_name: [::core::ffi::c_char; 16usize],
    pub ifan_what: u_short,
}
#[repr(C)]
#[derive(Debug)]
pub struct ifreq_buffer {
    pub length: usize,
    pub buffer: *mut ::core::ffi::c_void,
}
impl Default for ifreq_buffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct ifreq_nv_req {
    pub buf_length: u_int,
    pub length: u_int,
    pub buffer: *mut ::core::ffi::c_void,
}
impl Default for ifreq_nv_req {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ifreq {
    pub ifr_name: [::core::ffi::c_char; 16usize],
    pub ifr_ifru: ifreq__bindgen_ty_1,
}
#[repr(C)]
pub struct ifreq__bindgen_ty_1 {
    pub ifru_addr: __BindgenUnionField<sockaddr>,
    pub ifru_dstaddr: __BindgenUnionField<sockaddr>,
    pub ifru_broadaddr: __BindgenUnionField<sockaddr>,
    pub ifru_buffer: __BindgenUnionField<ifreq_buffer>,
    pub ifru_flags: __BindgenUnionField<[::core::ffi::c_short; 2usize]>,
    pub ifru_index: __BindgenUnionField<::core::ffi::c_short>,
    pub ifru_jid: __BindgenUnionField<::core::ffi::c_int>,
    pub ifru_metric: __BindgenUnionField<::core::ffi::c_int>,
    pub ifru_mtu: __BindgenUnionField<::core::ffi::c_int>,
    pub ifru_phys: __BindgenUnionField<::core::ffi::c_int>,
    pub ifru_media: __BindgenUnionField<::core::ffi::c_int>,
    pub ifru_data: __BindgenUnionField<caddr_t>,
    pub ifru_cap: __BindgenUnionField<[::core::ffi::c_int; 2usize]>,
    pub ifru_fib: __BindgenUnionField<u_int>,
    pub ifru_vlan_pcp: __BindgenUnionField<u_char>,
    pub ifru_nv: __BindgenUnionField<ifreq_nv_req>,
    pub bindgen_union_field: [u64; 2usize],
}
impl Default for ifreq__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ifreq {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct ifaliasreq {
    pub ifra_name: [::core::ffi::c_char; 16usize],
    pub ifra_addr: sockaddr,
    pub ifra_broadaddr: sockaddr,
    pub ifra_mask: sockaddr,
    pub ifra_vhid: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct oifaliasreq {
    pub ifra_name: [::core::ffi::c_char; 16usize],
    pub ifra_addr: sockaddr,
    pub ifra_broadaddr: sockaddr,
    pub ifra_mask: sockaddr,
}
#[repr(C)]
#[derive(Debug)]
pub struct ifmediareq {
    pub ifm_name: [::core::ffi::c_char; 16usize],
    pub ifm_current: ::core::ffi::c_int,
    pub ifm_mask: ::core::ffi::c_int,
    pub ifm_status: ::core::ffi::c_int,
    pub ifm_active: ::core::ffi::c_int,
    pub ifm_count: ::core::ffi::c_int,
    pub ifm_ulist: *mut ::core::ffi::c_int,
}
impl Default for ifmediareq {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct ifdrv {
    pub ifd_name: [::core::ffi::c_char; 16usize],
    pub ifd_cmd: ::core::ffi::c_ulong,
    pub ifd_len: usize,
    pub ifd_data: *mut ::core::ffi::c_void,
}
impl Default for ifdrv {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct ifstat {
    pub ifs_name: [::core::ffi::c_char; 16usize],
    pub ascii: [::core::ffi::c_char; 801usize],
}
impl Default for ifstat {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ifconf {
    pub ifc_len: ::core::ffi::c_int,
    pub ifc_ifcu: ifconf__bindgen_ty_1,
}
#[repr(C)]
pub struct ifconf__bindgen_ty_1 {
    pub ifcu_buf: __BindgenUnionField<caddr_t>,
    pub ifcu_req: __BindgenUnionField<*mut ifreq>,
    pub bindgen_union_field: u64,
}
impl Default for ifconf__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ifconf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ifg_req {
    pub ifgrq_ifgrqu: ifg_req__bindgen_ty_1,
}
#[repr(C)]
pub struct ifg_req__bindgen_ty_1 {
    pub ifgrqu_group: __BindgenUnionField<[::core::ffi::c_char; 16usize]>,
    pub ifgrqu_member: __BindgenUnionField<[::core::ffi::c_char; 16usize]>,
    pub bindgen_union_field: [u8; 16usize],
}
impl Default for ifg_req__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ifg_req {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ifgroupreq {
    pub ifgr_name: [::core::ffi::c_char; 16usize],
    pub ifgr_len: u_int,
    pub ifgr_ifgru: ifgroupreq__bindgen_ty_1,
}
#[repr(C)]
pub struct ifgroupreq__bindgen_ty_1 {
    pub ifgru_group: __BindgenUnionField<[::core::ffi::c_char; 16usize]>,
    pub ifgru_groups: __BindgenUnionField<*mut ifg_req>,
    pub bindgen_union_field: [u64; 2usize],
}
impl Default for ifgroupreq__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ifgroupreq {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct ifi2creq {
    pub dev_addr: u8,
    pub offset: u8,
    pub len: u8,
    pub spare0: u8,
    pub spare1: u32,
    pub data: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct ifrsskey {
    pub ifrk_name: [::core::ffi::c_char; 16usize],
    pub ifrk_func: u8,
    pub ifrk_spare0: u8,
    pub ifrk_keylen: u16,
    pub ifrk_key: [u8; 128usize],
}
impl Default for ifrsskey {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct ifrsshash {
    pub ifrh_name: [::core::ffi::c_char; 16usize],
    pub ifrh_func: u8,
    pub ifrh_spare0: u8,
    pub ifrh_spare1: u16,
    pub ifrh_types: u32,
}
#[repr(C)]
#[derive(Debug)]
pub struct ifdownreason {
    pub ifdr_name: [::core::ffi::c_char; 16usize],
    pub ifdr_reason: u32,
    pub ifdr_vendor: u32,
    pub ifdr_msg: [::core::ffi::c_char; 64usize],
}
impl Default for ifdownreason {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct ifnet {
    _unused: [u8; 0],
}
pub type if_t = *mut ifnet;
#[repr(C)]
#[derive(Debug)]
pub struct nvlist {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ifcap_nv_bit_name {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct siocsifcapnv_driver_data {
    pub reqcap: ::core::ffi::c_int,
    pub reqcap2: ::core::ffi::c_int,
    pub nvcap: *mut nvlist,
}
impl Default for siocsifcapnv_driver_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct sockaddr_in {
    pub sin_len: u8,
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::core::ffi::c_char; 8usize],
}
#[repr(C)]
#[repr(align(128))]
#[derive(Debug)]
pub struct vnet {
    pub vnet_le: vnet__bindgen_ty_1,
    pub vnet_magic_n: u_int,
    pub vnet_ifcnt: u_int,
    pub vnet_sockcnt: u_int,
    pub vnet_state: u_int,
    pub vnet_data_mem: *mut ::core::ffi::c_void,
    pub vnet_data_base: usize,
    pub vnet_shutdown: bool_,
}
#[repr(C)]
#[derive(Debug)]
pub struct vnet__bindgen_ty_1 {
    pub le_next: *mut vnet,
    pub le_prev: *mut *mut vnet,
}
impl Default for vnet__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vnet {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct rwlock {
    pub lock_object: lock_object,
    pub rw_lock: __uintptr_t,
}
impl Default for rwlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(128))]
#[derive(Debug)]
pub struct rwlock_padalign {
    pub lock_object: lock_object,
    pub rw_lock: __uintptr_t,
}
impl Default for rwlock_padalign {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct rw_args {
    pub ra_rw: *mut ::core::ffi::c_void,
    pub ra_desc: *const ::core::ffi::c_char,
    pub ra_flags: ::core::ffi::c_int,
}
impl Default for rw_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct sx_args {
    pub sa_sx: *mut sx,
    pub sa_desc: *const ::core::ffi::c_char,
    pub sa_flags: ::core::ffi::c_int,
}
impl Default for sx_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct vnet_list_head {
    pub lh_first: *mut vnet,
}
impl Default for vnet_list_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct vnet_sysinit {
    pub subsystem: sysinit_sub_id,
    pub order: sysinit_elem_order,
    pub func: sysinit_cfunc_t,
    pub arg: *const ::core::ffi::c_void,
    pub link: vnet_sysinit__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug)]
pub struct vnet_sysinit__bindgen_ty_1 {
    pub tqe_next: *mut vnet_sysinit,
    pub tqe_prev: *mut *mut vnet_sysinit,
}
impl Default for vnet_sysinit__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vnet_sysinit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_sourceaddr: in_addr,
    pub imr_interface: in_addr,
}
#[repr(C)]
#[derive(Debug)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
impl Default for group_req {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
impl Default for group_source_req {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct __msfilterreq {
    pub msfr_ifindex: u32,
    pub msfr_fmode: u32,
    pub msfr_nsrcs: u32,
    pub msfr_group: sockaddr_storage,
    pub msfr_srcs: *mut sockaddr_storage,
}
impl Default for __msfilterreq {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct in_ifaddr {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct in6_addr {
    pub __u6_addr: in6_addr__bindgen_ty_1,
}
#[repr(C)]
pub struct in6_addr__bindgen_ty_1 {
    pub __u6_addr8: __BindgenUnionField<[u8; 16usize]>,
    pub __u6_addr16: __BindgenUnionField<[u16; 8usize]>,
    pub __u6_addr32: __BindgenUnionField<[u32; 4usize]>,
    pub bindgen_union_field: [u32; 4usize],
}
impl Default for in6_addr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for in6_addr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct sockaddr_in6 {
    pub sin6_len: u8,
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
impl Default for sockaddr_in6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nhop_object {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct route_in6 {
    pub ro_nh: *mut nhop_object,
    pub ro_lle: *mut llentry,
    pub ro_prepend: *mut ::core::ffi::c_char,
    pub ro_plen: u16,
    pub ro_flags: u16,
    pub ro_mtu: u16,
    pub spare: u16,
    pub ro_dst: sockaddr_in6,
}
impl Default for route_in6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::core::ffi::c_uint,
}
impl Default for ipv6_mreq {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct in6_pktinfo {
    pub ipi6_addr: in6_addr,
    pub ipi6_ifindex: ::core::ffi::c_uint,
}
impl Default for in6_pktinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ip6_mtuinfo {
    pub ip6m_addr: sockaddr_in6,
    pub ip6m_mtu: u32,
}
impl Default for ip6_mtuinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct ip6_hdr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct in6_ifaddr {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct kd_ip {
    pub in4: __BindgenUnionField<in_addr>,
    pub in6: __BindgenUnionField<in6_addr>,
    pub bindgen_union_field: [u32; 4usize],
}
impl Default for kd_ip {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct diocskerneldump_arg {
    pub kda_index: u8,
    pub kda_compression: u8,
    pub kda_encryption: u8,
    pub kda_key: [u8; 64usize],
    pub kda_encryptedkeysize: u32,
    pub kda_encryptedkey: *mut u8,
    pub kda_iface: [::core::ffi::c_char; 16usize],
    pub kda_server: kd_ip,
    pub kda_client: kd_ip,
    pub kda_gateway: kd_ip,
    pub kda_af: u8,
}
impl Default for diocskerneldump_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nvme_consumer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct nvme_passthru_cmd {
    _unused: [u8; 0],
}
pub type nvme_cb_fn_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *const nvme_completion),
>;
pub type nvme_cons_ns_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nvme_namespace,
        arg2: *mut ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void,
>;
pub type nvme_cons_ctrlr_fn_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut nvme_controller) -> *mut ::core::ffi::c_void,
>;
pub type nvme_cons_async_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const nvme_completion,
        arg3: u32,
        arg4: *mut ::core::ffi::c_void,
        arg5: u32,
    ),
>;
pub type nvme_cons_fail_fn_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
pub const NVME_NS_DEALLOCATE_SUPPORTED: nvme_namespace_flags = 1;
pub const NVME_NS_FLUSH_SUPPORTED: nvme_namespace_flags = 2;
pub const NVME_NS_ADDED: nvme_namespace_flags = 4;
pub const NVME_NS_CHANGED: nvme_namespace_flags = 8;
pub const NVME_NS_GONE: nvme_namespace_flags = 16;
pub type nvme_namespace_flags = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default)]
pub struct nvme_completion_poll_status {
    pub cpl: nvme_completion,
    pub done: ::core::ffi::c_int,
}
#[repr(C)]
pub struct nvme_request {
    pub cmd: nvme_command,
    pub qpair: *mut nvme_qpair,
    pub payload: memdesc,
    pub cb_fn: nvme_cb_fn_t,
    pub cb_arg: *mut ::core::ffi::c_void,
    pub retries: i32,
    pub payload_valid: bool_,
    pub timeout: bool_,
    pub spare: [bool_; 2usize],
    pub stailq: nvme_request__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug)]
pub struct nvme_request__bindgen_ty_1 {
    pub stqe_next: *mut nvme_request,
}
impl Default for nvme_request__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for nvme_request {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nvme_async_event_request {
    pub ctrlr: *mut nvme_controller,
    pub req: *mut nvme_request,
    pub task: task,
    pub mtx: mtx,
    pub cpl: nvme_completion,
    pub log_page_id: u32,
    pub log_page_size: u32,
    pub log_page_buffer: [u8; 4096usize],
}
impl Default for nvme_async_event_request {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nvme_tracker {
    pub tailq: nvme_tracker__bindgen_ty_1,
    pub req: *mut nvme_request,
    pub qpair: *mut nvme_qpair,
    pub deadline: sbintime_t,
    pub payload_dma_map: bus_dmamap_t,
    pub cid: u16,
    pub prp: *mut u64,
    pub prp_bus_addr: bus_addr_t,
}
#[repr(C)]
#[derive(Debug)]
pub struct nvme_tracker__bindgen_ty_1 {
    pub tqe_next: *mut nvme_tracker,
    pub tqe_prev: *mut *mut nvme_tracker,
}
impl Default for nvme_tracker__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for nvme_tracker {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const RECOVERY_NONE: nvme_recovery = 0;
pub const RECOVERY_WAITING: nvme_recovery = 1;
pub type nvme_recovery = ::core::ffi::c_uint;
#[repr(C)]
#[repr(align(128))]
pub struct nvme_qpair {
    pub ctrlr: *mut nvme_controller,
    pub id: u32,
    pub domain: ::core::ffi::c_int,
    pub cpu: ::core::ffi::c_int,
    pub vector: u16,
    pub rid: ::core::ffi::c_int,
    pub res: *mut resource,
    pub tag: *mut ::core::ffi::c_void,
    pub timer: callout,
    pub timer_armed: bool_,
    pub recovery_state: nvme_recovery,
    pub num_entries: u32,
    pub num_trackers: u32,
    pub sq_tdbl_off: u32,
    pub cq_hdbl_off: u32,
    pub phase: u32,
    pub sq_head: u32,
    pub sq_tail: u32,
    pub cq_head: u32,
    pub num_cmds: i64,
    pub num_intr_handler_calls: i64,
    pub num_retries: i64,
    pub num_failures: i64,
    pub num_ignored: i64,
    pub num_recovery_nolock: i64,
    pub cmd: *mut nvme_command,
    pub cpl: *mut nvme_completion,
    pub dma_tag: bus_dma_tag_t,
    pub dma_tag_payload: bus_dma_tag_t,
    pub queuemem_map: bus_dmamap_t,
    pub cmd_bus_addr: u64,
    pub cpl_bus_addr: u64,
    pub free_tr: nvme_qpair__bindgen_ty_1,
    pub outstanding_tr: nvme_qpair__bindgen_ty_2,
    pub queued_req: nvme_qpair__bindgen_ty_3,
    pub act_tr: *mut *mut nvme_tracker,
    pub __bindgen_padding_0: [u64; 9usize],
    pub lock: mtx_padalign,
    pub recovery: mtx_padalign,
}
#[repr(C)]
#[derive(Debug)]
pub struct nvme_qpair__bindgen_ty_1 {
    pub tqh_first: *mut nvme_tracker,
    pub tqh_last: *mut *mut nvme_tracker,
}
impl Default for nvme_qpair__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nvme_qpair__bindgen_ty_2 {
    pub tqh_first: *mut nvme_tracker,
    pub tqh_last: *mut *mut nvme_tracker,
}
impl Default for nvme_qpair__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nvme_qpair__bindgen_ty_3 {
    pub stqh_first: *mut nvme_request,
    pub stqh_last: *mut *mut nvme_request,
}
impl Default for nvme_qpair__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for nvme_qpair {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct nvme_namespace {
    pub ctrlr: *mut nvme_controller,
    pub data: nvme_namespace_data,
    pub id: u32,
    pub flags: u32,
    pub cdev: *mut cdev,
    pub cons_cookie: [*mut ::core::ffi::c_void; 2usize],
    pub boundary: u32,
    pub lock: mtx,
}
impl Default for nvme_namespace {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(128))]
pub struct nvme_controller {
    pub dev: device_t,
    pub lock: mtx,
    pub domain: ::core::ffi::c_int,
    pub ready_timeout_in_ms: u32,
    pub quirks: u32,
    pub bus_tag: bus_space_tag_t,
    pub bus_handle: bus_space_handle_t,
    pub resource_id: ::core::ffi::c_int,
    pub resource: *mut resource,
    pub msix_table_resource_id: ::core::ffi::c_int,
    pub msix_table_resource: *mut resource,
    pub msix_pba_resource_id: ::core::ffi::c_int,
    pub msix_pba_resource: *mut resource,
    pub msi_count: ::core::ffi::c_int,
    pub enable_aborts: u32,
    pub num_io_queues: u32,
    pub max_hw_pend_io: u32,
    pub config_hook: intr_config_hook,
    pub ns_identified: u32,
    pub queues_created: u32,
    pub reset_task: task,
    pub taskqueue: *mut taskqueue,
    pub rid: ::core::ffi::c_int,
    pub res: *mut resource,
    pub tag: *mut ::core::ffi::c_void,
    #[doc = " maximum i/o size in bytes"]
    pub max_xfer_size: u32,
    #[doc = " LO and HI capacity mask"]
    pub cap_lo: u32,
    pub cap_hi: u32,
    #[doc = " Page size and log2(page_size) - 12 that we're currently using"]
    pub page_size: u32,
    pub mps: u32,
    #[doc = " interrupt coalescing time period (in microseconds)"]
    pub int_coal_time: u32,
    #[doc = " interrupt coalescing threshold"]
    pub int_coal_threshold: u32,
    #[doc = " timeout period in seconds"]
    pub admin_timeout_period: u32,
    pub timeout_period: u32,
    #[doc = " doorbell stride"]
    pub dstrd: u32,
    pub __bindgen_padding_0: [u64; 13usize],
    pub adminq: nvme_qpair,
    pub ioq: *mut nvme_qpair,
    pub regs: *mut nvme_registers,
    pub cdata: nvme_controller_data,
    pub ns: [nvme_namespace; 16usize],
    pub cdev: *mut cdev,
    #[doc = " bit mask of event types currently enabled for async events"]
    pub async_event_config: u32,
    pub num_aers: u32,
    pub aer: [nvme_async_event_request; 8usize],
    pub cons_cookie: [*mut ::core::ffi::c_void; 2usize],
    pub is_resetting: u32,
    pub notification_sent: u32,
    pub fail_on_reset: u_int,
    pub is_failed: bool_,
    pub is_failed_admin: bool_,
    pub is_dying: bool_,
    pub isr_warned: bool_,
    pub is_initialized: bool_,
    pub hmb_nchunks: ::core::ffi::c_int,
    pub hmb_chunk: usize,
    pub hmb_tag: bus_dma_tag_t,
    pub hmb_chunks: *mut nvme_controller_nvme_hmb_chunk,
    pub hmb_desc_tag: bus_dma_tag_t,
    pub hmb_desc_map: bus_dmamap_t,
    pub hmb_desc_vaddr: *mut nvme_hmb_desc,
    pub hmb_desc_paddr: u64,
    pub alignment_splits: counter_u64_t,
}
#[repr(C)]
#[derive(Debug)]
pub struct nvme_controller_nvme_hmb_chunk {
    pub hmbc_map: bus_dmamap_t,
    pub hmbc_vaddr: *mut ::core::ffi::c_void,
    pub hmbc_paddr: u64,
}
impl Default for nvme_controller_nvme_hmb_chunk {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for nvme_controller {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief A function implementing the PIC_ACTIVATE_INTR() method"]
pub type pic_activate_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: device_t,
        isrc: *mut intr_irqsrc,
        res: *mut resource,
        data: *mut intr_map_data,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the PIC_BIND_INTR() method"]
pub type pic_bind_intr_t = ::core::option::Option<
    unsafe extern "C" fn(dev: device_t, isrc: *mut intr_irqsrc) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the PIC_DISABLE_INTR() method"]
pub type pic_disable_intr_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t, isrc: *mut intr_irqsrc)>;
#[doc = " @brief A function implementing the PIC_ENABLE_INTR() method"]
pub type pic_enable_intr_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t, isrc: *mut intr_irqsrc)>;
#[doc = " @brief A function implementing the PIC_MAP_INTR() method"]
pub type pic_map_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: device_t,
        data: *mut intr_map_data,
        isrcp: *mut *mut intr_irqsrc,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the PIC_DEACTIVATE_INTR() method"]
pub type pic_deactivate_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: device_t,
        isrc: *mut intr_irqsrc,
        res: *mut resource,
        data: *mut intr_map_data,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the PIC_SETUP_INTR() method"]
pub type pic_setup_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: device_t,
        isrc: *mut intr_irqsrc,
        res: *mut resource,
        data: *mut intr_map_data,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the PIC_TEARDOWN_INTR() method"]
pub type pic_teardown_intr_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: device_t,
        isrc: *mut intr_irqsrc,
        res: *mut resource,
        data: *mut intr_map_data,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief A function implementing the PIC_POST_FILTER() method"]
pub type pic_post_filter_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t, isrc: *mut intr_irqsrc)>;
#[doc = " @brief A function implementing the PIC_POST_ITHREAD() method"]
pub type pic_post_ithread_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t, isrc: *mut intr_irqsrc)>;
#[doc = " @brief A function implementing the PIC_PRE_ITHREAD() method"]
pub type pic_pre_ithread_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t, isrc: *mut intr_irqsrc)>;
#[doc = " @brief A function implementing the PIC_INIT_SECONDARY() method"]
pub type pic_init_secondary_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t, rootnum: u32)>;
#[doc = " @brief A function implementing the PIC_IPI_SEND() method"]
pub type pic_ipi_send_t = ::core::option::Option<
    unsafe extern "C" fn(dev: device_t, isrc: *mut intr_irqsrc, cpus: cpuset_t, ipi: u_int),
>;
#[doc = " @brief A function implementing the PIC_IPI_SETUP() method"]
pub type pic_ipi_setup_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: device_t,
        ipi: u_int,
        isrcp: *mut *mut intr_irqsrc,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Default)]
pub struct witness {
    pub _address: u8,
}
pub type __uint128_t = u128;
#[repr(C)]
#[derive(Debug, Default)]
pub struct intr_event {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct aioliojob {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct cdev_priv {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct sysent {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct seltd {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct umtx_q {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct plimit {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct filedesc_to_leader {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct pwddesc {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct pstats {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct ktr_io_params {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct itimers {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct sysentvec {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct ktr_request {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct kerneldumpcomp {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct cdev_privdata {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct asid_set {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct g_consumer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct g_provider {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct msgbuf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct llentry {
    pub _address: u8,
}
unsafe extern "C" {
    #[link_name = "__bitcount16__extern"]
    pub fn __bitcount16(_x: __uint16_t) -> __uint16_t;
    #[link_name = "__bitcount32__extern"]
    pub fn __bitcount32(_x: __uint32_t) -> __uint32_t;
    #[link_name = "__bitcount64__extern"]
    pub fn __bitcount64(_x: __uint64_t) -> __uint64_t;
    #[link_name = "__major__extern"]
    pub fn __major(_d: dev_t) -> ::core::ffi::c_int;
    #[link_name = "__minor__extern"]
    pub fn __minor(_d: dev_t) -> ::core::ffi::c_int;
    #[link_name = "__makedev__extern"]
    pub fn __makedev(_Major: ::core::ffi::c_int, _Minor: ::core::ffi::c_int) -> dev_t;
    #[link_name = "bintime_addx__extern"]
    pub fn bintime_addx(_bt: *mut bintime, _x: u64);
    #[link_name = "bintime_add__extern"]
    pub fn bintime_add(_bt: *mut bintime, _bt2: *const bintime);
    #[link_name = "bintime_sub__extern"]
    pub fn bintime_sub(_bt: *mut bintime, _bt2: *const bintime);
    #[link_name = "bintime_mul__extern"]
    pub fn bintime_mul(_bt: *mut bintime, _x: u_int);
    #[link_name = "bintime_shift__extern"]
    pub fn bintime_shift(_bt: *mut bintime, _exp: ::core::ffi::c_int);
    #[link_name = "sbintime_getsec__extern"]
    pub fn sbintime_getsec(_sbt: sbintime_t) -> ::core::ffi::c_int;
    #[link_name = "bttosbt__extern"]
    pub fn bttosbt(_bt: bintime) -> sbintime_t;
    #[link_name = "sbttobt__extern"]
    pub fn sbttobt(_sbt: sbintime_t) -> bintime;
    #[link_name = "__stime64_scale32_ceil__extern"]
    pub fn __stime64_scale32_ceil(x: i64, factor: i32, divisor: i32) -> i64;
    #[link_name = "__stime64_scale32_floor__extern"]
    pub fn __stime64_scale32_floor(x: i64, factor: i32, divisor: i32) -> i64;
    #[link_name = "__utime64_scale32_ceil__extern"]
    pub fn __utime64_scale32_ceil(x: u64, factor: u32, divisor: u32) -> u64;
    #[link_name = "__utime64_scale32_floor__extern"]
    pub fn __utime64_scale32_floor(x: u64, factor: u32, divisor: u32) -> u64;
    #[link_name = "__stime64_scale64_ceil__extern"]
    pub fn __stime64_scale64_ceil(x: i64, factor: i64, divisor: i64) -> i64;
    #[link_name = "__stime64_scale64_floor__extern"]
    pub fn __stime64_scale64_floor(x: i64, factor: i64, divisor: i64) -> i64;
    #[link_name = "__utime64_scale64_ceil__extern"]
    pub fn __utime64_scale64_ceil(x: u64, factor: u64, divisor: u64) -> u64;
    #[link_name = "__utime64_scale64_floor__extern"]
    pub fn __utime64_scale64_floor(x: u64, factor: u64, divisor: u64) -> u64;
    #[link_name = "sbttons__extern"]
    pub fn sbttons(sbt: sbintime_t) -> i64;
    #[link_name = "nstosbt__extern"]
    pub fn nstosbt(ns: i64) -> sbintime_t;
    #[link_name = "sbttous__extern"]
    pub fn sbttous(sbt: sbintime_t) -> i64;
    #[link_name = "ustosbt__extern"]
    pub fn ustosbt(us: i64) -> sbintime_t;
    #[link_name = "sbttoms__extern"]
    pub fn sbttoms(sbt: sbintime_t) -> i64;
    #[link_name = "mstosbt__extern"]
    pub fn mstosbt(ms: i64) -> sbintime_t;
    #[link_name = "bintime2timespec__extern"]
    pub fn bintime2timespec(_bt: *const bintime, _ts: *mut timespec);
    #[link_name = "bintime2ns__extern"]
    pub fn bintime2ns(_bt: *const bintime) -> u64;
    #[link_name = "timespec2bintime__extern"]
    pub fn timespec2bintime(_ts: *const timespec, _bt: *mut bintime);
    #[link_name = "bintime2timeval__extern"]
    pub fn bintime2timeval(_bt: *const bintime, _tv: *mut timeval);
    #[link_name = "timeval2bintime__extern"]
    pub fn timeval2bintime(_tv: *const timeval, _bt: *mut bintime);
    #[link_name = "sbttots__extern"]
    pub fn sbttots(_sbt: sbintime_t) -> timespec;
    #[link_name = "tstosbt__extern"]
    pub fn tstosbt(_ts: timespec) -> sbintime_t;
    #[link_name = "sbttotv__extern"]
    pub fn sbttotv(_sbt: sbintime_t) -> timeval;
    #[link_name = "tvtosbt__extern"]
    pub fn tvtosbt(_tv: timeval) -> sbintime_t;
    pub fn inittodr(base: time_t);
    pub fn resettodr();
    pub static mut time_second: time_t;
    pub static mut time_uptime: time_t;
    pub static mut tc_tick_bt: bintime;
    pub static mut tc_tick_sbt: sbintime_t;
    pub static mut tick_seconds_max: time_t;
    pub static mut tick_bt: bintime;
    pub static mut tick_sbt: sbintime_t;
    pub static mut tc_precexp: ::core::ffi::c_int;
    pub static mut tc_timepercentage: ::core::ffi::c_int;
    pub static mut bt_timethreshold: bintime;
    pub static mut bt_tickthreshold: bintime;
    pub static mut sbt_timethreshold: sbintime_t;
    pub static mut sbt_tickthreshold: sbintime_t;
    pub static mut rtc_generation: ::core::ffi::c_int;
    pub fn binuptime(bt: *mut bintime);
    pub fn nanouptime(tsp: *mut timespec);
    pub fn microuptime(tvp: *mut timeval);
    #[link_name = "sbinuptime__extern"]
    pub fn sbinuptime() -> sbintime_t;
    pub fn bintime(bt: *mut bintime);
    pub fn nanotime(tsp: *mut timespec);
    pub fn microtime(tvp: *mut timeval);
    pub fn getbinuptime(bt: *mut bintime);
    pub fn getnanouptime(tsp: *mut timespec);
    pub fn getmicrouptime(tvp: *mut timeval);
    #[link_name = "getsbinuptime__extern"]
    pub fn getsbinuptime() -> sbintime_t;
    pub fn getbintime(bt: *mut bintime);
    pub fn getnanotime(tsp: *mut timespec);
    pub fn getmicrotime(tvp: *mut timeval);
    pub fn getboottime(boottime: *mut timeval);
    pub fn getboottimebin(boottimebin: *mut bintime);
    pub fn itimerdecr(itp: *mut itimerval, usec: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn itimerfix(tv: *mut timeval) -> ::core::ffi::c_int;
    pub fn eventratecheck(
        arg1: *mut timeval,
        arg2: *mut ::core::ffi::c_int,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn ratecheck(arg1: *mut timeval, arg2: *const timeval) -> ::core::ffi::c_int;
    pub fn timevaladd(t1: *mut timeval, t2: *const timeval);
    pub fn timevalsub(t1: *mut timeval, t2: *const timeval);
    pub fn tvtohz(tv: *mut timeval) -> ::core::ffi::c_int;
    pub fn htonl(arg1: __uint32_t) -> __uint32_t;
    pub fn htons(arg1: __uint16_t) -> __uint16_t;
    pub fn ntohl(arg1: __uint32_t) -> __uint32_t;
    pub fn ntohs(arg1: __uint16_t) -> __uint16_t;
    pub static mut panicstr: *const ::core::ffi::c_char;
    pub static mut poisoned_buf: *mut ::core::ffi::c_void;
    pub fn panic(arg1: *const ::core::ffi::c_char, ...) -> !;
    pub fn vpanic(arg1: *const ::core::ffi::c_char, arg2: __va_list) -> !;
    pub fn kobj_class_compile(cls: kobj_class_t);
    pub fn kobj_class_compile_static(cls: kobj_class_t, ops: kobj_ops_t);
    pub fn kobj_class_free(cls: kobj_class_t);
    pub fn kobj_create(
        cls: kobj_class_t,
        mtype: *mut malloc_type,
        mflags: ::core::ffi::c_int,
    ) -> kobj_t;
    pub fn kobj_init(obj: kobj_t, cls: kobj_class_t);
    pub fn kobj_init_static(obj: kobj_t, cls: kobj_class_t);
    pub fn kobj_delete(obj: kobj_t, mtype: *mut malloc_type);
    pub fn kobj_lookup_method(
        cls: kobj_class_t,
        cep: *mut *const kobj_method,
        desc: kobjop_desc_t,
    ) -> *const kobj_method;
    pub fn kobj_error_method() -> ::core::ffi::c_int;
    pub fn callout_init(arg1: *mut callout, arg2: ::core::ffi::c_int);
    pub fn _callout_init_lock(arg1: *mut callout, arg2: *mut lock_object, arg3: ::core::ffi::c_int);
    pub fn callout_reset_sbt_on(
        arg1: *mut callout,
        arg2: sbintime_t,
        arg3: sbintime_t,
        arg4: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg5: *mut ::core::ffi::c_void,
        arg6: ::core::ffi::c_int,
        arg7: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn callout_schedule(arg1: *mut callout, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn callout_schedule_on(
        arg1: *mut callout,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn _callout_stop_safe(arg1: *mut callout, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn callout_process(now: sbintime_t);
    pub fn callout_when(
        sbt: sbintime_t,
        precision: sbintime_t,
        flags: ::core::ffi::c_int,
        sbt_res: *mut sbintime_t,
        prec_res: *mut sbintime_t,
    );
    pub static mut lse_supported: bool;
    #[link_name = "atomic_add_8_llsc__extern"]
    pub fn atomic_add_8_llsc(p: *mut u8, val: u8);
    #[link_name = "atomic_add_8_lse__extern"]
    pub fn atomic_add_8_lse(p: *mut u8, val: u8);
    #[link_name = "atomic_add_8__extern"]
    pub fn atomic_add_8(p: *mut u8, val: u8);
    #[link_name = "atomic_add_16_llsc__extern"]
    pub fn atomic_add_16_llsc(p: *mut u16, val: u16);
    #[link_name = "atomic_add_16_lse__extern"]
    pub fn atomic_add_16_lse(p: *mut u16, val: u16);
    #[link_name = "atomic_add_16__extern"]
    pub fn atomic_add_16(p: *mut u16, val: u16);
    #[link_name = "atomic_add_32_llsc__extern"]
    pub fn atomic_add_32_llsc(p: *mut u32, val: u32);
    #[link_name = "atomic_add_32_lse__extern"]
    pub fn atomic_add_32_lse(p: *mut u32, val: u32);
    #[link_name = "atomic_add_32__extern"]
    pub fn atomic_add_32(p: *mut u32, val: u32);
    #[link_name = "atomic_add_64_llsc__extern"]
    pub fn atomic_add_64_llsc(p: *mut u64, val: u64);
    #[link_name = "atomic_add_64_lse__extern"]
    pub fn atomic_add_64_lse(p: *mut u64, val: u64);
    #[link_name = "atomic_add_64__extern"]
    pub fn atomic_add_64(p: *mut u64, val: u64);
    #[link_name = "atomic_add_acq_8_llsc__extern"]
    pub fn atomic_add_acq_8_llsc(p: *mut u8, val: u8);
    #[link_name = "atomic_add_acq_8_lse__extern"]
    pub fn atomic_add_acq_8_lse(p: *mut u8, val: u8);
    #[link_name = "atomic_add_acq_8__extern"]
    pub fn atomic_add_acq_8(p: *mut u8, val: u8);
    #[link_name = "atomic_add_acq_16_llsc__extern"]
    pub fn atomic_add_acq_16_llsc(p: *mut u16, val: u16);
    #[link_name = "atomic_add_acq_16_lse__extern"]
    pub fn atomic_add_acq_16_lse(p: *mut u16, val: u16);
    #[link_name = "atomic_add_acq_16__extern"]
    pub fn atomic_add_acq_16(p: *mut u16, val: u16);
    #[link_name = "atomic_add_acq_32_llsc__extern"]
    pub fn atomic_add_acq_32_llsc(p: *mut u32, val: u32);
    #[link_name = "atomic_add_acq_32_lse__extern"]
    pub fn atomic_add_acq_32_lse(p: *mut u32, val: u32);
    #[link_name = "atomic_add_acq_32__extern"]
    pub fn atomic_add_acq_32(p: *mut u32, val: u32);
    #[link_name = "atomic_add_acq_64_llsc__extern"]
    pub fn atomic_add_acq_64_llsc(p: *mut u64, val: u64);
    #[link_name = "atomic_add_acq_64_lse__extern"]
    pub fn atomic_add_acq_64_lse(p: *mut u64, val: u64);
    #[link_name = "atomic_add_acq_64__extern"]
    pub fn atomic_add_acq_64(p: *mut u64, val: u64);
    #[link_name = "atomic_add_rel_8_llsc__extern"]
    pub fn atomic_add_rel_8_llsc(p: *mut u8, val: u8);
    #[link_name = "atomic_add_rel_8_lse__extern"]
    pub fn atomic_add_rel_8_lse(p: *mut u8, val: u8);
    #[link_name = "atomic_add_rel_8__extern"]
    pub fn atomic_add_rel_8(p: *mut u8, val: u8);
    #[link_name = "atomic_add_rel_16_llsc__extern"]
    pub fn atomic_add_rel_16_llsc(p: *mut u16, val: u16);
    #[link_name = "atomic_add_rel_16_lse__extern"]
    pub fn atomic_add_rel_16_lse(p: *mut u16, val: u16);
    #[link_name = "atomic_add_rel_16__extern"]
    pub fn atomic_add_rel_16(p: *mut u16, val: u16);
    #[link_name = "atomic_add_rel_32_llsc__extern"]
    pub fn atomic_add_rel_32_llsc(p: *mut u32, val: u32);
    #[link_name = "atomic_add_rel_32_lse__extern"]
    pub fn atomic_add_rel_32_lse(p: *mut u32, val: u32);
    #[link_name = "atomic_add_rel_32__extern"]
    pub fn atomic_add_rel_32(p: *mut u32, val: u32);
    #[link_name = "atomic_add_rel_64_llsc__extern"]
    pub fn atomic_add_rel_64_llsc(p: *mut u64, val: u64);
    #[link_name = "atomic_add_rel_64_lse__extern"]
    pub fn atomic_add_rel_64_lse(p: *mut u64, val: u64);
    #[link_name = "atomic_add_rel_64__extern"]
    pub fn atomic_add_rel_64(p: *mut u64, val: u64);
    #[link_name = "atomic_clear_8_llsc__extern"]
    pub fn atomic_clear_8_llsc(p: *mut u8, val: u8);
    #[link_name = "atomic_clear_8_lse__extern"]
    pub fn atomic_clear_8_lse(p: *mut u8, val: u8);
    #[link_name = "atomic_clear_8__extern"]
    pub fn atomic_clear_8(p: *mut u8, val: u8);
    #[link_name = "atomic_clear_16_llsc__extern"]
    pub fn atomic_clear_16_llsc(p: *mut u16, val: u16);
    #[link_name = "atomic_clear_16_lse__extern"]
    pub fn atomic_clear_16_lse(p: *mut u16, val: u16);
    #[link_name = "atomic_clear_16__extern"]
    pub fn atomic_clear_16(p: *mut u16, val: u16);
    #[link_name = "atomic_clear_32_llsc__extern"]
    pub fn atomic_clear_32_llsc(p: *mut u32, val: u32);
    #[link_name = "atomic_clear_32_lse__extern"]
    pub fn atomic_clear_32_lse(p: *mut u32, val: u32);
    #[link_name = "atomic_clear_32__extern"]
    pub fn atomic_clear_32(p: *mut u32, val: u32);
    #[link_name = "atomic_clear_64_llsc__extern"]
    pub fn atomic_clear_64_llsc(p: *mut u64, val: u64);
    #[link_name = "atomic_clear_64_lse__extern"]
    pub fn atomic_clear_64_lse(p: *mut u64, val: u64);
    #[link_name = "atomic_clear_64__extern"]
    pub fn atomic_clear_64(p: *mut u64, val: u64);
    #[link_name = "atomic_clear_acq_8_llsc__extern"]
    pub fn atomic_clear_acq_8_llsc(p: *mut u8, val: u8);
    #[link_name = "atomic_clear_acq_8_lse__extern"]
    pub fn atomic_clear_acq_8_lse(p: *mut u8, val: u8);
    #[link_name = "atomic_clear_acq_8__extern"]
    pub fn atomic_clear_acq_8(p: *mut u8, val: u8);
    #[link_name = "atomic_clear_acq_16_llsc__extern"]
    pub fn atomic_clear_acq_16_llsc(p: *mut u16, val: u16);
    #[link_name = "atomic_clear_acq_16_lse__extern"]
    pub fn atomic_clear_acq_16_lse(p: *mut u16, val: u16);
    #[link_name = "atomic_clear_acq_16__extern"]
    pub fn atomic_clear_acq_16(p: *mut u16, val: u16);
    #[link_name = "atomic_clear_acq_32_llsc__extern"]
    pub fn atomic_clear_acq_32_llsc(p: *mut u32, val: u32);
    #[link_name = "atomic_clear_acq_32_lse__extern"]
    pub fn atomic_clear_acq_32_lse(p: *mut u32, val: u32);
    #[link_name = "atomic_clear_acq_32__extern"]
    pub fn atomic_clear_acq_32(p: *mut u32, val: u32);
    #[link_name = "atomic_clear_acq_64_llsc__extern"]
    pub fn atomic_clear_acq_64_llsc(p: *mut u64, val: u64);
    #[link_name = "atomic_clear_acq_64_lse__extern"]
    pub fn atomic_clear_acq_64_lse(p: *mut u64, val: u64);
    #[link_name = "atomic_clear_acq_64__extern"]
    pub fn atomic_clear_acq_64(p: *mut u64, val: u64);
    #[link_name = "atomic_clear_rel_8_llsc__extern"]
    pub fn atomic_clear_rel_8_llsc(p: *mut u8, val: u8);
    #[link_name = "atomic_clear_rel_8_lse__extern"]
    pub fn atomic_clear_rel_8_lse(p: *mut u8, val: u8);
    #[link_name = "atomic_clear_rel_8__extern"]
    pub fn atomic_clear_rel_8(p: *mut u8, val: u8);
    #[link_name = "atomic_clear_rel_16_llsc__extern"]
    pub fn atomic_clear_rel_16_llsc(p: *mut u16, val: u16);
    #[link_name = "atomic_clear_rel_16_lse__extern"]
    pub fn atomic_clear_rel_16_lse(p: *mut u16, val: u16);
    #[link_name = "atomic_clear_rel_16__extern"]
    pub fn atomic_clear_rel_16(p: *mut u16, val: u16);
    #[link_name = "atomic_clear_rel_32_llsc__extern"]
    pub fn atomic_clear_rel_32_llsc(p: *mut u32, val: u32);
    #[link_name = "atomic_clear_rel_32_lse__extern"]
    pub fn atomic_clear_rel_32_lse(p: *mut u32, val: u32);
    #[link_name = "atomic_clear_rel_32__extern"]
    pub fn atomic_clear_rel_32(p: *mut u32, val: u32);
    #[link_name = "atomic_clear_rel_64_llsc__extern"]
    pub fn atomic_clear_rel_64_llsc(p: *mut u64, val: u64);
    #[link_name = "atomic_clear_rel_64_lse__extern"]
    pub fn atomic_clear_rel_64_lse(p: *mut u64, val: u64);
    #[link_name = "atomic_clear_rel_64__extern"]
    pub fn atomic_clear_rel_64(p: *mut u64, val: u64);
    #[link_name = "atomic_set_8_llsc__extern"]
    pub fn atomic_set_8_llsc(p: *mut u8, val: u8);
    #[link_name = "atomic_set_8_lse__extern"]
    pub fn atomic_set_8_lse(p: *mut u8, val: u8);
    #[link_name = "atomic_set_8__extern"]
    pub fn atomic_set_8(p: *mut u8, val: u8);
    #[link_name = "atomic_set_16_llsc__extern"]
    pub fn atomic_set_16_llsc(p: *mut u16, val: u16);
    #[link_name = "atomic_set_16_lse__extern"]
    pub fn atomic_set_16_lse(p: *mut u16, val: u16);
    #[link_name = "atomic_set_16__extern"]
    pub fn atomic_set_16(p: *mut u16, val: u16);
    #[link_name = "atomic_set_32_llsc__extern"]
    pub fn atomic_set_32_llsc(p: *mut u32, val: u32);
    #[link_name = "atomic_set_32_lse__extern"]
    pub fn atomic_set_32_lse(p: *mut u32, val: u32);
    #[link_name = "atomic_set_32__extern"]
    pub fn atomic_set_32(p: *mut u32, val: u32);
    #[link_name = "atomic_set_64_llsc__extern"]
    pub fn atomic_set_64_llsc(p: *mut u64, val: u64);
    #[link_name = "atomic_set_64_lse__extern"]
    pub fn atomic_set_64_lse(p: *mut u64, val: u64);
    #[link_name = "atomic_set_64__extern"]
    pub fn atomic_set_64(p: *mut u64, val: u64);
    #[link_name = "atomic_set_acq_8_llsc__extern"]
    pub fn atomic_set_acq_8_llsc(p: *mut u8, val: u8);
    #[link_name = "atomic_set_acq_8_lse__extern"]
    pub fn atomic_set_acq_8_lse(p: *mut u8, val: u8);
    #[link_name = "atomic_set_acq_8__extern"]
    pub fn atomic_set_acq_8(p: *mut u8, val: u8);
    #[link_name = "atomic_set_acq_16_llsc__extern"]
    pub fn atomic_set_acq_16_llsc(p: *mut u16, val: u16);
    #[link_name = "atomic_set_acq_16_lse__extern"]
    pub fn atomic_set_acq_16_lse(p: *mut u16, val: u16);
    #[link_name = "atomic_set_acq_16__extern"]
    pub fn atomic_set_acq_16(p: *mut u16, val: u16);
    #[link_name = "atomic_set_acq_32_llsc__extern"]
    pub fn atomic_set_acq_32_llsc(p: *mut u32, val: u32);
    #[link_name = "atomic_set_acq_32_lse__extern"]
    pub fn atomic_set_acq_32_lse(p: *mut u32, val: u32);
    #[link_name = "atomic_set_acq_32__extern"]
    pub fn atomic_set_acq_32(p: *mut u32, val: u32);
    #[link_name = "atomic_set_acq_64_llsc__extern"]
    pub fn atomic_set_acq_64_llsc(p: *mut u64, val: u64);
    #[link_name = "atomic_set_acq_64_lse__extern"]
    pub fn atomic_set_acq_64_lse(p: *mut u64, val: u64);
    #[link_name = "atomic_set_acq_64__extern"]
    pub fn atomic_set_acq_64(p: *mut u64, val: u64);
    #[link_name = "atomic_set_rel_8_llsc__extern"]
    pub fn atomic_set_rel_8_llsc(p: *mut u8, val: u8);
    #[link_name = "atomic_set_rel_8_lse__extern"]
    pub fn atomic_set_rel_8_lse(p: *mut u8, val: u8);
    #[link_name = "atomic_set_rel_8__extern"]
    pub fn atomic_set_rel_8(p: *mut u8, val: u8);
    #[link_name = "atomic_set_rel_16_llsc__extern"]
    pub fn atomic_set_rel_16_llsc(p: *mut u16, val: u16);
    #[link_name = "atomic_set_rel_16_lse__extern"]
    pub fn atomic_set_rel_16_lse(p: *mut u16, val: u16);
    #[link_name = "atomic_set_rel_16__extern"]
    pub fn atomic_set_rel_16(p: *mut u16, val: u16);
    #[link_name = "atomic_set_rel_32_llsc__extern"]
    pub fn atomic_set_rel_32_llsc(p: *mut u32, val: u32);
    #[link_name = "atomic_set_rel_32_lse__extern"]
    pub fn atomic_set_rel_32_lse(p: *mut u32, val: u32);
    #[link_name = "atomic_set_rel_32__extern"]
    pub fn atomic_set_rel_32(p: *mut u32, val: u32);
    #[link_name = "atomic_set_rel_64_llsc__extern"]
    pub fn atomic_set_rel_64_llsc(p: *mut u64, val: u64);
    #[link_name = "atomic_set_rel_64_lse__extern"]
    pub fn atomic_set_rel_64_lse(p: *mut u64, val: u64);
    #[link_name = "atomic_set_rel_64__extern"]
    pub fn atomic_set_rel_64(p: *mut u64, val: u64);
    #[link_name = "atomic_subtract_8_llsc__extern"]
    pub fn atomic_subtract_8_llsc(p: *mut u8, val: u8);
    #[link_name = "atomic_subtract_8_lse__extern"]
    pub fn atomic_subtract_8_lse(p: *mut u8, val: u8);
    #[link_name = "atomic_subtract_8__extern"]
    pub fn atomic_subtract_8(p: *mut u8, val: u8);
    #[link_name = "atomic_subtract_16_llsc__extern"]
    pub fn atomic_subtract_16_llsc(p: *mut u16, val: u16);
    #[link_name = "atomic_subtract_16_lse__extern"]
    pub fn atomic_subtract_16_lse(p: *mut u16, val: u16);
    #[link_name = "atomic_subtract_16__extern"]
    pub fn atomic_subtract_16(p: *mut u16, val: u16);
    #[link_name = "atomic_subtract_32_llsc__extern"]
    pub fn atomic_subtract_32_llsc(p: *mut u32, val: u32);
    #[link_name = "atomic_subtract_32_lse__extern"]
    pub fn atomic_subtract_32_lse(p: *mut u32, val: u32);
    #[link_name = "atomic_subtract_32__extern"]
    pub fn atomic_subtract_32(p: *mut u32, val: u32);
    #[link_name = "atomic_subtract_64_llsc__extern"]
    pub fn atomic_subtract_64_llsc(p: *mut u64, val: u64);
    #[link_name = "atomic_subtract_64_lse__extern"]
    pub fn atomic_subtract_64_lse(p: *mut u64, val: u64);
    #[link_name = "atomic_subtract_64__extern"]
    pub fn atomic_subtract_64(p: *mut u64, val: u64);
    #[link_name = "atomic_subtract_acq_8_llsc__extern"]
    pub fn atomic_subtract_acq_8_llsc(p: *mut u8, val: u8);
    #[link_name = "atomic_subtract_acq_8_lse__extern"]
    pub fn atomic_subtract_acq_8_lse(p: *mut u8, val: u8);
    #[link_name = "atomic_subtract_acq_8__extern"]
    pub fn atomic_subtract_acq_8(p: *mut u8, val: u8);
    #[link_name = "atomic_subtract_acq_16_llsc__extern"]
    pub fn atomic_subtract_acq_16_llsc(p: *mut u16, val: u16);
    #[link_name = "atomic_subtract_acq_16_lse__extern"]
    pub fn atomic_subtract_acq_16_lse(p: *mut u16, val: u16);
    #[link_name = "atomic_subtract_acq_16__extern"]
    pub fn atomic_subtract_acq_16(p: *mut u16, val: u16);
    #[link_name = "atomic_subtract_acq_32_llsc__extern"]
    pub fn atomic_subtract_acq_32_llsc(p: *mut u32, val: u32);
    #[link_name = "atomic_subtract_acq_32_lse__extern"]
    pub fn atomic_subtract_acq_32_lse(p: *mut u32, val: u32);
    #[link_name = "atomic_subtract_acq_32__extern"]
    pub fn atomic_subtract_acq_32(p: *mut u32, val: u32);
    #[link_name = "atomic_subtract_acq_64_llsc__extern"]
    pub fn atomic_subtract_acq_64_llsc(p: *mut u64, val: u64);
    #[link_name = "atomic_subtract_acq_64_lse__extern"]
    pub fn atomic_subtract_acq_64_lse(p: *mut u64, val: u64);
    #[link_name = "atomic_subtract_acq_64__extern"]
    pub fn atomic_subtract_acq_64(p: *mut u64, val: u64);
    #[link_name = "atomic_subtract_rel_8_llsc__extern"]
    pub fn atomic_subtract_rel_8_llsc(p: *mut u8, val: u8);
    #[link_name = "atomic_subtract_rel_8_lse__extern"]
    pub fn atomic_subtract_rel_8_lse(p: *mut u8, val: u8);
    #[link_name = "atomic_subtract_rel_8__extern"]
    pub fn atomic_subtract_rel_8(p: *mut u8, val: u8);
    #[link_name = "atomic_subtract_rel_16_llsc__extern"]
    pub fn atomic_subtract_rel_16_llsc(p: *mut u16, val: u16);
    #[link_name = "atomic_subtract_rel_16_lse__extern"]
    pub fn atomic_subtract_rel_16_lse(p: *mut u16, val: u16);
    #[link_name = "atomic_subtract_rel_16__extern"]
    pub fn atomic_subtract_rel_16(p: *mut u16, val: u16);
    #[link_name = "atomic_subtract_rel_32_llsc__extern"]
    pub fn atomic_subtract_rel_32_llsc(p: *mut u32, val: u32);
    #[link_name = "atomic_subtract_rel_32_lse__extern"]
    pub fn atomic_subtract_rel_32_lse(p: *mut u32, val: u32);
    #[link_name = "atomic_subtract_rel_32__extern"]
    pub fn atomic_subtract_rel_32(p: *mut u32, val: u32);
    #[link_name = "atomic_subtract_rel_64_llsc__extern"]
    pub fn atomic_subtract_rel_64_llsc(p: *mut u64, val: u64);
    #[link_name = "atomic_subtract_rel_64_lse__extern"]
    pub fn atomic_subtract_rel_64_lse(p: *mut u64, val: u64);
    #[link_name = "atomic_subtract_rel_64__extern"]
    pub fn atomic_subtract_rel_64(p: *mut u64, val: u64);
    #[link_name = "atomic_cmpset_8_llsc__extern"]
    pub fn atomic_cmpset_8_llsc(p: *mut u8, cmpval: u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_8_lse__extern"]
    pub fn atomic_cmpset_8_lse(p: *mut u8, cmpval: u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_8__extern"]
    pub fn atomic_cmpset_8(p: *mut u8, cmpval: u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_8_llsc__extern"]
    pub fn atomic_fcmpset_8_llsc(p: *mut u8, cmpval: *mut u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_8_lse__extern"]
    pub fn atomic_fcmpset_8_lse(p: *mut u8, cmpval: *mut u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_8__extern"]
    pub fn atomic_fcmpset_8(p: *mut u8, cmpval: *mut u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_16_llsc__extern"]
    pub fn atomic_cmpset_16_llsc(p: *mut u16, cmpval: u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_16_lse__extern"]
    pub fn atomic_cmpset_16_lse(p: *mut u16, cmpval: u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_16__extern"]
    pub fn atomic_cmpset_16(p: *mut u16, cmpval: u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_16_llsc__extern"]
    pub fn atomic_fcmpset_16_llsc(p: *mut u16, cmpval: *mut u16, newval: u16)
    -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_16_lse__extern"]
    pub fn atomic_fcmpset_16_lse(p: *mut u16, cmpval: *mut u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_16__extern"]
    pub fn atomic_fcmpset_16(p: *mut u16, cmpval: *mut u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_32_llsc__extern"]
    pub fn atomic_cmpset_32_llsc(p: *mut u32, cmpval: u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_32_lse__extern"]
    pub fn atomic_cmpset_32_lse(p: *mut u32, cmpval: u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_32__extern"]
    pub fn atomic_cmpset_32(p: *mut u32, cmpval: u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_32_llsc__extern"]
    pub fn atomic_fcmpset_32_llsc(p: *mut u32, cmpval: *mut u32, newval: u32)
    -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_32_lse__extern"]
    pub fn atomic_fcmpset_32_lse(p: *mut u32, cmpval: *mut u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_32__extern"]
    pub fn atomic_fcmpset_32(p: *mut u32, cmpval: *mut u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_64_llsc__extern"]
    pub fn atomic_cmpset_64_llsc(p: *mut u64, cmpval: u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_64_lse__extern"]
    pub fn atomic_cmpset_64_lse(p: *mut u64, cmpval: u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_64__extern"]
    pub fn atomic_cmpset_64(p: *mut u64, cmpval: u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_64_llsc__extern"]
    pub fn atomic_fcmpset_64_llsc(p: *mut u64, cmpval: *mut u64, newval: u64)
    -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_64_lse__extern"]
    pub fn atomic_fcmpset_64_lse(p: *mut u64, cmpval: *mut u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_64__extern"]
    pub fn atomic_fcmpset_64(p: *mut u64, cmpval: *mut u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_acq_8_llsc__extern"]
    pub fn atomic_cmpset_acq_8_llsc(p: *mut u8, cmpval: u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_acq_8_lse__extern"]
    pub fn atomic_cmpset_acq_8_lse(p: *mut u8, cmpval: u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_acq_8__extern"]
    pub fn atomic_cmpset_acq_8(p: *mut u8, cmpval: u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_acq_8_llsc__extern"]
    pub fn atomic_fcmpset_acq_8_llsc(p: *mut u8, cmpval: *mut u8, newval: u8)
    -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_acq_8_lse__extern"]
    pub fn atomic_fcmpset_acq_8_lse(p: *mut u8, cmpval: *mut u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_acq_8__extern"]
    pub fn atomic_fcmpset_acq_8(p: *mut u8, cmpval: *mut u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_acq_16_llsc__extern"]
    pub fn atomic_cmpset_acq_16_llsc(p: *mut u16, cmpval: u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_acq_16_lse__extern"]
    pub fn atomic_cmpset_acq_16_lse(p: *mut u16, cmpval: u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_acq_16__extern"]
    pub fn atomic_cmpset_acq_16(p: *mut u16, cmpval: u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_acq_16_llsc__extern"]
    pub fn atomic_fcmpset_acq_16_llsc(
        p: *mut u16,
        cmpval: *mut u16,
        newval: u16,
    ) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_acq_16_lse__extern"]
    pub fn atomic_fcmpset_acq_16_lse(
        p: *mut u16,
        cmpval: *mut u16,
        newval: u16,
    ) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_acq_16__extern"]
    pub fn atomic_fcmpset_acq_16(p: *mut u16, cmpval: *mut u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_acq_32_llsc__extern"]
    pub fn atomic_cmpset_acq_32_llsc(p: *mut u32, cmpval: u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_acq_32_lse__extern"]
    pub fn atomic_cmpset_acq_32_lse(p: *mut u32, cmpval: u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_acq_32__extern"]
    pub fn atomic_cmpset_acq_32(p: *mut u32, cmpval: u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_acq_32_llsc__extern"]
    pub fn atomic_fcmpset_acq_32_llsc(
        p: *mut u32,
        cmpval: *mut u32,
        newval: u32,
    ) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_acq_32_lse__extern"]
    pub fn atomic_fcmpset_acq_32_lse(
        p: *mut u32,
        cmpval: *mut u32,
        newval: u32,
    ) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_acq_32__extern"]
    pub fn atomic_fcmpset_acq_32(p: *mut u32, cmpval: *mut u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_acq_64_llsc__extern"]
    pub fn atomic_cmpset_acq_64_llsc(p: *mut u64, cmpval: u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_acq_64_lse__extern"]
    pub fn atomic_cmpset_acq_64_lse(p: *mut u64, cmpval: u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_acq_64__extern"]
    pub fn atomic_cmpset_acq_64(p: *mut u64, cmpval: u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_acq_64_llsc__extern"]
    pub fn atomic_fcmpset_acq_64_llsc(
        p: *mut u64,
        cmpval: *mut u64,
        newval: u64,
    ) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_acq_64_lse__extern"]
    pub fn atomic_fcmpset_acq_64_lse(
        p: *mut u64,
        cmpval: *mut u64,
        newval: u64,
    ) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_acq_64__extern"]
    pub fn atomic_fcmpset_acq_64(p: *mut u64, cmpval: *mut u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_rel_8_llsc__extern"]
    pub fn atomic_cmpset_rel_8_llsc(p: *mut u8, cmpval: u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_rel_8_lse__extern"]
    pub fn atomic_cmpset_rel_8_lse(p: *mut u8, cmpval: u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_rel_8__extern"]
    pub fn atomic_cmpset_rel_8(p: *mut u8, cmpval: u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_rel_8_llsc__extern"]
    pub fn atomic_fcmpset_rel_8_llsc(p: *mut u8, cmpval: *mut u8, newval: u8)
    -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_rel_8_lse__extern"]
    pub fn atomic_fcmpset_rel_8_lse(p: *mut u8, cmpval: *mut u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_rel_8__extern"]
    pub fn atomic_fcmpset_rel_8(p: *mut u8, cmpval: *mut u8, newval: u8) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_rel_16_llsc__extern"]
    pub fn atomic_cmpset_rel_16_llsc(p: *mut u16, cmpval: u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_rel_16_lse__extern"]
    pub fn atomic_cmpset_rel_16_lse(p: *mut u16, cmpval: u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_rel_16__extern"]
    pub fn atomic_cmpset_rel_16(p: *mut u16, cmpval: u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_rel_16_llsc__extern"]
    pub fn atomic_fcmpset_rel_16_llsc(
        p: *mut u16,
        cmpval: *mut u16,
        newval: u16,
    ) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_rel_16_lse__extern"]
    pub fn atomic_fcmpset_rel_16_lse(
        p: *mut u16,
        cmpval: *mut u16,
        newval: u16,
    ) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_rel_16__extern"]
    pub fn atomic_fcmpset_rel_16(p: *mut u16, cmpval: *mut u16, newval: u16) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_rel_32_llsc__extern"]
    pub fn atomic_cmpset_rel_32_llsc(p: *mut u32, cmpval: u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_rel_32_lse__extern"]
    pub fn atomic_cmpset_rel_32_lse(p: *mut u32, cmpval: u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_rel_32__extern"]
    pub fn atomic_cmpset_rel_32(p: *mut u32, cmpval: u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_rel_32_llsc__extern"]
    pub fn atomic_fcmpset_rel_32_llsc(
        p: *mut u32,
        cmpval: *mut u32,
        newval: u32,
    ) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_rel_32_lse__extern"]
    pub fn atomic_fcmpset_rel_32_lse(
        p: *mut u32,
        cmpval: *mut u32,
        newval: u32,
    ) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_rel_32__extern"]
    pub fn atomic_fcmpset_rel_32(p: *mut u32, cmpval: *mut u32, newval: u32) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_rel_64_llsc__extern"]
    pub fn atomic_cmpset_rel_64_llsc(p: *mut u64, cmpval: u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_rel_64_lse__extern"]
    pub fn atomic_cmpset_rel_64_lse(p: *mut u64, cmpval: u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_cmpset_rel_64__extern"]
    pub fn atomic_cmpset_rel_64(p: *mut u64, cmpval: u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_rel_64_llsc__extern"]
    pub fn atomic_fcmpset_rel_64_llsc(
        p: *mut u64,
        cmpval: *mut u64,
        newval: u64,
    ) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_rel_64_lse__extern"]
    pub fn atomic_fcmpset_rel_64_lse(
        p: *mut u64,
        cmpval: *mut u64,
        newval: u64,
    ) -> ::core::ffi::c_int;
    #[link_name = "atomic_fcmpset_rel_64__extern"]
    pub fn atomic_fcmpset_rel_64(p: *mut u64, cmpval: *mut u64, newval: u64) -> ::core::ffi::c_int;
    #[link_name = "atomic_fetchadd_32_llsc__extern"]
    pub fn atomic_fetchadd_32_llsc(p: *mut u32, val: u32) -> u32;
    #[link_name = "atomic_fetchadd_32_lse__extern"]
    pub fn atomic_fetchadd_32_lse(p: *mut u32, val: u32) -> u32;
    #[link_name = "atomic_fetchadd_32__extern"]
    pub fn atomic_fetchadd_32(p: *mut u32, val: u32) -> u32;
    #[link_name = "atomic_fetchadd_64_llsc__extern"]
    pub fn atomic_fetchadd_64_llsc(p: *mut u64, val: u64) -> u64;
    #[link_name = "atomic_fetchadd_64_lse__extern"]
    pub fn atomic_fetchadd_64_lse(p: *mut u64, val: u64) -> u64;
    #[link_name = "atomic_fetchadd_64__extern"]
    pub fn atomic_fetchadd_64(p: *mut u64, val: u64) -> u64;
    #[link_name = "atomic_swap_32_llsc__extern"]
    pub fn atomic_swap_32_llsc(p: *mut u32, val: u32) -> u32;
    #[link_name = "atomic_swap_32_lse__extern"]
    pub fn atomic_swap_32_lse(p: *mut u32, val: u32) -> u32;
    #[link_name = "atomic_swap_32__extern"]
    pub fn atomic_swap_32(p: *mut u32, val: u32) -> u32;
    #[link_name = "atomic_readandclear_32_llsc__extern"]
    pub fn atomic_readandclear_32_llsc(p: *mut u32) -> u32;
    #[link_name = "atomic_readandclear_32_lse__extern"]
    pub fn atomic_readandclear_32_lse(p: *mut u32) -> u32;
    #[link_name = "atomic_readandclear_32__extern"]
    pub fn atomic_readandclear_32(p: *mut u32) -> u32;
    #[link_name = "atomic_swap_64_llsc__extern"]
    pub fn atomic_swap_64_llsc(p: *mut u64, val: u64) -> u64;
    #[link_name = "atomic_swap_64_lse__extern"]
    pub fn atomic_swap_64_lse(p: *mut u64, val: u64) -> u64;
    #[link_name = "atomic_swap_64__extern"]
    pub fn atomic_swap_64(p: *mut u64, val: u64) -> u64;
    #[link_name = "atomic_readandclear_64_llsc__extern"]
    pub fn atomic_readandclear_64_llsc(p: *mut u64) -> u64;
    #[link_name = "atomic_readandclear_64_lse__extern"]
    pub fn atomic_readandclear_64_lse(p: *mut u64) -> u64;
    #[link_name = "atomic_readandclear_64__extern"]
    pub fn atomic_readandclear_64(p: *mut u64) -> u64;
    #[link_name = "atomic_testandclear_32_llsc__extern"]
    pub fn atomic_testandclear_32_llsc(p: *mut u32, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandclear_32_lse__extern"]
    pub fn atomic_testandclear_32_lse(p: *mut u32, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandclear_32__extern"]
    pub fn atomic_testandclear_32(p: *mut u32, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandclear_acq_32_llsc__extern"]
    pub fn atomic_testandclear_acq_32_llsc(p: *mut u32, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandclear_acq_32_lse__extern"]
    pub fn atomic_testandclear_acq_32_lse(p: *mut u32, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandclear_acq_32__extern"]
    pub fn atomic_testandclear_acq_32(p: *mut u32, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandclear_64_llsc__extern"]
    pub fn atomic_testandclear_64_llsc(p: *mut u64, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandclear_64_lse__extern"]
    pub fn atomic_testandclear_64_lse(p: *mut u64, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandclear_64__extern"]
    pub fn atomic_testandclear_64(p: *mut u64, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandclear_acq_64_llsc__extern"]
    pub fn atomic_testandclear_acq_64_llsc(p: *mut u64, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandclear_acq_64_lse__extern"]
    pub fn atomic_testandclear_acq_64_lse(p: *mut u64, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandclear_acq_64__extern"]
    pub fn atomic_testandclear_acq_64(p: *mut u64, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandset_32_llsc__extern"]
    pub fn atomic_testandset_32_llsc(p: *mut u32, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandset_32_lse__extern"]
    pub fn atomic_testandset_32_lse(p: *mut u32, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandset_32__extern"]
    pub fn atomic_testandset_32(p: *mut u32, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandset_acq_32_llsc__extern"]
    pub fn atomic_testandset_acq_32_llsc(p: *mut u32, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandset_acq_32_lse__extern"]
    pub fn atomic_testandset_acq_32_lse(p: *mut u32, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandset_acq_32__extern"]
    pub fn atomic_testandset_acq_32(p: *mut u32, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandset_64_llsc__extern"]
    pub fn atomic_testandset_64_llsc(p: *mut u64, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandset_64_lse__extern"]
    pub fn atomic_testandset_64_lse(p: *mut u64, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandset_64__extern"]
    pub fn atomic_testandset_64(p: *mut u64, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandset_acq_64_llsc__extern"]
    pub fn atomic_testandset_acq_64_llsc(p: *mut u64, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandset_acq_64_lse__extern"]
    pub fn atomic_testandset_acq_64_lse(p: *mut u64, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_testandset_acq_64__extern"]
    pub fn atomic_testandset_acq_64(p: *mut u64, val: u_int) -> ::core::ffi::c_int;
    #[link_name = "atomic_load_acq_8__extern"]
    pub fn atomic_load_acq_8(p: *const u8) -> u8;
    #[link_name = "atomic_load_acq_16__extern"]
    pub fn atomic_load_acq_16(p: *const u16) -> u16;
    #[link_name = "atomic_load_acq_32__extern"]
    pub fn atomic_load_acq_32(p: *const u32) -> u32;
    #[link_name = "atomic_load_acq_64__extern"]
    pub fn atomic_load_acq_64(p: *const u64) -> u64;
    #[link_name = "atomic_store_rel_8__extern"]
    pub fn atomic_store_rel_8(p: *mut u8, val: u8);
    #[link_name = "atomic_store_rel_16__extern"]
    pub fn atomic_store_rel_16(p: *mut u16, val: u16);
    #[link_name = "atomic_store_rel_32__extern"]
    pub fn atomic_store_rel_32(p: *mut u32, val: u32);
    #[link_name = "atomic_store_rel_64__extern"]
    pub fn atomic_store_rel_64(p: *mut u64, val: u64);
    #[link_name = "atomic_thread_fence_acq__extern"]
    pub fn atomic_thread_fence_acq();
    #[link_name = "atomic_thread_fence_rel__extern"]
    pub fn atomic_thread_fence_rel();
    #[link_name = "atomic_thread_fence_acq_rel__extern"]
    pub fn atomic_thread_fence_acq_rel();
    #[link_name = "atomic_thread_fence_seq_cst__extern"]
    pub fn atomic_thread_fence_seq_cst();
    #[link_name = "breakpoint__extern"]
    pub fn breakpoint();
    #[link_name = "dbg_disable__extern"]
    pub fn dbg_disable() -> register_t;
    #[link_name = "dbg_enable__extern"]
    pub fn dbg_enable();
    #[link_name = "intr_disable__extern"]
    pub fn intr_disable() -> register_t;
    #[link_name = "intr_restore__extern"]
    pub fn intr_restore(s: register_t);
    #[link_name = "intr_enable__extern"]
    pub fn intr_enable();
    #[link_name = "serror_enable__extern"]
    pub fn serror_enable();
    #[link_name = "serror_disable__extern"]
    pub fn serror_disable();
    #[link_name = "get_midr__extern"]
    pub fn get_midr() -> register_t;
    #[link_name = "get_mpidr__extern"]
    pub fn get_mpidr() -> register_t;
    #[link_name = "clrex__extern"]
    pub fn clrex();
    #[link_name = "set_ttbr0__extern"]
    pub fn set_ttbr0(ttbr0: u64);
    #[link_name = "invalidate_icache__extern"]
    pub fn invalidate_icache();
    #[link_name = "invalidate_local_icache__extern"]
    pub fn invalidate_local_icache();
    #[link_name = "wfet__extern"]
    pub fn wfet(val: u64);
    #[link_name = "wfit__extern"]
    pub fn wfit(val: u64);
    pub static mut icache_aliasing: bool_;
    pub static mut icache_vmid: bool_;
    pub static mut dcache_line_size: i64;
    pub static mut icache_line_size: i64;
    pub static mut idcache_line_size: i64;
    pub static mut dczva_line_size: i64;
    pub static mut arm64_icache_sync_range: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: vm_size_t),
    >;
    pub fn arm64_nullop();
    pub fn arm64_tlb_flushID();
    pub fn arm64_dic_idc_icache_sync_range(arg1: *mut ::core::ffi::c_void, arg2: vm_size_t);
    pub fn arm64_idc_aliasing_icache_sync_range(arg1: *mut ::core::ffi::c_void, arg2: vm_size_t);
    pub fn arm64_aliasing_icache_sync_range(arg1: *mut ::core::ffi::c_void, arg2: vm_size_t);
    pub fn arm64_icache_sync_range_checked(
        arg1: *mut ::core::ffi::c_void,
        arg2: vm_size_t,
    ) -> ::core::ffi::c_int;
    pub fn arm64_dcache_wbinv_range(arg1: *mut ::core::ffi::c_void, arg2: vm_size_t);
    pub fn arm64_dcache_inv_range(arg1: *mut ::core::ffi::c_void, arg2: vm_size_t);
    pub fn arm64_dcache_wb_range(arg1: *mut ::core::ffi::c_void, arg2: vm_size_t);
    pub fn arm64_get_writable_addr(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut *mut ::core::ffi::c_void,
    ) -> bool_;
    pub static mut cold: ::core::ffi::c_int;
    pub static mut suspend_blocked: ::core::ffi::c_int;
    pub static mut rebooting: ::core::ffi::c_int;
    pub static version: [::core::ffi::c_char; 0usize];
    pub static compiler_version: [::core::ffi::c_char; 0usize];
    pub static copyright: [::core::ffi::c_char; 0usize];
    pub static mut kstack_pages: ::core::ffi::c_int;
    pub static mut pagesizes: [u_long; 0usize];
    pub static mut physmem: ::core::ffi::c_long;
    pub static mut realmem: ::core::ffi::c_long;
    pub static mut rootdevnames: [*mut ::core::ffi::c_char; 2usize];
    pub static mut boothowto: ::core::ffi::c_int;
    pub static mut bootverbose: ::core::ffi::c_int;
    pub static mut maxusers: ::core::ffi::c_int;
    pub static mut ngroups_max: ::core::ffi::c_int;
    pub static mut vm_guest: ::core::ffi::c_int;
    pub static mut maxphys: u_long;
    pub static mut averunnable: loadavg;
    pub fn read_cpu_time(cp_time: *mut ::core::ffi::c_long);
    pub fn signal(arg1: ::core::ffi::c_int, arg2: __sighandler_t) -> __sighandler_t;
    pub fn convert_sigevent32(sig32: *mut sigevent32, sig: *mut sigevent) -> ::core::ffi::c_int;
    pub fn siginfo_to_siginfo32(src: *const siginfo_t, dst: *mut __siginfo32);
    pub fn get_mcontext(
        arg1: *mut thread,
        arg2: *mut mcontext_t,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn set_mcontext(arg1: *mut thread, arg2: *mut mcontext_t) -> ::core::ffi::c_int;
    #[link_name = "midr_check_var_part_range__extern"]
    pub fn midr_check_var_part_range(
        midr: u_int,
        impl_: u_int,
        part: u_int,
        var_low: u_int,
        part_low: u_int,
        var_high: u_int,
        part_high: u_int,
    ) -> bool_;
    pub static mut btext: [::core::ffi::c_char; 0usize];
    pub static mut etext: [::core::ffi::c_char; 0usize];
    pub static mut __cpu_affinity: [u64; 0usize];
    pub static mut elf64_addr_mask: arm64_addr_mask;
    pub static mut elf64_addr_mask_14: arm64_addr_mask;
    pub static mut cpu_reset_hook: cpu_reset_hook_t;
    pub fn cpu_halt() -> !;
    pub fn cpu_reset() -> !;
    pub fn fork_trampoline();
    pub fn identify_cache(arg1: u64);
    pub fn identify_cpu(arg1: u_int);
    pub fn install_cpu_errata();
    pub fn ptrauth_init();
    pub fn ptrauth_fork(arg1: *mut thread, arg2: *mut thread);
    pub fn ptrauth_exec(arg1: *mut thread);
    pub fn ptrauth_copy_thread(arg1: *mut thread, arg2: *mut thread);
    pub fn ptrauth_thread_alloc(arg1: *mut thread);
    pub fn ptrauth_thread0(arg1: *mut thread);
    pub fn ptrauth_mp_start(arg1: u64);
    pub fn update_special_regs(arg1: u_int);
    pub fn update_special_reg_iss(arg1: u_int, arg2: u64, arg3: u64);
    pub fn get_kernel_reg_iss(arg1: u_int, arg2: *mut u64) -> bool_;
    pub fn get_kernel_reg_iss_masked(arg1: u_int, arg2: *mut u64, arg3: u64) -> bool_;
    pub fn get_user_reg_iss(arg1: u_int, arg2: *mut u64, arg3: bool_) -> bool_;
    pub fn cpu_desc_init();
    #[link_name = "get_cyclecount__extern"]
    pub fn get_cyclecount() -> u64;
    #[link_name = "arm64_address_translate_s1e0r__extern"]
    pub fn arm64_address_translate_s1e0r(addr: u64) -> u64;
    #[link_name = "arm64_address_translate_s1e0w__extern"]
    pub fn arm64_address_translate_s1e0w(addr: u64) -> u64;
    #[link_name = "arm64_address_translate_s1e1r__extern"]
    pub fn arm64_address_translate_s1e1r(addr: u64) -> u64;
    #[link_name = "arm64_address_translate_s1e1w__extern"]
    pub fn arm64_address_translate_s1e1w(addr: u64) -> u64;
    #[link_name = "\u{1}x18"]
    pub static mut pcpup: *mut pcpu;
    #[link_name = "get_pcpu__extern"]
    pub fn get_pcpu() -> *mut pcpu;
    #[link_name = "get_curthread__extern"]
    pub fn get_curthread() -> *mut thread;
    pub static mut __start_set_pcpu: *mut usize;
    pub static mut __stop_set_pcpu: *mut usize;
    pub static mut dpcpu_off: [usize; 0usize];
    pub static mut cpuhead: cpuhead;
    pub static mut cpuid_to_pcpu: [*mut pcpu; 0usize];
    pub static mut pcpu0: pcpu;
    pub fn cpu_pcpu_init(pcpu: *mut pcpu, cpuid: ::core::ffi::c_int, size: usize);
    pub fn db_show_mdpcpu(pcpu: *mut pcpu);
    pub fn dpcpu_alloc(size: ::core::ffi::c_int) -> *mut ::core::ffi::c_void;
    pub fn dpcpu_copy(s: *mut ::core::ffi::c_void, size: ::core::ffi::c_int);
    pub fn dpcpu_free(s: *mut ::core::ffi::c_void, size: ::core::ffi::c_int);
    pub fn dpcpu_init(dpcpu: *mut ::core::ffi::c_void, cpuid: ::core::ffi::c_int);
    pub fn pcpu_destroy(pcpu: *mut pcpu);
    pub fn pcpu_find(cpuid: u_int) -> *mut pcpu;
    pub fn pcpu_init(pcpu: *mut pcpu, cpuid: ::core::ffi::c_int, size: usize);
    #[link_name = "sched_pin_lite__extern"]
    pub fn sched_pin_lite(td: *mut thread_lite);
    #[link_name = "sched_unpin_lite__extern"]
    pub fn sched_unpin_lite(td: *mut thread_lite);
    pub static mut scheduler_stopped: bool_;
    pub static osreldate: ::core::ffi::c_int;
    pub static mut zero_region: *const ::core::ffi::c_void;
    pub static mut unmapped_buf_allowed: ::core::ffi::c_int;
    pub fn setjmp(arg1: *mut _jmp_buf) -> ::core::ffi::c_int;
    pub fn longjmp(arg1: *mut _jmp_buf, arg2: ::core::ffi::c_int) -> !;
    pub fn dumpstatus(addr: vm_offset_t, count: off_t) -> ::core::ffi::c_int;
    pub fn nullop() -> ::core::ffi::c_int;
    pub fn eopnotsupp() -> ::core::ffi::c_int;
    pub fn ureadc(arg1: ::core::ffi::c_int, arg2: *mut uio) -> ::core::ffi::c_int;
    pub fn hashdestroy(arg1: *mut ::core::ffi::c_void, arg2: *mut malloc_type, arg3: u_long);
    pub fn hashinit(
        count: ::core::ffi::c_int,
        type_: *mut malloc_type,
        hashmask: *mut u_long,
    ) -> *mut ::core::ffi::c_void;
    pub fn hashinit_flags(
        count: ::core::ffi::c_int,
        type_: *mut malloc_type,
        hashmask: *mut u_long,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn phashinit(
        count: ::core::ffi::c_int,
        type_: *mut malloc_type,
        nentries: *mut u_long,
    ) -> *mut ::core::ffi::c_void;
    pub fn phashinit_flags(
        count: ::core::ffi::c_int,
        type_: *mut malloc_type,
        nentries: *mut u_long,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn cpu_flush_dcache(arg1: *mut ::core::ffi::c_void, arg2: usize);
    pub fn cpu_rootconf();
    pub fn critical_enter_KBI();
    pub fn critical_exit_KBI();
    pub fn critical_exit_preempt();
    pub fn init_param1();
    pub fn init_param2(physpages: ::core::ffi::c_long);
    pub fn init_static_kenv(arg1: *mut ::core::ffi::c_char, arg2: usize);
    pub fn tablefull(arg1: *const ::core::ffi::c_char);
    pub static mut lkpi_alloc_current: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut thread, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int,
    >;
    pub fn linux_alloc_current_noop(
        arg1: *mut thread,
        arg2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[link_name = "critical_enter__extern"]
    pub fn critical_enter();
    #[link_name = "critical_exit__extern"]
    pub fn critical_exit();
    pub fn kvprintf(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: ::core::ffi::c_int, arg2: *mut ::core::ffi::c_void),
        >,
        arg3: *mut ::core::ffi::c_void,
        arg4: ::core::ffi::c_int,
        arg5: __va_list,
    ) -> ::core::ffi::c_int;
    pub fn log(arg1: ::core::ffi::c_int, arg2: *const ::core::ffi::c_char, ...);
    pub fn log_console(arg1: *mut uio);
    pub fn vlog(arg1: ::core::ffi::c_int, arg2: *const ::core::ffi::c_char, arg3: __va_list);
    pub fn asprintf(
        ret: *mut *mut ::core::ffi::c_char,
        mtp: *mut malloc_type,
        format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn printf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn snprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: usize,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn sprintf(
        buf: *mut ::core::ffi::c_char,
        arg1: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn uprintf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn vprintf(arg1: *const ::core::ffi::c_char, arg2: __va_list) -> ::core::ffi::c_int;
    pub fn vasprintf(
        ret: *mut *mut ::core::ffi::c_char,
        mtp: *mut malloc_type,
        format: *const ::core::ffi::c_char,
        ap: __va_list,
    ) -> ::core::ffi::c_int;
    pub fn vsnprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: usize,
        arg3: *const ::core::ffi::c_char,
        arg4: __va_list,
    ) -> ::core::ffi::c_int;
    pub fn vsnrprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: usize,
        arg3: ::core::ffi::c_int,
        arg4: *const ::core::ffi::c_char,
        arg5: __va_list,
    ) -> ::core::ffi::c_int;
    pub fn vsprintf(
        buf: *mut ::core::ffi::c_char,
        arg1: *const ::core::ffi::c_char,
        arg2: __va_list,
    ) -> ::core::ffi::c_int;
    pub fn sscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn vsscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: __va_list,
    ) -> ::core::ffi::c_int;
    pub fn strtol(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_long;
    pub fn strtoul(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> u_long;
    pub fn strtoq(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> quad_t;
    pub fn strtouq(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> u_quad_t;
    pub fn tprintf(p: *mut proc_, pri: ::core::ffi::c_int, arg1: *const ::core::ffi::c_char, ...);
    pub fn vtprintf(
        arg1: *mut proc_,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: __va_list,
    );
    pub fn hexdump(
        ptr: *const ::core::ffi::c_void,
        length: ::core::ffi::c_int,
        hdr: *const ::core::ffi::c_char,
        flags: ::core::ffi::c_int,
    );
    pub fn explicit_bzero(arg1: *mut ::core::ffi::c_void, arg2: usize);
    pub fn memset(
        buf: *mut ::core::ffi::c_void,
        c: ::core::ffi::c_int,
        len: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn memcpy(
        to: *mut ::core::ffi::c_void,
        from: *const ::core::ffi::c_void,
        len: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn memmove(
        dest: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        n: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn memcmp(
        b1: *const ::core::ffi::c_void,
        b2: *const ::core::ffi::c_void,
        len: usize,
    ) -> ::core::ffi::c_int;
    pub fn memset_early(
        buf: *mut ::core::ffi::c_void,
        c: ::core::ffi::c_int,
        len: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn memcpy_early(
        to: *mut ::core::ffi::c_void,
        from: *const ::core::ffi::c_void,
        len: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn memmove_early(
        dest: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        n: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn copyinstr(
        udaddr: *const ::core::ffi::c_void,
        kaddr: *mut ::core::ffi::c_void,
        len: usize,
        lencopied: *mut usize,
    ) -> ::core::ffi::c_int;
    pub fn copyin(
        udaddr: *const ::core::ffi::c_void,
        kaddr: *mut ::core::ffi::c_void,
        len: usize,
    ) -> ::core::ffi::c_int;
    pub fn copyin_nofault(
        udaddr: *const ::core::ffi::c_void,
        kaddr: *mut ::core::ffi::c_void,
        len: usize,
    ) -> ::core::ffi::c_int;
    pub fn copyout(
        kaddr: *const ::core::ffi::c_void,
        udaddr: *mut ::core::ffi::c_void,
        len: usize,
    ) -> ::core::ffi::c_int;
    pub fn copyout_nofault(
        kaddr: *const ::core::ffi::c_void,
        udaddr: *mut ::core::ffi::c_void,
        len: usize,
    ) -> ::core::ffi::c_int;
    pub fn fubyte(base: *const ::core::ffi::c_void) -> ::core::ffi::c_int;
    pub fn fuword(base: *const ::core::ffi::c_void) -> ::core::ffi::c_long;
    pub fn fuword16(base: *const ::core::ffi::c_void) -> ::core::ffi::c_int;
    pub fn fuword32(base: *const ::core::ffi::c_void) -> i32;
    pub fn fuword64(base: *const ::core::ffi::c_void) -> i64;
    pub fn fueword(
        base: *const ::core::ffi::c_void,
        val: *mut ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
    pub fn fueword32(base: *const ::core::ffi::c_void, val: *mut i32) -> ::core::ffi::c_int;
    pub fn fueword64(base: *const ::core::ffi::c_void, val: *mut i64) -> ::core::ffi::c_int;
    pub fn subyte(base: *mut ::core::ffi::c_void, byte: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn suword(base: *mut ::core::ffi::c_void, word: ::core::ffi::c_long) -> ::core::ffi::c_int;
    pub fn suword16(base: *mut ::core::ffi::c_void, word: ::core::ffi::c_int)
    -> ::core::ffi::c_int;
    pub fn suword32(base: *mut ::core::ffi::c_void, word: i32) -> ::core::ffi::c_int;
    pub fn suword64(base: *mut ::core::ffi::c_void, word: i64) -> ::core::ffi::c_int;
    pub fn casuword32(base: *mut u32, oldval: u32, newval: u32) -> u32;
    pub fn casuword(p: *mut u_long, oldval: u_long, newval: u_long) -> u_long;
    pub fn casueword32(
        base: *mut u32,
        oldval: u32,
        oldvalp: *mut u32,
        newval: u32,
    ) -> ::core::ffi::c_int;
    pub fn casueword(
        p: *mut u_long,
        oldval: u_long,
        oldvalp: *mut u_long,
        newval: u_long,
    ) -> ::core::ffi::c_int;
    pub fn sysbeep(hertz: ::core::ffi::c_int, duration: sbintime_t) -> ::core::ffi::c_int;
    pub fn hardclock(cnt: ::core::ffi::c_int, usermode: ::core::ffi::c_int);
    pub fn hardclock_sync(cpu: ::core::ffi::c_int);
    pub fn statclock(cnt: ::core::ffi::c_int, usermode: ::core::ffi::c_int);
    pub fn profclock(cnt: ::core::ffi::c_int, usermode: ::core::ffi::c_int, pc: uintfptr_t);
    pub fn hardclockintr() -> ::core::ffi::c_int;
    pub fn startprofclock(arg1: *mut proc_);
    pub fn stopprofclock(arg1: *mut proc_);
    pub fn cpu_startprofclock();
    pub fn cpu_stopprofclock();
    pub fn suspendclock();
    pub fn resumeclock();
    pub fn cpu_idleclock() -> sbintime_t;
    pub fn cpu_activeclock();
    pub fn cpu_new_callout(cpu: ::core::ffi::c_int, bt: sbintime_t, bt_opt: sbintime_t);
    pub fn cpu_et_frequency(et: *mut eventtimer, newfreq: u64);
    pub static mut cpu_disable_c2_sleep: ::core::ffi::c_int;
    pub static mut cpu_disable_c3_sleep: ::core::ffi::c_int;
    pub static mut tcp_hpts_softclock: ::core::option::Option<unsafe extern "C" fn()>;
    pub static mut hpts_that_need_softclock: u32;
    pub fn kern_getenv(name: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn freeenv(env: *mut ::core::ffi::c_char);
    pub fn getenv_int(
        name: *const ::core::ffi::c_char,
        data: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn getenv_uint(
        name: *const ::core::ffi::c_char,
        data: *mut ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
    pub fn getenv_long(
        name: *const ::core::ffi::c_char,
        data: *mut ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
    pub fn getenv_ulong(
        name: *const ::core::ffi::c_char,
        data: *mut ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
    pub fn getenv_string(
        name: *const ::core::ffi::c_char,
        data: *mut ::core::ffi::c_char,
        size: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn getenv_int64(name: *const ::core::ffi::c_char, data: *mut i64) -> ::core::ffi::c_int;
    pub fn getenv_uint64(name: *const ::core::ffi::c_char, data: *mut u64) -> ::core::ffi::c_int;
    pub fn getenv_quad(name: *const ::core::ffi::c_char, data: *mut quad_t) -> ::core::ffi::c_int;
    pub fn getenv_bool(name: *const ::core::ffi::c_char, data: *mut bool_) -> ::core::ffi::c_int;
    pub fn getenv_is_true(name: *const ::core::ffi::c_char) -> bool_;
    pub fn getenv_is_false(name: *const ::core::ffi::c_char) -> bool_;
    pub fn kern_setenv(
        name: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn kern_unsetenv(name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn testenv(name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn getenv_array(
        name: *const ::core::ffi::c_char,
        data: *mut ::core::ffi::c_void,
        size: ::core::ffi::c_int,
        psize: *mut ::core::ffi::c_int,
        type_size: ::core::ffi::c_int,
        allow_signed: bool_,
    ) -> ::core::ffi::c_int;
    pub fn set_cputicker(func: cpu_tick_f, freq: u64, isvariable: bool_);
    pub static mut cpu_ticks: cpu_tick_f;
    pub fn cpu_tickrate() -> u64;
    pub fn cputick2usec(tick: u64) -> u64;
    pub static bcd2bin_data: [u_char; 0usize];
    pub static bin2bcd_data: [u_char; 0usize];
    pub static hex2ascii_data: [::core::ffi::c_char; 0usize];
    #[link_name = "bcd2bin__extern"]
    pub fn bcd2bin(bcd: ::core::ffi::c_int) -> u_char;
    #[link_name = "bin2bcd__extern"]
    pub fn bin2bcd(bin: ::core::ffi::c_int) -> u_char;
    #[link_name = "hex2ascii__extern"]
    pub fn hex2ascii(hex: ::core::ffi::c_int) -> ::core::ffi::c_char;
    #[link_name = "validbcd__extern"]
    pub fn validbcd(bcd: ::core::ffi::c_int) -> bool_;
    #[link_name = "imax__extern"]
    pub fn imax(a: ::core::ffi::c_int, b: ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[link_name = "imin__extern"]
    pub fn imin(a: ::core::ffi::c_int, b: ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[link_name = "lmax__extern"]
    pub fn lmax(a: ::core::ffi::c_long, b: ::core::ffi::c_long) -> ::core::ffi::c_long;
    #[link_name = "lmin__extern"]
    pub fn lmin(a: ::core::ffi::c_long, b: ::core::ffi::c_long) -> ::core::ffi::c_long;
    #[link_name = "max__extern"]
    pub fn max(a: u_int, b: u_int) -> u_int;
    #[link_name = "min__extern"]
    pub fn min(a: u_int, b: u_int) -> u_int;
    #[link_name = "qmax__extern"]
    pub fn qmax(a: quad_t, b: quad_t) -> quad_t;
    #[link_name = "qmin__extern"]
    pub fn qmin(a: quad_t, b: quad_t) -> quad_t;
    #[link_name = "uqmax__extern"]
    pub fn uqmax(a: u_quad_t, b: u_quad_t) -> u_quad_t;
    #[link_name = "uqmin__extern"]
    pub fn uqmin(a: u_quad_t, b: u_quad_t) -> u_quad_t;
    #[link_name = "ulmax__extern"]
    pub fn ulmax(a: u_long, b: u_long) -> u_long;
    #[link_name = "ulmin__extern"]
    pub fn ulmin(a: u_long, b: u_long) -> u_long;
    #[link_name = "ummax__extern"]
    pub fn ummax(a: __uintmax_t, b: __uintmax_t) -> __uintmax_t;
    #[link_name = "ummin__extern"]
    pub fn ummin(a: __uintmax_t, b: __uintmax_t) -> __uintmax_t;
    #[link_name = "omax__extern"]
    pub fn omax(a: off_t, b: off_t) -> off_t;
    #[link_name = "omin__extern"]
    pub fn omin(a: off_t, b: off_t) -> off_t;
    #[link_name = "abs__extern"]
    pub fn abs(a: ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[link_name = "labs__extern"]
    pub fn labs(a: ::core::ffi::c_long) -> ::core::ffi::c_long;
    #[link_name = "abs64__extern"]
    pub fn abs64(a: i64) -> i64;
    #[link_name = "qabs__extern"]
    pub fn qabs(a: quad_t) -> quad_t;
    pub static mut arc4rand_iniseed_state: ::core::ffi::c_int;
    pub fn arc4random() -> u32;
    pub fn arc4random_buf(arg1: *mut ::core::ffi::c_void, arg2: usize);
    pub fn arc4random_uniform(arg1: u32) -> u32;
    pub fn arc4rand(arg1: *mut ::core::ffi::c_void, arg2: u_int, arg3: ::core::ffi::c_int);
    pub fn timingsafe_bcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: usize,
    ) -> ::core::ffi::c_int;
    pub fn bsearch(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: usize,
        arg4: usize,
        arg5: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
    ) -> *mut ::core::ffi::c_void;
    #[link_name = "ffs__extern"]
    pub fn ffs(mask: ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[link_name = "ffsl__extern"]
    pub fn ffsl(mask: ::core::ffi::c_long) -> ::core::ffi::c_int;
    #[link_name = "ffsll__extern"]
    pub fn ffsll(mask: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
    #[link_name = "fls__extern"]
    pub fn fls(mask: ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[link_name = "flsl__extern"]
    pub fn flsl(mask: ::core::ffi::c_long) -> ::core::ffi::c_int;
    #[link_name = "flsll__extern"]
    pub fn flsll(mask: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
    #[link_name = "ilog2_int__extern"]
    pub fn ilog2_int(n: ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[link_name = "ilog2_long__extern"]
    pub fn ilog2_long(n: ::core::ffi::c_long) -> ::core::ffi::c_int;
    #[link_name = "ilog2_long_long__extern"]
    pub fn ilog2_long_long(n: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
    pub fn fnmatch(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn locc(
        arg1: ::core::ffi::c_int,
        arg2: *mut ::core::ffi::c_char,
        arg3: u_int,
    ) -> ::core::ffi::c_int;
    pub fn memchr(
        s: *const ::core::ffi::c_void,
        c: ::core::ffi::c_int,
        n: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn memcchr(
        s: *const ::core::ffi::c_void,
        c: ::core::ffi::c_int,
        n: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn memmem(
        l: *const ::core::ffi::c_void,
        l_len: usize,
        s: *const ::core::ffi::c_void,
        s_len: usize,
    ) -> *mut ::core::ffi::c_void;
    pub fn qsort(
        base: *mut ::core::ffi::c_void,
        nmemb: usize,
        size: usize,
        compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
    );
    pub fn qsort_r(
        base: *mut ::core::ffi::c_void,
        nmemb: usize,
        size: usize,
        compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
                arg3: *mut ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
        thunk: *mut ::core::ffi::c_void,
    );
    pub fn random() -> u_long;
    pub fn scanc(
        arg1: u_int,
        arg2: *const u_char,
        arg3: *const u_char,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn strcasecmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn strcasestr(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcat(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strchr(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn strchrnul(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn strcpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strdup_flags(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut malloc_type,
        arg3: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn strcspn(arg1: *const ::core::ffi::c_char, arg2: *const ::core::ffi::c_char) -> usize;
    pub fn strdup(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut malloc_type,
    ) -> *mut ::core::ffi::c_char;
    pub fn strncat(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> *mut ::core::ffi::c_char;
    pub fn strndup(
        arg1: *const ::core::ffi::c_char,
        arg2: usize,
        arg3: *mut malloc_type,
    ) -> *mut ::core::ffi::c_char;
    pub fn strlcat(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> usize;
    pub fn strlcpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> usize;
    pub fn strlen(arg1: *const ::core::ffi::c_char) -> usize;
    pub fn strncasecmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> ::core::ffi::c_int;
    pub fn strncmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> ::core::ffi::c_int;
    pub fn strncpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> *mut ::core::ffi::c_char;
    pub fn strnlen(arg1: *const ::core::ffi::c_char, arg2: usize) -> usize;
    pub fn strnstr(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> *mut ::core::ffi::c_char;
    pub fn strrchr(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    pub fn strsep(
        arg1: *mut *mut ::core::ffi::c_char,
        delim: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strspn(arg1: *const ::core::ffi::c_char, arg2: *const ::core::ffi::c_char) -> usize;
    pub fn strstr(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn strvalid(arg1: *const ::core::ffi::c_char, arg2: usize) -> ::core::ffi::c_int;
    #[link_name = "index__extern"]
    pub fn index(p: *const ::core::ffi::c_char, ch: ::core::ffi::c_int)
    -> *mut ::core::ffi::c_char;
    #[link_name = "rindex__extern"]
    pub fn rindex(
        p: *const ::core::ffi::c_char,
        ch: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    #[link_name = "signed_extend64__extern"]
    pub fn signed_extend64(bitmap: u64, lsb: ::core::ffi::c_int, width: ::core::ffi::c_int) -> i64;
    #[link_name = "signed_extend32__extern"]
    pub fn signed_extend32(bitmap: u32, lsb: ::core::ffi::c_int, width: ::core::ffi::c_int) -> i32;
    pub fn consinit();
    pub fn cpu_initclocks();
    pub fn cpu_initclocks_bsp();
    pub fn cpu_initclocks_ap();
    pub fn usrinfoinit();
    pub fn kern_reboot(arg1: ::core::ffi::c_int) -> !;
    pub fn shutdown_nice(arg1: ::core::ffi::c_int);
    #[link_name = "splhigh__extern"]
    pub fn splhigh() -> intrmask_t;
    #[link_name = "splimp__extern"]
    pub fn splimp() -> intrmask_t;
    #[link_name = "splnet__extern"]
    pub fn splnet() -> intrmask_t;
    #[link_name = "spltty__extern"]
    pub fn spltty() -> intrmask_t;
    #[link_name = "splx__extern"]
    pub fn splx(ipl: intrmask_t);
    pub fn _sleep(
        chan: *const ::core::ffi::c_void,
        lock: *mut lock_object,
        pri: ::core::ffi::c_int,
        wmesg: *const ::core::ffi::c_char,
        sbt: sbintime_t,
        pr: sbintime_t,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn msleep_spin_sbt(
        chan: *const ::core::ffi::c_void,
        mtx: *mut mtx,
        wmesg: *const ::core::ffi::c_char,
        sbt: sbintime_t,
        pr: sbintime_t,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn pause_sbt(
        wmesg: *const ::core::ffi::c_char,
        sbt: sbintime_t,
        pr: sbintime_t,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[link_name = "pause__extern"]
    pub fn pause(wmesg: *const ::core::ffi::c_char, timo: ::core::ffi::c_int)
    -> ::core::ffi::c_int;
    pub fn wakeup(chan: *const ::core::ffi::c_void);
    pub fn wakeup_one(chan: *const ::core::ffi::c_void);
    pub fn wakeup_any(chan: *const ::core::ffi::c_void);
    pub fn dev2udev(x: *mut cdev) -> dev_t;
    pub fn devtoname(cdev: *mut cdev) -> *const ::core::ffi::c_char;
    pub fn devfs_iosize_max() -> usize;
    pub fn iosize_max() -> usize;
    pub fn poll_no_poll(events: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn DELAY(usec: ::core::ffi::c_int);
    pub fn kcmp_cmp(a: usize, b: usize) -> ::core::ffi::c_int;
    pub fn root_mount_hold(identifier: *const ::core::ffi::c_char) -> *mut root_hold_token;
    pub fn root_mount_hold_token(identifier: *const ::core::ffi::c_char, h: *mut root_hold_token);
    pub fn root_mount_rel(h: *mut root_hold_token);
    pub fn root_mounted() -> ::core::ffi::c_int;
    pub fn new_unrhdr(
        low: ::core::ffi::c_int,
        high: ::core::ffi::c_int,
        mutex: *mut mtx,
    ) -> *mut unrhdr;
    pub fn init_unrhdr(
        uh: *mut unrhdr,
        low: ::core::ffi::c_int,
        high: ::core::ffi::c_int,
        mutex: *mut mtx,
    );
    pub fn delete_unrhdr(uh: *mut unrhdr);
    pub fn clear_unrhdr(uh: *mut unrhdr);
    pub fn clean_unrhdr(uh: *mut unrhdr);
    pub fn clean_unrhdrl(uh: *mut unrhdr);
    pub fn alloc_unr(uh: *mut unrhdr) -> ::core::ffi::c_int;
    pub fn alloc_unr_specific(uh: *mut unrhdr, item: u_int) -> ::core::ffi::c_int;
    pub fn alloc_unrl(uh: *mut unrhdr) -> ::core::ffi::c_int;
    pub fn free_unr(uh: *mut unrhdr, item: u_int);
    pub fn create_iter_unr(uh: *mut unrhdr) -> *mut ::core::ffi::c_void;
    pub fn next_iter_unr(handle: *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
    pub fn free_iter_unr(handle: *mut ::core::ffi::c_void);
    #[link_name = "new_unrhdr64__extern"]
    pub fn new_unrhdr64(unr64: *mut unrhdr64, low: u64);
    #[link_name = "alloc_unr64__extern"]
    pub fn alloc_unr64(unr64: *mut unrhdr64) -> u64;
    pub fn intr_prof_stack_use(td: *mut thread, frame: *mut trapframe);
    pub fn counted_warning(counter: *mut ::core::ffi::c_uint, msg: *const ::core::ffi::c_char);
    pub fn _gone_in(major: ::core::ffi::c_int, msg: *const ::core::ffi::c_char, ...);
    pub fn _gone_in_dev(
        dev: device_t,
        major: ::core::ffi::c_int,
        msg: *const ::core::ffi::c_char,
        ...
    );
    #[doc = " devctl hooks.  Typically one should use the devctl_notify\n hook to send the message."]
    pub fn devctl_process_running() -> bool_;
    pub fn devctl_notify(
        __system: *const ::core::ffi::c_char,
        __subsystem: *const ::core::ffi::c_char,
        __type: *const ::core::ffi::c_char,
        __data: *const ::core::ffi::c_char,
    );
    pub fn devctl_safe_quote_sb(__sb: *mut sbuf, __src: *const ::core::ffi::c_char);
    pub fn devctl_set_notify_hook(hook: send_event_f);
    pub fn devctl_unset_notify_hook();
    pub fn resource_init_map_request_impl(_args: *mut resource_map_request, _sz: usize);
    pub fn resource_validate_map_request(
        r: *mut resource,
        in_: *mut resource_map_request,
        out: *mut resource_map_request,
        startp: *mut rman_res_t,
        lengthp: *mut rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn resource_list_init(rl: *mut resource_list);
    pub fn resource_list_free(rl: *mut resource_list);
    pub fn resource_list_add(
        rl: *mut resource_list,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
        start: rman_res_t,
        end: rman_res_t,
        count: rman_res_t,
    ) -> *mut resource_list_entry;
    pub fn resource_list_add_next(
        rl: *mut resource_list,
        type_: ::core::ffi::c_int,
        start: rman_res_t,
        end: rman_res_t,
        count: rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn resource_list_busy(
        rl: *mut resource_list,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn resource_list_reserved(
        rl: *mut resource_list,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn resource_list_find(
        rl: *mut resource_list,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
    ) -> *mut resource_list_entry;
    pub fn resource_list_delete(
        rl: *mut resource_list,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
    );
    pub fn resource_list_alloc(
        rl: *mut resource_list,
        bus: device_t,
        child: device_t,
        type_: ::core::ffi::c_int,
        rid: *mut ::core::ffi::c_int,
        start: rman_res_t,
        end: rman_res_t,
        count: rman_res_t,
        flags: u_int,
    ) -> *mut resource;
    pub fn resource_list_release(
        rl: *mut resource_list,
        bus: device_t,
        child: device_t,
        res: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn resource_list_release_active(
        rl: *mut resource_list,
        bus: device_t,
        child: device_t,
        type_: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn resource_list_reserve(
        rl: *mut resource_list,
        bus: device_t,
        child: device_t,
        type_: ::core::ffi::c_int,
        rid: *mut ::core::ffi::c_int,
        start: rman_res_t,
        end: rman_res_t,
        count: rman_res_t,
        flags: u_int,
    ) -> *mut resource;
    pub fn resource_list_unreserve(
        rl: *mut resource_list,
        bus: device_t,
        child: device_t,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn resource_list_purge(rl: *mut resource_list);
    pub fn resource_list_print_type(
        rl: *mut resource_list,
        name: *const ::core::ffi::c_char,
        type_: ::core::ffi::c_int,
        format: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub static mut root_bus: device_t;
    pub static mut root_devclass: devclass_t;
    pub fn root_bus_configure();
    pub fn bus_generic_activate_resource(
        dev: device_t,
        child: device_t,
        r: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_add_child(
        dev: device_t,
        order: u_int,
        name: *const ::core::ffi::c_char,
        unit: ::core::ffi::c_int,
    ) -> device_t;
    pub fn bus_generic_adjust_resource(
        bus: device_t,
        child: device_t,
        r: *mut resource,
        start: rman_res_t,
        end: rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_alloc_resource(
        bus: device_t,
        child: device_t,
        type_: ::core::ffi::c_int,
        rid: *mut ::core::ffi::c_int,
        start: rman_res_t,
        end: rman_res_t,
        count: rman_res_t,
        flags: u_int,
    ) -> *mut resource;
    pub fn bus_generic_translate_resource(
        dev: device_t,
        type_: ::core::ffi::c_int,
        start: rman_res_t,
        newstart: *mut rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_attach(dev: device_t) -> ::core::ffi::c_int;
    pub fn bus_generic_bind_intr(
        dev: device_t,
        child: device_t,
        irq: *mut resource,
        cpu: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_child_location(
        dev: device_t,
        child: device_t,
        sb: *mut sbuf,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_child_pnpinfo(
        dev: device_t,
        child: device_t,
        sb: *mut sbuf,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_child_present(dev: device_t, child: device_t) -> ::core::ffi::c_int;
    pub fn bus_generic_config_intr(
        arg1: device_t,
        arg2: ::core::ffi::c_int,
        arg3: intr_trigger,
        arg4: intr_polarity,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_describe_intr(
        dev: device_t,
        child: device_t,
        irq: *mut resource,
        cookie: *mut ::core::ffi::c_void,
        descr: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_deactivate_resource(
        dev: device_t,
        child: device_t,
        r: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_detach(dev: device_t) -> ::core::ffi::c_int;
    pub fn bus_generic_driver_added(dev: device_t, driver: *mut driver_t);
    pub fn bus_generic_get_cpus(
        dev: device_t,
        child: device_t,
        op: cpu_sets,
        setsize: usize,
        cpuset: *mut _cpuset,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_get_dma_tag(dev: device_t, child: device_t) -> bus_dma_tag_t;
    pub fn bus_generic_get_bus_tag(dev: device_t, child: device_t) -> bus_space_tag_t;
    pub fn bus_generic_get_domain(
        dev: device_t,
        child: device_t,
        domain: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_get_property(
        dev: device_t,
        child: device_t,
        propname: *const ::core::ffi::c_char,
        propvalue: *mut ::core::ffi::c_void,
        size: usize,
        type_: device_property_type_t,
    ) -> isize;
    pub fn bus_generic_map_resource(
        dev: device_t,
        child: device_t,
        r: *mut resource,
        args: *mut resource_map_request,
        map: *mut resource_map,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_new_pass(dev: device_t);
    pub fn bus_print_child_header(dev: device_t, child: device_t) -> ::core::ffi::c_int;
    pub fn bus_print_child_domain(dev: device_t, child: device_t) -> ::core::ffi::c_int;
    pub fn bus_print_child_footer(dev: device_t, child: device_t) -> ::core::ffi::c_int;
    pub fn bus_generic_print_child(dev: device_t, child: device_t) -> ::core::ffi::c_int;
    pub fn bus_generic_probe(dev: device_t) -> ::core::ffi::c_int;
    pub fn bus_generic_read_ivar(
        dev: device_t,
        child: device_t,
        which: ::core::ffi::c_int,
        result: *mut usize,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_release_resource(
        bus: device_t,
        child: device_t,
        r: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_resume(dev: device_t) -> ::core::ffi::c_int;
    pub fn bus_generic_resume_child(dev: device_t, child: device_t) -> ::core::ffi::c_int;
    pub fn bus_generic_setup_intr(
        dev: device_t,
        child: device_t,
        irq: *mut resource,
        flags: ::core::ffi::c_int,
        filter: driver_filter_t,
        intr: driver_intr_t,
        arg: *mut ::core::ffi::c_void,
        cookiep: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_rl_alloc_resource(
        arg1: device_t,
        arg2: device_t,
        arg3: ::core::ffi::c_int,
        arg4: *mut ::core::ffi::c_int,
        arg5: rman_res_t,
        arg6: rman_res_t,
        arg7: rman_res_t,
        arg8: u_int,
    ) -> *mut resource;
    pub fn bus_generic_rl_delete_resource(
        arg1: device_t,
        arg2: device_t,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
    );
    pub fn bus_generic_rl_get_resource(
        arg1: device_t,
        arg2: device_t,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
        arg5: *mut rman_res_t,
        arg6: *mut rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_rl_set_resource(
        arg1: device_t,
        arg2: device_t,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
        arg5: rman_res_t,
        arg6: rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_rl_release_resource(
        arg1: device_t,
        arg2: device_t,
        arg3: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_rman_alloc_resource(
        dev: device_t,
        child: device_t,
        type_: ::core::ffi::c_int,
        rid: *mut ::core::ffi::c_int,
        start: rman_res_t,
        end: rman_res_t,
        count: rman_res_t,
        flags: u_int,
    ) -> *mut resource;
    pub fn bus_generic_rman_adjust_resource(
        dev: device_t,
        child: device_t,
        r: *mut resource,
        start: rman_res_t,
        end: rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_rman_release_resource(
        dev: device_t,
        child: device_t,
        r: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_rman_activate_resource(
        dev: device_t,
        child: device_t,
        r: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_rman_deactivate_resource(
        dev: device_t,
        child: device_t,
        r: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_shutdown(dev: device_t) -> ::core::ffi::c_int;
    pub fn bus_generic_suspend(dev: device_t) -> ::core::ffi::c_int;
    pub fn bus_generic_suspend_child(dev: device_t, child: device_t) -> ::core::ffi::c_int;
    pub fn bus_generic_teardown_intr(
        dev: device_t,
        child: device_t,
        irq: *mut resource,
        cookie: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_suspend_intr(
        dev: device_t,
        child: device_t,
        irq: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_resume_intr(
        dev: device_t,
        child: device_t,
        irq: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_unmap_resource(
        dev: device_t,
        child: device_t,
        r: *mut resource,
        map: *mut resource_map,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_write_ivar(
        dev: device_t,
        child: device_t,
        which: ::core::ffi::c_int,
        value: usize,
    ) -> ::core::ffi::c_int;
    pub fn bus_generic_get_device_path(
        bus: device_t,
        child: device_t,
        locator: *const ::core::ffi::c_char,
        sb: *mut sbuf,
    ) -> ::core::ffi::c_int;
    pub fn bus_helper_reset_post(dev: device_t, flags: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn bus_helper_reset_prepare(dev: device_t, flags: ::core::ffi::c_int)
    -> ::core::ffi::c_int;
    pub fn bus_null_rescan(dev: device_t) -> ::core::ffi::c_int;
    pub fn bus_alloc_resources(
        dev: device_t,
        rs: *mut resource_spec,
        res: *mut *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_release_resources(dev: device_t, rs: *const resource_spec, res: *mut *mut resource);
    pub fn bus_adjust_resource(
        child: device_t,
        r: *mut resource,
        start: rman_res_t,
        end: rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn bus_translate_resource(
        child: device_t,
        type_: ::core::ffi::c_int,
        start: rman_res_t,
        newstart: *mut rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn bus_alloc_resource(
        dev: device_t,
        type_: ::core::ffi::c_int,
        rid: *mut ::core::ffi::c_int,
        start: rman_res_t,
        end: rman_res_t,
        count: rman_res_t,
        flags: u_int,
    ) -> *mut resource;
    pub fn bus_activate_resource(dev: device_t, r: *mut resource) -> ::core::ffi::c_int;
    pub fn bus_deactivate_resource(dev: device_t, r: *mut resource) -> ::core::ffi::c_int;
    pub fn bus_map_resource(
        dev: device_t,
        r: *mut resource,
        args: *mut resource_map_request,
        map: *mut resource_map,
    ) -> ::core::ffi::c_int;
    pub fn bus_unmap_resource(
        dev: device_t,
        r: *mut resource,
        map: *mut resource_map,
    ) -> ::core::ffi::c_int;
    pub fn bus_get_cpus(
        dev: device_t,
        op: cpu_sets,
        setsize: usize,
        cpuset: *mut _cpuset,
    ) -> ::core::ffi::c_int;
    pub fn bus_get_dma_tag(dev: device_t) -> bus_dma_tag_t;
    pub fn bus_get_bus_tag(dev: device_t) -> bus_space_tag_t;
    pub fn bus_get_domain(dev: device_t, domain: *mut ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn bus_release_resource(dev: device_t, r: *mut resource) -> ::core::ffi::c_int;
    pub fn bus_free_resource(
        dev: device_t,
        type_: ::core::ffi::c_int,
        r: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_setup_intr(
        dev: device_t,
        r: *mut resource,
        flags: ::core::ffi::c_int,
        filter: driver_filter_t,
        handler: driver_intr_t,
        arg: *mut ::core::ffi::c_void,
        cookiep: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn bus_teardown_intr(
        dev: device_t,
        r: *mut resource,
        cookie: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn bus_suspend_intr(dev: device_t, r: *mut resource) -> ::core::ffi::c_int;
    pub fn bus_resume_intr(dev: device_t, r: *mut resource) -> ::core::ffi::c_int;
    pub fn bus_bind_intr(
        dev: device_t,
        r: *mut resource,
        cpu: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_describe_intr(
        dev: device_t,
        irq: *mut resource,
        cookie: *mut ::core::ffi::c_void,
        fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn bus_set_resource(
        dev: device_t,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
        start: rman_res_t,
        count: rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn bus_get_resource(
        dev: device_t,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
        startp: *mut rman_res_t,
        countp: *mut rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn bus_get_resource_start(
        dev: device_t,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
    ) -> rman_res_t;
    pub fn bus_get_resource_count(
        dev: device_t,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
    ) -> rman_res_t;
    pub fn bus_delete_resource(dev: device_t, type_: ::core::ffi::c_int, rid: ::core::ffi::c_int);
    pub fn bus_child_present(child: device_t) -> ::core::ffi::c_int;
    pub fn bus_child_pnpinfo(child: device_t, sb: *mut sbuf) -> ::core::ffi::c_int;
    pub fn bus_child_location(child: device_t, sb: *mut sbuf) -> ::core::ffi::c_int;
    pub fn bus_attach_children(dev: device_t);
    pub fn bus_delayed_attach_children(bus: device_t);
    pub fn bus_detach_children(dev: device_t) -> ::core::ffi::c_int;
    pub fn bus_enumerate_hinted_children(bus: device_t);
    pub fn bus_identify_children(dev: device_t);
    #[link_name = "bus_alloc_resource_any__extern"]
    pub fn bus_alloc_resource_any(
        dev: device_t,
        type_: ::core::ffi::c_int,
        rid: *mut ::core::ffi::c_int,
        flags: u_int,
    ) -> *mut resource;
    #[link_name = "bus_alloc_resource_anywhere__extern"]
    pub fn bus_alloc_resource_anywhere(
        dev: device_t,
        type_: ::core::ffi::c_int,
        rid: *mut ::core::ffi::c_int,
        count: rman_res_t,
        flags: u_int,
    ) -> *mut resource;
    #[link_name = "bus_alloc_resource_const__extern"]
    pub fn bus_alloc_resource_const(
        dev: device_t,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
        start: rman_res_t,
        end: rman_res_t,
        count: rman_res_t,
        flags: u_int,
    ) -> *mut resource;
    #[link_name = "bus_alloc_resource_any_const__extern"]
    pub fn bus_alloc_resource_any_const(
        dev: device_t,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
        flags: u_int,
    ) -> *mut resource;
    #[link_name = "bus_alloc_resource_anywhere_const__extern"]
    pub fn bus_alloc_resource_anywhere_const(
        dev: device_t,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
        count: rman_res_t,
        flags: u_int,
    ) -> *mut resource;
    pub fn bus_adjust_resource_old(
        child: device_t,
        type_: ::core::ffi::c_int,
        r: *mut resource,
        start: rman_res_t,
        end: rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn bus_activate_resource_old(
        dev: device_t,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
        r: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_deactivate_resource_old(
        dev: device_t,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
        r: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn bus_map_resource_old(
        dev: device_t,
        type_: ::core::ffi::c_int,
        r: *mut resource,
        args: *mut resource_map_request,
        map: *mut resource_map,
    ) -> ::core::ffi::c_int;
    pub fn bus_unmap_resource_old(
        dev: device_t,
        type_: ::core::ffi::c_int,
        r: *mut resource,
        map: *mut resource_map,
    ) -> ::core::ffi::c_int;
    pub fn bus_release_resource_old(
        dev: device_t,
        type_: ::core::ffi::c_int,
        rid: ::core::ffi::c_int,
        r: *mut resource,
    ) -> ::core::ffi::c_int;
    pub fn device_add_child(
        dev: device_t,
        name: *const ::core::ffi::c_char,
        unit: ::core::ffi::c_int,
    ) -> device_t;
    pub fn device_add_child_ordered(
        dev: device_t,
        order: u_int,
        name: *const ::core::ffi::c_char,
        unit: ::core::ffi::c_int,
    ) -> device_t;
    pub fn device_busy(dev: device_t);
    pub fn device_delete_child(dev: device_t, child: device_t) -> ::core::ffi::c_int;
    pub fn device_delete_children(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_attach(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_detach(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_disable(dev: device_t);
    pub fn device_enable(dev: device_t);
    pub fn device_find_child(
        dev: device_t,
        classname: *const ::core::ffi::c_char,
        unit: ::core::ffi::c_int,
    ) -> device_t;
    pub fn device_get_desc(dev: device_t) -> *const ::core::ffi::c_char;
    pub fn device_get_devclass(dev: device_t) -> devclass_t;
    pub fn device_get_driver(dev: device_t) -> *mut driver_t;
    pub fn device_get_flags(dev: device_t) -> u_int32_t;
    pub fn device_get_parent(dev: device_t) -> device_t;
    pub fn device_get_children(
        dev: device_t,
        listp: *mut *mut device_t,
        countp: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn device_get_ivars(dev: device_t) -> *mut ::core::ffi::c_void;
    pub fn device_set_ivars(dev: device_t, ivars: *mut ::core::ffi::c_void);
    pub fn device_get_name(dev: device_t) -> *const ::core::ffi::c_char;
    pub fn device_get_nameunit(dev: device_t) -> *const ::core::ffi::c_char;
    pub fn device_get_softc(dev: device_t) -> *mut ::core::ffi::c_void;
    pub fn device_get_state(dev: device_t) -> device_state_t;
    pub fn device_get_unit(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_get_sysctl_ctx(dev: device_t) -> *mut sysctl_ctx_list;
    pub fn device_get_sysctl_tree(dev: device_t) -> *mut sysctl_oid;
    pub fn device_has_quiet_children(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_is_alive(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_is_attached(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_is_enabled(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_is_suspended(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_is_quiet(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_lookup_by_name(name: *const ::core::ffi::c_char) -> device_t;
    pub fn device_print_prettyname(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_printf(
        dev: device_t,
        arg1: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn device_log(
        dev: device_t,
        pri: ::core::ffi::c_int,
        arg1: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn device_probe(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_probe_and_attach(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_probe_child(bus: device_t, dev: device_t) -> ::core::ffi::c_int;
    pub fn device_quiesce(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_quiet(dev: device_t);
    pub fn device_quiet_children(dev: device_t);
    pub fn device_set_desc(dev: device_t, desc: *const ::core::ffi::c_char);
    pub fn device_set_descf(dev: device_t, fmt: *const ::core::ffi::c_char, ...);
    pub fn device_set_desc_copy(dev: device_t, desc: *const ::core::ffi::c_char);
    pub fn device_set_devclass(
        dev: device_t,
        classname: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn device_set_devclass_fixed(
        dev: device_t,
        classname: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn device_is_devclass_fixed(dev: device_t) -> bool_;
    pub fn device_set_driver(dev: device_t, driver: *mut driver_t) -> ::core::ffi::c_int;
    pub fn device_set_flags(dev: device_t, flags: u_int32_t);
    pub fn device_set_softc(dev: device_t, softc: *mut ::core::ffi::c_void);
    pub fn device_free_softc(softc: *mut ::core::ffi::c_void);
    pub fn device_claim_softc(dev: device_t);
    pub fn device_set_unit(dev: device_t, unit: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn device_shutdown(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_unbusy(dev: device_t);
    pub fn device_verbose(dev: device_t);
    pub fn device_get_property(
        dev: device_t,
        prop: *const ::core::ffi::c_char,
        val: *mut ::core::ffi::c_void,
        sz: usize,
        type_: device_property_type_t,
    ) -> isize;
    pub fn device_has_property(dev: device_t, prop: *const ::core::ffi::c_char) -> bool_;
    pub fn devclass_add_driver(
        dc: devclass_t,
        driver: *mut driver_t,
        pass: ::core::ffi::c_int,
        dcp: *mut devclass_t,
    ) -> ::core::ffi::c_int;
    pub fn devclass_create(classname: *const ::core::ffi::c_char) -> devclass_t;
    pub fn devclass_delete_driver(
        busclass: devclass_t,
        driver: *mut driver_t,
    ) -> ::core::ffi::c_int;
    pub fn devclass_find(classname: *const ::core::ffi::c_char) -> devclass_t;
    pub fn devclass_get_name(dc: devclass_t) -> *const ::core::ffi::c_char;
    pub fn devclass_get_device(dc: devclass_t, unit: ::core::ffi::c_int) -> device_t;
    pub fn devclass_get_softc(dc: devclass_t, unit: ::core::ffi::c_int)
    -> *mut ::core::ffi::c_void;
    pub fn devclass_get_devices(
        dc: devclass_t,
        listp: *mut *mut device_t,
        countp: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn devclass_get_drivers(
        dc: devclass_t,
        listp: *mut *mut *mut driver_t,
        countp: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn devclass_get_count(dc: devclass_t) -> ::core::ffi::c_int;
    pub fn devclass_get_maxunit(dc: devclass_t) -> ::core::ffi::c_int;
    pub fn devclass_find_free_unit(dc: devclass_t, unit: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn devclass_set_parent(dc: devclass_t, pdc: devclass_t);
    pub fn devclass_get_parent(dc: devclass_t) -> devclass_t;
    pub fn devclass_get_sysctl_ctx(dc: devclass_t) -> *mut sysctl_ctx_list;
    pub fn devclass_get_sysctl_tree(dc: devclass_t) -> *mut sysctl_oid;
    pub fn resource_int_value(
        name: *const ::core::ffi::c_char,
        unit: ::core::ffi::c_int,
        resname: *const ::core::ffi::c_char,
        result: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn resource_long_value(
        name: *const ::core::ffi::c_char,
        unit: ::core::ffi::c_int,
        resname: *const ::core::ffi::c_char,
        result: *mut ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
    pub fn resource_string_value(
        name: *const ::core::ffi::c_char,
        unit: ::core::ffi::c_int,
        resname: *const ::core::ffi::c_char,
        result: *mut *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn resource_disabled(
        name: *const ::core::ffi::c_char,
        unit: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn resource_find_match(
        anchor: *mut ::core::ffi::c_int,
        name: *mut *const ::core::ffi::c_char,
        unit: *mut ::core::ffi::c_int,
        resname: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn resource_find_dev(
        anchor: *mut ::core::ffi::c_int,
        name: *const ::core::ffi::c_char,
        unit: *mut ::core::ffi::c_int,
        resname: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn resource_unset_value(
        name: *const ::core::ffi::c_char,
        unit: ::core::ffi::c_int,
        resname: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn bus_data_generation_check(generation: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn bus_data_generation_update();
    pub fn bus_get_pass() -> ::core::ffi::c_int;
    #[doc = " Routines to lock / unlock the newbus lock.\n Must be taken out to interact with newbus."]
    pub fn bus_topo_lock();
    pub fn bus_topo_unlock();
    pub fn bus_topo_mtx() -> *mut mtx;
    pub fn bus_topo_assert();
    #[doc = " @brief Unique descriptor for the DEVICE_PROBE() method"]
    pub static mut device_probe_desc: kobjop_desc;
    #[doc = " @brief Probe to see if a device matches a driver.\n\n Users should not call this method directly. Normally, this\n is called via device_probe_and_attach() to select a driver\n calling the DEVICE_PROBE() of all candidate drivers and attach\n the winning driver (if any) to the device.\n\n This function is used to match devices to device drivers.\n Typically, the driver will examine the device to see if\n it is suitable for this driver. This might include checking\n the values of various device instance variables or reading\n hardware registers.\n\n In some cases, there may be more than one driver available\n which can be used for a device (for instance there might\n be a generic driver which works for a set of many types of\n device and a more specific driver which works for a subset\n of devices). Because of this, a driver should not assume\n that it will be the driver that attaches to the device even\n if it returns a success status from DEVICE_PROBE(). In particular,\n a driver must free any resources which it allocated during\n the probe before returning. The return value of DEVICE_PROBE()\n is used to elect which driver is used - the driver which returns\n the largest non-error value wins the election and attaches to\n the device. Common non-error values are described in the\n DEVICE_PROBE(9) manual page.\n\n If a driver matches the hardware, it should set the device\n description string using device_set_desc() or\n device_set_desc_copy(). This string is used to generate an\n informative message when DEVICE_ATTACH() is called.\n\n As a special case, if a driver returns zero, the driver election\n is cut short and that driver will attach to the device\n immediately. This should rarely be used.\n\n For example, a probe method for a PCI device driver might look\n like this:\n\n @code\n int\n foo_probe(device_t dev)\n {\n         if (pci_get_vendor(dev) == FOOVENDOR &&\n             pci_get_device(dev) == FOODEVICE) {\n                 device_set_desc(dev, \"Foo device\");\n                 return (BUS_PROBE_DEFAULT);\n         }\n         return (ENXIO);\n }\n @endcode\n\n To include this method in a device driver, use a line like this\n in the driver's method list:\n\n @code\n \tKOBJMETHOD(device_probe, foo_probe)\n @endcode\n\n @param dev\t\tthe device to probe\n\n @retval 0\t\tif this is the only possible driver for this\n\t\t\tdevice\n @retval negative\tif the driver can match this device - the\n\t\t\tleast negative value is used to select the\n\t\t\tdriver\n @retval ENXIO\tif the driver does not match the device\n @retval positive\tif some kind of error was detected during\n\t\t\tthe probe, a regular unix error code should\n\t\t\tbe returned to indicate the type of error\n @see DEVICE_ATTACH(), pci_get_vendor(), pci_get_device()"]
    #[link_name = "DEVICE_PROBE__extern"]
    pub fn DEVICE_PROBE(dev: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the DEVICE_IDENTIFY() method"]
    pub static mut device_identify_desc: kobjop_desc;
    #[doc = " @brief Allow a device driver to detect devices not otherwise enumerated.\n\n The DEVICE_IDENTIFY() method is used by some drivers (e.g. the ISA\n bus driver) to help populate the bus device with a useful set of\n child devices, normally by calling the BUS_ADD_CHILD() method of\n the parent device. For instance, the ISA bus driver uses several\n special drivers, including the isahint driver and the pnp driver to\n create child devices based on configuration hints and PnP bus\n probes respectively.\n\n Many bus drivers which support true plug-and-play do not need to\n use this method at all since child devices can be discovered\n automatically without help from child drivers.\n\n To include this method in a device driver, use a line like this\n in the driver's method list:\n\n @code\n \tKOBJMETHOD(device_identify, foo_identify)\n @endcode\n\n @param driver\tthe driver whose identify method is being called\n @param parent\tthe parent device to use when adding new children"]
    #[link_name = "DEVICE_IDENTIFY__extern"]
    pub fn DEVICE_IDENTIFY(driver: *mut driver_t, parent: device_t);
    #[doc = " @brief Unique descriptor for the DEVICE_ATTACH() method"]
    pub static mut device_attach_desc: kobjop_desc;
    #[doc = " @brief Attach a device to a device driver\n\n Normally only called via device_probe_and_attach(), this is called\n when a driver has succeeded in probing against a device.\n This method should initialise the hardware and allocate other\n system resources (e.g. devfs entries) as required.\n\n To include this method in a device driver, use a line like this\n in the driver's method list:\n\n @code\n \tKOBJMETHOD(device_attach, foo_attach)\n @endcode\n\n @param dev\t\tthe device to probe\n\n @retval 0\t\tsuccess\n @retval non-zero\tif some kind of error was detected during\n\t\t\tthe attach, a regular unix error code should\n\t\t\tbe returned to indicate the type of error\n @see DEVICE_PROBE()"]
    #[link_name = "DEVICE_ATTACH__extern"]
    pub fn DEVICE_ATTACH(dev: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the DEVICE_DETACH() method"]
    pub static mut device_detach_desc: kobjop_desc;
    #[doc = " @brief Detach a driver from a device.\n\n This can be called if the user is replacing the\n driver software or if a device is about to be physically removed\n from the system (e.g. for removable hardware such as USB or PCCARD).\n\n To include this method in a device driver, use a line like this\n in the driver's method list:\n\n @code\n \tKOBJMETHOD(device_detach, foo_detach)\n @endcode\n\n @param dev\t\tthe device to detach\n\n @retval 0\t\tsuccess\n @retval non-zero\tthe detach could not be performed, e.g. if the\n\t\t\tdriver does not support detaching.\n\n @see DEVICE_ATTACH()"]
    #[link_name = "DEVICE_DETACH__extern"]
    pub fn DEVICE_DETACH(dev: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the DEVICE_SHUTDOWN() method"]
    pub static mut device_shutdown_desc: kobjop_desc;
    #[doc = " @brief Called during system shutdown.\n\n This method allows drivers to detect when the system is being shut down.\n Some drivers need to use this to place their hardware in a consistent\n state before rebooting the computer.\n\n To include this method in a device driver, use a line like this\n in the driver's method list:\n\n @code\n \tKOBJMETHOD(device_shutdown, foo_shutdown)\n @endcode"]
    #[link_name = "DEVICE_SHUTDOWN__extern"]
    pub fn DEVICE_SHUTDOWN(dev: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the DEVICE_SUSPEND() method"]
    pub static mut device_suspend_desc: kobjop_desc;
    #[doc = " @brief This is called by the power-management subsystem when a\n suspend has been requested by the user or by some automatic\n mechanism.\n\n This gives drivers a chance to veto the suspend or save their\n configuration before power is removed.\n\n To include this method in a device driver, use a line like this in\n the driver's method list:\n\n @code\n \tKOBJMETHOD(device_suspend, foo_suspend)\n @endcode\n\n @param dev\t\tthe device being suspended\n\n @retval 0\t\tsuccess\n @retval non-zero\tan error occurred while attempting to prepare the\n                      device for suspension\n\n @see DEVICE_RESUME()"]
    #[link_name = "DEVICE_SUSPEND__extern"]
    pub fn DEVICE_SUSPEND(dev: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the DEVICE_RESUME() method"]
    pub static mut device_resume_desc: kobjop_desc;
    #[doc = " @brief This is called when the system resumes after a suspend.\n\n To include this method in a device driver, use a line like this\n in the driver's method list:\n\n @code\n \tKOBJMETHOD(device_resume, foo_resume)\n @endcode\n\n @param dev\t\tthe device being resumed\n\n @retval 0\t\tsuccess\n @retval non-zero\tan error occurred while attempting to restore the\n                      device from suspension\n\n @see DEVICE_SUSPEND()"]
    #[link_name = "DEVICE_RESUME__extern"]
    pub fn DEVICE_RESUME(dev: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the DEVICE_QUIESCE() method"]
    pub static mut device_quiesce_desc: kobjop_desc;
    #[doc = " @brief This is called when the driver is asked to quiesce itself.\n\n The driver should arrange for the orderly shutdown of this device.\n All further access to the device should be curtailed.  Soon there\n will be a request to detach, but there won't necessarily be one.\n\n To include this method in a device driver, use a line like this\n in the driver's method list:\n\n @code\n \tKOBJMETHOD(device_quiesce, foo_quiesce)\n @endcode\n\n @param dev\t\tthe device being quiesced\n\n @retval 0\t\tsuccess\n @retval non-zero\tan error occurred while attempting to quiesce the\n                      device\n\n @see DEVICE_DETACH()"]
    #[link_name = "DEVICE_QUIESCE__extern"]
    pub fn DEVICE_QUIESCE(dev: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the DEVICE_REGISTER() method"]
    pub static mut device_register_desc: kobjop_desc;
    #[doc = " @brief This is called when the driver is asked to register handlers.\n\n\n To include this method in a device driver, use a line like this\n in the driver's method list:\n\n @code\n \tKOBJMETHOD(device_register, foo_register)\n @endcode\n\n @param dev\t\tthe device for which handlers are being registered\n\n @retval NULL     method not implemented\n @retval non-NULL\ta pointer to implementation specific static driver state\n"]
    #[link_name = "DEVICE_REGISTER__extern"]
    pub fn DEVICE_REGISTER(dev: device_t) -> *mut ::core::ffi::c_void;
    #[doc = " @brief Unique descriptor for the BUS_PRINT_CHILD() method"]
    pub static mut bus_print_child_desc: kobjop_desc;
    #[doc = " @brief Print a description of a child device\n\n This is called from system code which prints out a description of a\n device. It should describe the attachment that the child has with\n the parent. For instance the TurboLaser bus prints which node the\n device is attached to. See bus_generic_print_child() for more\n information.\n\n @param _dev\t\tthe device whose child is being printed\n @param _child\tthe child device to describe\n\n @returns\t\tthe number of characters output."]
    #[link_name = "BUS_PRINT_CHILD__extern"]
    pub fn BUS_PRINT_CHILD(_dev: device_t, _child: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_PROBE_NOMATCH() method"]
    pub static mut bus_probe_nomatch_desc: kobjop_desc;
    #[doc = " @brief Print a notification about an unprobed child device.\n\n Called for each child device that did not succeed in probing for a\n driver.\n\n @param _dev\t\tthe device whose child was being probed\n @param _child\tthe child device which failed to probe"]
    #[link_name = "BUS_PROBE_NOMATCH__extern"]
    pub fn BUS_PROBE_NOMATCH(_dev: device_t, _child: device_t);
    #[doc = " @brief Unique descriptor for the BUS_READ_IVAR() method"]
    pub static mut bus_read_ivar_desc: kobjop_desc;
    #[doc = " @brief Read the value of a bus-specific attribute of a device\n\n This method, along with BUS_WRITE_IVAR() manages a bus-specific set\n of instance variables of a child device.  The intention is that\n each different type of bus defines a set of appropriate instance\n variables (such as ports and irqs for ISA bus etc.)\n\n This information could be given to the child device as a struct but\n that makes it hard for a bus to add or remove variables without\n forcing an edit and recompile for all drivers which may not be\n possible for vendor supplied binary drivers.\n\n This method copies the value of an instance variable to the\n location specified by @p *_result.\n\n @param _dev\t\tthe device whose child was being examined\n @param _child\tthe child device whose instance variable is\n\t\t\tbeing read\n @param _index\tthe instance variable to read\n @param _result\ta location to receive the instance variable\n\t\t\tvalue\n\n @retval 0\t\tsuccess\n @retval ENOENT\tno such instance variable is supported by @p\n\t\t\t_dev"]
    #[link_name = "BUS_READ_IVAR__extern"]
    pub fn BUS_READ_IVAR(
        _dev: device_t,
        _child: device_t,
        _index: ::core::ffi::c_int,
        _result: *mut usize,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_WRITE_IVAR() method"]
    pub static mut bus_write_ivar_desc: kobjop_desc;
    #[doc = " @brief Write the value of a bus-specific attribute of a device\n\n This method sets the value of an instance variable to @p _value.\n\n @param _dev\t\tthe device whose child was being updated\n @param _child\tthe child device whose instance variable is\n\t\t\tbeing written\n @param _index\tthe instance variable to write\n @param _value\tthe value to write to that instance variable\n\n @retval 0\t\tsuccess\n @retval ENOENT\tno such instance variable is supported by @p\n\t\t\t_dev\n @retval EINVAL\tthe instance variable was recognised but\n\t\t\tcontains a read-only value"]
    #[link_name = "BUS_WRITE_IVAR__extern"]
    pub fn BUS_WRITE_IVAR(
        _dev: device_t,
        _child: device_t,
        _indx: ::core::ffi::c_int,
        _value: usize,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_CHILD_DELETED() method"]
    pub static mut bus_child_deleted_desc: kobjop_desc;
    #[doc = " @brief Notify a bus that a child was deleted\n\n Called at the beginning of device_delete_child() to allow the parent\n to teardown any bus-specific state for the child.\n\n @param _dev\t\tthe device whose child is being deleted\n @param _child\tthe child device which is being deleted"]
    #[link_name = "BUS_CHILD_DELETED__extern"]
    pub fn BUS_CHILD_DELETED(_dev: device_t, _child: device_t);
    #[doc = " @brief Unique descriptor for the BUS_CHILD_DETACHED() method"]
    pub static mut bus_child_detached_desc: kobjop_desc;
    #[doc = " @brief Notify a bus that a child was detached\n\n Called after the child's DEVICE_DETACH() method to allow the parent\n to reclaim any resources allocated on behalf of the child.\n\n @param _dev\t\tthe device whose child changed state\n @param _child\tthe child device which changed state"]
    #[link_name = "BUS_CHILD_DETACHED__extern"]
    pub fn BUS_CHILD_DETACHED(_dev: device_t, _child: device_t);
    #[doc = " @brief Unique descriptor for the BUS_DRIVER_ADDED() method"]
    pub static mut bus_driver_added_desc: kobjop_desc;
    #[doc = " @brief Notify a bus that a new driver was added\n\n Called when a new driver is added to the devclass which owns this\n bus. The generic implementation of this method attempts to probe and\n attach any un-matched children of the bus.\n\n @param _dev\t\tthe device whose devclass had a new driver\n\t\t\tadded to it\n @param _driver\tthe new driver which was added"]
    #[link_name = "BUS_DRIVER_ADDED__extern"]
    pub fn BUS_DRIVER_ADDED(_dev: device_t, _driver: *mut driver_t);
    #[doc = " @brief Unique descriptor for the BUS_ADD_CHILD() method"]
    pub static mut bus_add_child_desc: kobjop_desc;
    #[doc = " @brief Create a new child device\n\n For buses which use use drivers supporting DEVICE_IDENTIFY() to\n enumerate their devices, this method is used to create new\n device instances. The new device will be added after the last\n existing child with the same order. Implementations of bus_add_child\n call device_add_child_ordered to add the child and often add\n a suitable ivar to the device specific to that bus.\n\n @param _dev\t\tthe bus device which will be the parent of the\n\t\t\tnew child device\n @param _order\ta value which is used to partially sort the\n\t\t\tchildren of @p _dev - devices created using\n\t\t\tlower values of @p _order appear first in @p\n\t\t\t_dev's list of children\n @param _name\t\tdevclass name for new device or @c NULL if not\n\t\t\tspecified\n @param _unit\t\tunit number for new device or @c -1 if not\n\t\t\tspecified"]
    #[link_name = "BUS_ADD_CHILD__extern"]
    pub fn BUS_ADD_CHILD(
        _dev: device_t,
        _order: u_int,
        _name: *const ::core::ffi::c_char,
        _unit: ::core::ffi::c_int,
    ) -> device_t;
    #[doc = " @brief Unique descriptor for the BUS_RESCAN() method"]
    pub static mut bus_rescan_desc: kobjop_desc;
    #[doc = " @brief Rescan the bus\n\n This method is called by a parent bridge or devctl to trigger a bus\n rescan.  The rescan should delete devices no longer present and\n enumerate devices that have newly arrived.\n\n @param _dev\t\tthe bus device"]
    #[link_name = "BUS_RESCAN__extern"]
    pub fn BUS_RESCAN(_dev: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_ALLOC_RESOURCE() method"]
    pub static mut bus_alloc_resource_desc: kobjop_desc;
    #[doc = " @brief Allocate a system resource\n\n This method is called by child devices of a bus to allocate resources.\n The types are defined in <machine/resource.h>; the meaning of the\n resource-ID field varies from bus to bus (but @p *rid == 0 is always\n valid if the resource type is). If a resource was allocated and the\n caller did not use the RF_ACTIVE to specify that it should be\n activated immediately, the caller is responsible for calling\n BUS_ACTIVATE_RESOURCE() when it actually uses the resource.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which is requesting an allocation\n @param _type\t\tthe type of resource to allocate\n @param _rid\t\ta pointer to the resource identifier\n @param _start\thint at the start of the resource range - pass\n\t\t\t@c 0 for any start address\n @param _end\t\thint at the end of the resource range - pass\n\t\t\t@c ~0 for any end address\n @param _count\thint at the size of range required - pass @c 1\n\t\t\tfor any size\n @param _flags\tany extra flags to control the resource\n\t\t\tallocation - see @c RF_XXX flags in\n\t\t\t<sys/rman.h> for details\n\n @returns\t\tthe resource which was allocated or @c NULL if no\n\t\t\tresource could be allocated"]
    #[link_name = "BUS_ALLOC_RESOURCE__extern"]
    pub fn BUS_ALLOC_RESOURCE(
        _dev: device_t,
        _child: device_t,
        _type: ::core::ffi::c_int,
        _rid: *mut ::core::ffi::c_int,
        _start: rman_res_t,
        _end: rman_res_t,
        _count: rman_res_t,
        _flags: u_int,
    ) -> *mut resource;
    #[doc = " @brief Unique descriptor for the BUS_ACTIVATE_RESOURCE() method"]
    pub static mut bus_activate_resource_desc: kobjop_desc;
    #[doc = " @brief Activate a resource\n\n Activate a resource previously allocated with\n BUS_ALLOC_RESOURCE().  This may enable decoding of this resource in a\n device for instance.  It will also establish a mapping for the resource\n unless RF_UNMAPPED was set when allocating the resource.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which allocated the resource\n @param _r\t\tthe resource to activate"]
    #[link_name = "BUS_ACTIVATE_RESOURCE__extern"]
    pub fn BUS_ACTIVATE_RESOURCE(
        _dev: device_t,
        _child: device_t,
        _r: *mut resource,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_MAP_RESOURCE() method"]
    pub static mut bus_map_resource_desc: kobjop_desc;
    #[doc = " @brief Map a resource\n\n Allocate a mapping for a range of an active resource.  The mapping\n is described by a struct resource_map object.  This may for instance\n map a memory region into the kernel's virtual address space.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which allocated the resource\n @param _r\t\tthe resource to map\n @param _args\t\toptional attributes of the mapping\n @param _map\t\tthe mapping"]
    #[link_name = "BUS_MAP_RESOURCE__extern"]
    pub fn BUS_MAP_RESOURCE(
        _dev: device_t,
        _child: device_t,
        _r: *mut resource,
        _args: *mut resource_map_request,
        _map: *mut resource_map,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_UNMAP_RESOURCE() method"]
    pub static mut bus_unmap_resource_desc: kobjop_desc;
    #[doc = " @brief Unmap a resource\n\n Release a mapping previously allocated with\n BUS_MAP_RESOURCE(). This may for instance unmap a memory region\n from the kernel's virtual address space.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which allocated the resource\n @param _r\t\tthe resource\n @param _map\t\tthe mapping to release"]
    #[link_name = "BUS_UNMAP_RESOURCE__extern"]
    pub fn BUS_UNMAP_RESOURCE(
        _dev: device_t,
        _child: device_t,
        _r: *mut resource,
        _map: *mut resource_map,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_DEACTIVATE_RESOURCE() method"]
    pub static mut bus_deactivate_resource_desc: kobjop_desc;
    #[doc = " @brief Deactivate a resource\n\n Deactivate a resource previously allocated with\n BUS_ALLOC_RESOURCE().\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which allocated the resource\n @param _r\t\tthe resource to deactivate"]
    #[link_name = "BUS_DEACTIVATE_RESOURCE__extern"]
    pub fn BUS_DEACTIVATE_RESOURCE(
        _dev: device_t,
        _child: device_t,
        _r: *mut resource,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_ADJUST_RESOURCE() method"]
    pub static mut bus_adjust_resource_desc: kobjop_desc;
    #[doc = " @brief Adjust a resource\n\n Adjust the start and/or end of a resource allocated by\n BUS_ALLOC_RESOURCE.  At least part of the new address range must overlap\n with the existing address range.  If the successful, the resource's range\n will be adjusted to [start, end] on return.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which allocated the resource\n @param _res\t\tthe resource to adjust\n @param _start\tthe new starting address of the resource range\n @param _end\t\tthe new ending address of the resource range"]
    #[link_name = "BUS_ADJUST_RESOURCE__extern"]
    pub fn BUS_ADJUST_RESOURCE(
        _dev: device_t,
        _child: device_t,
        _res: *mut resource,
        _start: rman_res_t,
        _end: rman_res_t,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_TRANSLATE_RESOURCE() method"]
    pub static mut bus_translate_resource_desc: kobjop_desc;
    #[doc = " @brief translate a resource value\n\n Give a bus driver the opportunity to translate resource ranges.  If\n successful, the host's view of the resource starting at @p _start is\n returned in @p _newstart, otherwise an error is returned.\n\n @param _dev\t\tthe device associated with the resource\n @param _type\t\tthe type of resource\n @param _start\tthe starting address of the resource range\n @param _newstart\tthe new starting address of the resource range"]
    #[link_name = "BUS_TRANSLATE_RESOURCE__extern"]
    pub fn BUS_TRANSLATE_RESOURCE(
        _dev: device_t,
        _type: ::core::ffi::c_int,
        _start: rman_res_t,
        _newstart: *mut rman_res_t,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_RELEASE_RESOURCE() method"]
    pub static mut bus_release_resource_desc: kobjop_desc;
    #[doc = " @brief Release a resource\n\n Free a resource allocated by the BUS_ALLOC_RESOURCE.  The @p _rid\n value must be the same as the one returned by BUS_ALLOC_RESOURCE()\n (which is not necessarily the same as the one the client passed).\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which allocated the resource\n @param _r\t\tthe resource to release"]
    #[link_name = "BUS_RELEASE_RESOURCE__extern"]
    pub fn BUS_RELEASE_RESOURCE(
        _dev: device_t,
        _child: device_t,
        _res: *mut resource,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_SETUP_INTR() method"]
    pub static mut bus_setup_intr_desc: kobjop_desc;
    #[doc = " @brief Install an interrupt handler\n\n This method is used to associate an interrupt handler function with\n an irq resource. When the interrupt triggers, the function @p _intr\n will be called with the value of @p _arg as its single\n argument. The value returned in @p *_cookiep is used to cancel the\n interrupt handler - the caller should save this value to use in a\n future call to BUS_TEARDOWN_INTR().\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which allocated the resource\n @param _irq\t\tthe resource representing the interrupt\n @param _flags\ta set of bits from enum intr_type specifying\n\t\t\tthe class of interrupt\n @param _intr\t\tthe function to call when the interrupt\n\t\t\ttriggers\n @param _arg\t\ta value to use as the single argument in calls\n\t\t\tto @p _intr\n @param _cookiep\ta pointer to a location to receive a cookie\n\t\t\tvalue that may be used to remove the interrupt\n\t\t\thandler"]
    #[link_name = "BUS_SETUP_INTR__extern"]
    pub fn BUS_SETUP_INTR(
        _dev: device_t,
        _child: device_t,
        _irq: *mut resource,
        _flags: ::core::ffi::c_int,
        _filter: driver_filter_t,
        _intr: driver_intr_t,
        _arg: *mut ::core::ffi::c_void,
        _cookiep: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_TEARDOWN_INTR() method"]
    pub static mut bus_teardown_intr_desc: kobjop_desc;
    #[doc = " @brief Uninstall an interrupt handler\n\n This method is used to disassociate an interrupt handler function\n with an irq resource. The value of @p _cookie must be the value\n returned from a previous call to BUS_SETUP_INTR().\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which allocated the resource\n @param _irq\t\tthe resource representing the interrupt\n @param _cookie\tthe cookie value returned when the interrupt\n\t\t\twas originally registered"]
    #[link_name = "BUS_TEARDOWN_INTR__extern"]
    pub fn BUS_TEARDOWN_INTR(
        _dev: device_t,
        _child: device_t,
        _irq: *mut resource,
        _cookie: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_SUSPEND_INTR() method"]
    pub static mut bus_suspend_intr_desc: kobjop_desc;
    #[doc = " @brief Suspend an interrupt handler\n\n This method is used to mark a handler as suspended in the case\n that the associated device is powered down and cannot be a source\n for the, typically shared, interrupt.\n The value of @p _irq must be the interrupt resource passed\n to a previous call to BUS_SETUP_INTR().\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which allocated the resource\n @param _irq\t\tthe resource representing the interrupt"]
    #[link_name = "BUS_SUSPEND_INTR__extern"]
    pub fn BUS_SUSPEND_INTR(
        _dev: device_t,
        _child: device_t,
        _irq: *mut resource,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_RESUME_INTR() method"]
    pub static mut bus_resume_intr_desc: kobjop_desc;
    #[doc = " @brief Resume an interrupt handler\n\n This method is used to clear suspended state of a handler when\n the associated device is powered up and can be an interrupt source\n again.\n The value of @p _irq must be the interrupt resource passed\n to a previous call to BUS_SETUP_INTR().\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which allocated the resource\n @param _irq\t\tthe resource representing the interrupt"]
    #[link_name = "BUS_RESUME_INTR__extern"]
    pub fn BUS_RESUME_INTR(
        _dev: device_t,
        _child: device_t,
        _irq: *mut resource,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_SET_RESOURCE() method"]
    pub static mut bus_set_resource_desc: kobjop_desc;
    #[doc = " @brief Define a resource which can be allocated with\n BUS_ALLOC_RESOURCE().\n\n This method is used by some buses (typically ISA) to allow a\n driver to describe a resource range that it would like to\n allocate. The resource defined by @p _type and @p _rid is defined\n to start at @p _start and to include @p _count indices in its\n range.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which owns the resource\n @param _type\t\tthe type of resource\n @param _rid\t\tthe resource identifier\n @param _start\tthe start of the resource range\n @param _count\tthe size of the resource range"]
    #[link_name = "BUS_SET_RESOURCE__extern"]
    pub fn BUS_SET_RESOURCE(
        _dev: device_t,
        _child: device_t,
        _type: ::core::ffi::c_int,
        _rid: ::core::ffi::c_int,
        _start: rman_res_t,
        _count: rman_res_t,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_GET_RESOURCE() method"]
    pub static mut bus_get_resource_desc: kobjop_desc;
    #[doc = " @brief Describe a resource\n\n This method allows a driver to examine the range used for a given\n resource without actually allocating it.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which owns the resource\n @param _type\t\tthe type of resource\n @param _rid\t\tthe resource identifier\n @param _start\tthe address of a location to receive the start\n\t\t\tindex of the resource range\n @param _count\tthe address of a location to receive the size\n\t\t\tof the resource range"]
    #[link_name = "BUS_GET_RESOURCE__extern"]
    pub fn BUS_GET_RESOURCE(
        _dev: device_t,
        _child: device_t,
        _type: ::core::ffi::c_int,
        _rid: ::core::ffi::c_int,
        _startp: *mut rman_res_t,
        _countp: *mut rman_res_t,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_DELETE_RESOURCE() method"]
    pub static mut bus_delete_resource_desc: kobjop_desc;
    #[doc = " @brief Delete a resource.\n\n Use this to delete a resource (possibly one previously added with\n BUS_SET_RESOURCE()).\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which owns the resource\n @param _type\t\tthe type of resource\n @param _rid\t\tthe resource identifier"]
    #[link_name = "BUS_DELETE_RESOURCE__extern"]
    pub fn BUS_DELETE_RESOURCE(
        _dev: device_t,
        _child: device_t,
        _type: ::core::ffi::c_int,
        _rid: ::core::ffi::c_int,
    );
    #[doc = " @brief Unique descriptor for the BUS_GET_RESOURCE_LIST() method"]
    pub static mut bus_get_resource_list_desc: kobjop_desc;
    #[doc = " @brief Return a struct resource_list.\n\n Used by drivers which use bus_generic_rl_alloc_resource() etc. to\n implement their resource handling. It should return the resource\n list of the given child device.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which owns the resource list"]
    #[link_name = "BUS_GET_RESOURCE_LIST__extern"]
    pub fn BUS_GET_RESOURCE_LIST(_dev: device_t, _child: device_t) -> *mut resource_list;
    #[doc = " @brief Unique descriptor for the BUS_GET_RMAN() method"]
    pub static mut bus_get_rman_desc: kobjop_desc;
    #[doc = " @brief Return a struct rman.\n\n Used by drivers which use bus_generic_rman_alloc_resource() etc. to\n implement their resource handling. It should return the resource\n manager used for the given resource type.\n\n @param _dev\t\tthe bus device\n @param _type\t\tthe resource type\n @param _flags\tresource flags (@c RF_XXX flags in\n\t\t\t<sys/rman.h>)"]
    #[link_name = "BUS_GET_RMAN__extern"]
    pub fn BUS_GET_RMAN(_dev: device_t, _type: ::core::ffi::c_int, _flags: u_int) -> *mut rman;
    #[doc = " @brief Unique descriptor for the BUS_CHILD_PRESENT() method"]
    pub static mut bus_child_present_desc: kobjop_desc;
    #[doc = " @brief Is the hardware described by @p _child still attached to the\n system?\n\n This method should return 0 if the device is not present.  It\n should return -1 if it is present.  Any errors in determining\n should be returned as a normal errno value.  Client drivers are to\n assume that the device is present, even if there is an error\n determining if it is there.  Buses are to try to avoid returning\n errors, but newcard will return an error if the device fails to\n implement this method.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which is being examined"]
    #[link_name = "BUS_CHILD_PRESENT__extern"]
    pub fn BUS_CHILD_PRESENT(_dev: device_t, _child: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_CHILD_PNPINFO() method"]
    pub static mut bus_child_pnpinfo_desc: kobjop_desc;
    #[doc = " @brief Returns the pnp info for this device.\n\n Return it as a string, appended to @p _sb\n\n The string must be formatted as a space-separated list of\n name=value pairs.  Names may only contain alphanumeric characters,\n underscores ('_') and hyphens ('-').  Values can contain any\n non-whitespace characters.  Values containing whitespace can be\n quoted with double quotes ('\"').  Double quotes and backslashes in\n quoted values can be escaped with backslashes ('\\').\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which is being examined\n @param _sb\t\tsbuf for results string"]
    #[link_name = "BUS_CHILD_PNPINFO__extern"]
    pub fn BUS_CHILD_PNPINFO(
        _dev: device_t,
        _child: device_t,
        _sb: *mut sbuf,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_CHILD_LOCATION() method"]
    pub static mut bus_child_location_desc: kobjop_desc;
    #[doc = " @brief Returns the location for this device.\n\n Return it as a string, appended to @p _sb\n\n The string must be formatted as a space-separated list of\n name=value pairs.  Names may only contain alphanumeric characters,\n underscores ('_') and hyphens ('-').  Values can contain any\n non-whitespace characters.  Values containing whitespace can be\n quoted with double quotes ('\"').  Double quotes and backslashes in\n quoted values can be escaped with backslashes ('\\').\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which is being examined\n @param _sb\t\tsbuf for results string"]
    #[link_name = "BUS_CHILD_LOCATION__extern"]
    pub fn BUS_CHILD_LOCATION(
        _dev: device_t,
        _child: device_t,
        _sb: *mut sbuf,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_BIND_INTR() method"]
    pub static mut bus_bind_intr_desc: kobjop_desc;
    #[doc = " @brief Allow drivers to request that an interrupt be bound to a specific\n CPU.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which allocated the resource\n @param _irq\t\tthe resource representing the interrupt\n @param _cpu\t\tthe CPU to bind the interrupt to"]
    #[link_name = "BUS_BIND_INTR__extern"]
    pub fn BUS_BIND_INTR(
        _dev: device_t,
        _child: device_t,
        _irq: *mut resource,
        _cpu: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_CONFIG_INTR() method"]
    pub static mut bus_config_intr_desc: kobjop_desc;
    #[doc = " @brief Allow (bus) drivers to specify the trigger mode and polarity\n of the specified interrupt.\n\n @param _dev\t\tthe bus device\n @param _irq\t\tthe interrupt number to modify\n @param _trig\t\tthe trigger mode required\n @param _pol\t\tthe interrupt polarity required"]
    #[link_name = "BUS_CONFIG_INTR__extern"]
    pub fn BUS_CONFIG_INTR(
        _dev: device_t,
        _irq: ::core::ffi::c_int,
        _trig: intr_trigger,
        _pol: intr_polarity,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_DESCRIBE_INTR() method"]
    pub static mut bus_describe_intr_desc: kobjop_desc;
    #[doc = " @brief Allow drivers to associate a description with an active\n interrupt handler.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device which allocated the resource\n @param _irq\t\tthe resource representing the interrupt\n @param _cookie\tthe cookie value returned when the interrupt\n\t\t\twas originally registered\n @param _descr\tthe description to associate with the interrupt"]
    #[link_name = "BUS_DESCRIBE_INTR__extern"]
    pub fn BUS_DESCRIBE_INTR(
        _dev: device_t,
        _child: device_t,
        _irq: *mut resource,
        _cookie: *mut ::core::ffi::c_void,
        _descr: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_HINTED_CHILD() method"]
    pub static mut bus_hinted_child_desc: kobjop_desc;
    #[doc = " @brief Notify a (bus) driver about a child that the hints mechanism\n believes it has discovered.\n\n The bus is responsible for then adding the child in the right order\n and discovering other things about the child.  The bus driver is\n free to ignore this hint, to do special things, etc.  It is all up\n to the bus driver to interpret.\n\n This method is only called in response to the parent bus asking for\n hinted devices to be enumerated.\n\n @param _dev\t\tthe bus device\n @param _dname\tthe name of the device w/o unit numbers\n @param _dunit\tthe unit number of the device"]
    #[link_name = "BUS_HINTED_CHILD__extern"]
    pub fn BUS_HINTED_CHILD(
        _dev: device_t,
        _dname: *const ::core::ffi::c_char,
        _dunit: ::core::ffi::c_int,
    );
    #[doc = " @brief Unique descriptor for the BUS_GET_DMA_TAG() method"]
    pub static mut bus_get_dma_tag_desc: kobjop_desc;
    #[doc = " @brief Returns bus_dma_tag_t for use w/ devices on the bus.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device to which the tag will belong"]
    #[link_name = "BUS_GET_DMA_TAG__extern"]
    pub fn BUS_GET_DMA_TAG(_dev: device_t, _child: device_t) -> bus_dma_tag_t;
    #[doc = " @brief Unique descriptor for the BUS_GET_BUS_TAG() method"]
    pub static mut bus_get_bus_tag_desc: kobjop_desc;
    #[doc = " @brief Returns bus_space_tag_t for use w/ devices on the bus.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device to which the tag will belong"]
    #[link_name = "BUS_GET_BUS_TAG__extern"]
    pub fn BUS_GET_BUS_TAG(_dev: device_t, _child: device_t) -> bus_space_tag_t;
    #[doc = " @brief Unique descriptor for the BUS_HINT_DEVICE_UNIT() method"]
    pub static mut bus_hint_device_unit_desc: kobjop_desc;
    #[doc = " @brief Allow the bus to determine the unit number of a device.\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device whose unit is to be wired\n @param _name\t\tthe name of the device's new devclass\n @param _unitp\ta pointer to the device's new unit value"]
    #[link_name = "BUS_HINT_DEVICE_UNIT__extern"]
    pub fn BUS_HINT_DEVICE_UNIT(
        _dev: device_t,
        _child: device_t,
        _name: *const ::core::ffi::c_char,
        _unitp: *mut ::core::ffi::c_int,
    );
    #[doc = " @brief Unique descriptor for the BUS_NEW_PASS() method"]
    pub static mut bus_new_pass_desc: kobjop_desc;
    #[doc = " @brief Notify a bus that the bus pass level has been changed\n\n @param _dev\t\tthe bus device"]
    #[link_name = "BUS_NEW_PASS__extern"]
    pub fn BUS_NEW_PASS(_dev: device_t);
    #[doc = " @brief Unique descriptor for the BUS_REMAP_INTR() method"]
    pub static mut bus_remap_intr_desc: kobjop_desc;
    #[doc = " @brief Notify a bus that specified child's IRQ should be remapped.\n\n @param _dev\t\tthe bus device\n @param _child\tthe child device\n @param _irq\t\tthe irq number"]
    #[link_name = "BUS_REMAP_INTR__extern"]
    pub fn BUS_REMAP_INTR(_dev: device_t, _child: device_t, _irq: u_int) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_SUSPEND_CHILD() method"]
    pub static mut bus_suspend_child_desc: kobjop_desc;
    #[doc = " @brief Suspend a given child\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device to suspend"]
    #[link_name = "BUS_SUSPEND_CHILD__extern"]
    pub fn BUS_SUSPEND_CHILD(_dev: device_t, _child: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_RESUME_CHILD() method"]
    pub static mut bus_resume_child_desc: kobjop_desc;
    #[doc = " @brief Resume a given child\n\n @param _dev\t\tthe parent device of @p _child\n @param _child\tthe device to resume"]
    #[link_name = "BUS_RESUME_CHILD__extern"]
    pub fn BUS_RESUME_CHILD(_dev: device_t, _child: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_GET_DOMAIN() method"]
    pub static mut bus_get_domain_desc: kobjop_desc;
    #[doc = " @brief Get the VM domain handle for the given bus and child.\n\n @param _dev\t\tthe bus device\n @param _child\tthe child device\n @param _domain\ta pointer to the bus's domain handle identifier"]
    #[link_name = "BUS_GET_DOMAIN__extern"]
    pub fn BUS_GET_DOMAIN(
        _dev: device_t,
        _child: device_t,
        _domain: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_GET_CPUS() method"]
    pub static mut bus_get_cpus_desc: kobjop_desc;
    #[doc = " @brief Request a set of CPUs\n\n @param _dev\t\tthe bus device\n @param _child\tthe child device\n @param _op\t\ttype of CPUs to request\n @param _setsize\tthe size of the set passed in _cpuset\n @param _cpuset\ta pointer to a cpuset to receive the requested\n\t\t\tset of CPUs"]
    #[link_name = "BUS_GET_CPUS__extern"]
    pub fn BUS_GET_CPUS(
        _dev: device_t,
        _child: device_t,
        _op: cpu_sets,
        _setsize: usize,
        _cpuset: *mut _cpuset,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_RESET_PREPARE() method"]
    pub static mut bus_reset_prepare_desc: kobjop_desc;
    #[doc = " @brief Prepares the given child of the bus for reset\n\n Typically bus detaches or suspends children' drivers, and then\n calls this method to save bus-specific information, for instance,\n PCI config space, which is damaged by reset.\n\n The bus_helper_reset_prepare() helper is provided to ease\n implementing bus reset methods.\n\n @param _dev\t\tthe bus device\n @param _child\tthe child device"]
    #[link_name = "BUS_RESET_PREPARE__extern"]
    pub fn BUS_RESET_PREPARE(_dev: device_t, _child: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_RESET_POST() method"]
    pub static mut bus_reset_post_desc: kobjop_desc;
    #[doc = " @brief Restores the child operations after the reset\n\n The bus_helper_reset_post() helper is provided to ease\n implementing bus reset methods.\n\n @param _dev\t\tthe bus device\n @param _child\tthe child device"]
    #[link_name = "BUS_RESET_POST__extern"]
    pub fn BUS_RESET_POST(_dev: device_t, _child: device_t) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_RESET_CHILD() method"]
    pub static mut bus_reset_child_desc: kobjop_desc;
    #[doc = " @brief Performs reset of the child\n\n @param _dev\t\tthe bus device\n @param _child\tthe child device\n @param _flags\tDEVF_RESET_ flags"]
    #[link_name = "BUS_RESET_CHILD__extern"]
    pub fn BUS_RESET_CHILD(
        _dev: device_t,
        _child: device_t,
        _flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the BUS_GET_PROPERTY() method"]
    pub static mut bus_get_property_desc: kobjop_desc;
    #[doc = " @brief Gets child's specific property\n\n The bus_get_property can be used to access device\n specific properties stored on the bus. If _propvalue\n is NULL or _size is 0, then method only returns size\n of the property.\n\n @param _dev\t\t\tthe bus device\n @param _child\t\tthe child device\n @param _propname\t\tproperty name\n @param _propvalue\tproperty value destination\n @param _size\t\t\tproperty value size\n\n @returns size of property if successful otherwise -1"]
    #[link_name = "BUS_GET_PROPERTY__extern"]
    pub fn BUS_GET_PROPERTY(
        _dev: device_t,
        _child: device_t,
        _propname: *const ::core::ffi::c_char,
        _propvalue: *mut ::core::ffi::c_void,
        _size: usize,
        type_: device_property_type_t,
    ) -> isize;
    #[doc = " @brief Unique descriptor for the BUS_GET_DEVICE_PATH() method"]
    pub static mut bus_get_device_path_desc: kobjop_desc;
    #[doc = " @brief Gets a child's full path to the device\n\n The get_device_path method retrieves a device's\n full path to the device using one of several\n locators present in the system.\n\n @param _bus\t\t\tthe bus device\n @param _child\t\tthe child device\n @param _locator\t\tlocator name\n @param _sb\t\t\tbuffer loaction string"]
    #[link_name = "BUS_GET_DEVICE_PATH__extern"]
    pub fn BUS_GET_DEVICE_PATH(
        _bus: device_t,
        _child: device_t,
        _locator: *const ::core::ffi::c_char,
        _sb: *mut sbuf,
    ) -> ::core::ffi::c_int;
    pub fn driver_module_handler(
        arg1: *mut module,
        arg2: ::core::ffi::c_int,
        arg3: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn dev_wired_cache_init() -> *mut device_location_cache_t;
    pub fn dev_wired_cache_fini(dcp: *mut device_location_cache_t);
    pub fn dev_wired_cache_match(
        dcp: *mut device_location_cache_t,
        dev: device_t,
        at: *const ::core::ffi::c_char,
    ) -> bool_;
    pub fn device_set_prop(
        dev: device_t,
        name: *const ::core::ffi::c_char,
        val: *mut ::core::ffi::c_void,
        dtr: device_prop_dtr_t,
        dtr_ctx: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn device_get_prop(
        dev: device_t,
        name: *const ::core::ffi::c_char,
        valp: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn device_clear_prop(dev: device_t, name: *const ::core::ffi::c_char)
    -> ::core::ffi::c_int;
    pub fn device_clear_prop_alldev(name: *const ::core::ffi::c_char);
    pub static mut cpusetsizemin: u_int;
    pub static mut cpuset_root: *mut cpuset_t;
    pub fn cpuset_thread0() -> *mut cpuset;
    pub fn cpuset_ref(arg1: *mut cpuset) -> *mut cpuset;
    pub fn cpuset_rel(arg1: *mut cpuset);
    pub fn cpuset_setthread(id: lwpid_t, arg1: *mut cpuset_t) -> ::core::ffi::c_int;
    pub fn cpuset_setithread(id: lwpid_t, cpu: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn cpuset_create_root(arg1: *mut prison, arg2: *mut *mut cpuset) -> ::core::ffi::c_int;
    pub fn cpuset_setproc_update_set(arg1: *mut proc_, arg2: *mut cpuset) -> ::core::ffi::c_int;
    pub fn cpuset_which(
        arg1: cpuwhich_t,
        arg2: id_t,
        arg3: *mut *mut proc_,
        arg4: *mut *mut thread,
        arg5: *mut *mut cpuset,
    ) -> ::core::ffi::c_int;
    pub fn cpuset_kernthread(arg1: *mut thread);
    pub fn cpusetobj_strprint(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const cpuset_t,
    ) -> *mut ::core::ffi::c_char;
    pub fn cpusetobj_strscan(
        arg1: *mut cpuset_t,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub static mut M_CACHE: [malloc_type; 1usize];
    pub static mut M_DEVBUF: [malloc_type; 1usize];
    pub static mut M_PARGS: [malloc_type; 1usize];
    pub static mut M_SESSION: [malloc_type; 1usize];
    pub static mut M_SUBPROC: [malloc_type; 1usize];
    pub static mut M_TEMP: [malloc_type; 1usize];
    pub static mut M_IOV: [malloc_type; 1usize];
    pub static mut malloc_mtx: mtx;
    pub fn contigfree(
        addr: *mut ::core::ffi::c_void,
        arg1: ::core::ffi::c_ulong,
        type_: *mut malloc_type,
    );
    pub fn contigmalloc(
        size: ::core::ffi::c_ulong,
        type_: *mut malloc_type,
        flags: ::core::ffi::c_int,
        low: vm_paddr_t,
        high: vm_paddr_t,
        alignment: ::core::ffi::c_ulong,
        boundary: vm_paddr_t,
    ) -> *mut ::core::ffi::c_void;
    pub fn contigmalloc_domainset(
        size: ::core::ffi::c_ulong,
        type_: *mut malloc_type,
        ds: *mut domainset,
        flags: ::core::ffi::c_int,
        low: vm_paddr_t,
        high: vm_paddr_t,
        alignment: ::core::ffi::c_ulong,
        boundary: vm_paddr_t,
    ) -> *mut ::core::ffi::c_void;
    pub fn free(addr: *mut ::core::ffi::c_void, type_: *mut malloc_type);
    pub fn zfree(addr: *mut ::core::ffi::c_void, type_: *mut malloc_type);
    pub fn malloc(
        size: usize,
        type_: *mut malloc_type,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn malloc_domainset(
        size: usize,
        type_: *mut malloc_type,
        ds: *mut domainset,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn mallocarray(
        nmemb: usize,
        size: usize,
        type_: *mut malloc_type,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn mallocarray_domainset(
        nmemb: usize,
        size: usize,
        type_: *mut malloc_type,
        ds: *mut domainset,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn malloc_exec(
        size: usize,
        type_: *mut malloc_type,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn malloc_domainset_exec(
        size: usize,
        type_: *mut malloc_type,
        ds: *mut domainset,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn malloc_init(arg1: *mut ::core::ffi::c_void);
    pub fn malloc_type_allocated(type_: *mut malloc_type, size: ::core::ffi::c_ulong);
    pub fn malloc_type_freed(type_: *mut malloc_type, size: ::core::ffi::c_ulong);
    pub fn malloc_type_list(arg1: malloc_type_list_func_t, arg2: *mut ::core::ffi::c_void);
    pub fn malloc_uninit(arg1: *mut ::core::ffi::c_void);
    pub fn malloc_size(arg1: usize) -> usize;
    pub fn malloc_usable_size(arg1: *const ::core::ffi::c_void) -> usize;
    pub fn realloc(
        addr: *mut ::core::ffi::c_void,
        size: usize,
        type_: *mut malloc_type,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn reallocf(
        addr: *mut ::core::ffi::c_void,
        size: usize,
        type_: *mut malloc_type,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn malloc_aligned(
        size: usize,
        align: usize,
        type_: *mut malloc_type,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn malloc_domainset_aligned(
        size: usize,
        align: usize,
        mtp: *mut malloc_type,
        ds: *mut domainset,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn malloc_desc2type(desc: *const ::core::ffi::c_char) -> *mut malloc_type;
    #[link_name = "WOULD_OVERFLOW__extern"]
    pub fn WOULD_OVERFLOW(nmemb: usize, size: usize) -> bool_;
    pub fn vm_ksubmap_init(arg1: *mut kva_md_info);
    pub fn swap_reserve(incr: vm_ooffset_t) -> bool_;
    pub fn swap_reserve_by_cred(incr: vm_ooffset_t, cred: *mut ucred) -> bool_;
    pub fn swap_reserve_force(incr: vm_ooffset_t);
    pub fn swap_release(decr: vm_ooffset_t);
    pub fn swap_release_by_cred(decr: vm_ooffset_t, cred: *mut ucred);
    pub static mut kmi: kva_md_info;
    pub static mut old_mlock: ::core::ffi::c_int;
    pub static mut vm_ndomains: ::core::ffi::c_int;
    pub static mut vm_overcommit: ::core::ffi::c_int;
    pub static mut M_OFWPROP: [malloc_type; 1usize];
    pub fn OF_install(name: *mut ::core::ffi::c_char, prio: ::core::ffi::c_int) -> bool_;
    pub fn OF_init(cookie: *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
    pub fn OF_test(name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn OF_printf(fmt: *const ::core::ffi::c_char, ...);
    pub fn OF_peer(node: phandle_t) -> phandle_t;
    pub fn OF_child(node: phandle_t) -> phandle_t;
    pub fn OF_parent(node: phandle_t) -> phandle_t;
    pub fn OF_getproplen(node: phandle_t, propname: *const ::core::ffi::c_char) -> isize;
    pub fn OF_getprop(
        node: phandle_t,
        propname: *const ::core::ffi::c_char,
        buf: *mut ::core::ffi::c_void,
        len: usize,
    ) -> isize;
    pub fn OF_getencprop(
        node: phandle_t,
        prop: *const ::core::ffi::c_char,
        buf: *mut pcell_t,
        len: usize,
    ) -> isize;
    pub fn OF_hasprop(node: phandle_t, propname: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn OF_searchprop(
        node: phandle_t,
        propname: *const ::core::ffi::c_char,
        buf: *mut ::core::ffi::c_void,
        len: usize,
    ) -> isize;
    pub fn OF_searchencprop(
        node: phandle_t,
        propname: *const ::core::ffi::c_char,
        buf: *mut pcell_t,
        len: usize,
    ) -> isize;
    pub fn OF_getprop_alloc(
        node: phandle_t,
        propname: *const ::core::ffi::c_char,
        buf: *mut *mut ::core::ffi::c_void,
    ) -> isize;
    pub fn OF_getprop_alloc_multi(
        node: phandle_t,
        propname: *const ::core::ffi::c_char,
        elsz: ::core::ffi::c_int,
        buf: *mut *mut ::core::ffi::c_void,
    ) -> isize;
    pub fn OF_getencprop_alloc(
        node: phandle_t,
        propname: *const ::core::ffi::c_char,
        buf: *mut *mut ::core::ffi::c_void,
    ) -> isize;
    pub fn OF_getencprop_alloc_multi(
        node: phandle_t,
        propname: *const ::core::ffi::c_char,
        elsz: ::core::ffi::c_int,
        buf: *mut *mut ::core::ffi::c_void,
    ) -> isize;
    pub fn OF_prop_free(buf: *mut ::core::ffi::c_void);
    pub fn OF_nextprop(
        node: phandle_t,
        propname: *const ::core::ffi::c_char,
        buf: *mut ::core::ffi::c_char,
        len: usize,
    ) -> ::core::ffi::c_int;
    pub fn OF_setprop(
        node: phandle_t,
        name: *const ::core::ffi::c_char,
        buf: *const ::core::ffi::c_void,
        len: usize,
    ) -> ::core::ffi::c_int;
    pub fn OF_canon(
        path: *const ::core::ffi::c_char,
        buf: *mut ::core::ffi::c_char,
        len: usize,
    ) -> isize;
    pub fn OF_finddevice(path: *const ::core::ffi::c_char) -> phandle_t;
    pub fn OF_package_to_path(node: phandle_t, buf: *mut ::core::ffi::c_char, len: usize) -> isize;
    pub fn OF_node_from_xref(xref: phandle_t) -> phandle_t;
    pub fn OF_xref_from_node(node: phandle_t) -> phandle_t;
    pub fn OF_device_from_xref(xref: phandle_t) -> device_t;
    pub fn OF_xref_from_device(dev: device_t) -> phandle_t;
    pub fn OF_device_register_xref(xref: phandle_t, dev: device_t) -> ::core::ffi::c_int;
    pub fn OF_device_unregister_xref(xref: phandle_t, dev: device_t);
    pub fn OF_open(path: *const ::core::ffi::c_char) -> ihandle_t;
    pub fn OF_close(instance: ihandle_t);
    pub fn OF_read(instance: ihandle_t, buf: *mut ::core::ffi::c_void, len: usize) -> isize;
    pub fn OF_write(instance: ihandle_t, buf: *const ::core::ffi::c_void, len: usize) -> isize;
    pub fn OF_seek(instance: ihandle_t, where_: u64) -> ::core::ffi::c_int;
    pub fn OF_instance_to_package(instance: ihandle_t) -> phandle_t;
    pub fn OF_instance_to_path(
        instance: ihandle_t,
        buf: *mut ::core::ffi::c_char,
        len: usize,
    ) -> isize;
    pub fn OF_call_method(
        method: *const ::core::ffi::c_char,
        instance: ihandle_t,
        nargs: ::core::ffi::c_int,
        nreturns: ::core::ffi::c_int,
        ...
    ) -> ::core::ffi::c_int;
    pub fn OF_claim(
        virtrequest: *mut ::core::ffi::c_void,
        size: usize,
        align: u_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn OF_release(virt: *mut ::core::ffi::c_void, size: usize);
    pub fn OF_enter();
    pub fn OF_exit() -> !;
    pub fn OF_interpret(
        cmd: *const ::core::ffi::c_char,
        nreturns: ::core::ffi::c_int,
        ...
    ) -> ::core::ffi::c_int;
    pub fn OF_decode_addr(
        dev: phandle_t,
        regno: ::core::ffi::c_int,
        ptag: *mut bus_space_tag_t,
        phandle: *mut bus_space_handle_t,
        sz: *mut bus_size_t,
    ) -> ::core::ffi::c_int;
    #[link_name = "arm_irq_memory_barrier__extern"]
    pub fn arm_irq_memory_barrier(irq: usize);
    pub fn intr_isrc_deregister(arg1: *mut intr_irqsrc) -> ::core::ffi::c_int;
    pub fn intr_isrc_register(
        arg1: *mut intr_irqsrc,
        arg2: device_t,
        arg3: u_int,
        arg4: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn intr_isrc_init_on_cpu(isrc: *mut intr_irqsrc, cpu: u_int) -> bool_;
    pub fn intr_isrc_dispatch(arg1: *mut intr_irqsrc, arg2: *mut trapframe) -> ::core::ffi::c_int;
    pub fn intr_irq_next_cpu(current_cpu: u_int, cpumask: *mut cpuset_t) -> u_int;
    pub fn intr_pic_register(arg1: device_t, arg2: isize) -> *mut intr_pic;
    pub fn intr_pic_deregister(arg1: device_t, arg2: isize) -> ::core::ffi::c_int;
    pub fn intr_pic_claim_root(
        arg1: device_t,
        arg2: isize,
        arg3: intr_irq_filter_t,
        arg4: *mut ::core::ffi::c_void,
        arg5: u32,
    ) -> ::core::ffi::c_int;
    pub fn intr_pic_add_handler(
        arg1: device_t,
        arg2: *mut intr_pic,
        arg3: intr_child_irq_filter_t,
        arg4: *mut ::core::ffi::c_void,
        arg5: usize,
        arg6: usize,
    ) -> ::core::ffi::c_int;
    pub fn intr_is_per_cpu(arg1: *mut resource) -> bool_;
    pub fn intr_irq_root_device(arg1: u32) -> device_t;
    pub fn intr_activate_irq(arg1: device_t, arg2: *mut resource) -> ::core::ffi::c_int;
    pub fn intr_deactivate_irq(arg1: device_t, arg2: *mut resource) -> ::core::ffi::c_int;
    pub fn intr_setup_irq(
        arg1: device_t,
        arg2: *mut resource,
        arg3: driver_filter_t,
        arg4: driver_intr_t,
        arg5: *mut ::core::ffi::c_void,
        arg6: ::core::ffi::c_int,
        arg7: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn intr_teardown_irq(
        arg1: device_t,
        arg2: *mut resource,
        arg3: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn intr_describe_irq(
        arg1: device_t,
        arg2: *mut resource,
        arg3: *mut ::core::ffi::c_void,
        arg4: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn intr_child_irq_handler(arg1: *mut intr_pic, arg2: usize) -> ::core::ffi::c_int;
    pub fn intr_alloc_map_data(
        arg1: intr_map_data_type,
        arg2: usize,
        arg3: ::core::ffi::c_int,
    ) -> *mut intr_map_data;
    pub fn intr_free_intr_map_data(arg1: *mut intr_map_data);
    pub fn intr_map_irq(arg1: device_t, arg2: isize, arg3: *mut intr_map_data) -> u_int;
    pub fn intr_unmap_irq(arg1: u_int);
    pub fn intr_map_clone_irq(arg1: u_int) -> u_int;
    pub fn intr_msi_register(arg1: device_t, arg2: isize) -> ::core::ffi::c_int;
    pub fn intr_alloc_msi(
        arg1: device_t,
        arg2: device_t,
        arg3: isize,
        arg4: ::core::ffi::c_int,
        arg5: ::core::ffi::c_int,
        arg6: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn intr_release_msi(
        arg1: device_t,
        arg2: device_t,
        arg3: isize,
        arg4: ::core::ffi::c_int,
        arg5: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn intr_map_msi(
        arg1: device_t,
        arg2: device_t,
        arg3: isize,
        arg4: ::core::ffi::c_int,
        arg5: *mut u64,
        arg6: *mut u32,
    ) -> ::core::ffi::c_int;
    pub fn intr_alloc_msix(
        arg1: device_t,
        arg2: device_t,
        arg3: isize,
        arg4: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn intr_release_msix(
        arg1: device_t,
        arg2: device_t,
        arg3: isize,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn intr_bind_irq(
        arg1: device_t,
        arg2: *mut resource,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn intr_pic_init_secondary();
    pub static mut intr_nirq: u_int;
    pub fn intr_ipi_pic_register(dev: device_t, priority: u_int) -> ::core::ffi::c_int;
    pub fn intr_ipi_setup(
        ipi: u_int,
        name: *const ::core::ffi::c_char,
        hand: intr_ipi_handler_t,
        arg: *mut ::core::ffi::c_void,
    );
    pub fn intr_ipi_send(cpus: cpuset_t, ipi: u_int);
    pub fn intr_ipi_dispatch(ipi: u_int);
    pub fn intr_irq_handler(tf: *mut trapframe, rootnum: u32);
    pub static mut kernelname: [::core::ffi::c_char; 1024usize];
    pub static mut tick: ::core::ffi::c_int;
    pub static mut hz: ::core::ffi::c_int;
    pub static mut psratio: ::core::ffi::c_int;
    pub static mut stathz: ::core::ffi::c_int;
    pub static mut profhz: ::core::ffi::c_int;
    pub static mut profprocs: ::core::ffi::c_int;
    pub static mut ticks: ::core::ffi::c_int;
    pub static mut ticksl: ::core::ffi::c_long;
    pub fn sysinit_add(set: *mut *mut sysinit, set_end: *mut *mut sysinit);
    pub fn tunable_int_init(arg1: *const ::core::ffi::c_void);
    pub fn tunable_long_init(arg1: *const ::core::ffi::c_void);
    pub fn tunable_ulong_init(arg1: *const ::core::ffi::c_void);
    pub fn tunable_int64_init(arg1: *const ::core::ffi::c_void);
    pub fn tunable_uint64_init(arg1: *const ::core::ffi::c_void);
    pub fn tunable_quad_init(arg1: *const ::core::ffi::c_void);
    pub fn tunable_bool_init(arg1: *const ::core::ffi::c_void);
    pub fn tunable_str_init(arg1: *const ::core::ffi::c_void);
    pub fn config_intrhook_establish(hook: *mut intr_config_hook) -> ::core::ffi::c_int;
    pub fn config_intrhook_disestablish(hook: *mut intr_config_hook);
    pub fn config_intrhook_drain(hook: *mut intr_config_hook) -> ::core::ffi::c_int;
    pub fn config_intrhook_oneshot(_func: ich_func_t, _arg: *mut ::core::ffi::c_void);
    pub static mut lock_class_mtx_sleep: lock_class;
    pub static mut lock_class_mtx_spin: lock_class;
    pub static mut lock_class_sx: lock_class;
    pub static mut lock_class_rw: lock_class;
    pub static mut lock_class_rm: lock_class;
    pub static mut lock_class_rm_sleepable: lock_class;
    pub static mut lock_class_lockmgr: lock_class;
    pub static mut lock_classes: [*mut lock_class; 0usize];
    pub static mut locks_delay: lock_delay_config;
    pub static mut locks_delay_retries: u_short;
    pub static mut locks_delay_loops: u_short;
    #[link_name = "lock_delay_arg_init__extern"]
    pub fn lock_delay_arg_init(la: *mut lock_delay_arg, lc: *mut lock_delay_config);
    #[link_name = "lock_delay_arg_init_noadapt__extern"]
    pub fn lock_delay_arg_init_noadapt(la: *mut lock_delay_arg);
    pub fn lock_init(
        arg1: *mut lock_object,
        arg2: *mut lock_class,
        arg3: *const ::core::ffi::c_char,
        arg4: *const ::core::ffi::c_char,
        arg5: ::core::ffi::c_int,
    );
    pub fn lock_destroy(arg1: *mut lock_object);
    pub fn lock_delay(arg1: *mut lock_delay_arg);
    pub fn lock_delay_default_init(arg1: *mut lock_delay_config);
    pub fn spinlock_enter();
    pub fn spinlock_exit();
    pub fn witness_init(arg1: *mut lock_object, arg2: *const ::core::ffi::c_char);
    pub fn witness_destroy(arg1: *mut lock_object);
    pub fn witness_defineorder(
        arg1: *mut lock_object,
        arg2: *mut lock_object,
    ) -> ::core::ffi::c_int;
    pub fn witness_checkorder(
        arg1: *mut lock_object,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: ::core::ffi::c_int,
        arg5: *mut lock_object,
    );
    pub fn witness_lock(
        arg1: *mut lock_object,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: ::core::ffi::c_int,
    );
    pub fn witness_upgrade(
        arg1: *mut lock_object,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: ::core::ffi::c_int,
    );
    pub fn witness_downgrade(
        arg1: *mut lock_object,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: ::core::ffi::c_int,
    );
    pub fn witness_unlock(
        arg1: *mut lock_object,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: ::core::ffi::c_int,
    );
    pub fn witness_save(
        arg1: *mut lock_object,
        arg2: *mut *const ::core::ffi::c_char,
        arg3: *mut ::core::ffi::c_int,
    );
    pub fn witness_restore(
        arg1: *mut lock_object,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    );
    pub fn witness_list_locks(
        arg1: *mut *mut lock_list_entry,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int,
        >,
    ) -> ::core::ffi::c_int;
    pub fn witness_warn(
        arg1: ::core::ffi::c_int,
        arg2: *mut lock_object,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn witness_assert(
        arg1: *const lock_object,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: ::core::ffi::c_int,
    );
    pub fn witness_is_owned(lock: *const lock_object) -> ::core::ffi::c_int;
    pub fn witness_display_spinlock(
        arg1: *mut lock_object,
        arg2: *mut thread,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int,
        >,
    );
    pub fn witness_line(arg1: *mut lock_object) -> ::core::ffi::c_int;
    pub fn witness_norelease(arg1: *mut lock_object);
    pub fn witness_releaseok(arg1: *mut lock_object);
    pub fn witness_file(arg1: *mut lock_object) -> *const ::core::ffi::c_char;
    pub fn witness_thread_exit(arg1: *mut thread);
    pub fn witness_startup_count() -> ::core::ffi::c_int;
    pub fn witness_startup(arg1: *mut ::core::ffi::c_void);
    #[doc = " descr is a string that describes each entry in the table. The general\n form is the grammar (TYPE:pnp_name[/pnp_name];)*\n where TYPE is one of the following:\n\tU8\tuint8_t element\n\tV8\tlike U8 and 0xff means match any\n\tG16\tuint16_t element, any value >= matches\n\tL16\tuint16_t element, any value <= matches\n\tM16\tuint16_t element, mask of which of the following fields to use.\n\tU16\tuint16_t element\n\tV16\tlike U16 and 0xffff means match any\n\tU32\tuint32_t element\n\tV32\tlike U32 and 0xffffffff means match any\n\tW32\tTwo 16-bit values with first pnp_name in LSW and second in MSW.\n\tZ\tpointer to a string to match exactly\n\tD\tpointer to a string to human readable description for device\n\tP\tA pointer that should be ignored\n\tE\tEISA PNP Identifier (in binary, but bus publishes string)\n\tT\tKey for whole table. pnp_name=value. must be last, if present.\n\n The pnp_name \"#\" is reserved for other fields that should be ignored.\n Otherwise pnp_name must match the name from the parent device's pnpinfo\n output. The second pnp_name is used for the W32 type."]
    pub static mut modules_sx: sx;
    pub fn module_register_init(arg1: *const ::core::ffi::c_void);
    pub fn module_register(arg1: *const moduledata, arg2: *mut linker_file) -> ::core::ffi::c_int;
    pub fn module_lookupbyname(arg1: *const ::core::ffi::c_char) -> module_t;
    pub fn module_lookupbyid(arg1: ::core::ffi::c_int) -> module_t;
    pub fn module_quiesce(arg1: module_t) -> ::core::ffi::c_int;
    pub fn module_reference(arg1: module_t);
    pub fn module_release(arg1: module_t);
    pub fn module_unload(arg1: module_t) -> ::core::ffi::c_int;
    pub fn module_getid(arg1: module_t) -> ::core::ffi::c_int;
    pub fn module_getfnext(arg1: module_t) -> module_t;
    pub fn module_getname(arg1: module_t) -> *const ::core::ffi::c_char;
    pub fn module_setspecific(arg1: module_t, arg2: *mut modspecific_t);
    pub fn module_file(arg1: module_t) -> *mut linker_file;
    pub static mut sdt_probes_enabled: bool_;
    pub fn sdt_probe(arg1: u32, arg2: usize, arg3: usize, arg4: usize, arg5: usize, arg6: usize);
    pub fn sdt_probe6(
        arg1: u32,
        arg2: usize,
        arg3: usize,
        arg4: usize,
        arg5: usize,
        arg6: usize,
        arg7: usize,
    );
    pub fn sdt_tracepoint_valid(patchpoint: usize, target: usize) -> bool_;
    pub fn sdt_tracepoint_patch(patchpoint: usize, target: usize);
    pub fn sdt_tracepoint_restore(patchpoint: usize);
    pub static mut __start_set_sdt_providers_set: *mut sdt_provider;
    pub static mut __stop_set_sdt_providers_set: *mut sdt_provider;
    pub static mut __start_set_sdt_probes_set: *mut sdt_probe;
    pub static mut __stop_set_sdt_probes_set: *mut sdt_probe;
    pub static mut __start_set_sdt_argtypes_set: *mut sdt_argtype;
    pub static mut __stop_set_sdt_argtypes_set: *mut sdt_argtype;
    pub static mut sdt_probe_func: sdt_probe_func_t;
    pub fn sdt_probe_stub(
        arg1: u32,
        arg2: usize,
        arg3: usize,
        arg4: usize,
        arg5: usize,
        arg6: usize,
        arg7: usize,
    );
    pub static mut sdt_provider_sdt: sdt_provider;
    pub static mut sdt_provider_lockstat: sdt_provider;
    pub static mut sdt_lockstat___adaptive__acquire: sdt_probe;
    pub static mut sdt_lockstat___adaptive__release: sdt_probe;
    pub static mut sdt_lockstat___adaptive__spin: sdt_probe;
    pub static mut sdt_lockstat___adaptive__block: sdt_probe;
    pub static mut sdt_lockstat___spin__acquire: sdt_probe;
    pub static mut sdt_lockstat___spin__release: sdt_probe;
    pub static mut sdt_lockstat___spin__spin: sdt_probe;
    pub static mut sdt_lockstat___rw__acquire: sdt_probe;
    pub static mut sdt_lockstat___rw__release: sdt_probe;
    pub static mut sdt_lockstat___rw__block: sdt_probe;
    pub static mut sdt_lockstat___rw__spin: sdt_probe;
    pub static mut sdt_lockstat___rw__upgrade: sdt_probe;
    pub static mut sdt_lockstat___rw__downgrade: sdt_probe;
    pub static mut sdt_lockstat___sx__acquire: sdt_probe;
    pub static mut sdt_lockstat___sx__release: sdt_probe;
    pub static mut sdt_lockstat___sx__block: sdt_probe;
    pub static mut sdt_lockstat___sx__spin: sdt_probe;
    pub static mut sdt_lockstat___sx__upgrade: sdt_probe;
    pub static mut sdt_lockstat___sx__downgrade: sdt_probe;
    pub static mut sdt_lockstat___lockmgr__acquire: sdt_probe;
    pub static mut sdt_lockstat___lockmgr__release: sdt_probe;
    pub static mut sdt_lockstat___lockmgr__disown: sdt_probe;
    pub static mut sdt_lockstat___lockmgr__block: sdt_probe;
    pub static mut sdt_lockstat___lockmgr__upgrade: sdt_probe;
    pub static mut sdt_lockstat___lockmgr__downgrade: sdt_probe;
    pub static mut sdt_lockstat___thread__spin: sdt_probe;
    pub static mut lockstat_enabled: bool_;
    pub fn lockstat_nsecs(arg1: *mut lock_object) -> u64;
    pub fn _mtx_init(
        c: *mut usize,
        name: *const ::core::ffi::c_char,
        type_: *const ::core::ffi::c_char,
        opts: ::core::ffi::c_int,
    );
    pub fn _mtx_destroy(c: *mut usize);
    pub fn mtx_sysinit(arg: *const ::core::ffi::c_void);
    pub fn _mtx_trylock_flags_int(
        m: *mut mtx,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn _mtx_trylock_flags_(
        c: *mut usize,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn mutex_init();
    pub fn __mtx_lock_sleep(
        c: *mut usize,
        v: usize,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn __mtx_unlock_sleep(
        c: *mut usize,
        v: usize,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn mtx_wait_unlocked(m: *mut mtx);
    pub fn _mtx_lock_spin_cookie(
        c: *mut usize,
        v: usize,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn __mtx_lock_flags(
        c: *mut usize,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn __mtx_unlock_flags(
        c: *mut usize,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn __mtx_lock_spin_flags(
        c: *mut usize,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn __mtx_trylock_spin_flags(
        c: *mut usize,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn __mtx_unlock_spin_flags(
        c: *mut usize,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn mtx_spin_wait_unlocked(m: *mut mtx);
    pub fn __mtx_assert(
        c: *const usize,
        what: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn thread_lock_flags_(
        arg1: *mut thread,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: ::core::ffi::c_int,
    );
    pub fn _thread_lock(
        td: *mut thread,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn mtx_pool_create(
        mtx_name: *const ::core::ffi::c_char,
        pool_size: ::core::ffi::c_int,
        opts: ::core::ffi::c_int,
    ) -> *mut mtx_pool;
    pub fn mtx_pool_destroy(poolp: *mut *mut mtx_pool);
    pub fn mtx_pool_find(pool: *mut mtx_pool, ptr: *mut ::core::ffi::c_void) -> *mut mtx;
    pub fn mtx_pool_alloc(pool: *mut mtx_pool) -> *mut mtx;
    pub static mut mtxpool_sleep: *mut mtx_pool;
    pub static mut Giant: mtx;
    pub static mut blocked_lock: mtx;
    pub fn knote(list: *mut knlist, hint: ::core::ffi::c_long, lockflags: ::core::ffi::c_int);
    pub fn knote_fork(list: *mut knlist, pid: ::core::ffi::c_int);
    pub fn knote_triv_copy(kn: *mut knote, p1: *mut proc_) -> ::core::ffi::c_int;
    pub fn knlist_alloc(lock: *mut mtx) -> *mut knlist;
    pub fn knlist_detach(knl: *mut knlist);
    pub fn knlist_add(knl: *mut knlist, kn: *mut knote, islocked: ::core::ffi::c_int);
    pub fn knlist_remove(knl: *mut knlist, kn: *mut knote, islocked: ::core::ffi::c_int);
    pub fn knlist_empty(knl: *mut knlist) -> ::core::ffi::c_int;
    pub fn knlist_init(
        knl: *mut knlist,
        lock: *mut ::core::ffi::c_void,
        kl_lock: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        kl_unlock: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        kl_assert_lock: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: ::core::ffi::c_int),
        >,
    );
    pub fn knlist_init_mtx(knl: *mut knlist, lock: *mut mtx);
    pub fn knlist_destroy(knl: *mut knlist);
    pub fn knlist_cleardel(
        knl: *mut knlist,
        td: *mut thread,
        islocked: ::core::ffi::c_int,
        killkn: ::core::ffi::c_int,
    );
    pub fn knote_fdclose(p: *mut thread, fd: ::core::ffi::c_int);
    pub fn kqfd_register(
        fd: ::core::ffi::c_int,
        kev: *mut kevent,
        p: *mut thread,
        mflag: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn kqueue_add_filteropts(
        filt: ::core::ffi::c_int,
        filtops: *const filterops,
    ) -> ::core::ffi::c_int;
    pub fn kqueue_del_filteropts(filt: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn kqueue_drain_schedtask();
    pub fn cv_init(cvp: *mut cv, desc: *const ::core::ffi::c_char);
    pub fn cv_destroy(cvp: *mut cv);
    pub fn _cv_wait(cvp: *mut cv, lock: *mut lock_object);
    pub fn _cv_wait_unlock(cvp: *mut cv, lock: *mut lock_object);
    pub fn _cv_wait_sig(cvp: *mut cv, lock: *mut lock_object) -> ::core::ffi::c_int;
    pub fn _cv_timedwait_sbt(
        cvp: *mut cv,
        lock: *mut lock_object,
        sbt: sbintime_t,
        pr: sbintime_t,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn _cv_timedwait_sig_sbt(
        cvp: *mut cv,
        lock: *mut lock_object,
        sbt: sbintime_t,
        pr: sbintime_t,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn cv_signal(cvp: *mut cv);
    pub fn cv_broadcastpri(cvp: *mut cv, pri: ::core::ffi::c_int);
    pub fn osd_register(
        type_: u_int,
        destructor: osd_destructor_t,
        methods: *const osd_method_t,
    ) -> ::core::ffi::c_int;
    pub fn osd_deregister(type_: u_int, slot: u_int);
    pub fn osd_set(
        type_: u_int,
        osd: *mut osd,
        slot: u_int,
        value: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn osd_reserve(slot: u_int) -> *mut *mut ::core::ffi::c_void;
    pub fn osd_set_reserved(
        type_: u_int,
        osd: *mut osd,
        slot: u_int,
        rsv: *mut *mut ::core::ffi::c_void,
        value: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn osd_free_reserved(rsv: *mut *mut ::core::ffi::c_void);
    pub fn osd_get(type_: u_int, osd: *mut osd, slot: u_int) -> *mut ::core::ffi::c_void;
    pub fn osd_get_unlocked(type_: u_int, osd: *mut osd, slot: u_int) -> *mut ::core::ffi::c_void;
    pub fn osd_del(type_: u_int, osd: *mut osd, slot: u_int);
    pub fn osd_call(
        type_: u_int,
        method: u_int,
        obj: *mut ::core::ffi::c_void,
        data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn osd_exit(type_: u_int, osd: *mut osd);
    pub fn rtp_to_pri(arg1: *mut rtprio, arg2: *mut thread) -> ::core::ffi::c_int;
    pub fn pri_to_rtp(arg1: *mut thread, arg2: *mut rtprio);
    pub fn fgetown(sigiop: *mut *mut sigio) -> pid_t;
    pub fn fsetown(pgid: pid_t, sigiop: *mut *mut sigio) -> ::core::ffi::c_int;
    pub fn funsetown(sigiop: *mut *mut sigio);
    pub fn funsetownlst(sigiolst: *mut sigiolst);
    #[link_name = "__sigisempty__extern"]
    pub fn __sigisempty(set: *mut sigset_t) -> ::core::ffi::c_int;
    #[link_name = "__sigseteq__extern"]
    pub fn __sigseteq(set1: *mut sigset_t, set2: *mut sigset_t) -> ::core::ffi::c_int;
    pub static mut sigfastblock_fetch_always: bool_;
    pub static mut pt_attach_transparent: bool_;
    #[link_name = "sigsetmasked__extern"]
    pub fn sigsetmasked(set: *mut sigset_t, mask: *mut sigset_t) -> bool_;
    #[link_name = "ksiginfo_copy__extern"]
    pub fn ksiginfo_copy(src: *mut ksiginfo_t, dst: *mut ksiginfo_t);
    #[link_name = "ksiginfo_set_sigev__extern"]
    pub fn ksiginfo_set_sigev(dst: *mut ksiginfo_t, sigev: *mut sigevent);
    pub static mut sigio_lock: mtx;
    pub fn sigdeferstop_impl(mode: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn sigallowstop_impl(prev: ::core::ffi::c_int);
    #[link_name = "sigdeferstop__extern"]
    pub fn sigdeferstop(mode: ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[link_name = "sigallowstop__extern"]
    pub fn sigallowstop(prev: ::core::ffi::c_int);
    pub fn cursig(td: *mut thread) -> ::core::ffi::c_int;
    pub fn execsigs(p: *mut proc_);
    pub fn killproc(p: *mut proc_, why: *const ::core::ffi::c_char);
    pub fn ksiginfo_alloc(mwait: ::core::ffi::c_int) -> *mut ksiginfo_t;
    pub fn ksiginfo_free(ksi: *mut ksiginfo_t);
    pub fn pksignal(
        p: *mut proc_,
        sig: ::core::ffi::c_int,
        ksi: *mut ksiginfo_t,
    ) -> ::core::ffi::c_int;
    pub fn pgsigio(sigiop: *mut *mut sigio, sig: ::core::ffi::c_int, checkctty: ::core::ffi::c_int);
    pub fn pgsignal(
        pgrp: *mut pgrp,
        sig: ::core::ffi::c_int,
        checkctty: ::core::ffi::c_int,
        ksi: *mut ksiginfo_t,
    );
    pub fn postsig(sig: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn kern_psignal(p: *mut proc_, sig: ::core::ffi::c_int);
    pub fn ptracestop(
        td: *mut thread,
        sig: ::core::ffi::c_int,
        si: *mut ksiginfo_t,
    ) -> ::core::ffi::c_int;
    pub fn sendsig(catcher: sig_t, ksi: *mut ksiginfo_t, retmask: *mut sigset_t);
    pub fn sigacts_alloc() -> *mut sigacts;
    pub fn sigacts_copy(dest: *mut sigacts, src: *mut sigacts);
    pub fn sigacts_free(ps: *mut sigacts);
    pub fn sigacts_hold(ps: *mut sigacts) -> *mut sigacts;
    pub fn sigacts_shared(ps: *mut sigacts) -> ::core::ffi::c_int;
    pub fn sig_ast_checksusp(td: *mut thread) -> ::core::ffi::c_int;
    pub fn sig_ast_needsigchk(td: *mut thread) -> ::core::ffi::c_int;
    pub fn sig_drop_caught(p: *mut proc_);
    pub fn sigexit(td: *mut thread, sig: ::core::ffi::c_int) -> !;
    pub fn sigev_findtd(
        p: *mut proc_,
        sigev: *mut sigevent,
        arg1: *mut *mut thread,
    ) -> ::core::ffi::c_int;
    pub fn sigfastblock_clear(td: *mut thread);
    pub fn sigfastblock_fetch(td: *mut thread);
    pub fn sig_intr() -> ::core::ffi::c_int;
    pub fn sig_do_core(arg1: ::core::ffi::c_int) -> bool_;
    pub fn siginit(p: *mut proc_);
    pub fn signotify(td: *mut thread);
    pub fn sigqueue_delete(queue: *mut sigqueue, sig: ::core::ffi::c_int);
    pub fn sigqueue_delete_proc(p: *mut proc_, sig: ::core::ffi::c_int);
    pub fn sigqueue_flush(queue: *mut sigqueue);
    pub fn sigqueue_init(queue: *mut sigqueue, p: *mut proc_);
    pub fn sigqueue_take(ksi: *mut ksiginfo_t);
    pub fn tdksignal(td: *mut thread, sig: ::core::ffi::c_int, ksi: *mut ksiginfo_t);
    pub fn tdsendsignal(
        p: *mut proc_,
        td: *mut thread,
        sig: ::core::ffi::c_int,
        ksi: *mut ksiginfo_t,
    ) -> ::core::ffi::c_int;
    pub fn tdsigcleanup(td: *mut thread);
    pub fn tdsignal(td: *mut thread, sig: ::core::ffi::c_int);
    pub fn trapsignal(td: *mut thread, ksi: *mut ksiginfo_t);
    pub fn user_setcred(td: *mut thread, flags: u_int, wcred: *mut setcred) -> ::core::ffi::c_int;
    #[link_name = "credbatch_prep__extern"]
    pub fn credbatch_prep(crb: *mut credbatch);
    pub fn credbatch_add(crb: *mut credbatch, td: *mut thread);
    #[link_name = "credbatch_process__extern"]
    pub fn credbatch_process(crb: *mut credbatch);
    pub fn credbatch_final(crb: *mut credbatch);
    pub fn change_egid(newcred: *mut ucred, egid: gid_t);
    pub fn change_euid(newcred: *mut ucred, euip: *mut uidinfo);
    pub fn change_rgid(newcred: *mut ucred, rgid: gid_t);
    pub fn change_ruid(newcred: *mut ucred, ruip: *mut uidinfo);
    pub fn change_svgid(newcred: *mut ucred, svgid: gid_t);
    pub fn change_svuid(newcred: *mut ucred, svuid: uid_t);
    pub fn crcopy(dest: *mut ucred, src: *mut ucred);
    pub fn crcopysafe(p: *mut proc_, cr: *mut ucred) -> *mut ucred;
    pub fn crdup(cr: *mut ucred) -> *mut ucred;
    pub fn crextend(cr: *mut ucred, n: ::core::ffi::c_int);
    pub fn proc_set_cred(p: *mut proc_, newcred: *mut ucred);
    pub fn proc_set_cred_enforce_proc_lim(p: *mut proc_, newcred: *mut ucred) -> bool_;
    pub fn proc_unset_cred(p: *mut proc_, decrement_proc_count: bool_);
    pub fn crfree(cr: *mut ucred);
    pub fn crcowsync() -> *mut ucred;
    pub fn crget() -> *mut ucred;
    pub fn crhold(cr: *mut ucred) -> *mut ucred;
    pub fn crcowget(cr: *mut ucred) -> *mut ucred;
    pub fn crcowfree(td: *mut thread);
    pub fn cru2x(cr: *mut ucred, xcr: *mut xucred);
    pub fn cru2xt(td: *mut thread, xcr: *mut xucred);
    pub fn crsetgroups(cr: *mut ucred, ngrp: ::core::ffi::c_int, groups: *const gid_t);
    pub fn crsetgroups_and_egid(
        cr: *mut ucred,
        ngrp: ::core::ffi::c_int,
        groups: *const gid_t,
        default_egid: gid_t,
    );
    pub fn cr_xids_subset(active_cred: *mut ucred, obj_cred: *mut ucred) -> bool_;
    #[link_name = "group_is_primary__extern"]
    pub fn group_is_primary(gid: gid_t, cred: *const ucred) -> bool_;
    pub fn group_is_supplementary(gid: gid_t, cred: *const ucred) -> bool_;
    pub fn groupmember(gid: gid_t, cred: *const ucred) -> bool_;
    pub fn realgroupmember(gid: gid_t, cred: *const ucred) -> bool_;
    pub fn thread_lock_block(arg1: *mut thread) -> *mut mtx;
    pub fn thread_lock_block_wait(arg1: *mut thread);
    pub fn thread_lock_set(arg1: *mut thread, arg2: *mut mtx);
    pub fn thread_lock_unblock(arg1: *mut thread, arg2: *mut mtx);
    pub static mut pid_max: pid_t;
    pub static mut pidhashtbl: *mut pidhashhead;
    pub static mut pidhashtbl_lock: *mut sx;
    pub static mut pidhash: u_long;
    pub static mut pidhashlock: u_long;
    pub static mut pgrphashtbl: *mut pgrphashhead;
    pub static mut pgrphash: u_long;
    pub static mut allproc_lock: sx;
    pub static mut allproc_gen: ::core::ffi::c_int;
    pub static mut proctree_lock: sx;
    pub static mut ppeers_lock: mtx;
    pub static mut procid_lock: mtx;
    pub static mut proc0: proc_;
    pub static mut thread0_st: thread0_storage;
    pub static mut vmspace0: vmspace;
    pub static mut hogticks: ::core::ffi::c_int;
    pub static mut lastpid: ::core::ffi::c_int;
    pub static mut nprocs: ::core::ffi::c_int;
    pub static mut maxproc: ::core::ffi::c_int;
    pub static mut maxprocperuid: ::core::ffi::c_int;
    pub static mut ps_arg_cache_limit: u_long;
    pub static mut allproc: proclist;
    pub static mut initproc: *mut proc_;
    pub static mut pageproc: *mut proc_;
    pub static mut proc_zone: *mut uma_zone;
    pub static mut pgrp_zone: *mut uma_zone;
    pub fn pfind(arg1: pid_t) -> *mut proc_;
    pub fn pfind_any(arg1: pid_t) -> *mut proc_;
    pub fn pfind_any_locked(pid: pid_t) -> *mut proc_;
    pub fn pgfind(arg1: pid_t) -> *mut pgrp;
    pub fn pidhash_slockall();
    pub fn pidhash_sunlockall();
    pub fn pget(pid: pid_t, flags: ::core::ffi::c_int, pp: *mut *mut proc_) -> ::core::ffi::c_int;
    pub fn ast(framep: *mut trapframe);
    pub fn ast_kclear(td: *mut thread);
    pub fn ast_register(
        ast: ::core::ffi::c_int,
        ast_flags: ::core::ffi::c_int,
        tdp: ::core::ffi::c_int,
        f: ::core::option::Option<unsafe extern "C" fn(td: *mut thread, asts: ::core::ffi::c_int)>,
    );
    pub fn ast_deregister(tda: ::core::ffi::c_int);
    pub fn ast_sched_locked(td: *mut thread, tda: ::core::ffi::c_int);
    pub fn ast_sched_mask(td: *mut thread, ast: ::core::ffi::c_int);
    pub fn ast_sched(td: *mut thread, tda: ::core::ffi::c_int);
    pub fn ast_unsched_locked(td: *mut thread, tda: ::core::ffi::c_int);
    pub fn choosethread() -> *mut thread;
    pub fn cr_bsd_visible(u1: *mut ucred, u2: *mut ucred) -> ::core::ffi::c_int;
    pub fn cr_cansee(u1: *mut ucred, u2: *mut ucred) -> ::core::ffi::c_int;
    pub fn cr_canseesocket(cred: *mut ucred, so: *mut socket) -> ::core::ffi::c_int;
    pub fn cr_cansignal(
        cred: *mut ucred,
        proc_: *mut proc_,
        signum: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn enterpgrp(
        p: *mut proc_,
        pgid: pid_t,
        pgrp: *mut pgrp,
        sess: *mut session,
    ) -> ::core::ffi::c_int;
    pub fn enterthispgrp(p: *mut proc_, pgrp: *mut pgrp) -> ::core::ffi::c_int;
    pub fn fork1(arg1: *mut thread, arg2: *mut fork_req) -> ::core::ffi::c_int;
    pub fn fork_exit(
        arg1: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *mut trapframe),
        >,
        arg2: *mut ::core::ffi::c_void,
        arg3: *mut trapframe,
    );
    pub fn fork_return(arg1: *mut thread, arg2: *mut trapframe);
    pub fn inferior(p: *mut proc_) -> ::core::ffi::c_int;
    pub fn itimer_proc_continue(p: *mut proc_);
    pub fn kqtimer_proc_continue(p: *mut proc_);
    pub fn kern_proc_vmmap_resident(
        map: *mut vm_map,
        entry: *mut vm_map_entry,
        resident_count: *mut ::core::ffi::c_int,
        super_: *mut bool_,
    );
    pub fn kern_yield(arg1: ::core::ffi::c_int);
    pub fn killjobc();
    pub fn leavepgrp(p: *mut proc_) -> ::core::ffi::c_int;
    pub fn maybe_preempt(td: *mut thread) -> ::core::ffi::c_int;
    pub fn maybe_yield();
    pub fn mi_switch(flags: ::core::ffi::c_int);
    pub fn p_candebug(td: *mut thread, p: *mut proc_) -> ::core::ffi::c_int;
    pub fn p_cansee(td: *mut thread, p: *mut proc_) -> ::core::ffi::c_int;
    pub fn p_cansched(td: *mut thread, p: *mut proc_) -> ::core::ffi::c_int;
    pub fn p_cansignal(
        td: *mut thread,
        p: *mut proc_,
        signum: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn p_canwait(td: *mut thread, p: *mut proc_) -> ::core::ffi::c_int;
    pub fn pargs_alloc(len: ::core::ffi::c_int) -> *mut pargs;
    pub fn pargs_drop(pa: *mut pargs);
    pub fn pargs_hold(pa: *mut pargs);
    pub fn pgrp_calc_jobc(pgrp: *mut pgrp) -> ::core::ffi::c_int;
    pub fn proc_add_orphan(child: *mut proc_, parent: *mut proc_);
    pub fn proc_get_binpath(
        p: *mut proc_,
        binname: *mut ::core::ffi::c_char,
        fullpath: *mut *mut ::core::ffi::c_char,
        freepath: *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn proc_getargv(td: *mut thread, p: *mut proc_, sb: *mut sbuf) -> ::core::ffi::c_int;
    pub fn proc_getauxv(td: *mut thread, p: *mut proc_, sb: *mut sbuf) -> ::core::ffi::c_int;
    pub fn proc_getenvv(td: *mut thread, p: *mut proc_, sb: *mut sbuf) -> ::core::ffi::c_int;
    pub fn procinit();
    pub fn proc_iterate(
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut proc_,
                arg2: *mut ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
        cbarg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn proc_linkup0(p: *mut proc_, td: *mut thread);
    pub fn proc_linkup(p: *mut proc_, td: *mut thread);
    pub fn proc_realparent(child: *mut proc_) -> *mut proc_;
    pub fn proc_reap(
        td: *mut thread,
        p: *mut proc_,
        status: *mut ::core::ffi::c_int,
        options: ::core::ffi::c_int,
    );
    pub fn proc_reparent(child: *mut proc_, newparent: *mut proc_, set_oppid: bool_);
    pub fn proc_set_p2_wexit(p: *mut proc_);
    pub fn proc_set_traced(p: *mut proc_, stop: bool_);
    pub fn proc_wkilled(p: *mut proc_);
    pub fn pstats_alloc() -> *mut pstats;
    pub fn pstats_fork(src: *mut pstats, dst: *mut pstats);
    pub fn pstats_free(ps: *mut pstats);
    pub fn proc_clear_orphan(p: *mut proc_);
    pub fn reaper_abandon_children(p: *mut proc_, exiting: bool_);
    pub fn securelevel_ge(cr: *mut ucred, level: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn securelevel_gt(cr: *mut ucred, level: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn sess_hold(arg1: *mut session);
    pub fn sess_release(arg1: *mut session);
    pub fn setrunnable(arg1: *mut thread, arg2: ::core::ffi::c_int);
    pub fn setsugid(p: *mut proc_);
    pub fn should_yield() -> bool_;
    pub fn sigonstack(sp: usize) -> ::core::ffi::c_int;
    pub fn stopevent(arg1: *mut proc_, arg2: u_int, arg3: u_int);
    pub fn tdfind(arg1: lwpid_t, arg2: pid_t) -> *mut thread;
    pub fn threadinit();
    pub fn tidhash_add(arg1: *mut thread);
    pub fn tidhash_remove(arg1: *mut thread);
    pub fn cpu_idle(arg1: ::core::ffi::c_int);
    pub fn cpu_idle_wakeup(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub static mut cpu_idle_hook: ::core::option::Option<unsafe extern "C" fn(arg1: sbintime_t)>;
    pub fn cpu_switch(arg1: *mut thread, arg2: *mut thread, arg3: *mut mtx);
    pub fn cpu_sync_core();
    pub fn cpu_throw(arg1: *mut thread, arg2: *mut thread) -> !;
    pub fn cpu_update_pcb(arg1: *mut thread);
    pub fn curproc_sigkilled() -> bool_;
    pub fn userret(arg1: *mut thread, arg2: *mut trapframe);
    pub fn cpu_exit(arg1: *mut thread);
    pub fn exit1(arg1: *mut thread, arg2: ::core::ffi::c_int, arg3: ::core::ffi::c_int) -> !;
    pub fn cpu_copy_thread(td: *mut thread, td0: *mut thread);
    pub fn cpu_exec_vmspace_reuse(p: *mut proc_, map: *mut vm_map) -> bool_;
    pub fn cpu_fetch_syscall_args(td: *mut thread) -> ::core::ffi::c_int;
    pub fn cpu_fork(
        arg1: *mut thread,
        arg2: *mut proc_,
        arg3: *mut thread,
        arg4: ::core::ffi::c_int,
    );
    pub fn cpu_fork_kthread_handler(
        arg1: *mut thread,
        arg2: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg3: *mut ::core::ffi::c_void,
    );
    pub fn cpu_procctl(
        td: *mut thread,
        idtype: ::core::ffi::c_int,
        id: id_t,
        com: ::core::ffi::c_int,
        data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn cpu_set_syscall_retval(arg1: *mut thread, arg2: ::core::ffi::c_int);
    pub fn cpu_set_upcall(
        arg1: *mut thread,
        arg2: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg3: *mut ::core::ffi::c_void,
        arg4: *mut stack_t,
    ) -> ::core::ffi::c_int;
    pub fn cpu_set_user_tls(
        arg1: *mut thread,
        tls_base: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn cpu_thread_alloc(arg1: *mut thread);
    pub fn cpu_thread_clean(arg1: *mut thread);
    pub fn cpu_thread_exit(arg1: *mut thread);
    pub fn cpu_thread_free(arg1: *mut thread);
    pub fn thread_alloc(pages: ::core::ffi::c_int) -> *mut thread;
    pub fn thread_check_susp(td: *mut thread, sleep: bool_) -> ::core::ffi::c_int;
    pub fn thread_cow_get_proc(newtd: *mut thread, p: *mut proc_);
    pub fn thread_cow_get(newtd: *mut thread, td: *mut thread);
    pub fn thread_cow_free(td: *mut thread);
    pub fn thread_cow_update(td: *mut thread);
    pub fn thread_cow_synced(td: *mut thread);
    pub fn thread_create(
        td: *mut thread,
        rtp: *mut rtprio,
        initialize_thread: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut thread,
                arg2: *mut ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
        thunk: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn thread_exit() -> !;
    pub fn thread_free(td: *mut thread);
    pub fn thread_link(td: *mut thread, p: *mut proc_);
    pub fn thread_reap_barrier();
    pub fn thread_recycle(arg1: *mut thread, pages: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn thread_single(p: *mut proc_, how: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn thread_single_end(p: *mut proc_, how: ::core::ffi::c_int);
    pub fn thread_stash(td: *mut thread);
    pub fn thread_stopped(p: *mut proc_);
    pub fn childproc_stopped(child: *mut proc_, reason: ::core::ffi::c_int);
    pub fn childproc_continued(child: *mut proc_);
    pub fn childproc_exited(child: *mut proc_);
    pub fn thread_run_flash(td: *mut thread);
    pub fn thread_suspend_check(how: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn thread_suspend_check_needed() -> bool_;
    pub fn thread_suspend_switch(arg1: *mut thread, p: *mut proc_);
    pub fn thread_suspend_one(td: *mut thread);
    pub fn thread_unlink(td: *mut thread);
    pub fn thread_unsuspend(p: *mut proc_);
    pub fn thread_wait(p: *mut proc_);
    pub fn stop_all_proc_block() -> bool_;
    pub fn stop_all_proc_unblock();
    pub fn stop_all_proc();
    pub fn resume_all_proc();
    #[link_name = "curthread_pflags_set__extern"]
    pub fn curthread_pflags_set(flags: ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[link_name = "curthread_pflags_restore__extern"]
    pub fn curthread_pflags_restore(save: ::core::ffi::c_int);
    #[link_name = "curthread_pflags2_set__extern"]
    pub fn curthread_pflags2_set(flags: ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[link_name = "curthread_pflags2_restore__extern"]
    pub fn curthread_pflags2_restore(save: ::core::ffi::c_int);
    #[link_name = "td_get_sched__extern"]
    pub fn td_get_sched(td: *mut thread) -> *mut td_sched;
    pub fn proc_id_set(type_: ::core::ffi::c_int, id: pid_t);
    pub fn proc_id_set_cond(type_: ::core::ffi::c_int, id: pid_t);
    pub fn proc_id_clear(type_: ::core::ffi::c_int, id: pid_t);
    pub static mut _eventhandler_list_process_ctor: *mut eventhandler_list;
    pub static mut _eventhandler_list_process_dtor: *mut eventhandler_list;
    pub static mut _eventhandler_list_process_init: *mut eventhandler_list;
    pub static mut _eventhandler_list_process_fini: *mut eventhandler_list;
    pub static mut _eventhandler_list_process_exit: *mut eventhandler_list;
    pub static mut _eventhandler_list_process_fork: *mut eventhandler_list;
    pub static mut _eventhandler_list_process_exec: *mut eventhandler_list;
    pub static mut _eventhandler_list_thread_ctor: *mut eventhandler_list;
    pub static mut _eventhandler_list_thread_dtor: *mut eventhandler_list;
    pub static mut _eventhandler_list_thread_init: *mut eventhandler_list;
    #[link_name = "_refcount_update_saturated__extern"]
    pub fn _refcount_update_saturated(count: *mut u_int);
    #[link_name = "refcount_init__extern"]
    pub fn refcount_init(count: *mut u_int, value: u_int);
    #[link_name = "refcount_load__extern"]
    pub fn refcount_load(count: *const u_int) -> u_int;
    #[link_name = "refcount_acquire__extern"]
    pub fn refcount_acquire(count: *mut u_int) -> u_int;
    #[link_name = "refcount_acquiren__extern"]
    pub fn refcount_acquiren(count: *mut u_int, n: u_int) -> u_int;
    #[link_name = "refcount_acquire_checked__extern"]
    pub fn refcount_acquire_checked(count: *mut u_int) -> bool_;
    #[link_name = "refcount_acquire_if_gt__extern"]
    pub fn refcount_acquire_if_gt(count: *mut u_int, n: u_int) -> bool_;
    #[link_name = "refcount_acquire_if_not_zero__extern"]
    pub fn refcount_acquire_if_not_zero(count: *mut u_int) -> bool_;
    #[link_name = "refcount_releasen__extern"]
    pub fn refcount_releasen(count: *mut u_int, n: u_int) -> bool_;
    #[link_name = "refcount_release__extern"]
    pub fn refcount_release(count: *mut u_int) -> bool_;
    #[link_name = "_refcount_release_if_gt__extern"]
    pub fn _refcount_release_if_gt(count: *mut u_int, n: u_int) -> bool_;
    #[link_name = "_refcount_release_if_eq__extern"]
    pub fn _refcount_release_if_eq(count: *mut u_int, n: u_int) -> bool_;
    #[link_name = "refcount_release_if_gt__extern"]
    pub fn refcount_release_if_gt(count: *mut u_int, n: u_int) -> bool_;
    #[link_name = "refcount_release_if_last__extern"]
    pub fn refcount_release_if_last(count: *mut u_int) -> bool_;
    #[link_name = "refcount_release_if_not_last__extern"]
    pub fn refcount_release_if_not_last(count: *mut u_int) -> bool_;
    pub fn rman_activate_resource(r: *mut resource) -> ::core::ffi::c_int;
    pub fn rman_adjust_resource(
        r: *mut resource,
        start: rman_res_t,
        end: rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn rman_first_free_region(
        rm: *mut rman,
        start: *mut rman_res_t,
        end: *mut rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn rman_get_bushandle(arg1: *const resource) -> bus_space_handle_t;
    pub fn rman_get_bustag(arg1: *const resource) -> bus_space_tag_t;
    pub fn rman_get_end(arg1: *const resource) -> rman_res_t;
    pub fn rman_get_device(arg1: *const resource) -> device_t;
    pub fn rman_get_flags(arg1: *const resource) -> u_int;
    pub fn rman_get_irq_cookie(arg1: *const resource) -> *mut ::core::ffi::c_void;
    pub fn rman_get_mapping(arg1: *const resource, arg2: *mut resource_map);
    pub fn rman_get_rid(arg1: *const resource) -> ::core::ffi::c_int;
    pub fn rman_get_size(arg1: *const resource) -> rman_res_t;
    pub fn rman_get_start(arg1: *const resource) -> rman_res_t;
    pub fn rman_get_type(arg1: *const resource) -> ::core::ffi::c_int;
    pub fn rman_get_virtual(arg1: *const resource) -> *mut ::core::ffi::c_void;
    pub fn rman_deactivate_resource(r: *mut resource) -> ::core::ffi::c_int;
    pub fn rman_fini(rm: *mut rman) -> ::core::ffi::c_int;
    pub fn rman_init(rm: *mut rman) -> ::core::ffi::c_int;
    pub fn rman_init_from_resource(rm: *mut rman, r: *mut resource) -> ::core::ffi::c_int;
    pub fn rman_last_free_region(
        rm: *mut rman,
        start: *mut rman_res_t,
        end: *mut rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn rman_make_alignment_flags(size: u32) -> u32;
    pub fn rman_manage_region(
        rm: *mut rman,
        start: rman_res_t,
        end: rman_res_t,
    ) -> ::core::ffi::c_int;
    pub fn rman_is_region_manager(r: *const resource, rm: *const rman) -> ::core::ffi::c_int;
    pub fn rman_release_resource(r: *mut resource) -> ::core::ffi::c_int;
    pub fn rman_reserve_resource(
        rm: *mut rman,
        start: rman_res_t,
        end: rman_res_t,
        count: rman_res_t,
        flags: u_int,
        dev: device_t,
    ) -> *mut resource;
    pub fn rman_set_bushandle(_r: *mut resource, _h: bus_space_handle_t);
    pub fn rman_set_bustag(_r: *mut resource, _t: bus_space_tag_t);
    pub fn rman_set_device(_r: *mut resource, _dev: device_t);
    pub fn rman_set_irq_cookie(_r: *mut resource, _c: *mut ::core::ffi::c_void);
    pub fn rman_set_mapping(arg1: *mut resource, arg2: *mut resource_map);
    pub fn rman_set_rid(_r: *mut resource, _rid: ::core::ffi::c_int);
    pub fn rman_set_type(_r: *mut resource, _type: ::core::ffi::c_int);
    pub fn rman_set_virtual(_r: *mut resource, _v: *mut ::core::ffi::c_void);
    pub static mut rman_head: rman_head;
    #[link_name = "sglist_init__extern"]
    pub fn sglist_init(sg: *mut sglist, maxsegs: u_short, segs: *mut sglist_seg);
    #[link_name = "sglist_reset__extern"]
    pub fn sglist_reset(sg: *mut sglist);
    #[link_name = "sglist_hold__extern"]
    pub fn sglist_hold(sg: *mut sglist) -> *mut sglist;
    pub fn sglist_alloc(nsegs: ::core::ffi::c_int, mflags: ::core::ffi::c_int) -> *mut sglist;
    pub fn sglist_append(
        sg: *mut sglist,
        buf: *mut ::core::ffi::c_void,
        len: usize,
    ) -> ::core::ffi::c_int;
    pub fn sglist_append_bio(sg: *mut sglist, bp: *mut bio) -> ::core::ffi::c_int;
    pub fn sglist_append_mbuf(sg: *mut sglist, m0: *mut mbuf) -> ::core::ffi::c_int;
    pub fn sglist_append_mbuf_epg(
        sg: *mut sglist,
        m0: *mut mbuf,
        off: usize,
        len: usize,
    ) -> ::core::ffi::c_int;
    pub fn sglist_append_phys(sg: *mut sglist, paddr: vm_paddr_t, len: usize)
    -> ::core::ffi::c_int;
    pub fn sglist_append_sglist(
        sg: *mut sglist,
        source: *mut sglist,
        offset: usize,
        length: usize,
    ) -> ::core::ffi::c_int;
    pub fn sglist_append_single_mbuf(sg: *mut sglist, m: *mut mbuf) -> ::core::ffi::c_int;
    pub fn sglist_append_uio(sg: *mut sglist, uio: *mut uio) -> ::core::ffi::c_int;
    pub fn sglist_append_user(
        sg: *mut sglist,
        buf: *mut ::core::ffi::c_void,
        len: usize,
        td: *mut thread,
    ) -> ::core::ffi::c_int;
    pub fn sglist_append_vmpages(
        sg: *mut sglist,
        m: *mut vm_page_t,
        pgoff: usize,
        len: usize,
    ) -> ::core::ffi::c_int;
    pub fn sglist_build(
        buf: *mut ::core::ffi::c_void,
        len: usize,
        mflags: ::core::ffi::c_int,
    ) -> *mut sglist;
    pub fn sglist_clone(sg: *mut sglist, mflags: ::core::ffi::c_int) -> *mut sglist;
    pub fn sglist_consume_uio(sg: *mut sglist, uio: *mut uio, resid: usize) -> ::core::ffi::c_int;
    pub fn sglist_count(buf: *mut ::core::ffi::c_void, len: usize) -> ::core::ffi::c_int;
    pub fn sglist_count_mbuf_epg(m: *mut mbuf, off: usize, len: usize) -> ::core::ffi::c_int;
    pub fn sglist_count_vmpages(m: *mut vm_page_t, pgoff: usize, len: usize) -> ::core::ffi::c_int;
    pub fn sglist_free(sg: *mut sglist);
    pub fn sglist_join(first: *mut sglist, second: *mut sglist) -> ::core::ffi::c_int;
    pub fn sglist_length(sg: *mut sglist) -> usize;
    pub fn sglist_slice(
        original: *mut sglist,
        slice: *mut *mut sglist,
        offset: usize,
        length: usize,
        mflags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn sglist_split(
        original: *mut sglist,
        head: *mut *mut sglist,
        length: usize,
        mflags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn topo_init_node(node: *mut topo_node);
    pub fn topo_init_root(root: *mut topo_node);
    pub fn topo_add_node_by_hwid(
        parent: *mut topo_node,
        hwid: ::core::ffi::c_int,
        type_: topo_node_type,
        subtype: usize,
    ) -> *mut topo_node;
    pub fn topo_find_node_by_hwid(
        parent: *mut topo_node,
        hwid: ::core::ffi::c_int,
        type_: topo_node_type,
        subtype: usize,
    ) -> *mut topo_node;
    pub fn topo_promote_child(child: *mut topo_node);
    pub fn topo_next_node(top: *mut topo_node, node: *mut topo_node) -> *mut topo_node;
    pub fn topo_next_nonchild_node(top: *mut topo_node, node: *mut topo_node) -> *mut topo_node;
    pub fn topo_set_pu_id(node: *mut topo_node, id: cpuid_t);
    pub fn topo_analyze(
        topo_root: *mut topo_node,
        all: ::core::ffi::c_int,
        results: *mut topo_analysis,
    ) -> ::core::ffi::c_int;
    pub fn smp_topo() -> *mut cpu_group;
    pub fn smp_topo_alloc(count: u_int) -> *mut cpu_group;
    pub fn smp_topo_none() -> *mut cpu_group;
    pub fn smp_topo_1level(
        l1share: ::core::ffi::c_int,
        l1count: ::core::ffi::c_int,
        l1flags: ::core::ffi::c_int,
    ) -> *mut cpu_group;
    pub fn smp_topo_2level(
        l2share: ::core::ffi::c_int,
        l2count: ::core::ffi::c_int,
        l1share: ::core::ffi::c_int,
        l1count: ::core::ffi::c_int,
        l1flags: ::core::ffi::c_int,
    ) -> *mut cpu_group;
    pub fn smp_topo_find(top: *mut cpu_group, cpu: ::core::ffi::c_int) -> *mut cpu_group;
    pub static mut cpustop_restartfunc: ::core::option::Option<unsafe extern "C" fn()>;
    pub static mut resuming_cpus: cpuset_t;
    pub static mut started_cpus: cpuset_t;
    pub static mut stopped_cpus: cpuset_t;
    pub static mut suspended_cpus: cpuset_t;
    pub static mut toresume_cpus: cpuset_t;
    pub static mut hlt_cpus_mask: cpuset_t;
    pub static mut logical_cpus_mask: cpuset_t;
    pub static mut mp_maxid: u_int;
    pub static mut mp_maxcpus: ::core::ffi::c_int;
    pub static mut mp_ncores: ::core::ffi::c_int;
    pub static mut mp_ncpus: ::core::ffi::c_int;
    pub static mut smp_cpus: ::core::ffi::c_int;
    pub static mut smp_started: ::core::ffi::c_int;
    pub static mut smp_threads_per_core: ::core::ffi::c_int;
    pub static mut all_cpus: cpuset_t;
    pub static mut cpuset_domain: [cpuset_t; 8usize];
    pub static mut stoppcbs: *mut pcb;
    #[link_name = "cpu_first__extern"]
    pub fn cpu_first() -> ::core::ffi::c_int;
    #[link_name = "cpu_next__extern"]
    pub fn cpu_next(i: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn cpu_topo() -> *mut cpu_group;
    pub fn cpu_mp_announce();
    pub fn cpu_mp_probe() -> ::core::ffi::c_int;
    pub fn cpu_mp_setmaxid();
    pub fn cpu_mp_start();
    pub fn cpu_mp_stop();
    pub fn forward_signal(arg1: *mut thread);
    pub fn restart_cpus(arg1: cpuset_t) -> ::core::ffi::c_int;
    pub fn stop_cpus(arg1: cpuset_t) -> ::core::ffi::c_int;
    pub fn stop_cpus_hard(arg1: cpuset_t) -> ::core::ffi::c_int;
    pub fn smp_rendezvous_action();
    pub static mut smp_ipi_mtx: mtx;
    pub fn quiesce_all_cpus(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn quiesce_cpus(
        arg1: cpuset_t,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn quiesce_all_critical();
    pub fn cpus_fence_seq_cst();
    pub fn smp_no_rendezvous_barrier(arg1: *mut ::core::ffi::c_void);
    pub fn smp_rendezvous(
        arg1: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg2: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg3: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg: *mut ::core::ffi::c_void,
    );
    pub fn smp_rendezvous_cpus(
        arg1: cpuset_t,
        arg2: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg3: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg4: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg: *mut ::core::ffi::c_void,
    );
    pub fn smp_rendezvous_cpus_retry(
        arg1: cpuset_t,
        arg2: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg3: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg4: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg5: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: ::core::ffi::c_int),
        >,
        arg6: *mut smp_rendezvous_cpus_retry_arg,
    );
    pub fn smp_rendezvous_cpus_done(arg1: *mut smp_rendezvous_cpus_retry_arg);
    pub fn taskqueue_create(
        name: *const ::core::ffi::c_char,
        mflags: ::core::ffi::c_int,
        enqueue: taskqueue_enqueue_fn,
        context: *mut ::core::ffi::c_void,
    ) -> *mut taskqueue;
    pub fn taskqueue_start_threads(
        tqp: *mut *mut taskqueue,
        count: ::core::ffi::c_int,
        pri: ::core::ffi::c_int,
        name: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn taskqueue_start_threads_in_proc(
        tqp: *mut *mut taskqueue,
        count: ::core::ffi::c_int,
        pri: ::core::ffi::c_int,
        p: *mut proc_,
        name: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn taskqueue_start_threads_cpuset(
        tqp: *mut *mut taskqueue,
        count: ::core::ffi::c_int,
        pri: ::core::ffi::c_int,
        mask: *mut cpuset_t,
        name: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn taskqueue_enqueue(queue: *mut taskqueue, task: *mut task) -> ::core::ffi::c_int;
    pub fn taskqueue_enqueue_flags(
        queue: *mut taskqueue,
        task: *mut task,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn taskqueue_enqueue_timeout(
        queue: *mut taskqueue,
        timeout_task: *mut timeout_task,
        ticks: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn taskqueue_enqueue_timeout_sbt(
        queue: *mut taskqueue,
        timeout_task: *mut timeout_task,
        sbt: sbintime_t,
        pr: sbintime_t,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn taskqueue_poll_is_busy(queue: *mut taskqueue, task: *mut task) -> ::core::ffi::c_int;
    pub fn taskqueue_cancel(
        queue: *mut taskqueue,
        task: *mut task,
        pendp: *mut u_int,
    ) -> ::core::ffi::c_int;
    pub fn taskqueue_cancel_timeout(
        queue: *mut taskqueue,
        timeout_task: *mut timeout_task,
        pendp: *mut u_int,
    ) -> ::core::ffi::c_int;
    pub fn taskqueue_drain(queue: *mut taskqueue, task: *mut task);
    pub fn taskqueue_drain_timeout(queue: *mut taskqueue, timeout_task: *mut timeout_task);
    pub fn taskqueue_drain_all(queue: *mut taskqueue);
    pub fn taskqueue_quiesce(queue: *mut taskqueue);
    pub fn taskqueue_free(queue: *mut taskqueue);
    pub fn taskqueue_run(queue: *mut taskqueue);
    pub fn taskqueue_block(queue: *mut taskqueue);
    pub fn taskqueue_unblock(queue: *mut taskqueue);
    pub fn taskqueue_member(queue: *mut taskqueue, td: *mut thread) -> ::core::ffi::c_int;
    pub fn taskqueue_set_callback(
        queue: *mut taskqueue,
        cb_type: taskqueue_callback_type,
        callback: taskqueue_callback_fn,
        context: *mut ::core::ffi::c_void,
    );
    pub fn taskqueue_thread_loop(arg: *mut ::core::ffi::c_void);
    pub fn taskqueue_thread_enqueue(context: *mut ::core::ffi::c_void);
    pub fn _timeout_task_init(
        queue: *mut taskqueue,
        timeout_task: *mut timeout_task,
        priority: ::core::ffi::c_int,
        func: task_fn_t,
        context: *mut ::core::ffi::c_void,
    );
    pub static mut taskqueue_swi_giant: *mut taskqueue;
    pub static mut taskqueue_swi: *mut taskqueue;
    pub static mut taskqueue_thread: *mut taskqueue;
    pub static mut taskqueue_fast: *mut taskqueue;
    pub fn taskqueue_create_fast(
        name: *const ::core::ffi::c_char,
        mflags: ::core::ffi::c_int,
        enqueue: taskqueue_enqueue_fn,
        context: *mut ::core::ffi::c_void,
    ) -> *mut taskqueue;
    pub static mut taskqueue_bus: *mut taskqueue;
    pub fn busdma_lock_mutex(arg: *mut ::core::ffi::c_void, op: bus_dma_lock_op_t);
    pub fn _busdma_dflt_lock(arg: *mut ::core::ffi::c_void, op: bus_dma_lock_op_t);
    pub fn bus_dma_tag_create(
        parent: bus_dma_tag_t,
        alignment: bus_size_t,
        boundary: bus_addr_t,
        lowaddr: bus_addr_t,
        highaddr: bus_addr_t,
        filtfunc: bus_dma_filter_t,
        filtfuncarg: *mut ::core::ffi::c_void,
        maxsize: bus_size_t,
        nsegments: ::core::ffi::c_int,
        maxsegsz: bus_size_t,
        flags: ::core::ffi::c_int,
        lockfunc: bus_dma_lock_t,
        lockfuncarg: *mut ::core::ffi::c_void,
        dmat: *mut bus_dma_tag_t,
    ) -> ::core::ffi::c_int;
    pub fn bus_dma_template_init(t: *mut bus_dma_template_t, parent: bus_dma_tag_t);
    pub fn bus_dma_template_tag(
        t: *mut bus_dma_template_t,
        dmat: *mut bus_dma_tag_t,
    ) -> ::core::ffi::c_int;
    pub fn bus_dma_template_clone(t: *mut bus_dma_template_t, dmat: bus_dma_tag_t);
    pub fn bus_dma_template_fill(
        t: *mut bus_dma_template_t,
        kv: *mut bus_dma_param_t,
        count: u_int,
    );
    pub fn bus_dma_tag_set_domain(
        dmat: bus_dma_tag_t,
        domain: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_dma_tag_destroy(dmat: bus_dma_tag_t) -> ::core::ffi::c_int;
    pub fn bus_dmamap_load(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        buf: *mut ::core::ffi::c_void,
        buflen: bus_size_t,
        callback: bus_dmamap_callback_t,
        callback_arg: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_dmamap_load_mbuf(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        mbuf: *mut mbuf,
        callback: bus_dmamap_callback2_t,
        callback_arg: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_dmamap_load_mbuf_sg(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        mbuf: *mut mbuf,
        segs: *mut bus_dma_segment_t,
        nsegs: *mut ::core::ffi::c_int,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_dmamap_load_uio(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        ui: *mut uio,
        callback: bus_dmamap_callback2_t,
        callback_arg: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_dmamap_load_ccb(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        ccb: *mut ccb,
        callback: bus_dmamap_callback_t,
        callback_arg: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_dmamap_load_bio(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        bio: *mut bio,
        callback: bus_dmamap_callback_t,
        callback_arg: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_dmamap_load_crp(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        crp: *mut cryptop,
        callback: bus_dmamap_callback_t,
        callback_arg: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_dmamap_load_crp_buffer(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        cb: *mut crypto_buffer,
        callback: bus_dmamap_callback_t,
        callback_arg: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_dmamap_load_mem(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        mem: *mut memdesc,
        callback: bus_dmamap_callback_t,
        callback_arg: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn bus_dmamap_load_ma_triv(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        ma: *mut *mut vm_page,
        tlen: bus_size_t,
        ma_offs: ::core::ffi::c_int,
        flags: ::core::ffi::c_int,
        segs: *mut bus_dma_segment_t,
        segp: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[link_name = "bus_dmamap_create__extern"]
    pub fn bus_dmamap_create(
        dmat: bus_dma_tag_t,
        flags: ::core::ffi::c_int,
        mapp: *mut bus_dmamap_t,
    ) -> ::core::ffi::c_int;
    #[link_name = "bus_dmamap_destroy__extern"]
    pub fn bus_dmamap_destroy(dmat: bus_dma_tag_t, map: bus_dmamap_t) -> ::core::ffi::c_int;
    #[link_name = "bus_dmamem_alloc__extern"]
    pub fn bus_dmamem_alloc(
        dmat: bus_dma_tag_t,
        vaddr: *mut *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
        mapp: *mut bus_dmamap_t,
    ) -> ::core::ffi::c_int;
    #[link_name = "bus_dmamem_free__extern"]
    pub fn bus_dmamem_free(dmat: bus_dma_tag_t, vaddr: *mut ::core::ffi::c_void, map: bus_dmamap_t);
    #[link_name = "bus_dmamap_sync__extern"]
    pub fn bus_dmamap_sync(dmat: bus_dma_tag_t, dmamap: bus_dmamap_t, op: bus_dmasync_op_t);
    #[link_name = "bus_dmamap_unload__extern"]
    pub fn bus_dmamap_unload(dmat: bus_dma_tag_t, dmamap: bus_dmamap_t);
    pub fn common_bus_dma_tag_create(
        parent: *mut bus_dma_tag_common,
        alignment: bus_size_t,
        boundary: bus_addr_t,
        lowaddr: bus_addr_t,
        highaddr: bus_addr_t,
        maxsize: bus_size_t,
        nsegments: ::core::ffi::c_int,
        maxsegsz: bus_size_t,
        flags: ::core::ffi::c_int,
        lockfunc: bus_dma_lock_t,
        lockfuncarg: *mut ::core::ffi::c_void,
        sz: usize,
        dmat: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub static mut bus_dma_bounce_impl: bus_dma_impl;
    #[link_name = "bus_dma_id_mapped__extern"]
    pub fn bus_dma_id_mapped(dmat: bus_dma_tag_t, buf: vm_paddr_t, buflen: bus_size_t) -> bool_;
    #[link_name = "_bus_dmamap_load_phys__extern"]
    pub fn _bus_dmamap_load_phys(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        buf: vm_paddr_t,
        buflen: bus_size_t,
        flags: ::core::ffi::c_int,
        segs: *mut bus_dma_segment_t,
        segp: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[link_name = "_bus_dmamap_load_ma__extern"]
    pub fn _bus_dmamap_load_ma(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        ma: *mut *mut vm_page,
        tlen: bus_size_t,
        ma_offs: ::core::ffi::c_int,
        flags: ::core::ffi::c_int,
        segs: *mut bus_dma_segment_t,
        segp: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[link_name = "_bus_dmamap_load_buffer__extern"]
    pub fn _bus_dmamap_load_buffer(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        buf: *mut ::core::ffi::c_void,
        buflen: bus_size_t,
        pmap: *mut pmap,
        flags: ::core::ffi::c_int,
        segs: *mut bus_dma_segment_t,
        segp: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[link_name = "_bus_dmamap_waitok__extern"]
    pub fn _bus_dmamap_waitok(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        mem: *mut memdesc,
        callback: bus_dmamap_callback_t,
        callback_arg: *mut ::core::ffi::c_void,
    );
    #[link_name = "_bus_dmamap_complete__extern"]
    pub fn _bus_dmamap_complete(
        dmat: bus_dma_tag_t,
        map: bus_dmamap_t,
        segs: *mut bus_dma_segment_t,
        nsegs: ::core::ffi::c_int,
        error: ::core::ffi::c_int,
    ) -> *mut bus_dma_segment_t;
    pub static mut arm64_bus_method: arm64_bus;
    pub fn dbg_init();
    pub fn has_hyp() -> bool_;
    pub fn in_vhe() -> bool_;
    pub fn initarm(arg1: *mut arm64_bootparams);
    pub fn parse_boot_param(abp: *mut arm64_bootparams) -> vm_offset_t;
    pub fn parse_fdt_bootargs();
    pub fn memory_mapping_mode(pa: vm_paddr_t) -> ::core::ffi::c_int;
    pub static mut pagezero:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
    pub fn dbg_monitor_init();
    pub fn dbg_register_sync(arg1: *mut debug_monitor_state);
    pub fn vfp_init_secondary();
    pub fn vfp_enable();
    pub fn vfp_disable();
    pub fn vfp_discard(arg1: *mut thread);
    pub fn vfp_store(arg1: *mut vfpstate);
    pub fn vfp_restore(arg1: *mut vfpstate);
    pub fn vfp_new_thread(arg1: *mut thread, arg2: *mut thread, arg3: bool_);
    pub fn vfp_reset_state(arg1: *mut thread, arg2: *mut pcb);
    pub fn vfp_restore_state();
    pub fn vfp_save_state(arg1: *mut thread, arg2: *mut pcb);
    pub fn vfp_save_state_savectx(arg1: *mut pcb);
    pub fn vfp_save_state_switch(arg1: *mut thread);
    pub fn vfp_to_sve_sync(arg1: *mut thread);
    pub fn sve_to_vfp_sync(arg1: *mut thread);
    pub fn sve_max_buf_size() -> usize;
    pub fn sve_buf_size(arg1: *mut thread) -> usize;
    pub fn sve_restore_state(arg1: *mut thread) -> bool_;
    pub fn fpu_kern_alloc_ctx(arg1: u_int) -> *mut fpu_kern_ctx;
    pub fn fpu_kern_free_ctx(arg1: *mut fpu_kern_ctx);
    pub fn fpu_kern_enter(arg1: *mut thread, arg2: *mut fpu_kern_ctx, arg3: u_int);
    pub fn fpu_kern_leave(arg1: *mut thread, arg2: *mut fpu_kern_ctx) -> ::core::ffi::c_int;
    pub fn fpu_kern_thread(arg1: u_int) -> ::core::ffi::c_int;
    pub fn is_fpu_kern_thread(arg1: u_int) -> ::core::ffi::c_int;
    pub fn fpu_save_area_alloc() -> *mut vfpstate;
    pub fn fpu_save_area_free(fsa: *mut vfpstate);
    pub fn fpu_save_area_reset(fsa: *mut vfpstate);
    pub fn get_fpcontext32(td: *mut thread, mcp: *mut mcontext32_vfp_t);
    pub fn set_fpcontext32(td: *mut thread, mcp: *mut mcontext32_vfp_t);
    pub fn makectx(tf: *mut trapframe, pcb: *mut pcb);
    pub fn savectx(pcb: *mut pcb);
    pub fn ipi_all_but_self(ipi: u_int);
    pub fn ipi_cpu(cpu: ::core::ffi::c_int, ipi: u_int);
    pub fn ipi_selected(cpus: cpuset_t, ipi: u_int);
    #[doc = " @brief Unique descriptor for the OFW_BUS_GET_DEVINFO() method"]
    pub static mut ofw_bus_get_devinfo_desc: kobjop_desc;
    #[link_name = "OFW_BUS_GET_DEVINFO__extern"]
    pub fn OFW_BUS_GET_DEVINFO(bus: device_t, dev: device_t) -> *const ofw_bus_devinfo;
    #[doc = " @brief Unique descriptor for the OFW_BUS_GET_COMPAT() method"]
    pub static mut ofw_bus_get_compat_desc: kobjop_desc;
    #[link_name = "OFW_BUS_GET_COMPAT__extern"]
    pub fn OFW_BUS_GET_COMPAT(bus: device_t, dev: device_t) -> *const ::core::ffi::c_char;
    #[doc = " @brief Unique descriptor for the OFW_BUS_GET_MODEL() method"]
    pub static mut ofw_bus_get_model_desc: kobjop_desc;
    #[link_name = "OFW_BUS_GET_MODEL__extern"]
    pub fn OFW_BUS_GET_MODEL(bus: device_t, dev: device_t) -> *const ::core::ffi::c_char;
    #[doc = " @brief Unique descriptor for the OFW_BUS_GET_NAME() method"]
    pub static mut ofw_bus_get_name_desc: kobjop_desc;
    #[link_name = "OFW_BUS_GET_NAME__extern"]
    pub fn OFW_BUS_GET_NAME(bus: device_t, dev: device_t) -> *const ::core::ffi::c_char;
    #[doc = " @brief Unique descriptor for the OFW_BUS_GET_NODE() method"]
    pub static mut ofw_bus_get_node_desc: kobjop_desc;
    #[link_name = "OFW_BUS_GET_NODE__extern"]
    pub fn OFW_BUS_GET_NODE(bus: device_t, dev: device_t) -> phandle_t;
    #[doc = " @brief Unique descriptor for the OFW_BUS_GET_TYPE() method"]
    pub static mut ofw_bus_get_type_desc: kobjop_desc;
    #[link_name = "OFW_BUS_GET_TYPE__extern"]
    pub fn OFW_BUS_GET_TYPE(bus: device_t, dev: device_t) -> *const ::core::ffi::c_char;
    #[doc = " @brief Unique descriptor for the OFW_BUS_MAP_INTR() method"]
    pub static mut ofw_bus_map_intr_desc: kobjop_desc;
    #[link_name = "OFW_BUS_MAP_INTR__extern"]
    pub fn OFW_BUS_MAP_INTR(
        bus: device_t,
        dev: device_t,
        iparent: phandle_t,
        icells: ::core::ffi::c_int,
        interrupt: *mut pcell_t,
    ) -> ::core::ffi::c_int;
    #[link_name = "ofw_bus_get_compat__extern"]
    pub fn ofw_bus_get_compat(dev: device_t) -> *const ::core::ffi::c_char;
    #[link_name = "ofw_bus_get_model__extern"]
    pub fn ofw_bus_get_model(dev: device_t) -> *const ::core::ffi::c_char;
    #[link_name = "ofw_bus_get_name__extern"]
    pub fn ofw_bus_get_name(dev: device_t) -> *const ::core::ffi::c_char;
    #[link_name = "ofw_bus_get_node__extern"]
    pub fn ofw_bus_get_node(dev: device_t) -> phandle_t;
    #[link_name = "ofw_bus_get_type__extern"]
    pub fn ofw_bus_get_type(dev: device_t) -> *const ::core::ffi::c_char;
    #[link_name = "ofw_bus_map_intr__extern"]
    pub fn ofw_bus_map_intr(
        dev: device_t,
        iparent: phandle_t,
        icells: ::core::ffi::c_int,
        intr: *mut pcell_t,
    ) -> ::core::ffi::c_int;
    pub static mut simplebus_driver: kobj_class;
    pub fn simplebus_init(dev: device_t, node: phandle_t);
    pub fn simplebus_add_device(
        dev: device_t,
        node: phandle_t,
        order: u_int,
        name: *const ::core::ffi::c_char,
        unit: ::core::ffi::c_int,
        di: *mut simplebus_devinfo,
    ) -> device_t;
    pub fn simplebus_setup_dinfo(
        dev: device_t,
        node: phandle_t,
        di: *mut simplebus_devinfo,
    ) -> *mut simplebus_devinfo;
    pub fn simplebus_fill_ranges(node: phandle_t, sc: *mut simplebus_softc) -> ::core::ffi::c_int;
    pub fn simplebus_attach(dev: device_t) -> ::core::ffi::c_int;
    pub fn simplebus_attach_impl(dev: device_t) -> ::core::ffi::c_int;
    pub fn simplebus_detach(dev: device_t) -> ::core::ffi::c_int;
    pub fn ofw_bus_gen_setup_devinfo(
        arg1: *mut ofw_bus_devinfo,
        arg2: phandle_t,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_gen_destroy_devinfo(arg1: *mut ofw_bus_devinfo);
    pub fn ofw_bus_gen_get_compat(bus: device_t, dev: device_t) -> *const ::core::ffi::c_char;
    pub fn ofw_bus_gen_get_model(bus: device_t, dev: device_t) -> *const ::core::ffi::c_char;
    pub fn ofw_bus_gen_get_name(bus: device_t, dev: device_t) -> *const ::core::ffi::c_char;
    pub fn ofw_bus_gen_get_node(bus: device_t, dev: device_t) -> phandle_t;
    pub fn ofw_bus_gen_get_type(bus: device_t, dev: device_t) -> *const ::core::ffi::c_char;
    pub fn ofw_bus_gen_child_pnpinfo(
        _dev: device_t,
        _child: device_t,
        _sb: *mut sbuf,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_gen_get_device_path(
        _bus: device_t,
        _child: device_t,
        _locator: *const ::core::ffi::c_char,
        _sb: *mut sbuf,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_setup_iinfo(arg1: phandle_t, arg2: *mut ofw_bus_iinfo, arg3: ::core::ffi::c_int);
    pub fn ofw_bus_lookup_imap(
        arg1: phandle_t,
        arg2: *mut ofw_bus_iinfo,
        arg3: *mut ::core::ffi::c_void,
        arg4: ::core::ffi::c_int,
        arg5: *mut ::core::ffi::c_void,
        arg6: ::core::ffi::c_int,
        arg7: *mut ::core::ffi::c_void,
        arg8: ::core::ffi::c_int,
        arg9: *mut phandle_t,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_search_intrmap(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::core::ffi::c_int,
        arg3: *mut ::core::ffi::c_void,
        arg4: ::core::ffi::c_int,
        arg5: *mut ::core::ffi::c_void,
        arg6: ::core::ffi::c_int,
        arg7: *mut ::core::ffi::c_void,
        arg8: *mut ::core::ffi::c_void,
        arg9: *mut ::core::ffi::c_void,
        arg10: ::core::ffi::c_int,
        arg11: *mut phandle_t,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_msimap(
        arg1: phandle_t,
        arg2: u16,
        arg3: *mut phandle_t,
        arg4: *mut u32,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_iommu_map(
        arg1: phandle_t,
        arg2: u16,
        arg3: *mut phandle_t,
        arg4: *mut u32,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_reg_to_rl(
        arg1: device_t,
        arg2: phandle_t,
        arg3: pcell_t,
        arg4: pcell_t,
        arg5: *mut resource_list,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_assigned_addresses_to_rl(
        arg1: device_t,
        arg2: phandle_t,
        arg3: pcell_t,
        arg4: pcell_t,
        arg5: *mut resource_list,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_intr_to_rl(
        arg1: device_t,
        arg2: phandle_t,
        arg3: *mut resource_list,
        arg4: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_intr_by_rid(
        arg1: device_t,
        arg2: phandle_t,
        arg3: ::core::ffi::c_int,
        arg4: *mut phandle_t,
        arg5: *mut ::core::ffi::c_int,
        arg6: *mut *mut pcell_t,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_get_status(dev: device_t) -> *const ::core::ffi::c_char;
    pub fn ofw_bus_status_okay(dev: device_t) -> ::core::ffi::c_int;
    pub fn ofw_bus_node_status_okay(node: phandle_t) -> ::core::ffi::c_int;
    pub fn ofw_bus_find_iparent(arg1: phandle_t) -> phandle_t;
    pub fn ofw_bus_is_compatible(
        arg1: device_t,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_is_compatible_strict(
        arg1: device_t,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_node_is_compatible(
        arg1: phandle_t,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_search_compatible(
        arg1: device_t,
        arg2: *const ofw_compat_data,
    ) -> *const ofw_compat_data;
    pub fn ofw_bus_has_prop(arg1: device_t, arg2: *const ::core::ffi::c_char)
    -> ::core::ffi::c_int;
    pub fn ofw_bus_find_compatible(arg1: phandle_t, arg2: *const ::core::ffi::c_char) -> phandle_t;
    pub fn ofw_bus_find_child(arg1: phandle_t, arg2: *const ::core::ffi::c_char) -> phandle_t;
    pub fn ofw_bus_find_child_device_by_phandle(bus: device_t, node: phandle_t) -> device_t;
    pub fn ofw_bus_parse_xref_list_alloc(
        node: phandle_t,
        list_name: *const ::core::ffi::c_char,
        cells_name: *const ::core::ffi::c_char,
        idx: ::core::ffi::c_int,
        producer: *mut phandle_t,
        ncells: *mut ::core::ffi::c_int,
        cells: *mut *mut pcell_t,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_parse_xref_list_get_length(
        node: phandle_t,
        list_name: *const ::core::ffi::c_char,
        cells_name: *const ::core::ffi::c_char,
        count: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_find_string_index(
        node: phandle_t,
        list_name: *const ::core::ffi::c_char,
        name: *const ::core::ffi::c_char,
        idx: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn ofw_bus_string_list_to_array(
        node: phandle_t,
        list_name: *const ::core::ffi::c_char,
        array: *mut *mut *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub static mut ktr_cpumask: cpuset_t;
    pub static mut ktr_mask: u64;
    pub static mut ktr_entries: ::core::ffi::c_int;
    pub static mut ktr_verbose: ::core::ffi::c_int;
    pub static mut ktr_idx: ::core::ffi::c_int;
    pub static mut ktr_buf: *mut ktr_entry;
    pub static power_stype_names: [*const ::core::ffi::c_char; 6usize];
    pub static mut power_standby_stype: power_stype;
    pub static mut power_suspend_stype: power_stype;
    pub static mut power_hibernate_stype: power_stype;
    pub fn power_name_to_stype(_name: *const ::core::ffi::c_char) -> power_stype;
    pub fn power_stype_to_name(_stype: power_stype) -> *const ::core::ffi::c_char;
    pub fn power_pm_register(
        _pm_type: u_int,
        _pm_fn: power_pm_fn_t,
        _pm_arg: *mut ::core::ffi::c_void,
        _pm_supported: *mut bool_,
    ) -> ::core::ffi::c_int;
    pub fn power_pm_get_type() -> u_int;
    pub fn power_pm_suspend(arg1: ::core::ffi::c_int);
    pub fn power_profile_get_state() -> ::core::ffi::c_int;
    pub fn power_profile_set_state(arg1: ::core::ffi::c_int);
    pub fn eventhandler_register(
        list: *mut eventhandler_list,
        name: *const ::core::ffi::c_char,
        func: *mut ::core::ffi::c_void,
        arg: *mut ::core::ffi::c_void,
        priority: ::core::ffi::c_int,
    ) -> eventhandler_tag;
    pub fn eventhandler_deregister(list: *mut eventhandler_list, tag: eventhandler_tag);
    pub fn eventhandler_deregister_nowait(list: *mut eventhandler_list, tag: eventhandler_tag);
    pub fn eventhandler_find_list(name: *const ::core::ffi::c_char) -> *mut eventhandler_list;
    pub fn eventhandler_prune_list(list: *mut eventhandler_list);
    pub fn eventhandler_create_list(name: *const ::core::ffi::c_char) -> *mut eventhandler_list;
    pub fn vimage_eventhandler_register(
        list: *mut eventhandler_list,
        name: *const ::core::ffi::c_char,
        func: *mut ::core::ffi::c_void,
        arg: *mut ::core::ffi::c_void,
        priority: ::core::ffi::c_int,
        arg1: vimage_iterator_func_t,
    ) -> eventhandler_tag;
    pub fn fiodgname_buf_get_ptr(
        fgnp: *mut ::core::ffi::c_void,
        com: u_long,
    ) -> *mut ::core::ffi::c_void;
    pub fn seldrain(sip: *mut selinfo);
    pub fn selrecord(selector: *mut thread, sip: *mut selinfo);
    pub fn selwakeup(sip: *mut selinfo);
    pub fn selwakeuppri(sip: *mut selinfo, pri: ::core::ffi::c_int);
    pub fn seltdfini(td: *mut thread);
    pub fn clone_setup(cdp: *mut *mut clonedevs);
    pub fn clone_cleanup(arg1: *mut *mut clonedevs);
    pub fn clone_create(
        arg1: *mut *mut clonedevs,
        arg2: *mut cdevsw,
        unit: *mut ::core::ffi::c_int,
        dev: *mut *mut cdev,
        extra: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn make_dev_args_init_impl(_args: *mut make_dev_args, _sz: usize);
    pub fn delist_dev(_dev: *mut cdev);
    pub fn destroy_dev(_dev: *mut cdev);
    pub fn destroy_dev_sched(dev: *mut cdev) -> ::core::ffi::c_int;
    pub fn destroy_dev_sched_cb(
        dev: *mut cdev,
        cb: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn destroy_dev_drain(csw: *mut cdevsw);
    pub fn dev_copyname(dev: *mut cdev, path: *mut ::core::ffi::c_char, len: usize);
    pub fn dev_refthread(_dev: *mut cdev, _ref: *mut ::core::ffi::c_int) -> *mut cdevsw;
    pub fn devvn_refthread(
        vp: *mut vnode,
        devp: *mut *mut cdev,
        _ref: *mut ::core::ffi::c_int,
    ) -> *mut cdevsw;
    pub fn dev_relthread(_dev: *mut cdev, _ref: ::core::ffi::c_int);
    pub fn dev_depends(_pdev: *mut cdev, _cdev: *mut cdev);
    pub fn dev_ref(dev: *mut cdev);
    pub fn dev_refl(dev: *mut cdev);
    pub fn dev_rel(dev: *mut cdev);
    pub fn make_dev(
        _devsw: *mut cdevsw,
        _unit: ::core::ffi::c_int,
        _uid: uid_t,
        _gid: gid_t,
        _perms: ::core::ffi::c_int,
        _fmt: *const ::core::ffi::c_char,
        ...
    ) -> *mut cdev;
    pub fn make_dev_cred(
        _devsw: *mut cdevsw,
        _unit: ::core::ffi::c_int,
        _cr: *mut ucred,
        _uid: uid_t,
        _gid: gid_t,
        _perms: ::core::ffi::c_int,
        _fmt: *const ::core::ffi::c_char,
        ...
    ) -> *mut cdev;
    pub fn make_dev_credf(
        _flags: ::core::ffi::c_int,
        _devsw: *mut cdevsw,
        _unit: ::core::ffi::c_int,
        _cr: *mut ucred,
        _uid: uid_t,
        _gid: gid_t,
        _mode: ::core::ffi::c_int,
        _fmt: *const ::core::ffi::c_char,
        ...
    ) -> *mut cdev;
    pub fn make_dev_p(
        _flags: ::core::ffi::c_int,
        _cdev: *mut *mut cdev,
        _devsw: *mut cdevsw,
        _cr: *mut ucred,
        _uid: uid_t,
        _gid: gid_t,
        _mode: ::core::ffi::c_int,
        _fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn make_dev_s(
        _args: *mut make_dev_args,
        _cdev: *mut *mut cdev,
        _fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn make_dev_alias(_pdev: *mut cdev, _fmt: *const ::core::ffi::c_char, ...) -> *mut cdev;
    pub fn make_dev_alias_p(
        _flags: ::core::ffi::c_int,
        _cdev: *mut *mut cdev,
        _pdev: *mut cdev,
        _fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn make_dev_physpath_alias(
        _flags: ::core::ffi::c_int,
        _cdev: *mut *mut cdev,
        _pdev: *mut cdev,
        _old_alias: *mut cdev,
        _physpath: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn dev_lock();
    pub fn dev_unlock();
    pub fn devfs_get_cdevpriv(datap: *mut *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
    pub fn devfs_set_cdevpriv(
        priv_: *mut ::core::ffi::c_void,
        dtr: d_priv_dtor_t,
    ) -> ::core::ffi::c_int;
    pub fn devfs_clear_cdevpriv();
    pub fn devfs_foreach_cdevpriv(
        dev: *mut cdev,
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                data: *mut ::core::ffi::c_void,
                arg: *mut ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
        arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn devfs_alloc_cdp_inode() -> ino_t;
    pub fn devfs_free_cdp_inode(ino: ino_t);
    pub fn dev_stdclone(
        _name: *mut ::core::ffi::c_char,
        _namep: *mut *mut ::core::ffi::c_char,
        _stem: *const ::core::ffi::c_char,
        _unit: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub static mut dumping: ::core::ffi::c_int;
    pub static mut dumped_core: bool_;
    pub fn doadump(arg1: boolean_t) -> ::core::ffi::c_int;
    pub fn dumper_create(
        di_template: *const dumperinfo,
        devname: *const ::core::ffi::c_char,
        kda: *const diocskerneldump_arg,
        dip: *mut *mut dumperinfo,
    ) -> ::core::ffi::c_int;
    pub fn dumper_destroy(di: *mut dumperinfo);
    pub fn dumper_insert(
        di_template: *const dumperinfo,
        devname: *const ::core::ffi::c_char,
        kda: *const diocskerneldump_arg,
    ) -> ::core::ffi::c_int;
    pub fn dumper_remove(
        devname: *const ::core::ffi::c_char,
        kda: *const diocskerneldump_arg,
    ) -> ::core::ffi::c_int;
    pub fn dumper_ddb_insert(arg1: *mut dumperinfo);
    pub fn dumper_ddb_remove(arg1: *mut dumperinfo);
    pub fn dump_start(di: *mut dumperinfo, kdh: *mut kerneldumpheader) -> ::core::ffi::c_int;
    pub fn dump_append(
        arg1: *mut dumperinfo,
        arg2: *mut ::core::ffi::c_void,
        arg3: usize,
    ) -> ::core::ffi::c_int;
    pub fn dump_write(
        arg1: *mut dumperinfo,
        arg2: *mut ::core::ffi::c_void,
        arg3: off_t,
        arg4: usize,
    ) -> ::core::ffi::c_int;
    pub fn dump_finish(di: *mut dumperinfo, kdh: *mut kerneldumpheader) -> ::core::ffi::c_int;
    pub fn dump_init_header(
        di: *const dumperinfo,
        kdh: *mut kerneldumpheader,
        magic: *const ::core::ffi::c_char,
        archver: u32,
        dumplen: u64,
    );
    pub fn foffset_lock(fp: *mut file, flags: ::core::ffi::c_int) -> off_t;
    pub fn foffset_lock_pair(
        fp1: *mut file,
        off1p: *mut off_t,
        fp2: *mut file,
        off2p: *mut off_t,
        flags: ::core::ffi::c_int,
    );
    pub fn foffset_lock_uio(fp: *mut file, uio: *mut uio, flags: ::core::ffi::c_int);
    pub fn foffset_unlock(fp: *mut file, val: off_t, flags: ::core::ffi::c_int);
    pub fn foffset_unlock_uio(fp: *mut file, uio: *mut uio, flags: ::core::ffi::c_int);
    pub fn fsetfl_lock(fp: *mut file);
    pub fn fsetfl_unlock(fp: *mut file);
    #[link_name = "foffset_get__extern"]
    pub fn foffset_get(fp: *mut file) -> off_t;
    pub static vnops: fileops;
    pub static badfileops: fileops;
    pub static path_fileops: fileops;
    pub static socketops: fileops;
    pub static mut maxfiles: ::core::ffi::c_int;
    pub static mut maxfilesperproc: ::core::ffi::c_int;
    pub fn fget(
        td: *mut thread,
        fd: ::core::ffi::c_int,
        rightsp: *const cap_rights_t,
        fpp: *mut *mut file,
    ) -> ::core::ffi::c_int;
    pub fn fget_mmap(
        td: *mut thread,
        fd: ::core::ffi::c_int,
        rightsp: *const cap_rights_t,
        maxprotp: *mut vm_prot_t,
        fpp: *mut *mut file,
    ) -> ::core::ffi::c_int;
    pub fn fget_read(
        td: *mut thread,
        fd: ::core::ffi::c_int,
        rightsp: *const cap_rights_t,
        fpp: *mut *mut file,
    ) -> ::core::ffi::c_int;
    pub fn fget_write(
        td: *mut thread,
        fd: ::core::ffi::c_int,
        rightsp: *const cap_rights_t,
        fpp: *mut *mut file,
    ) -> ::core::ffi::c_int;
    pub fn fget_fcntl(
        td: *mut thread,
        fd: ::core::ffi::c_int,
        rightsp: *const cap_rights_t,
        needfcntl: ::core::ffi::c_int,
        fpp: *mut *mut file,
    ) -> ::core::ffi::c_int;
    pub fn _fdrop(fp: *mut file, td: *mut thread) -> ::core::ffi::c_int;
    pub fn fget_remote(
        td: *mut thread,
        p: *mut proc_,
        fd: ::core::ffi::c_int,
        fpp: *mut *mut file,
    ) -> ::core::ffi::c_int;
    pub fn fget_remote_foreach(
        td: *mut thread,
        p: *mut proc_,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut proc_,
                arg2: ::core::ffi::c_int,
                arg3: *mut file,
                arg4: *mut ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
        arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn invfo_rdwr(
        fp: *mut file,
        uio: *mut uio,
        active_cred: *mut ucred,
        flags: ::core::ffi::c_int,
        td: *mut thread,
    ) -> ::core::ffi::c_int;
    pub fn invfo_truncate(
        fp: *mut file,
        length: off_t,
        active_cred: *mut ucred,
        td: *mut thread,
    ) -> ::core::ffi::c_int;
    pub fn invfo_ioctl(
        fp: *mut file,
        com: u_long,
        data: *mut ::core::ffi::c_void,
        active_cred: *mut ucred,
        td: *mut thread,
    ) -> ::core::ffi::c_int;
    pub fn invfo_poll(
        fp: *mut file,
        events: ::core::ffi::c_int,
        active_cred: *mut ucred,
        td: *mut thread,
    ) -> ::core::ffi::c_int;
    pub fn invfo_kqfilter(fp: *mut file, kn: *mut knote) -> ::core::ffi::c_int;
    pub fn invfo_chmod(
        fp: *mut file,
        mode: mode_t,
        active_cred: *mut ucred,
        td: *mut thread,
    ) -> ::core::ffi::c_int;
    pub fn invfo_chown(
        fp: *mut file,
        uid: uid_t,
        gid: gid_t,
        active_cred: *mut ucred,
        td: *mut thread,
    ) -> ::core::ffi::c_int;
    pub fn invfo_sendfile(
        fp: *mut file,
        sockfd: ::core::ffi::c_int,
        hdr_uio: *mut uio,
        trl_uio: *mut uio,
        offset: off_t,
        nbytes: usize,
        sent: *mut off_t,
        flags: ::core::ffi::c_int,
        td: *mut thread,
    ) -> ::core::ffi::c_int;
    pub fn vn_statfile(fp: *mut file, sb: *mut stat, active_cred: *mut ucred)
    -> ::core::ffi::c_int;
    pub fn vn_sendfile(
        fp: *mut file,
        sockfd: ::core::ffi::c_int,
        hdr_uio: *mut uio,
        trl_uio: *mut uio,
        offset: off_t,
        nbytes: usize,
        sent: *mut off_t,
        flags: ::core::ffi::c_int,
        td: *mut thread,
    ) -> ::core::ffi::c_int;
    pub fn vn_seek(
        fp: *mut file,
        offset: off_t,
        whence: ::core::ffi::c_int,
        td: *mut thread,
    ) -> ::core::ffi::c_int;
    pub fn vn_fill_kinfo(
        fp: *mut file,
        kif: *mut kinfo_file,
        fdp: *mut filedesc,
    ) -> ::core::ffi::c_int;
    pub fn vn_kqfilter_opath(fp: *mut file, kn: *mut knote) -> ::core::ffi::c_int;
    pub fn vn_fill_kinfo_vnode(vp: *mut vnode, kif: *mut kinfo_file) -> ::core::ffi::c_int;
    pub fn file_kcmp_generic(fp1: *mut file, fp2: *mut file, td: *mut thread)
    -> ::core::ffi::c_int;
    pub fn finit(
        arg1: *mut file,
        arg2: u_int,
        arg3: ::core::ffi::c_short,
        arg4: *mut ::core::ffi::c_void,
        arg5: *const fileops,
    );
    pub fn finit_vnode(
        arg1: *mut file,
        arg2: u_int,
        arg3: *mut ::core::ffi::c_void,
        arg4: *const fileops,
    );
    pub fn fgetvp(
        td: *mut thread,
        fd: ::core::ffi::c_int,
        rightsp: *const cap_rights_t,
        vpp: *mut *mut vnode,
    ) -> ::core::ffi::c_int;
    pub fn fgetvp_exec(
        td: *mut thread,
        fd: ::core::ffi::c_int,
        rightsp: *const cap_rights_t,
        vpp: *mut *mut vnode,
    ) -> ::core::ffi::c_int;
    pub fn fgetvp_rights(
        td: *mut thread,
        fd: ::core::ffi::c_int,
        needrightsp: *const cap_rights_t,
        havecaps: *mut filecaps,
        vpp: *mut *mut vnode,
    ) -> ::core::ffi::c_int;
    pub fn fgetvp_read(
        td: *mut thread,
        fd: ::core::ffi::c_int,
        rightsp: *const cap_rights_t,
        vpp: *mut *mut vnode,
    ) -> ::core::ffi::c_int;
    pub fn fgetvp_write(
        td: *mut thread,
        fd: ::core::ffi::c_int,
        rightsp: *const cap_rights_t,
        vpp: *mut *mut vnode,
    ) -> ::core::ffi::c_int;
    pub fn fgetvp_lookup_smr(
        ndp: *mut nameidata,
        vpp: *mut *mut vnode,
        flagsp: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn fgetvp_lookup(ndp: *mut nameidata, vpp: *mut *mut vnode) -> ::core::ffi::c_int;
    #[link_name = "fhold__extern"]
    pub fn fhold(fp: *mut file) -> bool_;
    #[link_name = "fo_seek__extern"]
    pub fn fo_seek(
        fp: *mut file,
        offset: off_t,
        whence: ::core::ffi::c_int,
        td: *mut thread,
    ) -> ::core::ffi::c_int;
    #[link_name = "fo_fill_kinfo__extern"]
    pub fn fo_fill_kinfo(
        fp: *mut file,
        kif: *mut kinfo_file,
        fdp: *mut filedesc,
    ) -> ::core::ffi::c_int;
    #[link_name = "fo_mmap__extern"]
    pub fn fo_mmap(
        fp: *mut file,
        map: vm_map_t,
        addr: *mut vm_offset_t,
        size: vm_size_t,
        prot: vm_prot_t,
        cap_maxprot: vm_prot_t,
        flags: ::core::ffi::c_int,
        foff: vm_ooffset_t,
        td: *mut thread,
    ) -> ::core::ffi::c_int;
    #[link_name = "fo_aio_queue__extern"]
    pub fn fo_aio_queue(fp: *mut file, job: *mut kaiocb) -> ::core::ffi::c_int;
    #[link_name = "fo_add_seals__extern"]
    pub fn fo_add_seals(fp: *mut file, seals: ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[link_name = "fo_get_seals__extern"]
    pub fn fo_get_seals(fp: *mut file, seals: *mut ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[link_name = "fo_fallocate__extern"]
    pub fn fo_fallocate(
        fp: *mut file,
        offset: off_t,
        len: off_t,
        td: *mut thread,
    ) -> ::core::ffi::c_int;
    #[link_name = "fo_fspacectl__extern"]
    pub fn fo_fspacectl(
        fp: *mut file,
        cmd: ::core::ffi::c_int,
        offset: *mut off_t,
        length: *mut off_t,
        flags: ::core::ffi::c_int,
        active_cred: *mut ucred,
        td: *mut thread,
    ) -> ::core::ffi::c_int;
    #[link_name = "fo_cmp__extern"]
    pub fn fo_cmp(fp1: *mut file, fp2: *mut file, td: *mut thread) -> ::core::ffi::c_int;
    pub fn allocuio(iovcnt: u_int) -> *mut uio;
    pub fn freeuio(uio: *mut uio);
    pub fn cloneuio(uiop: *mut uio) -> *mut uio;
    pub fn copyiniov(
        iovp: *const iovec,
        iovcnt: u_int,
        iov: *mut *mut iovec,
        error: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn copyinuio(iovp: *const iovec, iovcnt: u_int, uiop: *mut *mut uio) -> ::core::ffi::c_int;
    pub fn copyout_map(td: *mut thread, addr: *mut vm_offset_t, sz: usize) -> ::core::ffi::c_int;
    pub fn copyout_unmap(td: *mut thread, addr: vm_offset_t, sz: usize) -> ::core::ffi::c_int;
    pub fn exterr_copyout(td: *mut thread);
    pub fn physcopyin(
        src: *mut ::core::ffi::c_void,
        dst: vm_paddr_t,
        len: usize,
    ) -> ::core::ffi::c_int;
    pub fn physcopyout(
        src: vm_paddr_t,
        dst: *mut ::core::ffi::c_void,
        len: usize,
    ) -> ::core::ffi::c_int;
    pub fn physcopyin_vlist(
        src: *mut bus_dma_segment,
        offset: off_t,
        dst: vm_paddr_t,
        len: usize,
    ) -> ::core::ffi::c_int;
    pub fn physcopyout_vlist(
        src: vm_paddr_t,
        dst: *mut bus_dma_segment,
        offset: off_t,
        len: usize,
    ) -> ::core::ffi::c_int;
    pub fn uioadvance(arg1: *mut uio, arg2: usize);
    pub fn uiomove(
        cp: *mut ::core::ffi::c_void,
        n: ::core::ffi::c_int,
        uio: *mut uio,
    ) -> ::core::ffi::c_int;
    pub fn uiomove_frombuf(
        buf: *mut ::core::ffi::c_void,
        buflen: ::core::ffi::c_int,
        uio: *mut uio,
    ) -> ::core::ffi::c_int;
    pub fn uiomove_fromphys(
        ma: *mut *mut vm_page,
        offset: vm_offset_t,
        n: ::core::ffi::c_int,
        uio: *mut uio,
    ) -> ::core::ffi::c_int;
    pub fn uiomove_nofault(
        cp: *mut ::core::ffi::c_void,
        n: ::core::ffi::c_int,
        uio: *mut uio,
    ) -> ::core::ffi::c_int;
    pub fn uiomove_object(
        obj: *mut vm_object,
        obj_size: off_t,
        uio: *mut uio,
    ) -> ::core::ffi::c_int;
    pub fn rangelock_init(lock: *mut rangelock);
    pub fn rangelock_destroy(lock: *mut rangelock);
    pub fn rangelock_unlock(lock: *mut rangelock, cookie: *mut ::core::ffi::c_void);
    pub fn rangelock_rlock(
        lock: *mut rangelock,
        start: vm_ooffset_t,
        end: vm_ooffset_t,
    ) -> *mut ::core::ffi::c_void;
    pub fn rangelock_tryrlock(
        lock: *mut rangelock,
        start: vm_ooffset_t,
        end: vm_ooffset_t,
    ) -> *mut ::core::ffi::c_void;
    pub fn rangelock_wlock(
        lock: *mut rangelock,
        start: vm_ooffset_t,
        end: vm_ooffset_t,
    ) -> *mut ::core::ffi::c_void;
    pub fn rangelock_trywlock(
        lock: *mut rangelock,
        start: vm_ooffset_t,
        end: vm_ooffset_t,
    ) -> *mut ::core::ffi::c_void;
    pub fn rangelock_may_recurse(lock: *mut rangelock);
    pub fn _rangelock_cookie_assert(
        cookie: *mut ::core::ffi::c_void,
        what: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn shm_map(
        fp: *mut file,
        size: usize,
        offset: off_t,
        memp: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn shm_unmap(
        fp: *mut file,
        mem: *mut ::core::ffi::c_void,
        size: usize,
    ) -> ::core::ffi::c_int;
    pub fn shm_access(
        shmfd: *mut shmfd,
        ucred: *mut ucred,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn shm_alloc(ucred: *mut ucred, mode: mode_t, largepage: bool_) -> *mut shmfd;
    pub fn shm_hold(shmfd: *mut shmfd) -> *mut shmfd;
    pub fn shm_drop(shmfd: *mut shmfd);
    pub fn shm_dotruncate(shmfd: *mut shmfd, length: off_t) -> ::core::ffi::c_int;
    pub fn shm_largepage(shmfd: *mut shmfd) -> bool_;
    pub fn shm_remove_prison(pr: *mut prison);
    pub fn shm_get_path(
        obj: *mut vm_object,
        path: *mut ::core::ffi::c_char,
        sz: usize,
    ) -> ::core::ffi::c_int;
    pub static shm_ops: fileops;
    pub fn sbuf_new(
        arg1: *mut sbuf,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
    ) -> *mut sbuf;
    pub fn sbuf_get_flags(arg1: *mut sbuf) -> ::core::ffi::c_int;
    pub fn sbuf_clear_flags(arg1: *mut sbuf, arg2: ::core::ffi::c_int);
    pub fn sbuf_set_flags(arg1: *mut sbuf, arg2: ::core::ffi::c_int);
    pub fn sbuf_clear(arg1: *mut sbuf);
    pub fn sbuf_setpos(arg1: *mut sbuf, arg2: isize) -> ::core::ffi::c_int;
    pub fn sbuf_bcat(
        arg1: *mut sbuf,
        arg2: *const ::core::ffi::c_void,
        arg3: usize,
    ) -> ::core::ffi::c_int;
    pub fn sbuf_bcpy(
        arg1: *mut sbuf,
        arg2: *const ::core::ffi::c_void,
        arg3: usize,
    ) -> ::core::ffi::c_int;
    pub fn sbuf_cat(arg1: *mut sbuf, arg2: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn sbuf_cpy(arg1: *mut sbuf, arg2: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn sbuf_printf(
        arg1: *mut sbuf,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn sbuf_vprintf(
        arg1: *mut sbuf,
        arg2: *const ::core::ffi::c_char,
        arg3: __va_list,
    ) -> ::core::ffi::c_int;
    pub fn sbuf_nl_terminate(arg1: *mut sbuf) -> ::core::ffi::c_int;
    pub fn sbuf_putc(arg1: *mut sbuf, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn sbuf_set_drain(arg1: *mut sbuf, arg2: sbuf_drain_func, arg3: *mut ::core::ffi::c_void);
    pub fn sbuf_drain(arg1: *mut sbuf) -> ::core::ffi::c_int;
    pub fn sbuf_trim(arg1: *mut sbuf) -> ::core::ffi::c_int;
    pub fn sbuf_error(arg1: *const sbuf) -> ::core::ffi::c_int;
    pub fn sbuf_finish(arg1: *mut sbuf) -> ::core::ffi::c_int;
    pub fn sbuf_data(arg1: *mut sbuf) -> *mut ::core::ffi::c_char;
    pub fn sbuf_len(arg1: *mut sbuf) -> isize;
    pub fn sbuf_done(arg1: *const sbuf) -> ::core::ffi::c_int;
    pub fn sbuf_delete(arg1: *mut sbuf);
    pub fn sbuf_start_section(arg1: *mut sbuf, arg2: *mut isize);
    pub fn sbuf_end_section(
        arg1: *mut sbuf,
        arg2: isize,
        arg3: usize,
        arg4: ::core::ffi::c_int,
    ) -> isize;
    pub fn sbuf_hexdump(
        arg1: *mut sbuf,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_int,
        arg4: *const ::core::ffi::c_char,
        arg5: ::core::ffi::c_int,
    );
    pub fn sbuf_count_drain(
        arg: *mut ::core::ffi::c_void,
        data: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn sbuf_printf_drain(
        arg: *mut ::core::ffi::c_void,
        data: *const ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn sbuf_putbuf(arg1: *mut sbuf);
    pub fn sbuf_uionew(arg1: *mut sbuf, arg2: *mut uio, arg3: *mut ::core::ffi::c_int)
    -> *mut sbuf;
    pub fn sbuf_bcopyin(
        arg1: *mut sbuf,
        arg2: *const ::core::ffi::c_void,
        arg3: usize,
    ) -> ::core::ffi::c_int;
    pub fn sbuf_copyin(
        arg1: *mut sbuf,
        arg2: *const ::core::ffi::c_void,
        arg3: usize,
    ) -> ::core::ffi::c_int;
    #[link_name = "cmp_sysctl_oid__extern"]
    pub fn cmp_sysctl_oid(a: *mut sysctl_oid, b: *mut sysctl_oid) -> ::core::ffi::c_int;
    pub fn sysctl_oid_list_RB_INSERT_COLOR(
        arg1: *mut sysctl_oid_list,
        arg2: *mut sysctl_oid,
        arg3: *mut sysctl_oid,
    ) -> *mut sysctl_oid;
    pub fn sysctl_oid_list_RB_REMOVE_COLOR(
        arg1: *mut sysctl_oid_list,
        arg2: *mut sysctl_oid,
        arg3: *mut sysctl_oid,
    ) -> *mut sysctl_oid;
    pub fn sysctl_oid_list_RB_INSERT_FINISH(
        arg1: *mut sysctl_oid_list,
        arg2: *mut sysctl_oid,
        arg3: *mut *mut sysctl_oid,
        arg4: *mut sysctl_oid,
    ) -> *mut sysctl_oid;
    pub fn sysctl_oid_list_RB_INSERT(
        arg1: *mut sysctl_oid_list,
        arg2: *mut sysctl_oid,
    ) -> *mut sysctl_oid;
    pub fn sysctl_oid_list_RB_REMOVE(
        arg1: *mut sysctl_oid_list,
        arg2: *mut sysctl_oid,
    ) -> *mut sysctl_oid;
    pub fn sysctl_oid_list_RB_FIND(
        arg1: *mut sysctl_oid_list,
        arg2: *mut sysctl_oid,
    ) -> *mut sysctl_oid;
    pub fn sysctl_oid_list_RB_NFIND(
        arg1: *mut sysctl_oid_list,
        arg2: *mut sysctl_oid,
    ) -> *mut sysctl_oid;
    pub fn sysctl_oid_list_RB_NEXT(arg1: *mut sysctl_oid) -> *mut sysctl_oid;
    pub fn sysctl_oid_list_RB_INSERT_NEXT(
        arg1: *mut sysctl_oid_list,
        arg2: *mut sysctl_oid,
        arg3: *mut sysctl_oid,
    ) -> *mut sysctl_oid;
    pub fn sysctl_oid_list_RB_PREV(arg1: *mut sysctl_oid) -> *mut sysctl_oid;
    pub fn sysctl_oid_list_RB_INSERT_PREV(
        arg1: *mut sysctl_oid_list,
        arg2: *mut sysctl_oid,
        arg3: *mut sysctl_oid,
    ) -> *mut sysctl_oid;
    pub fn sysctl_oid_list_RB_MINMAX(
        arg1: *mut sysctl_oid_list,
        arg2: ::core::ffi::c_int,
    ) -> *mut sysctl_oid;
    pub fn sysctl_oid_list_RB_REINSERT(
        arg1: *mut sysctl_oid_list,
        arg2: *mut sysctl_oid,
    ) -> *mut sysctl_oid;
    pub fn sysctl_handle_bool(
        oidp: *mut sysctl_oid,
        arg1: *mut ::core::ffi::c_void,
        arg2: intmax_t,
        req: *mut sysctl_req,
    ) -> ::core::ffi::c_int;
    pub fn sysctl_handle_8(
        oidp: *mut sysctl_oid,
        arg1: *mut ::core::ffi::c_void,
        arg2: intmax_t,
        req: *mut sysctl_req,
    ) -> ::core::ffi::c_int;
    pub fn sysctl_handle_16(
        oidp: *mut sysctl_oid,
        arg1: *mut ::core::ffi::c_void,
        arg2: intmax_t,
        req: *mut sysctl_req,
    ) -> ::core::ffi::c_int;
    pub fn sysctl_handle_32(
        oidp: *mut sysctl_oid,
        arg1: *mut ::core::ffi::c_void,
        arg2: intmax_t,
        req: *mut sysctl_req,
    ) -> ::core::ffi::c_int;
    pub fn sysctl_handle_64(
        oidp: *mut sysctl_oid,
        arg1: *mut ::core::ffi::c_void,
        arg2: intmax_t,
        req: *mut sysctl_req,
    ) -> ::core::ffi::c_int;
    pub fn sysctl_handle_int(
        oidp: *mut sysctl_oid,
        arg1: *mut ::core::ffi::c_void,
        arg2: intmax_t,
        req: *mut sysctl_req,
    ) -> ::core::ffi::c_int;
    pub fn sysctl_msec_to_ticks(
        oidp: *mut sysctl_oid,
        arg1: *mut ::core::ffi::c_void,
        arg2: intmax_t,
        req: *mut sysctl_req,
    ) -> ::core::ffi::c_int;
    pub fn sysctl_handle_long(
        oidp: *mut sysctl_oid,
        arg1: *mut ::core::ffi::c_void,
        arg2: intmax_t,
        req: *mut sysctl_req,
    ) -> ::core::ffi::c_int;
    pub fn sysctl_handle_string(
        oidp: *mut sysctl_oid,
        arg1: *mut ::core::ffi::c_void,
        arg2: intmax_t,
        req: *mut sysctl_req,
    ) -> ::core::ffi::c_int;
    pub fn sysctl_handle_opaque(
        oidp: *mut sysctl_oid,
        arg1: *mut ::core::ffi::c_void,
        arg2: intmax_t,
        req: *mut sysctl_req,
    ) -> ::core::ffi::c_int;
    pub fn sysctl_handle_counter_u64(
        oidp: *mut sysctl_oid,
        arg1: *mut ::core::ffi::c_void,
        arg2: intmax_t,
        req: *mut sysctl_req,
    ) -> ::core::ffi::c_int;
    pub fn sysctl_handle_counter_u64_array(
        oidp: *mut sysctl_oid,
        arg1: *mut ::core::ffi::c_void,
        arg2: intmax_t,
        req: *mut sysctl_req,
    ) -> ::core::ffi::c_int;
    pub fn sysctl_handle_uma_zone_max(
        oidp: *mut sysctl_oid,
        arg1: *mut ::core::ffi::c_void,
        arg2: intmax_t,
        req: *mut sysctl_req,
    ) -> ::core::ffi::c_int;
    pub fn sysctl_handle_uma_zone_cur(
        oidp: *mut sysctl_oid,
        arg1: *mut ::core::ffi::c_void,
        arg2: intmax_t,
        req: *mut sysctl_req,
    ) -> ::core::ffi::c_int;
    pub fn sysctl_msec_to_sbintime(
        oidp: *mut sysctl_oid,
        arg1: *mut ::core::ffi::c_void,
        arg2: intmax_t,
        req: *mut sysctl_req,
    ) -> ::core::ffi::c_int;
    pub fn sysctl_usec_to_sbintime(
        oidp: *mut sysctl_oid,
        arg1: *mut ::core::ffi::c_void,
        arg2: intmax_t,
        req: *mut sysctl_req,
    ) -> ::core::ffi::c_int;
    pub fn sysctl_sec_to_timeval(
        oidp: *mut sysctl_oid,
        arg1: *mut ::core::ffi::c_void,
        arg2: intmax_t,
        req: *mut sysctl_req,
    ) -> ::core::ffi::c_int;
    pub fn sysctl_dpcpu_int(
        oidp: *mut sysctl_oid,
        arg1: *mut ::core::ffi::c_void,
        arg2: intmax_t,
        req: *mut sysctl_req,
    ) -> ::core::ffi::c_int;
    pub fn sysctl_dpcpu_long(
        oidp: *mut sysctl_oid,
        arg1: *mut ::core::ffi::c_void,
        arg2: intmax_t,
        req: *mut sysctl_req,
    ) -> ::core::ffi::c_int;
    pub fn sysctl_dpcpu_quad(
        oidp: *mut sysctl_oid,
        arg1: *mut ::core::ffi::c_void,
        arg2: intmax_t,
        req: *mut sysctl_req,
    ) -> ::core::ffi::c_int;
    pub fn sysctl_register_oid(oidp: *mut sysctl_oid);
    pub fn sysctl_register_disabled_oid(oidp: *mut sysctl_oid);
    pub fn sysctl_enable_oid(oidp: *mut sysctl_oid);
    pub fn sysctl_unregister_oid(oidp: *mut sysctl_oid);
    pub static mut sysctl__children: sysctl_oid_list;
    pub static mut sysctl___kern: sysctl_oid;
    pub static mut sysctl___kern_features: sysctl_oid;
    pub static mut sysctl___kern_ipc: sysctl_oid;
    pub static mut sysctl___kern_proc: sysctl_oid;
    pub static mut sysctl___kern_sched: sysctl_oid;
    pub static mut sysctl___kern_sched_stats: sysctl_oid;
    pub static mut sysctl___sysctl: sysctl_oid;
    pub static mut sysctl___vm: sysctl_oid;
    pub static mut sysctl___vm_stats: sysctl_oid;
    pub static mut sysctl___vm_stats_misc: sysctl_oid;
    pub static mut sysctl___vfs: sysctl_oid;
    pub static mut sysctl___net: sysctl_oid;
    pub static mut sysctl___debug: sysctl_oid;
    pub static mut sysctl___debug_sizeof: sysctl_oid;
    pub static mut sysctl___dev: sysctl_oid;
    pub static mut sysctl___hw: sysctl_oid;
    pub static mut sysctl___hw_bus: sysctl_oid;
    pub static mut sysctl___hw_bus_devices: sysctl_oid;
    pub static mut sysctl___machdep: sysctl_oid;
    pub static mut sysctl___machdep_mitigations: sysctl_oid;
    pub static mut sysctl___user: sysctl_oid;
    pub static mut sysctl___compat: sysctl_oid;
    pub static mut sysctl___regression: sysctl_oid;
    pub static mut sysctl___security: sysctl_oid;
    pub static mut sysctl___security_bsd: sysctl_oid;
    pub static machine: [::core::ffi::c_char; 0usize];
    pub static osrelease: [::core::ffi::c_char; 0usize];
    pub static ostype: [::core::ffi::c_char; 0usize];
    pub static kern_ident: [::core::ffi::c_char; 0usize];
    pub fn sysctl_add_oid(
        clist: *mut sysctl_ctx_list,
        parent: *mut sysctl_oid_list,
        nbr: ::core::ffi::c_int,
        name: *const ::core::ffi::c_char,
        kind: ::core::ffi::c_int,
        arg1: *mut ::core::ffi::c_void,
        arg2: intmax_t,
        handler: ::core::option::Option<
            unsafe extern "C" fn(
                oidp: *mut sysctl_oid,
                arg1: *mut ::core::ffi::c_void,
                arg2: intmax_t,
                req: *mut sysctl_req,
            ) -> ::core::ffi::c_int,
        >,
        fmt: *const ::core::ffi::c_char,
        descr: *const ::core::ffi::c_char,
        label: *const ::core::ffi::c_char,
    ) -> *mut sysctl_oid;
    pub fn sysctl_remove_name(
        parent: *mut sysctl_oid,
        name: *const ::core::ffi::c_char,
        del: ::core::ffi::c_int,
        recurse: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn sysctl_rename_oid(oidp: *mut sysctl_oid, name: *const ::core::ffi::c_char);
    pub fn sysctl_move_oid(
        oidp: *mut sysctl_oid,
        parent: *mut sysctl_oid_list,
    ) -> ::core::ffi::c_int;
    pub fn sysctl_remove_oid(
        oidp: *mut sysctl_oid,
        del: ::core::ffi::c_int,
        recurse: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn sysctl_ctx_init(clist: *mut sysctl_ctx_list) -> ::core::ffi::c_int;
    pub fn sysctl_ctx_free(clist: *mut sysctl_ctx_list) -> ::core::ffi::c_int;
    pub fn sysctl_ctx_entry_add(
        clist: *mut sysctl_ctx_list,
        oidp: *mut sysctl_oid,
    ) -> *mut sysctl_ctx_entry;
    pub fn sysctl_ctx_entry_find(
        clist: *mut sysctl_ctx_list,
        oidp: *mut sysctl_oid,
    ) -> *mut sysctl_ctx_entry;
    pub fn sysctl_ctx_entry_del(
        clist: *mut sysctl_ctx_list,
        oidp: *mut sysctl_oid,
    ) -> ::core::ffi::c_int;
    pub fn kernel_sysctl(
        td: *mut thread,
        name: *mut ::core::ffi::c_int,
        namelen: u_int,
        old: *mut ::core::ffi::c_void,
        oldlenp: *mut usize,
        new: *mut ::core::ffi::c_void,
        newlen: usize,
        retval: *mut usize,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn kernel_sysctlbyname(
        td: *mut thread,
        name: *mut ::core::ffi::c_char,
        old: *mut ::core::ffi::c_void,
        oldlenp: *mut usize,
        new: *mut ::core::ffi::c_void,
        newlen: usize,
        retval: *mut usize,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn userland_sysctl(
        td: *mut thread,
        name: *mut ::core::ffi::c_int,
        namelen: u_int,
        old: *mut ::core::ffi::c_void,
        oldlenp: *mut usize,
        inkernel: ::core::ffi::c_int,
        new: *const ::core::ffi::c_void,
        newlen: usize,
        retval: *mut usize,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn sysctl_find_oid(
        name: *mut ::core::ffi::c_int,
        namelen: u_int,
        noid: *mut *mut sysctl_oid,
        nindx: *mut ::core::ffi::c_int,
        req: *mut sysctl_req,
    ) -> ::core::ffi::c_int;
    pub fn sysctl_wlock();
    pub fn sysctl_wunlock();
    pub fn sysctl_wire_old_buffer(req: *mut sysctl_req, len: usize) -> ::core::ffi::c_int;
    pub fn kern___sysctlbyname(
        td: *mut thread,
        name: *const ::core::ffi::c_char,
        namelen: usize,
        old: *mut ::core::ffi::c_void,
        oldlenp: *mut usize,
        new: *mut ::core::ffi::c_void,
        newlen: usize,
        retval: *mut usize,
        flags: ::core::ffi::c_int,
        inkernel: bool_,
    ) -> ::core::ffi::c_int;
    pub fn sbuf_new_for_sysctl(
        arg1: *mut sbuf,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: *mut sysctl_req,
    ) -> *mut sbuf;
    #[link_name = "pc_is_full__extern"]
    pub fn pc_is_full(pc: *mut pv_chunk) -> bool_;
    #[link_name = "pc_is_free__extern"]
    pub fn pc_is_free(pc: *mut pv_chunk) -> bool_;
    #[link_name = "pv_to_chunk__extern"]
    pub fn pv_to_chunk(pv: pv_entry_t) -> *mut pv_chunk;
    pub fn pmap_page_set_memattr(m: vm_page_t, ma: vm_memattr_t);
    pub static mut kernel_pmap_store: pmap;
    pub static mut pmap_lpa_enabled: bool_;
    pub static mut virtual_avail: vm_offset_t;
    pub static mut virtual_end: vm_offset_t;
    pub static mut pmap_sh_attr: pt_entry_t;
    pub fn pmap_activate_vm(arg1: pmap_t);
    pub fn pmap_bootstrap_dmap(arg1: vm_size_t);
    pub fn pmap_bootstrap();
    pub fn pmap_change_attr(
        va: vm_offset_t,
        size: vm_size_t,
        mode: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn pmap_change_prot(
        va: vm_offset_t,
        size: vm_size_t,
        prot: vm_prot_t,
    ) -> ::core::ffi::c_int;
    pub fn pmap_kenter(sva: vm_offset_t, size: vm_size_t, pa: vm_paddr_t, mode: ::core::ffi::c_int);
    pub fn pmap_kenter_device(arg1: vm_offset_t, arg2: vm_size_t, arg3: vm_paddr_t);
    pub fn pmap_klookup(va: vm_offset_t, pa: *mut vm_paddr_t) -> bool_;
    pub fn pmap_kextract(va: vm_offset_t) -> vm_paddr_t;
    pub fn pmap_kremove(arg1: vm_offset_t);
    pub fn pmap_kremove_device(arg1: vm_offset_t, arg2: vm_size_t);
    pub fn pmap_mapdev_attr(
        pa: vm_paddr_t,
        size: vm_size_t,
        ma: vm_memattr_t,
    ) -> *mut ::core::ffi::c_void;
    pub fn pmap_page_is_mapped(m: vm_page_t) -> bool_;
    pub fn pmap_pinit_stage(
        arg1: pmap_t,
        arg2: pmap_stage,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn pmap_ps_enabled(pmap: pmap_t) -> bool_;
    pub fn pmap_to_ttbr0(pmap: pmap_t) -> u64;
    pub fn pmap_disable_promotion(sva: vm_offset_t, size: vm_size_t);
    pub fn pmap_map_delete(arg1: pmap_t, arg2: vm_offset_t, arg3: vm_offset_t);
    pub fn pmap_mapdev(arg1: vm_paddr_t, arg2: vm_size_t) -> *mut ::core::ffi::c_void;
    pub fn pmap_mapbios(arg1: vm_paddr_t, arg2: vm_size_t) -> *mut ::core::ffi::c_void;
    pub fn pmap_unmapdev(arg1: *mut ::core::ffi::c_void, arg2: vm_size_t);
    pub fn pmap_unmapbios(arg1: *mut ::core::ffi::c_void, arg2: vm_size_t);
    pub fn pmap_map_io_transient(
        arg1: *mut vm_page_t,
        arg2: *mut vm_offset_t,
        arg3: ::core::ffi::c_int,
        arg4: bool_,
    ) -> bool_;
    pub fn pmap_unmap_io_transient(
        arg1: *mut vm_page_t,
        arg2: *mut vm_offset_t,
        arg3: ::core::ffi::c_int,
        arg4: bool_,
    );
    pub fn pmap_get_tables(
        arg1: pmap_t,
        arg2: vm_offset_t,
        arg3: *mut *mut pd_entry_t,
        arg4: *mut *mut pd_entry_t,
        arg5: *mut *mut pd_entry_t,
        arg6: *mut *mut pt_entry_t,
    ) -> bool_;
    pub fn pmap_fault(arg1: pmap_t, arg2: u64, arg3: u64) -> ::core::ffi::c_int;
    pub fn pmap_switch(arg1: *mut thread) -> *mut pcb;
    pub fn pmap_s1_invalidate_all_kernel();
    pub static mut pmap_clean_stage2_tlbi: ::core::option::Option<unsafe extern "C" fn()>;
    pub static mut pmap_stage2_invalidate_range: ::core::option::Option<
        unsafe extern "C" fn(arg1: u64, arg2: vm_offset_t, arg3: vm_offset_t, arg4: bool_),
    >;
    pub static mut pmap_stage2_invalidate_all:
        ::core::option::Option<unsafe extern "C" fn(arg1: u64)>;
    pub fn pmap_vmspace_copy(arg1: pmap_t, arg2: pmap_t) -> ::core::ffi::c_int;
    pub fn pmap_bti_set(arg1: pmap_t, arg2: vm_offset_t, arg3: vm_offset_t) -> ::core::ffi::c_int;
    pub fn pmap_bti_clear(arg1: pmap_t, arg2: vm_offset_t, arg3: vm_offset_t)
    -> ::core::ffi::c_int;
    pub static mut kernel_vm_end: vm_offset_t;
    pub fn pmap_activate(td: *mut thread);
    pub fn pmap_active_cpus(pmap: pmap_t, res: *mut cpuset_t);
    pub fn pmap_advise(
        pmap: pmap_t,
        sva: vm_offset_t,
        eva: vm_offset_t,
        advice: ::core::ffi::c_int,
    );
    pub fn pmap_align_superpage(
        arg1: vm_object_t,
        arg2: vm_ooffset_t,
        arg3: *mut vm_offset_t,
        arg4: vm_size_t,
    );
    pub fn pmap_clear_modify(m: vm_page_t);
    pub fn pmap_copy(
        arg1: pmap_t,
        arg2: pmap_t,
        arg3: vm_offset_t,
        arg4: vm_size_t,
        arg5: vm_offset_t,
    );
    pub fn pmap_copy_page(arg1: vm_page_t, arg2: vm_page_t);
    pub fn pmap_copy_pages(
        ma: *mut vm_page_t,
        a_offset: vm_offset_t,
        mb: *mut vm_page_t,
        b_offset: vm_offset_t,
        xfersize: ::core::ffi::c_int,
    );
    pub fn pmap_enter(
        pmap: pmap_t,
        va: vm_offset_t,
        m: vm_page_t,
        prot: vm_prot_t,
        flags: u_int,
        psind: i8,
    ) -> ::core::ffi::c_int;
    pub fn pmap_enter_object(
        pmap: pmap_t,
        start: vm_offset_t,
        end: vm_offset_t,
        m_start: vm_page_t,
        prot: vm_prot_t,
    );
    pub fn pmap_enter_quick(pmap: pmap_t, va: vm_offset_t, m: vm_page_t, prot: vm_prot_t);
    pub fn pmap_extract(pmap: pmap_t, va: vm_offset_t) -> vm_paddr_t;
    pub fn pmap_extract_and_hold(pmap: pmap_t, va: vm_offset_t, prot: vm_prot_t) -> vm_page_t;
    pub fn pmap_growkernel(arg1: vm_offset_t) -> ::core::ffi::c_int;
    pub fn pmap_init();
    pub fn pmap_is_modified(m: vm_page_t) -> bool_;
    pub fn pmap_is_prefaultable(pmap: pmap_t, va: vm_offset_t) -> bool_;
    pub fn pmap_is_referenced(m: vm_page_t) -> bool_;
    pub fn pmap_is_valid_memattr(arg1: pmap_t, arg2: vm_memattr_t) -> bool_;
    pub fn pmap_map(
        arg1: *mut vm_offset_t,
        arg2: vm_paddr_t,
        arg3: vm_paddr_t,
        arg4: ::core::ffi::c_int,
    ) -> vm_offset_t;
    pub fn pmap_mincore(
        pmap: pmap_t,
        addr: vm_offset_t,
        pap: *mut vm_paddr_t,
    ) -> ::core::ffi::c_int;
    pub fn pmap_object_init_pt(
        pmap: pmap_t,
        addr: vm_offset_t,
        object: vm_object_t,
        pindex: vm_pindex_t,
        size: vm_size_t,
    );
    pub fn pmap_page_exists_quick(pmap: pmap_t, m: vm_page_t) -> bool_;
    pub fn pmap_page_init(m: vm_page_t);
    pub fn pmap_page_wired_mappings(m: vm_page_t) -> ::core::ffi::c_int;
    pub fn pmap_pinit(arg1: pmap_t) -> ::core::ffi::c_int;
    pub fn pmap_pinit0(arg1: pmap_t);
    pub fn pmap_protect(arg1: pmap_t, arg2: vm_offset_t, arg3: vm_offset_t, arg4: vm_prot_t);
    pub fn pmap_qenter(arg1: vm_offset_t, arg2: *mut vm_page_t, arg3: ::core::ffi::c_int);
    pub fn pmap_qremove(arg1: vm_offset_t, arg2: ::core::ffi::c_int);
    pub fn pmap_quick_enter_page(arg1: vm_page_t) -> vm_offset_t;
    pub fn pmap_quick_remove_page(arg1: vm_offset_t);
    pub fn pmap_release(arg1: pmap_t);
    pub fn pmap_remove(arg1: pmap_t, arg2: vm_offset_t, arg3: vm_offset_t);
    pub fn pmap_remove_all(m: vm_page_t);
    pub fn pmap_remove_pages(arg1: pmap_t);
    pub fn pmap_remove_write(m: vm_page_t);
    pub fn pmap_sync_icache(arg1: pmap_t, arg2: vm_offset_t, arg3: vm_size_t);
    pub fn pmap_ts_referenced(m: vm_page_t) -> ::core::ffi::c_int;
    pub fn pmap_unwire(pmap: pmap_t, start: vm_offset_t, end: vm_offset_t);
    pub fn pmap_zero_page(arg1: vm_page_t);
    pub fn pmap_zero_page_area(arg1: vm_page_t, off: ::core::ffi::c_int, size: ::core::ffi::c_int);
    pub fn sndbuf_create(
        channel: *mut pcm_channel,
        desc: *const ::core::ffi::c_char,
    ) -> *mut snd_dbuf;
    pub fn sndbuf_destroy(b: *mut snd_dbuf);
    pub fn sndbuf_alloc(
        b: *mut snd_dbuf,
        dmatag: bus_dma_tag_t,
        dmaflags: ::core::ffi::c_int,
        size: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
    pub fn sndbuf_setup(
        b: *mut snd_dbuf,
        buf: *mut ::core::ffi::c_void,
        size: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
    pub fn sndbuf_free(b: *mut snd_dbuf);
    pub fn sndbuf_resize(
        b: *mut snd_dbuf,
        blkcnt: ::core::ffi::c_uint,
        blksz: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
    pub fn sndbuf_remalloc(
        b: *mut snd_dbuf,
        blkcnt: ::core::ffi::c_uint,
        blksz: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
    pub fn sndbuf_reset(b: *mut snd_dbuf);
    pub fn sndbuf_clear(b: *mut snd_dbuf, length: ::core::ffi::c_uint);
    pub fn sndbuf_fillsilence(b: *mut snd_dbuf);
    pub fn sndbuf_fillsilence_rl(b: *mut snd_dbuf, rl: u_int);
    pub fn sndbuf_softreset(b: *mut snd_dbuf);
    pub fn sndbuf_clearshadow(b: *mut snd_dbuf);
    pub fn sndbuf_setfmt(b: *mut snd_dbuf, fmt: u_int32_t) -> ::core::ffi::c_int;
    pub fn sndbuf_setspd(b: *mut snd_dbuf, spd: ::core::ffi::c_uint);
    pub fn sndbuf_getbufofs(b: *mut snd_dbuf, ofs: ::core::ffi::c_uint)
    -> *mut ::core::ffi::c_void;
    pub fn sndbuf_runsz(b: *mut snd_dbuf) -> ::core::ffi::c_uint;
    pub fn sndbuf_setrun(b: *mut snd_dbuf, go: ::core::ffi::c_int);
    pub fn sndbuf_setxrun(b: *mut snd_dbuf, xrun: ::core::ffi::c_uint);
    pub fn sndbuf_getfree(b: *mut snd_dbuf) -> ::core::ffi::c_uint;
    pub fn sndbuf_getfreeptr(b: *mut snd_dbuf) -> ::core::ffi::c_uint;
    pub fn sndbuf_getready(b: *mut snd_dbuf) -> ::core::ffi::c_uint;
    pub fn sndbuf_getreadyptr(b: *mut snd_dbuf) -> ::core::ffi::c_uint;
    pub fn sndbuf_getblocks(b: *mut snd_dbuf) -> u_int64_t;
    pub fn sndbuf_xbytes(
        v: ::core::ffi::c_uint,
        from: *mut snd_dbuf,
        to: *mut snd_dbuf,
    ) -> ::core::ffi::c_uint;
    pub fn sndbuf_zerodata(fmt: u_int32_t) -> u_int8_t;
    pub fn sndbuf_acquire(
        b: *mut snd_dbuf,
        from: *mut u_int8_t,
        count: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
    pub fn sndbuf_dispose(
        b: *mut snd_dbuf,
        to: *mut u_int8_t,
        count: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
    pub fn sndbuf_feed(
        from: *mut snd_dbuf,
        to: *mut snd_dbuf,
        channel: *mut pcm_channel,
        feeder: *mut pcm_feeder,
        count: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
    #[link_name = "snd_xbytes__extern"]
    pub fn snd_xbytes(v: u_int32_t, from: u_int32_t, to: u_int32_t) -> u_int32_t;
    pub static mut snd_pcm_syncgroups_mtx: mtx;
    pub static mut snd_pcm_syncgroups: pcm_synclist;
    #[doc = " @brief Unique descriptor for the CHANNEL_INIT() method"]
    pub static mut channel_init_desc: kobjop_desc;
    #[link_name = "CHANNEL_INIT__extern"]
    pub fn CHANNEL_INIT(
        obj: kobj_t,
        devinfo: *mut ::core::ffi::c_void,
        b: *mut snd_dbuf,
        c: *mut pcm_channel,
        dir: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    #[doc = " @brief Unique descriptor for the CHANNEL_FREE() method"]
    pub static mut channel_free_desc: kobjop_desc;
    #[link_name = "CHANNEL_FREE__extern"]
    pub fn CHANNEL_FREE(obj: kobj_t, data: *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the CHANNEL_RESET() method"]
    pub static mut channel_reset_desc: kobjop_desc;
    #[link_name = "CHANNEL_RESET__extern"]
    pub fn CHANNEL_RESET(obj: kobj_t, data: *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the CHANNEL_RESETDONE() method"]
    pub static mut channel_resetdone_desc: kobjop_desc;
    #[link_name = "CHANNEL_RESETDONE__extern"]
    pub fn CHANNEL_RESETDONE(obj: kobj_t, data: *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the CHANNEL_SETFORMAT() method"]
    pub static mut channel_setformat_desc: kobjop_desc;
    #[link_name = "CHANNEL_SETFORMAT__extern"]
    pub fn CHANNEL_SETFORMAT(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        format: u_int32_t,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the CHANNEL_SETSPEED() method"]
    pub static mut channel_setspeed_desc: kobjop_desc;
    #[link_name = "CHANNEL_SETSPEED__extern"]
    pub fn CHANNEL_SETSPEED(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        speed: u_int32_t,
    ) -> u_int32_t;
    #[doc = " @brief Unique descriptor for the CHANNEL_SETBLOCKSIZE() method"]
    pub static mut channel_setblocksize_desc: kobjop_desc;
    #[link_name = "CHANNEL_SETBLOCKSIZE__extern"]
    pub fn CHANNEL_SETBLOCKSIZE(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        blocksize: u_int32_t,
    ) -> u_int32_t;
    #[doc = " @brief Unique descriptor for the CHANNEL_SETFRAGMENTS() method"]
    pub static mut channel_setfragments_desc: kobjop_desc;
    #[link_name = "CHANNEL_SETFRAGMENTS__extern"]
    pub fn CHANNEL_SETFRAGMENTS(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        blocksize: u_int32_t,
        blockcount: u_int32_t,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the CHANNEL_TRIGGER() method"]
    pub static mut channel_trigger_desc: kobjop_desc;
    #[link_name = "CHANNEL_TRIGGER__extern"]
    pub fn CHANNEL_TRIGGER(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        go: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the CHANNEL_GETPTR() method"]
    pub static mut channel_getptr_desc: kobjop_desc;
    #[link_name = "CHANNEL_GETPTR__extern"]
    pub fn CHANNEL_GETPTR(obj: kobj_t, data: *mut ::core::ffi::c_void) -> u_int32_t;
    #[doc = " @brief Unique descriptor for the CHANNEL_GETCAPS() method"]
    pub static mut channel_getcaps_desc: kobjop_desc;
    #[link_name = "CHANNEL_GETCAPS__extern"]
    pub fn CHANNEL_GETCAPS(obj: kobj_t, data: *mut ::core::ffi::c_void) -> *mut pcmchan_caps;
    #[doc = " @brief Unique descriptor for the CHANNEL_NOTIFY() method"]
    pub static mut channel_notify_desc: kobjop_desc;
    #[link_name = "CHANNEL_NOTIFY__extern"]
    pub fn CHANNEL_NOTIFY(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        changed: u_int32_t,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the CHANNEL_GETPEAKS() method"]
    pub static mut channel_getpeaks_desc: kobjop_desc;
    #[doc = " @brief Retrieve channel peak values\n\n This function is intended to obtain peak volume values for samples\n played/recorded on a channel.  Values are on a linear scale from 0 to\n 32767.  If the channel is monaural, a single value should be recorded\n in @c lpeak.\n\n If hardware support isn't available, the SNDCTL_DSP_GET[IO]PEAKS\n operation should return EINVAL.  However, we may opt to provide\n software support that the user may toggle via sysctl/mixext.\n\n @param obj\tstandard kobj object (usually @c channel->methods)\n @param data\tdriver-specific data (usually @c channel->devinfo)\n @param lpeak\tpointer to store left peak level\n @param rpeak\tpointer to store right peak level\n\n @retval -1\tError; usually operation isn't supported.\n @retval 0\tsuccess"]
    #[link_name = "CHANNEL_GETPEAKS__extern"]
    pub fn CHANNEL_GETPEAKS(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        lpeak: *mut ::core::ffi::c_int,
        rpeak: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the CHANNEL_GETRATES() method"]
    pub static mut channel_getrates_desc: kobjop_desc;
    #[doc = " @brief Retrieve discrete supported sample rates\n\n Some cards operate at fixed rates, and this call is intended to retrieve\n those rates primarily for when in-kernel rate adjustment is undesirable\n (e.g., application wants direct DMA access after setting a channel to run\n \"uncooked\").\n\n The parameter @c rates is a double pointer which will be reset to\n point to an array of supported sample rates.  The number of elements\n in the array is returned to the caller.\n\n @param obj\tstandard kobj object (usually @c channel->methods)\n @param data\tdriver-specific data (usually @c channel->devinfo)\n @param rates\trate array pointer\n\n @return Number of rates in the array"]
    #[link_name = "CHANNEL_GETRATES__extern"]
    pub fn CHANNEL_GETRATES(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        rates: *mut *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the CHANNEL_GETMATRIX() method"]
    pub static mut channel_getmatrix_desc: kobjop_desc;
    #[link_name = "CHANNEL_GETMATRIX__extern"]
    pub fn CHANNEL_GETMATRIX(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        format: u_int32_t,
    ) -> *mut pcmchan_matrix;
    #[doc = " @brief Unique descriptor for the CHANNEL_SETMATRIX() method"]
    pub static mut channel_setmatrix_desc: kobjop_desc;
    #[link_name = "CHANNEL_SETMATRIX__extern"]
    pub fn CHANNEL_SETMATRIX(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        m: *mut pcmchan_matrix,
    ) -> ::core::ffi::c_int;
    pub fn chn_reinit(c: *mut pcm_channel) -> ::core::ffi::c_int;
    pub fn chn_write(c: *mut pcm_channel, buf: *mut uio) -> ::core::ffi::c_int;
    pub fn chn_read(c: *mut pcm_channel, buf: *mut uio) -> ::core::ffi::c_int;
    pub fn chn_start(c: *mut pcm_channel, force: ::core::ffi::c_int) -> u_int32_t;
    pub fn chn_sync(c: *mut pcm_channel, threshold: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn chn_flush(c: *mut pcm_channel) -> ::core::ffi::c_int;
    pub fn chn_polltrigger(c: *mut pcm_channel) -> ::core::ffi::c_int;
    pub fn chn_poll(
        c: *mut pcm_channel,
        ev: ::core::ffi::c_int,
        td: *mut thread,
    ) -> ::core::ffi::c_int;
    pub fn chn_mkname(
        buf: *mut ::core::ffi::c_char,
        len: usize,
        c: *mut pcm_channel,
    ) -> *mut ::core::ffi::c_char;
    pub fn chn_init(
        d: *mut snddev_info,
        parent: *mut pcm_channel,
        cls: kobj_class_t,
        dir: ::core::ffi::c_int,
        devinfo: *mut ::core::ffi::c_void,
    ) -> *mut pcm_channel;
    pub fn chn_kill(c: *mut pcm_channel);
    pub fn chn_shutdown(c: *mut pcm_channel);
    pub fn chn_release(c: *mut pcm_channel) -> ::core::ffi::c_int;
    pub fn chn_reset(c: *mut pcm_channel, fmt: u_int32_t, spd: u_int32_t) -> ::core::ffi::c_int;
    pub fn chn_setvolume_multi(
        c: *mut pcm_channel,
        vc: ::core::ffi::c_int,
        left: ::core::ffi::c_int,
        right: ::core::ffi::c_int,
        center: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn chn_setvolume_matrix(
        c: *mut pcm_channel,
        vc: ::core::ffi::c_int,
        vt: ::core::ffi::c_int,
        val: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn chn_getvolume_matrix(
        c: *mut pcm_channel,
        vc: ::core::ffi::c_int,
        vt: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn chn_setmute_multi(
        c: *mut pcm_channel,
        vc: ::core::ffi::c_int,
        mute: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn chn_setmute_matrix(
        c: *mut pcm_channel,
        vc: ::core::ffi::c_int,
        vt: ::core::ffi::c_int,
        mute: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn chn_getmute_matrix(
        c: *mut pcm_channel,
        vc: ::core::ffi::c_int,
        vt: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn chn_vpc_reset(c: *mut pcm_channel, vc: ::core::ffi::c_int, force: ::core::ffi::c_int);
    pub fn chn_setparam(c: *mut pcm_channel, format: u32, speed: u32) -> ::core::ffi::c_int;
    pub fn chn_setspeed(c: *mut pcm_channel, speed: u32) -> ::core::ffi::c_int;
    pub fn chn_setformat(c: *mut pcm_channel, format: u32) -> ::core::ffi::c_int;
    pub fn chn_setblocksize(
        c: *mut pcm_channel,
        blkcnt: ::core::ffi::c_int,
        blksz: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn chn_setlatency(c: *mut pcm_channel, latency: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn chn_syncstate(c: *mut pcm_channel);
    pub fn chn_trigger(c: *mut pcm_channel, go: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn chn_getptr(c: *mut pcm_channel) -> ::core::ffi::c_int;
    pub fn chn_getcaps(c: *mut pcm_channel) -> *mut pcmchan_caps;
    pub fn chn_getformats(c: *mut pcm_channel) -> u_int32_t;
    pub fn chn_getmatrix(arg1: *mut pcm_channel) -> *mut pcmchan_matrix;
    pub fn chn_setmatrix(arg1: *mut pcm_channel, arg2: *mut pcmchan_matrix) -> ::core::ffi::c_int;
    pub fn chn_oss_getorder(
        arg1: *mut pcm_channel,
        arg2: *mut ::core::ffi::c_ulonglong,
    ) -> ::core::ffi::c_int;
    pub fn chn_oss_setorder(
        arg1: *mut pcm_channel,
        arg2: *mut ::core::ffi::c_ulonglong,
    ) -> ::core::ffi::c_int;
    pub fn chn_oss_getmask(arg1: *mut pcm_channel, arg2: *mut u32) -> ::core::ffi::c_int;
    pub fn chn_resetbuf(c: *mut pcm_channel);
    pub fn chn_intr_locked(c: *mut pcm_channel);
    pub fn chn_intr(c: *mut pcm_channel);
    pub fn chn_abort(c: *mut pcm_channel) -> ::core::ffi::c_int;
    pub fn chn_notify(c: *mut pcm_channel, flags: u_int32_t) -> ::core::ffi::c_int;
    pub fn chn_getrates(
        c: *mut pcm_channel,
        rates: *mut *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn chn_syncdestroy(c: *mut pcm_channel) -> ::core::ffi::c_int;
    pub fn snd_fmtvalid(fmt: u32, fmtlist: *mut u32) -> ::core::ffi::c_int;
    pub fn snd_str2afmt(arg1: *const ::core::ffi::c_char) -> u32;
    pub fn snd_afmt2str(arg1: u32, arg2: *mut ::core::ffi::c_char, arg3: usize) -> u32;
    pub static mut chn_latency: ::core::ffi::c_int;
    pub static mut chn_latency_profile: ::core::ffi::c_int;
    pub static mut report_soft_formats: ::core::ffi::c_int;
    pub static mut report_soft_matrix: ::core::ffi::c_int;
    pub fn feeder_register(p: *mut ::core::ffi::c_void);
    pub fn feeder_getclass(type_: u_int32_t) -> *mut feeder_class;
    pub fn snd_fmtscore(fmt: u_int32_t) -> u_int32_t;
    pub fn snd_fmtbestbit(fmt: u_int32_t, fmts: *mut u_int32_t) -> u_int32_t;
    pub fn snd_fmtbestchannel(fmt: u_int32_t, fmts: *mut u_int32_t) -> u_int32_t;
    pub fn snd_fmtbest(fmt: u_int32_t, fmts: *mut u_int32_t) -> u_int32_t;
    pub fn feeder_add(
        c: *mut pcm_channel,
        fc: *mut feeder_class,
        desc: *mut pcm_feederdesc,
    ) -> ::core::ffi::c_int;
    pub fn feeder_remove(c: *mut pcm_channel);
    pub fn feeder_find(c: *mut pcm_channel, type_: u_int32_t) -> *mut pcm_feeder;
    pub fn feeder_chain(arg1: *mut pcm_channel) -> ::core::ffi::c_int;
    pub static mut feeder_rate_min: ::core::ffi::c_int;
    pub static mut feeder_rate_max: ::core::ffi::c_int;
    pub static mut feeder_rate_round: ::core::ffi::c_int;
    pub static mut feeder_rate_quality: ::core::ffi::c_int;
    pub fn feeder_eq_validrate(arg1: u32) -> ::core::ffi::c_int;
    pub fn feeder_eq_initsys(arg1: device_t);
    pub fn feeder_volume_apply_matrix(
        arg1: *mut pcm_feeder,
        arg2: *mut pcmchan_matrix,
    ) -> ::core::ffi::c_int;
    pub fn feeder_matrix_default_id(arg1: u32) -> ::core::ffi::c_int;
    pub fn feeder_matrix_default_channel_map(arg1: u32) -> *mut pcmchan_matrix;
    pub fn feeder_matrix_default_format(arg1: u32) -> u32;
    pub fn feeder_matrix_format_id(arg1: u32) -> ::core::ffi::c_int;
    pub fn feeder_matrix_format_map(arg1: u32) -> *mut pcmchan_matrix;
    pub fn feeder_matrix_id_map(arg1: ::core::ffi::c_int) -> *mut pcmchan_matrix;
    pub fn feeder_matrix_setup(
        arg1: *mut pcm_feeder,
        arg2: *mut pcmchan_matrix,
        arg3: *mut pcmchan_matrix,
    ) -> ::core::ffi::c_int;
    pub fn feeder_matrix_compare(
        arg1: *mut pcmchan_matrix,
        arg2: *mut pcmchan_matrix,
    ) -> ::core::ffi::c_int;
    pub fn feeder_matrix_oss_get_channel_order(
        arg1: *mut pcmchan_matrix,
        arg2: *mut ::core::ffi::c_ulonglong,
    ) -> ::core::ffi::c_int;
    pub fn feeder_matrix_oss_set_channel_order(
        arg1: *mut pcmchan_matrix,
        arg2: *mut ::core::ffi::c_ulonglong,
    ) -> ::core::ffi::c_int;
    pub fn mixer_create(
        dev: device_t,
        cls: kobj_class_t,
        devinfo: *mut ::core::ffi::c_void,
        desc: *const ::core::ffi::c_char,
    ) -> *mut snd_mixer;
    pub fn mixer_delete(m: *mut snd_mixer) -> ::core::ffi::c_int;
    pub fn mixer_init(
        dev: device_t,
        cls: kobj_class_t,
        devinfo: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn mixer_uninit(dev: device_t) -> ::core::ffi::c_int;
    pub fn mixer_reinit(dev: device_t) -> ::core::ffi::c_int;
    pub fn mixer_ioctl_cmd(
        i_dev: *mut cdev,
        cmd: u_long,
        arg: caddr_t,
        mode: ::core::ffi::c_int,
        td: *mut thread,
        from: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn mixer_oss_mixerinfo(i_dev: *mut cdev, mi: *mut oss_mixerinfo) -> ::core::ffi::c_int;
    pub fn mixer_hwvol_init(dev: device_t) -> ::core::ffi::c_int;
    pub fn mixer_hwvol_mute_locked(m: *mut snd_mixer);
    pub fn mixer_hwvol_mute(dev: device_t);
    pub fn mixer_hwvol_step_locked(
        m: *mut snd_mixer,
        l_step: ::core::ffi::c_int,
        r_step: ::core::ffi::c_int,
    );
    pub fn mixer_hwvol_step(
        dev: device_t,
        left_step: ::core::ffi::c_int,
        right_step: ::core::ffi::c_int,
    );
    pub fn mixer_busy(m: *mut snd_mixer) -> ::core::ffi::c_int;
    pub fn mix_set(m: *mut snd_mixer, dev: u_int, left: u_int, right: u_int) -> ::core::ffi::c_int;
    pub fn mix_get(m: *mut snd_mixer, dev: u_int) -> ::core::ffi::c_int;
    pub fn mix_setrecsrc(m: *mut snd_mixer, src: u_int32_t) -> ::core::ffi::c_int;
    pub fn mix_getrecsrc(m: *mut snd_mixer) -> u_int32_t;
    pub fn mix_get_dev(m: *mut snd_mixer) -> device_t;
    pub fn mix_setdevs(m: *mut snd_mixer, v: u_int32_t);
    pub fn mix_setrecdevs(m: *mut snd_mixer, v: u_int32_t);
    pub fn mix_setmutedevs(m: *mut snd_mixer, v: u_int32_t);
    pub fn mix_getdevs(m: *mut snd_mixer) -> u_int32_t;
    pub fn mix_getrecdevs(m: *mut snd_mixer) -> u_int32_t;
    pub fn mix_getmutedevs(m: *mut snd_mixer) -> u_int32_t;
    pub fn mix_setparentchild(m: *mut snd_mixer, parent: u_int32_t, childs: u_int32_t);
    pub fn mix_setrealdev(m: *mut snd_mixer, dev: u_int32_t, realdev: u_int32_t);
    pub fn mix_getparent(m: *mut snd_mixer, dev: u_int32_t) -> u_int32_t;
    pub fn mix_getdevinfo(m: *mut snd_mixer) -> *mut ::core::ffi::c_void;
    pub fn mixer_get_lock(m: *mut snd_mixer) -> *mut mtx;
    pub fn dsp_make_dev(arg1: device_t) -> ::core::ffi::c_int;
    pub fn dsp_destroy_dev(arg1: device_t);
    pub fn dsp_oss_audioinfo(
        arg1: *mut cdev,
        arg2: *mut oss_audioinfo,
        arg3: bool_,
    ) -> ::core::ffi::c_int;
    pub fn dsp_oss_engineinfo(arg1: *mut cdev, arg2: *mut oss_audioinfo) -> ::core::ffi::c_int;
    pub static mut snd_unit: ::core::ffi::c_int;
    pub static mut snd_verbose: ::core::ffi::c_int;
    pub static mut pcm_devclass: devclass_t;
    pub static mut pcmsg_unrhdr: *mut unrhdr;
    pub static mut sysctl___hw_snd: sysctl_oid;
    pub fn pcm_addchan(
        dev: device_t,
        dir: ::core::ffi::c_int,
        cls: kobj_class_t,
        devinfo: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn pcm_getbuffersize(
        dev: device_t,
        minbufsz: ::core::ffi::c_uint,
        deflt: ::core::ffi::c_uint,
        maxbufsz: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
    pub fn pcm_init(dev: device_t, devinfo: *mut ::core::ffi::c_void);
    pub fn pcm_register(dev: device_t, str_: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn pcm_unregister(dev: device_t) -> ::core::ffi::c_int;
    pub fn pcm_getflags(dev: device_t) -> u_int32_t;
    pub fn pcm_setflags(dev: device_t, val: u_int32_t);
    pub fn pcm_getdevinfo(dev: device_t) -> *mut ::core::ffi::c_void;
    pub fn snd_setup_intr(
        dev: device_t,
        res: *mut resource,
        flags: ::core::ffi::c_int,
        hand: driver_intr_t,
        param: *mut ::core::ffi::c_void,
        cookiep: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn sndstat_register(dev: device_t, str_: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn sndstat_unregister(dev: device_t) -> ::core::ffi::c_int;
    pub fn sound_oss_sysinfo(arg1: *mut oss_sysinfo);
    pub fn sound_oss_card_info(arg1: *mut oss_card_info) -> ::core::ffi::c_int;
    #[link_name = "be16dec__extern"]
    pub fn be16dec(pp: *const ::core::ffi::c_void) -> u16;
    #[link_name = "be32dec__extern"]
    pub fn be32dec(pp: *const ::core::ffi::c_void) -> u32;
    #[link_name = "be64dec__extern"]
    pub fn be64dec(pp: *const ::core::ffi::c_void) -> u64;
    #[link_name = "le16dec__extern"]
    pub fn le16dec(pp: *const ::core::ffi::c_void) -> u16;
    #[link_name = "le32dec__extern"]
    pub fn le32dec(pp: *const ::core::ffi::c_void) -> u32;
    #[link_name = "le64dec__extern"]
    pub fn le64dec(pp: *const ::core::ffi::c_void) -> u64;
    #[link_name = "be16enc__extern"]
    pub fn be16enc(pp: *mut ::core::ffi::c_void, u: u16);
    #[link_name = "be32enc__extern"]
    pub fn be32enc(pp: *mut ::core::ffi::c_void, u: u32);
    #[link_name = "be64enc__extern"]
    pub fn be64enc(pp: *mut ::core::ffi::c_void, u: u64);
    #[link_name = "le16enc__extern"]
    pub fn le16enc(pp: *mut ::core::ffi::c_void, u: u16);
    #[link_name = "le32enc__extern"]
    pub fn le32enc(pp: *mut ::core::ffi::c_void, u: u32);
    #[link_name = "le64enc__extern"]
    pub fn le64enc(pp: *mut ::core::ffi::c_void, u: u64);
    #[link_name = "virtio_htog16__extern"]
    pub fn virtio_htog16(modern: bool_, val: u16) -> u16;
    #[link_name = "virtio_gtoh16__extern"]
    pub fn virtio_gtoh16(modern: bool_, val: u16) -> u16;
    #[link_name = "virtio_htog32__extern"]
    pub fn virtio_htog32(modern: bool_, val: u32) -> u32;
    #[link_name = "virtio_gtoh32__extern"]
    pub fn virtio_gtoh32(modern: bool_, val: u32) -> u32;
    #[link_name = "virtio_htog64__extern"]
    pub fn virtio_htog64(modern: bool_, val: u64) -> u64;
    #[link_name = "virtio_gtoh64__extern"]
    pub fn virtio_gtoh64(modern: bool_, val: u64) -> u64;
    pub fn virtio_device_name(devid: u16) -> *const ::core::ffi::c_char;
    pub fn virtio_describe(
        dev: device_t,
        msg: *const ::core::ffi::c_char,
        features: u64,
        desc: *mut virtio_feature_desc,
    );
    pub fn virtio_describe_sbuf(
        sb: *mut sbuf,
        features: u64,
        desc: *mut virtio_feature_desc,
    ) -> ::core::ffi::c_int;
    pub fn virtio_filter_transport_features(features: u64) -> u64;
    pub fn virtio_bus_is_modern(dev: device_t) -> bool_;
    pub fn virtio_read_device_config_array(
        dev: device_t,
        offset: bus_size_t,
        dst: *mut ::core::ffi::c_void,
        size: ::core::ffi::c_int,
        count: ::core::ffi::c_int,
    );
    pub fn virtio_read_ivar(dev: device_t, ivar: ::core::ffi::c_int, val: *mut usize);
    pub fn virtio_write_ivar(dev: device_t, ivar: ::core::ffi::c_int, val: usize);
    pub fn virtio_negotiate_features(dev: device_t, child_features: u64) -> u64;
    pub fn virtio_finalize_features(dev: device_t) -> ::core::ffi::c_int;
    pub fn virtio_alloc_virtqueues(
        dev: device_t,
        nvqs: ::core::ffi::c_int,
        info: *mut vq_alloc_info,
    ) -> ::core::ffi::c_int;
    pub fn virtio_setup_intr(dev: device_t, type_: intr_type) -> ::core::ffi::c_int;
    pub fn virtio_with_feature(dev: device_t, feature: u64) -> bool_;
    pub fn virtio_stop(dev: device_t);
    pub fn virtio_config_generation(dev: device_t) -> ::core::ffi::c_int;
    pub fn virtio_reinit(dev: device_t, features: u64) -> ::core::ffi::c_int;
    pub fn virtio_reinit_complete(dev: device_t);
    pub fn virtio_child_pnpinfo(
        busdev: device_t,
        child: device_t,
        sb: *mut sbuf,
    ) -> ::core::ffi::c_int;
    pub fn virtio_read_device_config(
        dev: device_t,
        offset: bus_size_t,
        dst: *mut ::core::ffi::c_void,
        length: ::core::ffi::c_int,
    );
    pub fn virtio_write_device_config(
        dev: device_t,
        offset: bus_size_t,
        src: *const ::core::ffi::c_void,
        length: ::core::ffi::c_int,
    );
    #[link_name = "virtio_read_dev_config_1__extern"]
    pub fn virtio_read_dev_config_1(dev: device_t, offset: bus_size_t) -> u8;
    #[link_name = "virtio_write_dev_config_1__extern"]
    pub fn virtio_write_dev_config_1(dev: device_t, offset: bus_size_t, val: u8);
    #[link_name = "virtio_read_dev_config_2__extern"]
    pub fn virtio_read_dev_config_2(dev: device_t, offset: bus_size_t) -> u16;
    #[link_name = "virtio_write_dev_config_2__extern"]
    pub fn virtio_write_dev_config_2(dev: device_t, offset: bus_size_t, val: u16);
    #[link_name = "virtio_read_dev_config_4__extern"]
    pub fn virtio_read_dev_config_4(dev: device_t, offset: bus_size_t) -> u32;
    #[link_name = "virtio_write_dev_config_4__extern"]
    pub fn virtio_write_dev_config_4(dev: device_t, offset: bus_size_t, val: u32);
    #[link_name = "virtio_get_device_type__extern"]
    pub fn virtio_get_device_type(dev: device_t) -> ::core::ffi::c_int;
    #[link_name = "virtio_get_vendor__extern"]
    pub fn virtio_get_vendor(dev: device_t) -> ::core::ffi::c_int;
    #[link_name = "virtio_get_device__extern"]
    pub fn virtio_get_device(dev: device_t) -> ::core::ffi::c_int;
    #[link_name = "virtio_get_subvendor__extern"]
    pub fn virtio_get_subvendor(dev: device_t) -> ::core::ffi::c_int;
    #[link_name = "virtio_get_subdevice__extern"]
    pub fn virtio_get_subdevice(dev: device_t) -> ::core::ffi::c_int;
    #[link_name = "virtio_get_modern__extern"]
    pub fn virtio_get_modern(dev: device_t) -> ::core::ffi::c_int;
    #[link_name = "virtio_set_feature_desc__extern"]
    pub fn virtio_set_feature_desc(dev: device_t, val: *mut ::core::ffi::c_void);
    #[link_name = "virtio_simple_probe__extern"]
    pub fn virtio_simple_probe(
        dev: device_t,
        match_: *const virtio_pnp_match,
    ) -> ::core::ffi::c_int;
    pub fn virtqueue_alloc(
        dev: device_t,
        queue: u16,
        size: u16,
        notify_offset: bus_size_t,
        align: ::core::ffi::c_int,
        highaddr: vm_paddr_t,
        info: *mut vq_alloc_info,
        vqp: *mut *mut virtqueue,
    ) -> ::core::ffi::c_int;
    pub fn virtqueue_drain(
        vq: *mut virtqueue,
        last: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn virtqueue_free(vq: *mut virtqueue);
    pub fn virtqueue_reinit(vq: *mut virtqueue, size: u16) -> ::core::ffi::c_int;
    pub fn virtqueue_intr_filter(vq: *mut virtqueue) -> ::core::ffi::c_int;
    pub fn virtqueue_intr(vq: *mut virtqueue);
    pub fn virtqueue_enable_intr(vq: *mut virtqueue) -> ::core::ffi::c_int;
    pub fn virtqueue_postpone_intr(vq: *mut virtqueue, hint: vq_postpone_t) -> ::core::ffi::c_int;
    pub fn virtqueue_disable_intr(vq: *mut virtqueue);
    pub fn virtqueue_paddr(vq: *mut virtqueue) -> vm_paddr_t;
    pub fn virtqueue_desc_paddr(vq: *mut virtqueue) -> vm_paddr_t;
    pub fn virtqueue_avail_paddr(vq: *mut virtqueue) -> vm_paddr_t;
    pub fn virtqueue_used_paddr(vq: *mut virtqueue) -> vm_paddr_t;
    pub fn virtqueue_index(vq: *mut virtqueue) -> u16;
    pub fn virtqueue_full(vq: *mut virtqueue) -> bool_;
    pub fn virtqueue_empty(vq: *mut virtqueue) -> bool_;
    pub fn virtqueue_size(vq: *mut virtqueue) -> ::core::ffi::c_int;
    pub fn virtqueue_nfree(vq: *mut virtqueue) -> ::core::ffi::c_int;
    pub fn virtqueue_nused(vq: *mut virtqueue) -> ::core::ffi::c_int;
    pub fn virtqueue_notify(vq: *mut virtqueue);
    pub fn virtqueue_dump(vq: *mut virtqueue);
    pub fn virtqueue_enqueue(
        vq: *mut virtqueue,
        cookie: *mut ::core::ffi::c_void,
        sg: *mut sglist,
        readable: ::core::ffi::c_int,
        writable: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn virtqueue_dequeue(vq: *mut virtqueue, len: *mut u32) -> *mut ::core::ffi::c_void;
    pub fn virtqueue_poll(vq: *mut virtqueue, len: *mut u32) -> *mut ::core::ffi::c_void;
    pub fn vtsnd_device_probe(dev: device_t) -> ::core::ffi::c_int;
    pub fn vtsnd_get_chan_class() -> *mut kobj_class;
    pub fn vtsnd_chan_init_rust(
        devinfo: *mut ::core::ffi::c_void,
        b: *mut snd_dbuf,
        c: *mut pcm_channel,
        dir: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn vtsnd_chan_setformat(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        format: u32,
    ) -> ::core::ffi::c_int;
    pub fn vtsnd_chan_setspeed_rust(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        speed: u32,
    ) -> ::core::ffi::c_int;
    pub fn vtsnd_chan_getcaps_rust(
        devinfo: *mut ::core::ffi::c_void,
        outp: *mut *mut pcmchan_caps,
    ) -> ::core::ffi::c_int;
    pub fn vtsnd_get_fmt() -> *mut u32;
    #[doc = " @brief Unique descriptor for the GPIO_GET_BUS() method"]
    pub static mut gpio_get_bus_desc: kobjop_desc;
    #[link_name = "GPIO_GET_BUS__extern"]
    pub fn GPIO_GET_BUS(dev: device_t) -> device_t;
    #[doc = " @brief Unique descriptor for the GPIO_PIN_MAX() method"]
    pub static mut gpio_pin_max_desc: kobjop_desc;
    #[link_name = "GPIO_PIN_MAX__extern"]
    pub fn GPIO_PIN_MAX(dev: device_t, maxpin: *mut ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the GPIO_PIN_SET() method"]
    pub static mut gpio_pin_set_desc: kobjop_desc;
    #[link_name = "GPIO_PIN_SET__extern"]
    pub fn GPIO_PIN_SET(dev: device_t, pin_num: u32, pin_value: u32) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the GPIO_PIN_GET() method"]
    pub static mut gpio_pin_get_desc: kobjop_desc;
    #[link_name = "GPIO_PIN_GET__extern"]
    pub fn GPIO_PIN_GET(dev: device_t, pin_num: u32, pin_value: *mut u32) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the GPIO_PIN_TOGGLE() method"]
    pub static mut gpio_pin_toggle_desc: kobjop_desc;
    #[link_name = "GPIO_PIN_TOGGLE__extern"]
    pub fn GPIO_PIN_TOGGLE(dev: device_t, pin_num: u32) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the GPIO_PIN_GETCAPS() method"]
    pub static mut gpio_pin_getcaps_desc: kobjop_desc;
    #[link_name = "GPIO_PIN_GETCAPS__extern"]
    pub fn GPIO_PIN_GETCAPS(dev: device_t, pin_num: u32, caps: *mut u32) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the GPIO_PIN_GETFLAGS() method"]
    pub static mut gpio_pin_getflags_desc: kobjop_desc;
    #[link_name = "GPIO_PIN_GETFLAGS__extern"]
    pub fn GPIO_PIN_GETFLAGS(dev: device_t, pin_num: u32, flags: *mut u32) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the GPIO_PIN_GETNAME() method"]
    pub static mut gpio_pin_getname_desc: kobjop_desc;
    #[link_name = "GPIO_PIN_GETNAME__extern"]
    pub fn GPIO_PIN_GETNAME(
        dev: device_t,
        pin_num: u32,
        name: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the GPIO_PIN_SETFLAGS() method"]
    pub static mut gpio_pin_setflags_desc: kobjop_desc;
    #[link_name = "GPIO_PIN_SETFLAGS__extern"]
    pub fn GPIO_PIN_SETFLAGS(dev: device_t, pin_num: u32, flags: u32) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the GPIO_MAP_GPIOS() method"]
    pub static mut gpio_map_gpios_desc: kobjop_desc;
    #[link_name = "GPIO_MAP_GPIOS__extern"]
    pub fn GPIO_MAP_GPIOS(
        bus: device_t,
        dev: phandle_t,
        gparent: phandle_t,
        gcells: ::core::ffi::c_int,
        gpios: *mut pcell_t,
        pin: *mut u32,
        flags: *mut u32,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the GPIO_PIN_ACCESS_32() method"]
    pub static mut gpio_pin_access_32_desc: kobjop_desc;
    #[link_name = "GPIO_PIN_ACCESS_32__extern"]
    pub fn GPIO_PIN_ACCESS_32(
        dev: device_t,
        first_pin: u32,
        clear_pins: u32,
        change_pins: u32,
        orig_pins: *mut u32,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the GPIO_PIN_CONFIG_32() method"]
    pub static mut gpio_pin_config_32_desc: kobjop_desc;
    #[link_name = "GPIO_PIN_CONFIG_32__extern"]
    pub fn GPIO_PIN_CONFIG_32(
        dev: device_t,
        first_pin: u32,
        num_pins: u32,
        pin_flags: *mut u32,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the GPIO_GET_PIN_LIST() method"]
    pub static mut gpio_get_pin_list_desc: kobjop_desc;
    #[link_name = "GPIO_GET_PIN_LIST__extern"]
    pub fn GPIO_GET_PIN_LIST(dev: device_t, pin_list: *mut u32) -> ::core::ffi::c_int;
    #[link_name = "gpiobus_get_npins__extern"]
    pub fn gpiobus_get_npins(dev: device_t) -> u32;
    #[link_name = "gpiobus_set_npins__extern"]
    pub fn gpiobus_set_npins(dev: device_t, t: u32);
    #[link_name = "gpiobus_get_pins__extern"]
    pub fn gpiobus_get_pins(dev: device_t) -> *const u32;
    #[link_name = "gpiobus_set_pins__extern"]
    pub fn gpiobus_set_pins(dev: device_t, t: *const u32);
    #[link_name = "gpio_map_gpios__extern"]
    pub fn gpio_map_gpios(
        bus: device_t,
        dev: phandle_t,
        gparent: phandle_t,
        gcells: ::core::ffi::c_int,
        gpios: *mut pcell_t,
        pin: *mut u32,
        flags: *mut u32,
    ) -> ::core::ffi::c_int;
    pub fn ofw_gpiobus_add_fdt_child(
        arg1: device_t,
        arg2: *const ::core::ffi::c_char,
        arg3: phandle_t,
    ) -> device_t;
    pub fn ofw_gpiobus_parse_gpios(
        arg1: device_t,
        arg2: *mut ::core::ffi::c_char,
        arg3: *mut *mut gpiobus_pin,
    ) -> ::core::ffi::c_int;
    pub fn ofw_gpiobus_register_provider(arg1: device_t);
    pub fn ofw_gpiobus_unregister_provider(arg1: device_t);
    pub fn gpio_pin_get_by_ofw_name(
        consumer: device_t,
        node: phandle_t,
        name: *mut ::core::ffi::c_char,
        gpio: *mut gpio_pin_t,
    ) -> ::core::ffi::c_int;
    pub fn gpio_pin_get_by_ofw_idx(
        consumer: device_t,
        node: phandle_t,
        idx: ::core::ffi::c_int,
        gpio: *mut gpio_pin_t,
    ) -> ::core::ffi::c_int;
    pub fn gpio_pin_get_by_ofw_property(
        consumer: device_t,
        node: phandle_t,
        name: *mut ::core::ffi::c_char,
        gpio: *mut gpio_pin_t,
    ) -> ::core::ffi::c_int;
    pub fn gpio_pin_get_by_ofw_propidx(
        consumer: device_t,
        node: phandle_t,
        name: *mut ::core::ffi::c_char,
        idx: ::core::ffi::c_int,
        gpio: *mut gpio_pin_t,
    ) -> ::core::ffi::c_int;
    pub fn gpio_pin_get_by_bus_pinnum(
        _bus: device_t,
        _pinnum: u32,
        _gp: *mut gpio_pin_t,
    ) -> ::core::ffi::c_int;
    pub fn gpio_pin_get_by_child_index(
        _child: device_t,
        _idx: u32,
        _gp: *mut gpio_pin_t,
    ) -> ::core::ffi::c_int;
    pub fn gpio_pin_acquire(gpio: gpio_pin_t) -> ::core::ffi::c_int;
    pub fn gpio_pin_release(gpio: gpio_pin_t);
    pub fn gpio_pin_getcaps(pin: gpio_pin_t, caps: *mut u32) -> ::core::ffi::c_int;
    pub fn gpio_pin_is_active(pin: gpio_pin_t, active: *mut bool_) -> ::core::ffi::c_int;
    pub fn gpio_pin_set_active(pin: gpio_pin_t, active: bool_) -> ::core::ffi::c_int;
    pub fn gpio_pin_setflags(pin: gpio_pin_t, flags: u32) -> ::core::ffi::c_int;
    pub fn gpio_alloc_intr_resource(
        consumer_dev: device_t,
        rid: *mut ::core::ffi::c_int,
        alloc_flags: u_int,
        pin: gpio_pin_t,
        intr_mode: u32,
    ) -> *mut resource;
    pub fn gpio_check_flags(arg1: u32, arg2: u32) -> ::core::ffi::c_int;
    pub fn gpiobus_add_bus(arg1: device_t) -> device_t;
    pub fn gpiobus_detach_bus(arg1: device_t) -> ::core::ffi::c_int;
    pub static mut bio_transient_maxcnt: ::core::ffi::c_int;
    pub fn biodone(bp: *mut bio);
    pub fn biofinish(bp: *mut bio, stat: *mut devstat, error: ::core::ffi::c_int);
    pub fn biowait(bp: *mut bio, wmesg: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn biotrack_buf(bp: *mut bio, location: *const ::core::ffi::c_char);
    #[link_name = "biotrack__extern"]
    pub fn biotrack(bp: *mut bio, location: *const ::core::ffi::c_char);
    pub fn bioq_disksort(ap: *mut bio_queue_head, bp: *mut bio);
    pub fn bioq_first(head: *mut bio_queue_head) -> *mut bio;
    pub fn bioq_takefirst(head: *mut bio_queue_head) -> *mut bio;
    pub fn bioq_flush(head: *mut bio_queue_head, stp: *mut devstat, error: ::core::ffi::c_int);
    pub fn bioq_init(head: *mut bio_queue_head);
    pub fn bioq_insert_head(head: *mut bio_queue_head, bp: *mut bio);
    pub fn bioq_insert_tail(head: *mut bio_queue_head, bp: *mut bio);
    pub fn bioq_remove(head: *mut bio_queue_head, bp: *mut bio);
    pub fn physio(dev: *mut cdev, uio: *mut uio, ioflag: ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[link_name = "counter_u64_add__extern"]
    pub fn counter_u64_add(c: counter_u64_t, inc: i64);
    pub fn counter_u64_alloc(arg1: ::core::ffi::c_int) -> counter_u64_t;
    pub fn counter_u64_free(arg1: counter_u64_t);
    pub fn counter_u64_zero(arg1: counter_u64_t);
    pub fn counter_u64_fetch(arg1: counter_u64_t) -> u64;
    pub fn counter_rate_alloc(
        flags: ::core::ffi::c_int,
        period: ::core::ffi::c_int,
    ) -> *mut counter_rate;
    pub fn counter_rate_free(arg1: *mut counter_rate);
    pub fn counter_ratecheck(arg1: *mut counter_rate, arg2: i64) -> i64;
    pub fn counter_rate_get(arg1: *mut counter_rate) -> u64;
    pub fn counter_u64_sysinit(arg1: *mut ::core::ffi::c_void);
    pub fn counter_u64_sysuninit(arg1: *mut ::core::ffi::c_void);
    #[link_name = "memdesc_vaddr__extern"]
    pub fn memdesc_vaddr(vaddr: *mut ::core::ffi::c_void, len: usize) -> memdesc;
    #[link_name = "memdesc_paddr__extern"]
    pub fn memdesc_paddr(paddr: vm_paddr_t, len: usize) -> memdesc;
    #[link_name = "memdesc_vlist__extern"]
    pub fn memdesc_vlist(vlist: *mut bus_dma_segment, sglist_cnt: ::core::ffi::c_int) -> memdesc;
    #[link_name = "memdesc_plist__extern"]
    pub fn memdesc_plist(plist: *mut bus_dma_segment, sglist_cnt: ::core::ffi::c_int) -> memdesc;
    #[link_name = "memdesc_uio__extern"]
    pub fn memdesc_uio(uio: *mut uio) -> memdesc;
    #[link_name = "memdesc_mbuf__extern"]
    pub fn memdesc_mbuf(mbuf: *mut mbuf) -> memdesc;
    #[link_name = "memdesc_vmpages__extern"]
    pub fn memdesc_vmpages(ma: *mut *mut vm_page, len: usize, ma_offset: u_int) -> memdesc;
    pub fn memdesc_bio(bio: *mut bio) -> memdesc;
    pub fn memdesc_ccb(ccb: *mut ccb) -> memdesc;
    pub fn memdesc_copyback(
        mem: *mut memdesc,
        off: ::core::ffi::c_int,
        size: ::core::ffi::c_int,
        src: *const ::core::ffi::c_void,
    );
    pub fn memdesc_copydata(
        mem: *mut memdesc,
        off: ::core::ffi::c_int,
        size: ::core::ffi::c_int,
        dst: *mut ::core::ffi::c_void,
    );
    pub fn memdesc_alloc_ext_mbufs(
        mem: *mut memdesc,
        ext_alloc: memdesc_alloc_ext_mbuf_t,
        extpg_alloc: memdesc_alloc_extpg_mbuf_t,
        cb_arg: *mut ::core::ffi::c_void,
        how: ::core::ffi::c_int,
        offset: usize,
        len: usize,
        actual_len: *mut usize,
        can_truncate: bool_,
    ) -> *mut mbuf;
    pub fn uma_zcreate(
        name: *const ::core::ffi::c_char,
        size: usize,
        ctor: uma_ctor,
        dtor: uma_dtor,
        uminit: uma_init,
        fini: uma_fini,
        align: ::core::ffi::c_int,
        flags: u32,
    ) -> uma_zone_t;
    pub fn uma_zsecond_create(
        name: *const ::core::ffi::c_char,
        ctor: uma_ctor,
        dtor: uma_dtor,
        zinit: uma_init,
        zfini: uma_fini,
        primary: uma_zone_t,
    ) -> uma_zone_t;
    pub fn uma_zcache_create(
        name: *const ::core::ffi::c_char,
        size: ::core::ffi::c_int,
        ctor: uma_ctor,
        dtor: uma_dtor,
        zinit: uma_init,
        zfini: uma_fini,
        zimport: uma_import,
        zrelease: uma_release,
        arg: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> uma_zone_t;
    pub fn uma_zdestroy(zone: uma_zone_t);
    pub fn uma_zalloc_arg(
        zone: uma_zone_t,
        arg: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn uma_zalloc_pcpu_arg(
        zone: uma_zone_t,
        arg: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn uma_zalloc_smr(zone: uma_zone_t, flags: ::core::ffi::c_int) -> *mut ::core::ffi::c_void;
    pub fn uma_zalloc_domain(
        zone: uma_zone_t,
        arg: *mut ::core::ffi::c_void,
        domain: ::core::ffi::c_int,
        flags: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    #[link_name = "uma_zalloc__extern"]
    pub fn uma_zalloc(zone: uma_zone_t, flags: ::core::ffi::c_int) -> *mut ::core::ffi::c_void;
    #[link_name = "uma_zalloc_pcpu__extern"]
    pub fn uma_zalloc_pcpu(zone: uma_zone_t, flags: ::core::ffi::c_int)
    -> *mut ::core::ffi::c_void;
    pub fn uma_zfree_arg(
        zone: uma_zone_t,
        item: *mut ::core::ffi::c_void,
        arg: *mut ::core::ffi::c_void,
    );
    pub fn uma_zfree_pcpu_arg(
        zone: uma_zone_t,
        item: *mut ::core::ffi::c_void,
        arg: *mut ::core::ffi::c_void,
    );
    pub fn uma_zfree_smr(zone: uma_zone_t, item: *mut ::core::ffi::c_void);
    #[link_name = "uma_zfree__extern"]
    pub fn uma_zfree(zone: uma_zone_t, item: *mut ::core::ffi::c_void);
    #[link_name = "uma_zfree_pcpu__extern"]
    pub fn uma_zfree_pcpu(zone: uma_zone_t, item: *mut ::core::ffi::c_void);
    pub fn uma_zwait(zone: uma_zone_t);
    pub fn uma_reclaim(req: ::core::ffi::c_int);
    pub fn uma_reclaim_domain(req: ::core::ffi::c_int, domain: ::core::ffi::c_int);
    pub fn uma_zone_reclaim(arg1: uma_zone_t, req: ::core::ffi::c_int);
    pub fn uma_zone_reclaim_domain(
        arg1: uma_zone_t,
        req: ::core::ffi::c_int,
        domain: ::core::ffi::c_int,
    );
    pub fn uma_set_cache_align_mask(mask: ::core::ffi::c_uint);
    pub fn uma_get_cache_align_mask() -> ::core::ffi::c_uint;
    pub fn uma_zone_reserve(zone: uma_zone_t, nitems: ::core::ffi::c_int);
    pub fn uma_zone_reserve_kva(zone: uma_zone_t, nitems: ::core::ffi::c_int)
    -> ::core::ffi::c_int;
    pub fn uma_zone_set_max(zone: uma_zone_t, nitems: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn uma_zone_set_maxcache(zone: uma_zone_t, nitems: ::core::ffi::c_int);
    pub fn uma_zone_get_max(zone: uma_zone_t) -> ::core::ffi::c_int;
    pub fn uma_zone_set_warning(zone: uma_zone_t, warning: *const ::core::ffi::c_char);
    pub fn uma_zone_set_maxaction(zone: uma_zone_t, arg1: uma_maxaction_t);
    pub fn uma_zone_get_cur(zone: uma_zone_t) -> ::core::ffi::c_int;
    pub fn uma_zone_set_init(zone: uma_zone_t, uminit: uma_init);
    pub fn uma_zone_set_fini(zone: uma_zone_t, fini: uma_fini);
    pub fn uma_zone_set_zinit(zone: uma_zone_t, zinit: uma_init);
    pub fn uma_zone_set_zfini(zone: uma_zone_t, zfini: uma_fini);
    pub fn uma_zone_set_allocf(zone: uma_zone_t, allocf: uma_alloc);
    pub fn uma_zone_set_freef(zone: uma_zone_t, freef: uma_free);
    pub fn uma_zone_set_smr(zone: uma_zone_t, smr: smr_t);
    pub fn uma_zone_get_smr(zone: uma_zone_t) -> smr_t;
    pub fn uma_prealloc(zone: uma_zone_t, itemcnt: ::core::ffi::c_int);
    pub fn uma_zone_exhausted(zone: uma_zone_t) -> ::core::ffi::c_int;
    pub fn uma_zone_memory(zone: uma_zone_t) -> usize;
    pub static mut pcpu_zone_4: uma_zone_t;
    pub static mut pcpu_zone_8: uma_zone_t;
    pub static mut pcpu_zone_16: uma_zone_t;
    pub static mut pcpu_zone_32: uma_zone_t;
    pub static mut pcpu_zone_64: uma_zone_t;
    pub fn uma_reclaim_wakeup();
    pub fn uma_reclaim_worker(arg1: *mut ::core::ffi::c_void);
    pub fn uma_limit() -> ::core::ffi::c_ulong;
    pub fn uma_size() -> ::core::ffi::c_ulong;
    pub fn uma_avail() -> ::core::ffi::c_long;
    pub fn nvme_cpl_sbuf(cpl: *const nvme_completion, sbuf: *mut sbuf);
    pub fn nvme_opcode_sbuf(admin: bool_, opc: u8, sb: *mut sbuf);
    pub fn nvme_sc_sbuf(cpl: *const nvme_completion, sbuf: *mut sbuf);
    pub fn nvme_strvis(
        dst: *mut u8,
        src: *const u8,
        dstlen: ::core::ffi::c_int,
        srclen: ::core::ffi::c_int,
    );
    #[link_name = "kerneldump_parity__extern"]
    pub fn kerneldump_parity(kdhp: *mut kerneldumpheader) -> u_int32_t;
    pub fn minidumpsys(arg1: *mut dumperinfo, arg2: bool_) -> ::core::ffi::c_int;
    pub fn dumpsys_generic(arg1: *mut dumperinfo) -> ::core::ffi::c_int;
    pub fn dumpsys_map_chunk(arg1: vm_paddr_t, arg2: usize, arg3: *mut *mut ::core::ffi::c_void);
    pub fn dumpsys_foreach_chunk(
        arg1: dumpsys_callback_t,
        arg2: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn dumpsys_cb_dumpdata(
        arg1: *mut dump_pa,
        arg2: ::core::ffi::c_int,
        arg3: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn dumpsys_buf_seek(arg1: *mut dumperinfo, arg2: usize) -> ::core::ffi::c_int;
    pub fn dumpsys_buf_write(
        arg1: *mut dumperinfo,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
    ) -> ::core::ffi::c_int;
    pub fn dumpsys_buf_flush(arg1: *mut dumperinfo) -> ::core::ffi::c_int;
    pub fn dumpsys_gen_pa_init();
    pub fn dumpsys_gen_pa_next(arg1: *mut dump_pa) -> *mut dump_pa;
    pub fn dumpsys_gen_wbinv_all();
    pub fn dumpsys_gen_unmap_chunk(arg1: vm_paddr_t, arg2: usize, arg3: *mut ::core::ffi::c_void);
    pub fn dumpsys_gen_write_aux_headers(arg1: *mut dumperinfo) -> ::core::ffi::c_int;
    pub fn dumpsys_pb_init(arg1: u64);
    pub fn dumpsys_pb_progress(arg1: usize);
    pub static mut do_minidump: ::core::ffi::c_int;
    pub fn livedump_start(
        arg1: ::core::ffi::c_int,
        arg2: ::core::ffi::c_int,
        arg3: u8,
    ) -> ::core::ffi::c_int;
    pub fn livedump_start_vnode(
        arg1: *mut vnode,
        arg2: ::core::ffi::c_int,
        arg3: u8,
    ) -> ::core::ffi::c_int;
    pub fn so_options_get(arg1: *const socket) -> ::core::ffi::c_int;
    pub fn so_options_set(arg1: *mut socket, arg2: ::core::ffi::c_int);
    pub fn so_error_get(arg1: *const socket) -> ::core::ffi::c_int;
    pub fn so_error_set(arg1: *mut socket, arg2: ::core::ffi::c_int);
    pub fn disk_err(
        bp: *mut bio,
        what: *const ::core::ffi::c_char,
        blkdone: ::core::ffi::c_int,
        nl: ::core::ffi::c_int,
    );
    pub static mut M_IFADDR: [malloc_type; 1usize];
    pub static mut M_IFMADDR: [malloc_type; 1usize];
    pub static mut ifnet_detach_sxlock: sx;
    pub fn if_capnv_to_capint(
        nv: *const nvlist,
        old_cap: *mut ::core::ffi::c_int,
        nn: *const ifcap_nv_bit_name,
        all: bool_,
    ) -> ::core::ffi::c_int;
    pub fn if_capint_to_capnv(
        nv: *mut nvlist,
        nn: *const ifcap_nv_bit_name,
        ifr_cap: ::core::ffi::c_int,
        ifr_req: ::core::ffi::c_int,
    );
    pub fn _rw_init_flags(
        c: *mut usize,
        name: *const ::core::ffi::c_char,
        opts: ::core::ffi::c_int,
    );
    pub fn _rw_destroy(c: *mut usize);
    pub fn rw_sysinit(arg: *const ::core::ffi::c_void);
    pub fn _rw_wowned(c: *const usize) -> ::core::ffi::c_int;
    pub fn _rw_wlock_cookie(
        c: *mut usize,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn __rw_try_wlock_int(
        rw: *mut rwlock,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn __rw_try_wlock(
        c: *mut usize,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn _rw_wunlock_cookie(
        c: *mut usize,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn __rw_rlock_int(
        rw: *mut rwlock,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn __rw_rlock(c: *mut usize, file: *const ::core::ffi::c_char, line: ::core::ffi::c_int);
    pub fn __rw_try_rlock_int(
        rw: *mut rwlock,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn __rw_try_rlock(
        c: *mut usize,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn _rw_runlock_cookie_int(
        rw: *mut rwlock,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn _rw_runlock_cookie(
        c: *mut usize,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn __rw_wlock_hard(
        c: *mut usize,
        v: usize,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn __rw_wunlock_hard(
        c: *mut usize,
        v: usize,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn __rw_try_upgrade_int(
        rw: *mut rwlock,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn __rw_try_upgrade(
        c: *mut usize,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn __rw_downgrade_int(
        rw: *mut rwlock,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn __rw_downgrade(
        c: *mut usize,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn __rw_assert(
        c: *const usize,
        what: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn sx_sysinit(arg: *const ::core::ffi::c_void);
    pub fn sx_init_flags(
        sx: *mut sx,
        description: *const ::core::ffi::c_char,
        opts: ::core::ffi::c_int,
    );
    pub fn sx_destroy(sx: *mut sx);
    pub fn sx_try_slock_int(
        sx: *mut sx,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn sx_try_slock_(
        sx: *mut sx,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn sx_try_xlock_int(
        sx: *mut sx,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn sx_try_xlock_(
        sx: *mut sx,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn sx_try_upgrade_int(
        sx: *mut sx,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn sx_try_upgrade_(
        sx: *mut sx,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn sx_downgrade_int(
        sx: *mut sx,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn sx_downgrade_(sx: *mut sx, file: *const ::core::ffi::c_char, line: ::core::ffi::c_int);
    pub fn _sx_slock_int(
        sx: *mut sx,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn _sx_slock(
        sx: *mut sx,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn _sx_xlock(
        sx: *mut sx,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn _sx_sunlock_int(sx: *mut sx, file: *const ::core::ffi::c_char, line: ::core::ffi::c_int);
    pub fn _sx_sunlock(sx: *mut sx, file: *const ::core::ffi::c_char, line: ::core::ffi::c_int);
    pub fn _sx_xunlock(sx: *mut sx, file: *const ::core::ffi::c_char, line: ::core::ffi::c_int);
    pub fn _sx_xlock_hard(
        sx: *mut sx,
        x: usize,
        opts: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn _sx_xunlock_hard(
        sx: *mut sx,
        x: usize,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub fn _sx_assert(
        sx: *const sx,
        what: ::core::ffi::c_int,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
    pub static mut __start_set_vnet: *mut usize;
    pub static mut __stop_set_vnet: *mut usize;
    pub fn vnet_alloc() -> *mut vnet;
    pub fn vnet_destroy(vnet: *mut vnet);
    pub static mut vnet0: *mut vnet;
    pub static mut vnet_head: vnet_list_head;
    pub static mut vnet_rwlock: rwlock;
    pub static mut vnet_sxlock: sx;
    pub fn vnet_data_alloc(size: ::core::ffi::c_int) -> *mut ::core::ffi::c_void;
    pub fn vnet_data_copy(start: *mut ::core::ffi::c_void, size: ::core::ffi::c_int);
    pub fn vnet_data_free(start_arg: *mut ::core::ffi::c_void, size: ::core::ffi::c_int);
    pub fn vnet_save_init(arg1: *mut ::core::ffi::c_void, arg2: usize);
    pub fn vnet_restore_init(arg1: *mut ::core::ffi::c_void, arg2: usize);
    pub fn vnet_register_sysinit(arg: *mut ::core::ffi::c_void);
    pub fn vnet_register_sysuninit(arg: *mut ::core::ffi::c_void);
    pub fn vnet_deregister_sysinit(arg: *mut ::core::ffi::c_void);
    pub fn vnet_deregister_sysuninit(arg: *mut ::core::ffi::c_void);
    pub fn vnet_global_eventhandler_iterator_func(arg1: *mut ::core::ffi::c_void, ...);
    pub static mut vnet_entry_ip_allow_net0: bool_;
    pub static mut vnet_entry_ip_allow_net240: bool_;
    pub static mut vnet_entry_in_loopback_mask: u32;
    pub fn setipv4sourcefilter(
        arg1: ::core::ffi::c_int,
        arg2: in_addr,
        arg3: in_addr,
        arg4: u32,
        arg5: u32,
        arg6: *mut in_addr,
    ) -> ::core::ffi::c_int;
    pub fn getipv4sourcefilter(
        arg1: ::core::ffi::c_int,
        arg2: in_addr,
        arg3: in_addr,
        arg4: *mut u32,
        arg5: *mut u32,
        arg6: *mut in_addr,
    ) -> ::core::ffi::c_int;
    pub fn setsourcefilter(
        arg1: ::core::ffi::c_int,
        arg2: u32,
        arg3: *mut sockaddr,
        arg4: socklen_t,
        arg5: u32,
        arg6: u32,
        arg7: *mut sockaddr_storage,
    ) -> ::core::ffi::c_int;
    pub fn getsourcefilter(
        arg1: ::core::ffi::c_int,
        arg2: u32,
        arg3: *mut sockaddr,
        arg4: socklen_t,
        arg5: *mut u32,
        arg6: *mut u32,
        arg7: *mut sockaddr_storage,
    ) -> ::core::ffi::c_int;
    pub fn in_ifnet_broadcast(arg1: in_addr, arg2: *mut ifnet) -> bool_;
    pub fn in_ifaddr_broadcast(arg1: in_addr, arg2: *mut in_ifaddr) -> bool_;
    pub fn in_canforward(arg1: in_addr) -> bool_;
    pub fn in_localaddr(arg1: in_addr) -> bool_;
    pub fn in_localip(arg1: in_addr) -> bool_;
    pub fn in_localip_fib(arg1: in_addr, arg2: u16) -> bool_;
    pub fn in_ifhasaddr(arg1: *mut ifnet, arg2: in_addr) -> bool_;
    pub fn in_findlocal(arg1: u32, arg2: bool_) -> *mut in_ifaddr;
    pub fn inet_aton(arg1: *const ::core::ffi::c_char, arg2: *mut in_addr) -> ::core::ffi::c_int;
    pub fn inet_ntoa_r(ina: in_addr, buf: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn inet_ntop(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_void,
        arg3: *mut ::core::ffi::c_char,
        arg4: socklen_t,
    ) -> *mut ::core::ffi::c_char;
    pub fn inet_pton(
        af: ::core::ffi::c_int,
        arg1: *const ::core::ffi::c_char,
        arg2: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn in_ifdetach(arg1: *mut ifnet);
    #[link_name = "in_broadcast__extern"]
    pub fn in_broadcast(in_: in_addr) -> bool_;
    pub static sa6_any: sockaddr_in6;
    pub static in6mask0: in6_addr;
    pub static in6mask32: in6_addr;
    pub static in6mask64: in6_addr;
    pub static in6mask96: in6_addr;
    pub static in6mask128: in6_addr;
    pub static in6addr_any: in6_addr;
    pub static in6addr_loopback: in6_addr;
    pub static in6addr_nodelocal_allnodes: in6_addr;
    pub static in6addr_linklocal_allnodes: in6_addr;
    pub static in6addr_linklocal_allrouters: in6_addr;
    pub static in6addr_linklocal_allv2routers: in6_addr;
    pub fn in6_cksum(arg1: *mut mbuf, arg2: u8, arg3: u32, arg4: u32) -> ::core::ffi::c_int;
    pub fn in6_cksum_partial(
        arg1: *mut mbuf,
        arg2: u8,
        arg3: u32,
        arg4: u32,
        arg5: u32,
    ) -> ::core::ffi::c_int;
    pub fn in6_cksum_partial_l2(
        m: *mut mbuf,
        nxt: u8,
        off_l3: u32,
        off_l4: u32,
        len: u32,
        cov: u32,
    ) -> ::core::ffi::c_int;
    pub fn in6_cksum_pseudo(
        arg1: *mut ip6_hdr,
        arg2: u32,
        arg3: u8,
        arg4: u16,
    ) -> ::core::ffi::c_int;
    pub fn in6_localaddr(arg1: *mut in6_addr) -> ::core::ffi::c_int;
    pub fn in6_localip(arg1: *mut in6_addr) -> ::core::ffi::c_int;
    pub fn in6_localip_fib(arg1: *mut in6_addr, arg2: u16) -> bool_;
    pub fn in6_ifhasaddr(arg1: *mut ifnet, arg2: *mut in6_addr) -> ::core::ffi::c_int;
    pub fn in6_addrscope(arg1: *const in6_addr) -> ::core::ffi::c_int;
    pub fn ip6_sprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const in6_addr,
    ) -> *mut ::core::ffi::c_char;
    pub fn in6_ifawithifp(arg1: *mut ifnet, arg2: *mut in6_addr) -> *mut in6_ifaddr;
    pub fn in6_if_up(arg1: *mut ifnet);
    pub fn in6_sin6_2_sin(sin: *mut sockaddr_in, sin6: *const sockaddr_in6);
    pub fn in6_sin_2_v4mapsin6(sin: *const sockaddr_in, sin6: *mut sockaddr_in6);
    pub fn in6_sin6_2_sin_in_sock(nam: *mut sockaddr);
    pub fn addrsel_policy_init();
    pub fn inet6_option_space(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn inet6_option_init(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut *mut cmsghdr,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn inet6_option_append(
        arg1: *mut cmsghdr,
        arg2: *const u8,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn inet6_option_alloc(
        arg1: *mut cmsghdr,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
    ) -> *mut u8;
    pub fn inet6_option_next(arg1: *const cmsghdr, arg2: *mut *mut u8) -> ::core::ffi::c_int;
    pub fn inet6_option_find(
        arg1: *const cmsghdr,
        arg2: *mut *mut u8,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn inet6_rthdr_space(arg1: ::core::ffi::c_int, arg2: ::core::ffi::c_int) -> usize;
    pub fn inet6_rthdr_init(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::core::ffi::c_int,
    ) -> *mut cmsghdr;
    pub fn inet6_rthdr_add(
        arg1: *mut cmsghdr,
        arg2: *const in6_addr,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
    pub fn inet6_rthdr_lasthop(arg1: *mut cmsghdr, arg2: ::core::ffi::c_uint)
    -> ::core::ffi::c_int;
    pub fn inet6_rthdr_segments(arg1: *const cmsghdr) -> ::core::ffi::c_int;
    pub fn inet6_rthdr_getaddr(arg1: *mut cmsghdr, arg2: ::core::ffi::c_int) -> *mut in6_addr;
    pub fn inet6_rthdr_getflags(
        arg1: *const cmsghdr,
        arg2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn inet6_opt_init(arg1: *mut ::core::ffi::c_void, arg2: socklen_t) -> ::core::ffi::c_int;
    pub fn inet6_opt_append(
        arg1: *mut ::core::ffi::c_void,
        arg2: socklen_t,
        arg3: ::core::ffi::c_int,
        arg4: u8,
        arg5: socklen_t,
        arg6: u8,
        arg7: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn inet6_opt_finish(
        arg1: *mut ::core::ffi::c_void,
        arg2: socklen_t,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn inet6_opt_set_val(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::core::ffi::c_int,
        arg3: *mut ::core::ffi::c_void,
        arg4: socklen_t,
    ) -> ::core::ffi::c_int;
    pub fn inet6_opt_next(
        arg1: *mut ::core::ffi::c_void,
        arg2: socklen_t,
        arg3: ::core::ffi::c_int,
        arg4: *mut u8,
        arg5: *mut socklen_t,
        arg6: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn inet6_opt_find(
        arg1: *mut ::core::ffi::c_void,
        arg2: socklen_t,
        arg3: ::core::ffi::c_int,
        arg4: u8,
        arg5: *mut socklen_t,
        arg6: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn inet6_opt_get_val(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::core::ffi::c_int,
        arg3: *mut ::core::ffi::c_void,
        arg4: socklen_t,
    ) -> ::core::ffi::c_int;
    pub fn inet6_rth_space(arg1: ::core::ffi::c_int, arg2: ::core::ffi::c_int) -> socklen_t;
    pub fn inet6_rth_init(
        arg1: *mut ::core::ffi::c_void,
        arg2: socklen_t,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn inet6_rth_add(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const in6_addr,
    ) -> ::core::ffi::c_int;
    pub fn inet6_rth_reverse(
        arg1: *const ::core::ffi::c_void,
        arg2: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn inet6_rth_segments(arg1: *const ::core::ffi::c_void) -> ::core::ffi::c_int;
    pub fn inet6_rth_getaddr(
        arg1: *const ::core::ffi::c_void,
        arg2: ::core::ffi::c_int,
    ) -> *mut in6_addr;
    pub fn nvme_ctrlr_passthrough_cmd(
        ctrlr: *mut nvme_controller,
        pt: *mut nvme_pt_command,
        nsid: u32,
        is_user_buffer: ::core::ffi::c_int,
        is_admin_cmd: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn nvme_ctrlr_linux_passthru_cmd(
        ctrlr: *mut nvme_controller,
        npc: *mut nvme_passthru_cmd,
        nsid: u32,
        is_user: bool_,
        is_admin: bool_,
    ) -> ::core::ffi::c_int;
    pub fn nvme_ctrlr_cmd_set_feature(
        ctrlr: *mut nvme_controller,
        feature: u8,
        cdw11: u32,
        cdw12: u32,
        cdw13: u32,
        cdw14: u32,
        cdw15: u32,
        payload: *mut ::core::ffi::c_void,
        payload_size: u32,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_get_feature(
        ctrlr: *mut nvme_controller,
        feature: u8,
        cdw11: u32,
        payload: *mut ::core::ffi::c_void,
        payload_size: u32,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_get_log_page(
        ctrlr: *mut nvme_controller,
        log_page: u8,
        nsid: u32,
        payload: *mut ::core::ffi::c_void,
        payload_size: u32,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ns_cmd_write(
        ns: *mut nvme_namespace,
        payload: *mut ::core::ffi::c_void,
        lba: u64,
        lba_count: u32,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn nvme_ns_cmd_write_bio(
        ns: *mut nvme_namespace,
        bp: *mut bio,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn nvme_ns_cmd_read(
        ns: *mut nvme_namespace,
        payload: *mut ::core::ffi::c_void,
        lba: u64,
        lba_count: u32,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn nvme_ns_cmd_read_bio(
        ns: *mut nvme_namespace,
        bp: *mut bio,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn nvme_ns_cmd_deallocate(
        ns: *mut nvme_namespace,
        payload: *mut ::core::ffi::c_void,
        num_ranges: u8,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn nvme_ns_cmd_flush(
        ns: *mut nvme_namespace,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn nvme_ns_dump(
        ns: *mut nvme_namespace,
        virt: *mut ::core::ffi::c_void,
        offset: off_t,
        len: usize,
    ) -> ::core::ffi::c_int;
    pub fn nvme_register_consumer(
        ns_fn: nvme_cons_ns_fn_t,
        ctrlr_fn: nvme_cons_ctrlr_fn_t,
        async_fn: nvme_cons_async_fn_t,
        fail_fn: nvme_cons_fail_fn_t,
    ) -> *mut nvme_consumer;
    pub fn nvme_unregister_consumer(consumer: *mut nvme_consumer);
    pub fn nvme_ctrlr_get_device(ctrlr: *mut nvme_controller) -> device_t;
    pub fn nvme_ctrlr_get_data(ctrlr: *mut nvme_controller) -> *const nvme_controller_data;
    #[link_name = "nvme_ctrlr_has_dataset_mgmt__extern"]
    pub fn nvme_ctrlr_has_dataset_mgmt(cd: *const nvme_controller_data) -> bool_;
    #[link_name = "nvme_cdata_get_disk_ident__extern"]
    pub fn nvme_cdata_get_disk_ident(cdata: *const nvme_controller_data, sn: *mut u8);
    pub fn nvme_ns_get_max_io_xfer_size(ns: *mut nvme_namespace) -> u32;
    pub fn nvme_ns_get_sector_size(ns: *mut nvme_namespace) -> u32;
    pub fn nvme_ns_get_num_sectors(ns: *mut nvme_namespace) -> u64;
    pub fn nvme_ns_get_size(ns: *mut nvme_namespace) -> u64;
    pub fn nvme_ns_get_flags(ns: *mut nvme_namespace) -> u32;
    pub fn nvme_ns_get_serial_number(ns: *mut nvme_namespace) -> *const ::core::ffi::c_char;
    pub fn nvme_ns_get_model_number(ns: *mut nvme_namespace) -> *const ::core::ffi::c_char;
    pub fn nvme_ns_get_data(ns: *mut nvme_namespace) -> *const nvme_namespace_data;
    pub fn nvme_ns_get_stripesize(ns: *mut nvme_namespace) -> u32;
    pub fn nvme_ns_bio_process(
        ns: *mut nvme_namespace,
        bp: *mut bio,
        cb_fn: nvme_cb_fn_t,
    ) -> ::core::ffi::c_int;
    pub fn nvme_ns_ioctl_process(
        ns: *mut nvme_namespace,
        cmd: u_long,
        arg: caddr_t,
        flag: ::core::ffi::c_int,
        td: *mut thread,
    ) -> ::core::ffi::c_int;
    #[link_name = "nvme_ns_flush_cmd__extern"]
    pub fn nvme_ns_flush_cmd(cmd: *mut nvme_command, nsid: u32);
    #[link_name = "nvme_ns_rw_cmd__extern"]
    pub fn nvme_ns_rw_cmd(cmd: *mut nvme_command, rwcmd: u32, nsid: u32, lba: u64, count: u32);
    #[link_name = "nvme_ns_write_cmd__extern"]
    pub fn nvme_ns_write_cmd(cmd: *mut nvme_command, nsid: u32, lba: u64, count: u32);
    #[link_name = "nvme_ns_read_cmd__extern"]
    pub fn nvme_ns_read_cmd(cmd: *mut nvme_command, nsid: u32, lba: u64, count: u32);
    #[link_name = "nvme_ns_trim_cmd__extern"]
    pub fn nvme_ns_trim_cmd(cmd: *mut nvme_command, nsid: u32, num_ranges: u32);
    pub static mut nvme_use_nvd: ::core::ffi::c_int;
    #[link_name = "nvme_completion_swapbytes__extern"]
    pub fn nvme_completion_swapbytes(s: *mut nvme_completion);
    #[link_name = "nvme_power_state_swapbytes__extern"]
    pub fn nvme_power_state_swapbytes(s: *mut nvme_power_state);
    #[link_name = "nvme_controller_data_swapbytes__extern"]
    pub fn nvme_controller_data_swapbytes(s: *mut nvme_controller_data);
    #[link_name = "nvme_namespace_data_swapbytes__extern"]
    pub fn nvme_namespace_data_swapbytes(s: *mut nvme_namespace_data);
    #[link_name = "nvme_error_information_entry_swapbytes__extern"]
    pub fn nvme_error_information_entry_swapbytes(s: *mut nvme_error_information_entry);
    #[link_name = "nvme_le128toh__extern"]
    pub fn nvme_le128toh(p: *mut ::core::ffi::c_void);
    #[link_name = "nvme_health_information_page_swapbytes__extern"]
    pub fn nvme_health_information_page_swapbytes(s: *mut nvme_health_information_page);
    #[link_name = "nvme_ns_list_swapbytes__extern"]
    pub fn nvme_ns_list_swapbytes(s: *mut nvme_ns_list);
    #[link_name = "nvme_command_effects_page_swapbytes__extern"]
    pub fn nvme_command_effects_page_swapbytes(s: *mut nvme_command_effects_page);
    #[link_name = "nvme_res_notification_page_swapbytes__extern"]
    pub fn nvme_res_notification_page_swapbytes(s: *mut nvme_res_notification_page);
    #[link_name = "nvme_sanitize_status_page_swapbytes__extern"]
    pub fn nvme_sanitize_status_page_swapbytes(s: *mut nvme_sanitize_status_page);
    #[link_name = "nvme_resv_status_swapbytes__extern"]
    pub fn nvme_resv_status_swapbytes(s: *mut nvme_resv_status, size: usize);
    #[link_name = "nvme_resv_status_ext_swapbytes__extern"]
    pub fn nvme_resv_status_ext_swapbytes(s: *mut nvme_resv_status_ext, size: usize);
    #[link_name = "nvme_device_self_test_swapbytes__extern"]
    pub fn nvme_device_self_test_swapbytes(s: *mut nvme_device_self_test_page);
    #[link_name = "nvme_discovery_log_entry_swapbytes__extern"]
    pub fn nvme_discovery_log_entry_swapbytes(s: *mut nvme_discovery_log_entry);
    #[link_name = "nvme_discovery_log_swapbytes__extern"]
    pub fn nvme_discovery_log_swapbytes(s: *mut nvme_discovery_log);
    pub static mut M_NVME: [malloc_type; 1usize];
    pub static mut nvme_retry_count: i32;
    pub static mut nvme_verbose_cmd_dump: bool_;
    pub fn nvme_ns_test(ns: *mut nvme_namespace, cmd: u_long, arg: caddr_t);
    pub fn nvme_ctrlr_cmd_identify_controller(
        ctrlr: *mut nvme_controller,
        payload: *mut ::core::ffi::c_void,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_identify_namespace(
        ctrlr: *mut nvme_controller,
        nsid: u32,
        payload: *mut ::core::ffi::c_void,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_set_interrupt_coalescing(
        ctrlr: *mut nvme_controller,
        microseconds: u32,
        threshold: u32,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_get_error_page(
        ctrlr: *mut nvme_controller,
        payload: *mut nvme_error_information_entry,
        num_entries: u32,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_get_health_information_page(
        ctrlr: *mut nvme_controller,
        nsid: u32,
        payload: *mut nvme_health_information_page,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_get_firmware_page(
        ctrlr: *mut nvme_controller,
        payload: *mut nvme_firmware_page,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_create_io_cq(
        ctrlr: *mut nvme_controller,
        io_que: *mut nvme_qpair,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_create_io_sq(
        ctrlr: *mut nvme_controller,
        io_que: *mut nvme_qpair,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_delete_io_cq(
        ctrlr: *mut nvme_controller,
        io_que: *mut nvme_qpair,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_delete_io_sq(
        ctrlr: *mut nvme_controller,
        io_que: *mut nvme_qpair,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_set_num_queues(
        ctrlr: *mut nvme_controller,
        num_queues: u32,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_set_async_event_config(
        ctrlr: *mut nvme_controller,
        state: u32,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_ctrlr_cmd_abort(
        ctrlr: *mut nvme_controller,
        cid: u16,
        sqid: u16,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    );
    pub fn nvme_completion_poll_cb(arg: *mut ::core::ffi::c_void, cpl: *const nvme_completion);
    pub fn nvme_ctrlr_construct(ctrlr: *mut nvme_controller, dev: device_t) -> ::core::ffi::c_int;
    pub fn nvme_ctrlr_destruct(ctrlr: *mut nvme_controller, dev: device_t);
    pub fn nvme_ctrlr_shutdown(ctrlr: *mut nvme_controller);
    pub fn nvme_ctrlr_reset(ctrlr: *mut nvme_controller);
    pub fn nvme_ctrlr_start_config_hook(ctrlr_arg: *mut ::core::ffi::c_void);
    pub fn nvme_ctrlr_submit_admin_request(ctrlr: *mut nvme_controller, req: *mut nvme_request);
    pub fn nvme_ctrlr_submit_io_request(ctrlr: *mut nvme_controller, req: *mut nvme_request);
    pub fn nvme_qpair_construct(
        qpair: *mut nvme_qpair,
        num_entries: u32,
        num_trackers: u32,
        ctrlr: *mut nvme_controller,
    ) -> ::core::ffi::c_int;
    pub fn nvme_qpair_submit_tracker(qpair: *mut nvme_qpair, tr: *mut nvme_tracker);
    pub fn nvme_qpair_process_completions(qpair: *mut nvme_qpair) -> bool_;
    pub fn nvme_qpair_submit_request(qpair: *mut nvme_qpair, req: *mut nvme_request);
    pub fn nvme_qpair_reset(qpair: *mut nvme_qpair);
    pub fn nvme_qpair_fail(qpair: *mut nvme_qpair);
    pub fn nvme_admin_qpair_enable(qpair: *mut nvme_qpair);
    pub fn nvme_admin_qpair_disable(qpair: *mut nvme_qpair);
    pub fn nvme_admin_qpair_destroy(qpair: *mut nvme_qpair);
    pub fn nvme_io_qpair_enable(qpair: *mut nvme_qpair);
    pub fn nvme_io_qpair_disable(qpair: *mut nvme_qpair);
    pub fn nvme_io_qpair_destroy(qpair: *mut nvme_qpair);
    pub fn nvme_ns_construct(
        ns: *mut nvme_namespace,
        id: u32,
        ctrlr: *mut nvme_controller,
    ) -> ::core::ffi::c_int;
    pub fn nvme_ns_destruct(ns: *mut nvme_namespace);
    pub fn nvme_sysctl_initialize_ctrlr(ctrlr: *mut nvme_controller);
    pub fn nvme_qpair_print_command(qpair: *mut nvme_qpair, cmd: *mut nvme_command);
    pub fn nvme_qpair_print_completion(qpair: *mut nvme_qpair, cpl: *mut nvme_completion);
    pub fn nvme_attach(dev: device_t) -> ::core::ffi::c_int;
    pub fn nvme_shutdown(dev: device_t) -> ::core::ffi::c_int;
    pub fn nvme_detach(dev: device_t) -> ::core::ffi::c_int;
    #[link_name = "nvme_completion_poll__extern"]
    pub fn nvme_completion_poll(status: *mut nvme_completion_poll_status);
    #[link_name = "nvme_single_map__extern"]
    pub fn nvme_single_map(
        arg: *mut ::core::ffi::c_void,
        seg: *mut bus_dma_segment_t,
        nseg: ::core::ffi::c_int,
        error: ::core::ffi::c_int,
    );
    #[link_name = "_nvme_allocate_request__extern"]
    pub fn _nvme_allocate_request(
        how: ::core::ffi::c_int,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> *mut nvme_request;
    #[link_name = "nvme_allocate_request_vaddr__extern"]
    pub fn nvme_allocate_request_vaddr(
        payload: *mut ::core::ffi::c_void,
        payload_size: u32,
        how: ::core::ffi::c_int,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> *mut nvme_request;
    #[link_name = "nvme_allocate_request_null__extern"]
    pub fn nvme_allocate_request_null(
        how: ::core::ffi::c_int,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> *mut nvme_request;
    #[link_name = "nvme_allocate_request_bio__extern"]
    pub fn nvme_allocate_request_bio(
        bio: *mut bio,
        how: ::core::ffi::c_int,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> *mut nvme_request;
    #[link_name = "nvme_allocate_request_ccb__extern"]
    pub fn nvme_allocate_request_ccb(
        ccb: *mut ccb,
        how: ::core::ffi::c_int,
        cb_fn: nvme_cb_fn_t,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> *mut nvme_request;
    pub fn nvme_notify_async_consumers(
        ctrlr: *mut nvme_controller,
        async_cpl: *const nvme_completion,
        log_page_id: u32,
        log_page_buffer: *mut ::core::ffi::c_void,
        log_page_size: u32,
    );
    pub fn nvme_notify_fail_consumers(ctrlr: *mut nvme_controller);
    pub fn nvme_notify_new_controller(ctrlr: *mut nvme_controller);
    pub fn nvme_notify_ns(ctrlr: *mut nvme_controller, nsid: ::core::ffi::c_int);
    pub fn nvme_ctrlr_shared_handler(arg: *mut ::core::ffi::c_void);
    pub fn nvme_ctrlr_poll(ctrlr: *mut nvme_controller);
    pub fn nvme_ctrlr_suspend(ctrlr: *mut nvme_controller) -> ::core::ffi::c_int;
    pub fn nvme_ctrlr_resume(ctrlr: *mut nvme_controller) -> ::core::ffi::c_int;
    pub fn device_suspend(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_resume(dev: device_t) -> ::core::ffi::c_int;
    pub fn device_register(dev: device_t) -> *mut ::core::ffi::c_void;
    #[doc = " @brief Unique descriptor for the PIC_ACTIVATE_INTR() method"]
    pub static mut pic_activate_intr_desc: kobjop_desc;
    #[link_name = "PIC_ACTIVATE_INTR__extern"]
    pub fn PIC_ACTIVATE_INTR(
        dev: device_t,
        isrc: *mut intr_irqsrc,
        res: *mut resource,
        data: *mut intr_map_data,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the PIC_BIND_INTR() method"]
    pub static mut pic_bind_intr_desc: kobjop_desc;
    #[link_name = "PIC_BIND_INTR__extern"]
    pub fn PIC_BIND_INTR(dev: device_t, isrc: *mut intr_irqsrc) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the PIC_DISABLE_INTR() method"]
    pub static mut pic_disable_intr_desc: kobjop_desc;
    #[link_name = "PIC_DISABLE_INTR__extern"]
    pub fn PIC_DISABLE_INTR(dev: device_t, isrc: *mut intr_irqsrc);
    #[doc = " @brief Unique descriptor for the PIC_ENABLE_INTR() method"]
    pub static mut pic_enable_intr_desc: kobjop_desc;
    #[link_name = "PIC_ENABLE_INTR__extern"]
    pub fn PIC_ENABLE_INTR(dev: device_t, isrc: *mut intr_irqsrc);
    #[doc = " @brief Unique descriptor for the PIC_MAP_INTR() method"]
    pub static mut pic_map_intr_desc: kobjop_desc;
    #[link_name = "PIC_MAP_INTR__extern"]
    pub fn PIC_MAP_INTR(
        dev: device_t,
        data: *mut intr_map_data,
        isrcp: *mut *mut intr_irqsrc,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the PIC_DEACTIVATE_INTR() method"]
    pub static mut pic_deactivate_intr_desc: kobjop_desc;
    #[link_name = "PIC_DEACTIVATE_INTR__extern"]
    pub fn PIC_DEACTIVATE_INTR(
        dev: device_t,
        isrc: *mut intr_irqsrc,
        res: *mut resource,
        data: *mut intr_map_data,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the PIC_SETUP_INTR() method"]
    pub static mut pic_setup_intr_desc: kobjop_desc;
    #[link_name = "PIC_SETUP_INTR__extern"]
    pub fn PIC_SETUP_INTR(
        dev: device_t,
        isrc: *mut intr_irqsrc,
        res: *mut resource,
        data: *mut intr_map_data,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the PIC_TEARDOWN_INTR() method"]
    pub static mut pic_teardown_intr_desc: kobjop_desc;
    #[link_name = "PIC_TEARDOWN_INTR__extern"]
    pub fn PIC_TEARDOWN_INTR(
        dev: device_t,
        isrc: *mut intr_irqsrc,
        res: *mut resource,
        data: *mut intr_map_data,
    ) -> ::core::ffi::c_int;
    #[doc = " @brief Unique descriptor for the PIC_POST_FILTER() method"]
    pub static mut pic_post_filter_desc: kobjop_desc;
    #[link_name = "PIC_POST_FILTER__extern"]
    pub fn PIC_POST_FILTER(dev: device_t, isrc: *mut intr_irqsrc);
    #[doc = " @brief Unique descriptor for the PIC_POST_ITHREAD() method"]
    pub static mut pic_post_ithread_desc: kobjop_desc;
    #[link_name = "PIC_POST_ITHREAD__extern"]
    pub fn PIC_POST_ITHREAD(dev: device_t, isrc: *mut intr_irqsrc);
    #[doc = " @brief Unique descriptor for the PIC_PRE_ITHREAD() method"]
    pub static mut pic_pre_ithread_desc: kobjop_desc;
    #[link_name = "PIC_PRE_ITHREAD__extern"]
    pub fn PIC_PRE_ITHREAD(dev: device_t, isrc: *mut intr_irqsrc);
    #[doc = " @brief Unique descriptor for the PIC_INIT_SECONDARY() method"]
    pub static mut pic_init_secondary_desc: kobjop_desc;
    #[link_name = "PIC_INIT_SECONDARY__extern"]
    pub fn PIC_INIT_SECONDARY(dev: device_t, rootnum: u32);
    #[doc = " @brief Unique descriptor for the PIC_IPI_SEND() method"]
    pub static mut pic_ipi_send_desc: kobjop_desc;
    #[link_name = "PIC_IPI_SEND__extern"]
    pub fn PIC_IPI_SEND(dev: device_t, isrc: *mut intr_irqsrc, cpus: cpuset_t, ipi: u_int);
    #[doc = " @brief Unique descriptor for the PIC_IPI_SETUP() method"]
    pub static mut pic_ipi_setup_desc: kobjop_desc;
    #[link_name = "PIC_IPI_SETUP__extern"]
    pub fn PIC_IPI_SETUP(
        dev: device_t,
        ipi: u_int,
        isrcp: *mut *mut intr_irqsrc,
    ) -> ::core::ffi::c_int;
    pub fn pic_setup_intr(
        dev: device_t,
        isrc: *mut intr_irqsrc,
        res: *mut resource,
        data: *mut intr_map_data,
    ) -> ::core::ffi::c_int;
    pub fn pic_teardown_intr(
        dev: device_t,
        isrc: *mut intr_irqsrc,
        res: *mut resource,
        data: *mut intr_map_data,
    ) -> ::core::ffi::c_int;
    pub fn pic_enable_intr(dev: device_t, isrc: *mut intr_irqsrc);
    pub fn pic_disable_intr(dev: device_t, isrc: *mut intr_irqsrc);
    pub fn pic_post_filter(dev: device_t, isrc: *mut intr_irqsrc);
    pub fn pic_post_ithread(dev: device_t, isrc: *mut intr_irqsrc);
    pub fn pic_pre_ithread(dev: device_t, isrc: *mut intr_irqsrc);
    pub fn pic_bind_intr(dev: device_t, isrc: *mut intr_irqsrc) -> ::core::ffi::c_int;
    pub fn pic_init_secondary(dev: device_t, rootnum: u32);
    pub fn pic_ipi_send(dev: device_t, isrc: *mut intr_irqsrc, cpus: cpuset_t, ipi: u_int);
    pub fn pic_map_intr(
        dev: device_t,
        data: *mut intr_map_data,
        isrcp: *mut *mut intr_irqsrc,
    ) -> ::core::ffi::c_int;
    pub fn pic_ipi_setup(
        dev: device_t,
        ipi: u_int,
        isrcp: *mut *mut intr_irqsrc,
    ) -> ::core::ffi::c_int;
    pub fn channel_init(
        obj: kobj_t,
        devinfo: *mut ::core::ffi::c_void,
        b: *mut snd_dbuf,
        c: *mut pcm_channel,
        dir: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn channel_setformat(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        format: u_int32_t,
    ) -> ::core::ffi::c_int;
    pub fn channel_setspeed(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        speed: u_int32_t,
    ) -> u_int32_t;
    pub fn channel_setblocksize(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        blocksize: u_int32_t,
    ) -> u_int32_t;
    pub fn channel_setfragments(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        blocksize: u_int32_t,
        blockcount: u_int32_t,
    ) -> ::core::ffi::c_int;
    pub fn channel_trigger(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        go: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn channel_getptr(obj: kobj_t, data: *mut ::core::ffi::c_void) -> u_int32_t;
    pub fn channel_getcaps(obj: kobj_t, data: *mut ::core::ffi::c_void) -> *mut pcmchan_caps;
    pub fn channel_getmatrix(
        obj: kobj_t,
        data: *mut ::core::ffi::c_void,
        format: u_int32_t,
    ) -> *mut pcmchan_matrix;
    pub static mut memmap_bus: bus_space;
    pub fn rust_bindings_CPU_SET(cpu: u_int, set: *mut cpuset_t);
    pub fn rust_bindings_CPU_ISSET(cpu: u_int, set: *mut cpuset_t) -> bool_;
    pub fn rust_bindings_CPU_AFFINITY(cpu: u_int) -> u64;
    pub fn rust_bindings_CPU_AFF0(mpidr: u64) -> u64;
    pub fn rust_bindings_CPU_AFF1(mpidr: u64) -> u64;
    pub fn rust_bindings_bus_space_barrier(
        s: bus_space_tag_t,
        h: bus_space_handle_t,
        o: bus_size_t,
        len: bus_size_t,
        flags: ::core::ffi::c_int,
    );
    pub fn rust_bindings_bus_barrier(
        r: *mut resource,
        o: bus_size_t,
        len: bus_size_t,
        flags: ::core::ffi::c_int,
    );
    pub fn rust_bindings_bus_space_map(
        s: bus_space_tag_t,
        a: bus_addr_t,
        sz: bus_size_t,
        f: ::core::ffi::c_int,
        hp: *mut bus_space_handle_t,
    ) -> ::core::ffi::c_int;
    pub fn rust_bindings_mtx_initialized(mutex: *const mtx) -> usize;
    pub fn rust_bindings_bus_read_1(res: *mut resource, offset: bus_size_t) -> u8;
    pub fn rust_bindings_bus_write_region_1(
        res: *mut resource,
        o: bus_size_t,
        p: *mut u8,
        count: bus_size_t,
    );
    pub fn rust_bindings_bus_write_1(res: *mut resource, offset: bus_size_t, value: u8);
    pub fn rust_bindings_bus_read_2(res: *mut resource, offset: bus_size_t) -> u16;
    pub fn rust_bindings_bus_write_region_2(
        res: *mut resource,
        o: bus_size_t,
        p: *mut u16,
        count: bus_size_t,
    );
    pub fn rust_bindings_bus_write_2(res: *mut resource, offset: bus_size_t, value: u16);
    pub fn rust_bindings_bus_read_4(res: *mut resource, offset: bus_size_t) -> u32;
    pub fn rust_bindings_bus_write_region_4(
        res: *mut resource,
        o: bus_size_t,
        p: *mut u32,
        count: bus_size_t,
    );
    pub fn rust_bindings_bus_write_4(res: *mut resource, offset: bus_size_t, value: u32);
    pub fn rust_bindings_bus_read_8(res: *mut resource, offset: bus_size_t) -> u64;
    pub fn rust_bindings_bus_write_region_8(
        res: *mut resource,
        o: bus_size_t,
        p: *mut u64,
        count: bus_size_t,
    );
    pub fn rust_bindings_bus_write_8(res: *mut resource, offset: bus_size_t, value: u64);
}
