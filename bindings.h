/*-
 * SPDX-License-Identifier: BSD-2-Clause
 *
 * Copyright (c) 2024 Ayrton Mu√±oz
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "opt_platform.h"

#include <sys/cdefs.h>

#include <sys/param.h>
#include <sys/bus.h>
#include <sys/cpuset.h>
#ifdef INTRNG
#include <sys/intr.h>
#endif
#include <sys/kernel.h>
#include <sys/lock.h>
#include <sys/malloc.h>
#include <sys/module.h>
#include <sys/mutex.h>
#include <sys/proc.h>
#include <sys/refcount.h>
#include <sys/rman.h>
#include <sys/smp.h>
#include <sys/systm.h>
#include <sys/taskqueue.h>

#include <machine/_inttypes.h>
#include <machine/bus.h>

#if !defined(__x86_64__)
#include <machine/machdep.h>
#endif

#include <machine/resource.h>
#ifdef SMP
#include <machine/smp.h>
#endif

#ifdef FDT
#include <dev/fdt/fdt_intr.h>
#include <dev/fdt/simplebus.h>

#include <dev/ofw/openfirm.h>
#include <dev/ofw/ofw_bus.h>
#include <dev/ofw/ofw_bus_subr.h>

#include "ofw_bus_if.h"
#endif // FDT

#include <dev/virtio/virtio.h>
#include <dev/virtio/virtqueue.h>

#include <dev/gpio/gpiobusvar.h>

#include <dev/nvme/nvme_private.h>
// TODO: Enable these once apple silicon work is mainlined
#if 0
#include "nvme_if.h"
#include <dt-bindings/interrupt-controller/apple-aic.h>
#endif

#include "device_if.h"

#if !defined(__x86_64__)
#include "pic_if.h"
#endif

#if defined(__aarch64__)
extern struct bus_space memmap_bus;
#endif

/*
 * This header is preprocessed by bindgen with -DBINDGEN to create bindings.rs and inlines.c then
 * preprocessed again without it when compiling inlines.c. In that compile step we'd like to ignore
 * -Wmissing-prototypes since the code generated by bindgen does not fit the FreeBSD style
 * guidelines and attempting to do so would require invasive changes for little benefit.
 */
#if !defined(BINDGEN)
#pragma clang diagnostic ignored "-Wmissing-prototypes"
#endif


/*
 * function-like macros defined in headers are not supported well by bindgen yet. We work around
 * this by instantiating them once in this file. These functions cannot be static since they're
 * referenced by other translation units but they only need to be called from rust so we just add
 * declarations here for simplicity.
 */
#define INLINE(...) __VA_ARGS__;__VA_ARGS__

INLINE(void rust_bindings_CPU_SET(u_int cpu, cpuset_t *set)) {
    CPU_SET(cpu, set);
}

INLINE(bool rust_bindings_CPU_ISSET(u_int cpu, cpuset_t *set)) {
    return CPU_ISSET(cpu, set);
}

INLINE(uint64_t rust_bindings_CPU_AFFINITY(u_int cpu)) {
    return CPU_AFFINITY(cpu);
}

INLINE(uint64_t rust_bindings_CPU_AFF0(uint64_t mpidr)) {
    return CPU_AFF0(mpidr);
}

INLINE(uint64_t rust_bindings_CPU_AFF1(uint64_t mpidr)) {
    return CPU_AFF1(mpidr);
}

INLINE(void rust_bindings_bus_space_barrier(bus_space_tag_t s, bus_space_handle_t h, bus_size_t o, bus_size_t len, int flags)) {
    return bus_space_barrier(s, h, o, len, flags);
}
INLINE(void rust_bindings_bus_barrier(struct resource *r, bus_size_t o, bus_size_t len, int flags)) {
    return bus_barrier(r, o, len, flags);
}
INLINE(int rust_bindings_bus_space_map(bus_space_tag_t s, bus_addr_t a, bus_size_t sz, int f, bus_space_handle_t *hp)) {
    return bus_space_map(s, a, sz, f, hp);
}
INLINE(size_t rust_bindings_mtx_initialized(const struct mtx *mutex)) {
    return mtx_initialized(mutex);
}

#define BUS_N(n, ty) \
    INLINE(ty rust_bindings_bus_read_##n(struct resource *res, bus_size_t offset)) { \
        return bus_read_##n(res, offset); \
    } \
    INLINE(void rust_bindings_bus_write_region_##n(struct resource *res, bus_size_t o, ty *p, bus_size_t count)) { \
        return bus_write_region_##n(res, o, p, count); \
    } \
    INLINE(void rust_bindings_bus_write_##n(struct resource *res, bus_size_t offset, ty value)) { \
        return bus_write_##n(res, offset, value); \
    }

BUS_N(1, uint8_t);
BUS_N(2, uint16_t);
BUS_N(4, uint32_t);
BUS_N(8, uint64_t);
